function jt(n) {
  this.content = n;
}
jt.prototype = {
  constructor: jt,
  find: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === n) return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(n) {
    var e = this.find(n);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(n, e, t) {
    var r = t && t != n ? this.remove(t) : this, o = r.find(n), a = r.content.slice();
    return o == -1 ? a.push(t || n, e) : (a[o + 1] = e, t && (a[o] = t)), new jt(a);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(n) {
    var e = this.find(n);
    if (e == -1) return this;
    var t = this.content.slice();
    return t.splice(e, 2), new jt(t);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(n, e) {
    return new jt([n, e].concat(this.remove(n).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(n, e) {
    var t = this.remove(n).content.slice();
    return t.push(n, e), new jt(t);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(n, e, t) {
    var r = this.remove(e), o = r.content.slice(), a = r.find(n);
    return o.splice(a == -1 ? o.length : a, 0, e, t), new jt(o);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      n(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(n) {
    return n = jt.from(n), n.size ? new jt(n.content.concat(this.subtract(n).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(n) {
    return n = jt.from(n), n.size ? new jt(this.subtract(n).content.concat(n.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(n) {
    var e = this;
    n = jt.from(n);
    for (var t = 0; t < n.content.length; t += 2)
      e = e.remove(n.content[t]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var n = {};
    return this.forEach(function(e, t) {
      n[e] = t;
    }), n;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
jt.from = function(n) {
  if (n instanceof jt) return n;
  var e = [];
  if (n) for (var t in n) e.push(t, n[t]);
  return new jt(e);
};
function lk(n, e, t) {
  for (let r = 0; ; r++) {
    if (r == n.childCount || r == e.childCount)
      return n.childCount == e.childCount ? null : t;
    let o = n.child(r), a = e.child(r);
    if (o == a) {
      t += o.nodeSize;
      continue;
    }
    if (!o.sameMarkup(a))
      return t;
    if (o.isText && o.text != a.text) {
      for (let l = 0; o.text[l] == a.text[l]; l++)
        t++;
      return t;
    }
    if (o.content.size || a.content.size) {
      let l = lk(o.content, a.content, t + 1);
      if (l != null)
        return l;
    }
    t += o.nodeSize;
  }
}
function ck(n, e, t, r) {
  for (let o = n.childCount, a = e.childCount; ; ) {
    if (o == 0 || a == 0)
      return o == a ? null : { a: t, b: r };
    let l = n.child(--o), d = e.child(--a), p = l.nodeSize;
    if (l == d) {
      t -= p, r -= p;
      continue;
    }
    if (!l.sameMarkup(d))
      return { a: t, b: r };
    if (l.isText && l.text != d.text) {
      let f = 0, m = Math.min(l.text.length, d.text.length);
      for (; f < m && l.text[l.text.length - f - 1] == d.text[d.text.length - f - 1]; )
        f++, t--, r--;
      return { a: t, b: r };
    }
    if (l.content.size || d.content.size) {
      let f = ck(l.content, d.content, t - 1, r - 1);
      if (f)
        return f;
    }
    t -= p, r -= p;
  }
}
class X {
  /**
  @internal
  */
  constructor(e, t) {
    if (this.content = e, this.size = t || 0, t == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, t, r, o = 0, a) {
    for (let l = 0, d = 0; d < t; l++) {
      let p = this.content[l], f = d + p.nodeSize;
      if (f > e && r(p, o + d, a || null, l) !== !1 && p.content.size) {
        let m = d + 1;
        p.nodesBetween(Math.max(0, e - m), Math.min(p.content.size, t - m), r, o + m);
      }
      d = f;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, t, r, o) {
    let a = "", l = !0;
    return this.nodesBetween(e, t, (d, p) => {
      let f = d.isText ? d.text.slice(Math.max(e, p) - p, t - p) : d.isLeaf ? o ? typeof o == "function" ? o(d) : o : d.type.spec.leafText ? d.type.spec.leafText(d) : "" : "";
      d.isBlock && (d.isLeaf && f || d.isTextblock) && r && (l ? l = !1 : a += r), a += f;
    }, 0), a;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let t = this.lastChild, r = e.firstChild, o = this.content.slice(), a = 0;
    for (t.isText && t.sameMarkup(r) && (o[o.length - 1] = t.withText(t.text + r.text), a = 1); a < e.content.length; a++)
      o.push(e.content[a]);
    return new X(o, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, t = this.size) {
    if (e == 0 && t == this.size)
      return this;
    let r = [], o = 0;
    if (t > e)
      for (let a = 0, l = 0; l < t; a++) {
        let d = this.content[a], p = l + d.nodeSize;
        p > e && ((l < e || p > t) && (d.isText ? d = d.cut(Math.max(0, e - l), Math.min(d.text.length, t - l)) : d = d.cut(Math.max(0, e - l - 1), Math.min(d.content.size, t - l - 1))), r.push(d), o += d.nodeSize), l = p;
      }
    return new X(r, o);
  }
  /**
  @internal
  */
  cutByIndex(e, t) {
    return e == t ? X.empty : e == 0 && t == this.content.length ? this : new X(this.content.slice(e, t));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, t) {
    let r = this.content[e];
    if (r == t)
      return this;
    let o = this.content.slice(), a = this.size + t.nodeSize - r.nodeSize;
    return o[e] = t, new X(o, a);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new X([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new X(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let t = 0; t < this.content.length; t++)
      if (!this.content[t].eq(e.content[t]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let t = this.content[e];
    if (!t)
      throw new RangeError("Index " + e + " out of range for " + this);
    return t;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let t = 0, r = 0; t < this.content.length; t++) {
      let o = this.content[t];
      e(o, r, t), r += o.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, t = 0) {
    return lk(this, e, t);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, t = this.size, r = e.size) {
    return ck(this, e, t, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e) {
    if (e == 0)
      return Gc(0, e);
    if (e == this.size)
      return Gc(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let t = 0, r = 0; ; t++) {
      let o = this.child(t), a = r + o.nodeSize;
      if (a >= e)
        return a == e ? Gc(t + 1, a) : Gc(t, r);
      r = a;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return X.empty;
    if (!Array.isArray(t))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new X(t.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return X.empty;
    let t, r = 0;
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      r += a.nodeSize, o && a.isText && e[o - 1].sameMarkup(a) ? (t || (t = e.slice(0, o)), t[t.length - 1] = a.withText(t[t.length - 1].text + a.text)) : t && t.push(a);
    }
    return new X(t || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return X.empty;
    if (e instanceof X)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new X([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
X.empty = new X([], 0);
const sh = { index: 0, offset: 0 };
function Gc(n, e) {
  return sh.index = n, sh.offset = e, sh;
}
function Au(n, e) {
  if (n === e)
    return !0;
  if (!(n && typeof n == "object") || !(e && typeof e == "object"))
    return !1;
  let t = Array.isArray(n);
  if (Array.isArray(e) != t)
    return !1;
  if (t) {
    if (n.length != e.length)
      return !1;
    for (let r = 0; r < n.length; r++)
      if (!Au(n[r], e[r]))
        return !1;
  } else {
    for (let r in n)
      if (!(r in e) || !Au(n[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in n))
        return !1;
  }
  return !0;
}
let Je = class qh {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.attrs = t;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let t, r = !1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      if (this.eq(a))
        return e;
      if (this.type.excludes(a.type))
        t || (t = e.slice(0, o));
      else {
        if (a.type.excludes(this.type))
          return e;
        !r && a.type.rank > this.type.rank && (t || (t = e.slice(0, o)), t.push(this), r = !0), t && t.push(a);
      }
    }
    return t || (t = e.slice()), r || t.push(this), t;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return e.slice(0, t).concat(e.slice(t + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && Au(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[t.type];
    if (!r)
      throw new RangeError(`There is no mark type ${t.type} in this schema`);
    let o = r.create(t.attrs);
    return r.checkAttrs(o.attrs), o;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, t) {
    if (e == t)
      return !0;
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(t[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return qh.none;
    if (e instanceof qh)
      return [e];
    let t = e.slice();
    return t.sort((r, o) => r.type.rank - o.type.rank), t;
  }
};
Je.none = [];
class Cu extends Error {
}
class ne {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, t, r) {
    this.content = e, this.openStart = t, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, t) {
    let r = dk(this.content, e + this.openStart, t);
    return r && new ne(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, t) {
    return new ne(uk(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return ne.empty;
    let r = t.openStart || 0, o = t.openEnd || 0;
    if (typeof r != "number" || typeof o != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new ne(X.fromJSON(e, t.content), r, o);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, t = !0) {
    let r = 0, o = 0;
    for (let a = e.firstChild; a && !a.isLeaf && (t || !a.type.spec.isolating); a = a.firstChild)
      r++;
    for (let a = e.lastChild; a && !a.isLeaf && (t || !a.type.spec.isolating); a = a.lastChild)
      o++;
    return new ne(e, r, o);
  }
}
ne.empty = new ne(X.empty, 0, 0);
function uk(n, e, t) {
  let { index: r, offset: o } = n.findIndex(e), a = n.maybeChild(r), { index: l, offset: d } = n.findIndex(t);
  if (o == e || a.isText) {
    if (d != t && !n.child(l).isText)
      throw new RangeError("Removing non-flat range");
    return n.cut(0, e).append(n.cut(t));
  }
  if (r != l)
    throw new RangeError("Removing non-flat range");
  return n.replaceChild(r, a.copy(uk(a.content, e - o - 1, t - o - 1)));
}
function dk(n, e, t, r) {
  let { index: o, offset: a } = n.findIndex(e), l = n.maybeChild(o);
  if (a == e || l.isText)
    return r && !r.canReplace(o, o, t) ? null : n.cut(0, e).append(t).append(n.cut(e));
  let d = dk(l.content, e - a - 1, t, l);
  return d && n.replaceChild(o, l.copy(d));
}
function _R(n, e, t) {
  if (t.openStart > n.depth)
    throw new Cu("Inserted content deeper than insertion position");
  if (n.depth - t.openStart != e.depth - t.openEnd)
    throw new Cu("Inconsistent open depths");
  return pk(n, e, t, 0);
}
function pk(n, e, t, r) {
  let o = n.index(r), a = n.node(r);
  if (o == e.index(r) && r < n.depth - t.openStart) {
    let l = pk(n, e, t, r + 1);
    return a.copy(a.content.replaceChild(o, l));
  } else if (t.content.size)
    if (!t.openStart && !t.openEnd && n.depth == r && e.depth == r) {
      let l = n.parent, d = l.content;
      return bo(l, d.cut(0, n.parentOffset).append(t.content).append(d.cut(e.parentOffset)));
    } else {
      let { start: l, end: d } = zR(t, n);
      return bo(a, fk(n, l, d, e, r));
    }
  else return bo(a, Su(n, e, r));
}
function hk(n, e) {
  if (!e.type.compatibleContent(n.type))
    throw new Cu("Cannot join " + e.type.name + " onto " + n.type.name);
}
function Vh(n, e, t) {
  let r = n.node(t);
  return hk(r, e.node(t)), r;
}
function wo(n, e) {
  let t = e.length - 1;
  t >= 0 && n.isText && n.sameMarkup(e[t]) ? e[t] = n.withText(e[t].text + n.text) : e.push(n);
}
function Ya(n, e, t, r) {
  let o = (e || n).node(t), a = 0, l = e ? e.index(t) : o.childCount;
  n && (a = n.index(t), n.depth > t ? a++ : n.textOffset && (wo(n.nodeAfter, r), a++));
  for (let d = a; d < l; d++)
    wo(o.child(d), r);
  e && e.depth == t && e.textOffset && wo(e.nodeBefore, r);
}
function bo(n, e) {
  return n.type.checkContent(e), n.copy(e);
}
function fk(n, e, t, r, o) {
  let a = n.depth > o && Vh(n, e, o + 1), l = r.depth > o && Vh(t, r, o + 1), d = [];
  return Ya(null, n, o, d), a && l && e.index(o) == t.index(o) ? (hk(a, l), wo(bo(a, fk(n, e, t, r, o + 1)), d)) : (a && wo(bo(a, Su(n, e, o + 1)), d), Ya(e, t, o, d), l && wo(bo(l, Su(t, r, o + 1)), d)), Ya(r, null, o, d), new X(d);
}
function Su(n, e, t) {
  let r = [];
  if (Ya(null, n, t, r), n.depth > t) {
    let o = Vh(n, e, t + 1);
    wo(bo(o, Su(n, e, t + 1)), r);
  }
  return Ya(e, null, t, r), new X(r);
}
function zR(n, e) {
  let t = e.depth - n.openStart, o = e.node(t).copy(n.content);
  for (let a = t - 1; a >= 0; a--)
    o = e.node(a).copy(X.from(o));
  return {
    start: o.resolveNoCache(n.openStart + t),
    end: o.resolveNoCache(o.content.size - n.openEnd - t)
  };
}
class ul {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.pos = e, this.path = t, this.parentOffset = r, this.depth = t.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, t = this.index(this.depth);
    if (t == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], o = e.child(t);
    return r ? e.child(t).cut(r) : o;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1];
    return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, t) {
    t = this.resolveDepth(t);
    let r = this.path[t * 3], o = t == 0 ? 0 : this.path[t * 3 - 1] + 1;
    for (let a = 0; a < e; a++)
      o += r.child(a).nodeSize;
    return o;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, t = this.index();
    if (e.content.size == 0)
      return Je.none;
    if (this.textOffset)
      return e.child(t).marks;
    let r = e.maybeChild(t - 1), o = e.maybeChild(t);
    if (!r) {
      let d = r;
      r = o, o = d;
    }
    let a = r.marks;
    for (var l = 0; l < a.length; l++)
      a[l].type.spec.inclusive === !1 && (!o || !a[l].isInSet(o.marks)) && (a = a[l--].removeFromSet(a));
    return a;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let t = this.parent.maybeChild(this.index());
    if (!t || !t.isInline)
      return null;
    let r = t.marks, o = e.parent.maybeChild(e.index());
    for (var a = 0; a < r.length; a++)
      r[a].type.spec.inclusive === !1 && (!o || !r[a].isInSet(o.marks)) && (r = r[a--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let t = this.depth; t > 0; t--)
      if (this.start(t) <= e && this.end(t) >= e)
        return t;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, t) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!t || t(this.node(r))))
        return new Eu(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 1; t <= this.depth; t++)
      e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, t) {
    if (!(t >= 0 && t <= e.content.size))
      throw new RangeError("Position " + t + " out of range");
    let r = [], o = 0, a = t;
    for (let l = e; ; ) {
      let { index: d, offset: p } = l.content.findIndex(a), f = a - p;
      if (r.push(l, d, o + p), !f || (l = l.child(d), l.isText))
        break;
      a = f - 1, o += p + 1;
    }
    return new ul(t, r, a);
  }
  /**
  @internal
  */
  static resolveCached(e, t) {
    let r = Sb.get(e);
    if (r)
      for (let a = 0; a < r.elts.length; a++) {
        let l = r.elts[a];
        if (l.pos == t)
          return l;
      }
    else
      Sb.set(e, r = new qR());
    let o = r.elts[r.i] = ul.resolve(e, t);
    return r.i = (r.i + 1) % VR, o;
  }
}
class qR {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const VR = 12, Sb = /* @__PURE__ */ new WeakMap();
class Eu {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const XR = /* @__PURE__ */ Object.create(null);
let Ii = class Xh {
  /**
  @internal
  */
  constructor(e, t, r, o = Je.none) {
    this.type = e, this.attrs = t, this.marks = o, this.content = r || X.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, t, r, o = 0) {
    this.content.nodesBetween(e, t, r, o, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(e, t, r, o) {
    return this.content.textBetween(e, t, r, o);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, t, r) {
    return this.type == e && Au(this.attrs, t || e.defaultAttrs || XR) && Je.sameSet(this.marks, r || Je.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new Xh(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new Xh(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, t = this.content.size) {
    return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, t = this.content.size, r = !1) {
    if (e == t)
      return ne.empty;
    let o = this.resolve(e), a = this.resolve(t), l = r ? 0 : o.sharedDepth(t), d = o.start(l), f = o.node(l).content.cut(o.pos - d, a.pos - d);
    return new ne(f, o.depth - l, a.depth - l);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, t, r) {
    return _R(this.resolve(e), this.resolve(t), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let t = this; ; ) {
      let { index: r, offset: o } = t.content.findIndex(e);
      if (t = t.maybeChild(r), !t)
        return null;
      if (o == e || t.isText)
        return t;
      e -= o + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: t, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(t), index: t, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: t, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(t), index: t, offset: r };
    let o = this.content.child(t - 1);
    return { node: o, index: t - 1, offset: r - o.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return ul.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return ul.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, t, r) {
    let o = !1;
    return t > e && this.nodesBetween(e, t, (a) => (r.isInSet(a.marks) && (o = !0), !o)), o;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), mk(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let t = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!t)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return t;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, t, r = X.empty, o = 0, a = r.childCount) {
    let l = this.contentMatchAt(e).matchFragment(r, o, a), d = l && l.matchFragment(this.content, t);
    if (!d || !d.validEnd)
      return !1;
    for (let p = o; p < a; p++)
      if (!this.type.allowsMarks(r.child(p).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, t, r, o) {
    if (o && !this.type.allowsMarks(o))
      return !1;
    let a = this.contentMatchAt(e).matchType(r), l = a && a.matchFragment(this.content, t);
    return l ? l.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = Je.none;
    for (let t = 0; t < this.marks.length; t++) {
      let r = this.marks[t];
      r.type.checkAttrs(r.attrs), e = r.addToSet(e);
    }
    if (!Je.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t) => t.type.name)}`);
    this.content.forEach((t) => t.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((t) => t.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (t.marks) {
      if (!Array.isArray(t.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = t.marks.map(e.markFromJSON);
    }
    if (t.type == "text") {
      if (typeof t.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(t.text, r);
    }
    let o = X.fromJSON(e, t.content), a = e.nodeType(t.type).create(t.attrs, o, r);
    return a.type.checkAttrs(a.attrs), a;
  }
};
Ii.prototype.text = void 0;
class Tu extends Ii {
  /**
  @internal
  */
  constructor(e, t, r, o) {
    if (super(e, t, null, o), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : mk(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, t) {
    return this.text.slice(e, t);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new Tu(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new Tu(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, t = this.text.length) {
    return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function mk(n, e) {
  for (let t = n.length - 1; t >= 0; t--)
    e = n[t].type.name + "(" + e + ")";
  return e;
}
class To {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, t) {
    let r = new JR(e, t);
    if (r.next == null)
      return To.empty;
    let o = gk(r);
    r.next && r.err("Unexpected trailing text");
    let a = t3(e3(o));
    return n3(a, r), a;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let t = 0; t < this.next.length; t++)
      if (this.next[t].type == e)
        return this.next[t].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, t = 0, r = e.childCount) {
    let o = this;
    for (let a = t; o && a < r; a++)
      o = o.matchType(e.child(a).type);
    return o;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: t } = this.next[e];
      if (!(t.isText || t.hasRequiredAttrs()))
        return t;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let t = 0; t < this.next.length; t++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[t].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, t = !1, r = 0) {
    let o = [this];
    function a(l, d) {
      let p = l.matchFragment(e, r);
      if (p && (!t || p.validEnd))
        return X.from(d.map((f) => f.createAndFill()));
      for (let f = 0; f < l.next.length; f++) {
        let { type: m, next: y } = l.next[f];
        if (!(m.isText || m.hasRequiredAttrs()) && o.indexOf(y) == -1) {
          o.push(y);
          let v = a(y, d.concat(m));
          if (v)
            return v;
        }
      }
      return null;
    }
    return a(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let t = this.computeWrapping(e);
    return this.wrapCache.push(e, t), t;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let t = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let o = r.shift(), a = o.match;
      if (a.matchType(e)) {
        let l = [];
        for (let d = o; d.type; d = d.via)
          l.push(d.type);
        return l.reverse();
      }
      for (let l = 0; l < a.next.length; l++) {
        let { type: d, next: p } = a.next[l];
        !d.isLeaf && !d.hasRequiredAttrs() && !(d.name in t) && (!o.type || p.validEnd) && (r.push({ match: d.contentMatch, type: d, via: o }), t[d.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function t(r) {
      e.push(r);
      for (let o = 0; o < r.next.length; o++)
        e.indexOf(r.next[o].next) == -1 && t(r.next[o].next);
    }
    return t(this), e.map((r, o) => {
      let a = o + (r.validEnd ? "*" : " ") + " ";
      for (let l = 0; l < r.next.length; l++)
        a += (l ? ", " : "") + r.next[l].type.name + "->" + e.indexOf(r.next[l].next);
      return a;
    }).join(`
`);
  }
}
To.empty = new To(!0);
class JR {
  constructor(e, t) {
    this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function gk(n) {
  let e = [];
  do
    e.push(KR(n));
  while (n.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function KR(n) {
  let e = [];
  do
    e.push(WR(n));
  while (n.next && n.next != ")" && n.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function WR(n) {
  let e = ZR(n);
  for (; ; )
    if (n.eat("+"))
      e = { type: "plus", expr: e };
    else if (n.eat("*"))
      e = { type: "star", expr: e };
    else if (n.eat("?"))
      e = { type: "opt", expr: e };
    else if (n.eat("{"))
      e = YR(n, e);
    else
      break;
  return e;
}
function Eb(n) {
  /\D/.test(n.next) && n.err("Expected number, got '" + n.next + "'");
  let e = Number(n.next);
  return n.pos++, e;
}
function YR(n, e) {
  let t = Eb(n), r = t;
  return n.eat(",") && (n.next != "}" ? r = Eb(n) : r = -1), n.eat("}") || n.err("Unclosed braced range"), { type: "range", min: t, max: r, expr: e };
}
function QR(n, e) {
  let t = n.nodeTypes, r = t[e];
  if (r)
    return [r];
  let o = [];
  for (let a in t) {
    let l = t[a];
    l.isInGroup(e) && o.push(l);
  }
  return o.length == 0 && n.err("No node type or group '" + e + "' found"), o;
}
function ZR(n) {
  if (n.eat("(")) {
    let e = gk(n);
    return n.eat(")") || n.err("Missing closing paren"), e;
  } else if (/\W/.test(n.next))
    n.err("Unexpected token '" + n.next + "'");
  else {
    let e = QR(n, n.next).map((t) => (n.inline == null ? n.inline = t.isInline : n.inline != t.isInline && n.err("Mixing inline and block content"), { type: "name", value: t }));
    return n.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function e3(n) {
  let e = [[]];
  return o(a(n, 0), t()), e;
  function t() {
    return e.push([]) - 1;
  }
  function r(l, d, p) {
    let f = { term: p, to: d };
    return e[l].push(f), f;
  }
  function o(l, d) {
    l.forEach((p) => p.to = d);
  }
  function a(l, d) {
    if (l.type == "choice")
      return l.exprs.reduce((p, f) => p.concat(a(f, d)), []);
    if (l.type == "seq")
      for (let p = 0; ; p++) {
        let f = a(l.exprs[p], d);
        if (p == l.exprs.length - 1)
          return f;
        o(f, d = t());
      }
    else if (l.type == "star") {
      let p = t();
      return r(d, p), o(a(l.expr, p), p), [r(p)];
    } else if (l.type == "plus") {
      let p = t();
      return o(a(l.expr, d), p), o(a(l.expr, p), p), [r(p)];
    } else {
      if (l.type == "opt")
        return [r(d)].concat(a(l.expr, d));
      if (l.type == "range") {
        let p = d;
        for (let f = 0; f < l.min; f++) {
          let m = t();
          o(a(l.expr, p), m), p = m;
        }
        if (l.max == -1)
          o(a(l.expr, p), p);
        else
          for (let f = l.min; f < l.max; f++) {
            let m = t();
            r(p, m), o(a(l.expr, p), m), p = m;
          }
        return [r(p)];
      } else {
        if (l.type == "name")
          return [r(d, void 0, l.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function yk(n, e) {
  return e - n;
}
function Tb(n, e) {
  let t = [];
  return r(e), t.sort(yk);
  function r(o) {
    let a = n[o];
    if (a.length == 1 && !a[0].term)
      return r(a[0].to);
    t.push(o);
    for (let l = 0; l < a.length; l++) {
      let { term: d, to: p } = a[l];
      !d && t.indexOf(p) == -1 && r(p);
    }
  }
}
function t3(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return t(Tb(n, 0));
  function t(r) {
    let o = [];
    r.forEach((l) => {
      n[l].forEach(({ term: d, to: p }) => {
        if (!d)
          return;
        let f;
        for (let m = 0; m < o.length; m++)
          o[m][0] == d && (f = o[m][1]);
        Tb(n, p).forEach((m) => {
          f || o.push([d, f = []]), f.indexOf(m) == -1 && f.push(m);
        });
      });
    });
    let a = e[r.join(",")] = new To(r.indexOf(n.length - 1) > -1);
    for (let l = 0; l < o.length; l++) {
      let d = o[l][1].sort(yk);
      a.next.push({ type: o[l][0], next: e[d.join(",")] || t(d) });
    }
    return a;
  }
}
function n3(n, e) {
  for (let t = 0, r = [n]; t < r.length; t++) {
    let o = r[t], a = !o.validEnd, l = [];
    for (let d = 0; d < o.next.length; d++) {
      let { type: p, next: f } = o.next[d];
      l.push(p.name), a && !(p.isText || p.hasRequiredAttrs()) && (a = !1), r.indexOf(f) == -1 && r.push(f);
    }
    a && e.err("Only non-generatable nodes (" + l.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function wk(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let r = n[t];
    if (!r.hasDefault)
      return null;
    e[t] = r.default;
  }
  return e;
}
function bk(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r in n) {
    let o = e && e[r];
    if (o === void 0) {
      let a = n[r];
      if (a.hasDefault)
        o = a.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    t[r] = o;
  }
  return t;
}
function vk(n, e, t, r) {
  for (let o in e)
    if (!(o in n))
      throw new RangeError(`Unsupported attribute ${o} for ${t} of type ${o}`);
  for (let o in n) {
    let a = n[o];
    a.validate && a.validate(e[o]);
  }
}
function xk(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let r in e)
      t[r] = new i3(n, r, e[r]);
  return t;
}
let Nb = class kk {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.name = e, this.schema = t, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = xk(e, r.attrs), this.defaultAttrs = wk(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == To.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : bk(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, t, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Ii(this, this.computeAttrs(e), X.from(t), Je.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, t, r) {
    return t = X.from(t), this.checkContent(t), new Ii(this, this.computeAttrs(e), t, Je.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, t, r) {
    if (e = this.computeAttrs(e), t = X.from(t), t.size) {
      let l = this.contentMatch.fillBefore(t);
      if (!l)
        return null;
      t = l.append(t);
    }
    let o = this.contentMatch.matchFragment(t), a = o && o.fillBefore(X.empty, !0);
    return a ? new Ii(this, e, t.append(a), Je.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let t = this.contentMatch.matchFragment(e);
    if (!t || !t.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    vk(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let t = 0; t < e.length; t++)
      if (!this.allowsMarkType(e[t].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let t;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? t && t.push(e[r]) : t || (t = e.slice(0, r));
    return t ? t.length ? t : Je.none : e;
  }
  /**
  @internal
  */
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((a, l) => r[a] = new kk(a, t, l));
    let o = t.spec.topNode || "doc";
    if (!r[o])
      throw new RangeError("Schema is missing its top node type ('" + o + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let a in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function r3(n, e, t) {
  let r = t.split("|");
  return (o) => {
    let a = o === null ? "null" : typeof o;
    if (r.indexOf(a) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${n}, got ${a}`);
  };
}
class i3 {
  constructor(e, t, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? r3(e, t, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class td {
  /**
  @internal
  */
  constructor(e, t, r, o) {
    this.name = e, this.rank = t, this.schema = r, this.spec = o, this.attrs = xk(e, o.attrs), this.excluded = null;
    let a = wk(this.attrs);
    this.instance = a ? new Je(this, a) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new Je(this, bk(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null), o = 0;
    return e.forEach((a, l) => r[a] = new td(a, o++, t, l)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var t = 0; t < e.length; t++)
      e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].type == this)
        return e[t];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    vk(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class Ak {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let t = this.spec = {};
    for (let o in e)
      t[o] = e[o];
    t.nodes = jt.from(e.nodes), t.marks = jt.from(e.marks || {}), this.nodes = Nb.compile(this.spec.nodes, this), this.marks = td.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let o in this.nodes) {
      if (o in this.marks)
        throw new RangeError(o + " can not be both a node and a mark");
      let a = this.nodes[o], l = a.spec.content || "", d = a.spec.marks;
      if (a.contentMatch = r[l] || (r[l] = To.parse(l, this.nodes)), a.inlineContent = a.contentMatch.inlineContent, a.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!a.isInline || !a.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = a;
      }
      a.markSet = d == "_" ? null : d ? Bb(this, d.split(" ")) : d == "" || !a.inlineContent ? [] : null;
    }
    for (let o in this.marks) {
      let a = this.marks[o], l = a.spec.excludes;
      a.excluded = l == null ? [a] : l == "" ? [] : Bb(this, l.split(" "));
    }
    this.nodeFromJSON = (o) => Ii.fromJSON(this, o), this.markFromJSON = (o) => Je.fromJSON(this, o), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, t = null, r, o) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof Nb) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(t, r, o);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, t) {
    let r = this.nodes.text;
    return new Tu(r, r.defaultAttrs, e, Je.setFrom(t));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, t) {
    return typeof e == "string" && (e = this.marks[e]), e.create(t);
  }
  /**
  @internal
  */
  nodeType(e) {
    let t = this.nodes[e];
    if (!t)
      throw new RangeError("Unknown node type: " + e);
    return t;
  }
}
function Bb(n, e) {
  let t = [];
  for (let r = 0; r < e.length; r++) {
    let o = e[r], a = n.marks[o], l = a;
    if (a)
      t.push(a);
    else
      for (let d in n.marks) {
        let p = n.marks[d];
        (o == "_" || p.spec.group && p.spec.group.split(" ").indexOf(o) > -1) && t.push(l = p);
      }
    if (!l)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return t;
}
function o3(n) {
  return n.tag != null;
}
function s3(n) {
  return n.style != null;
}
let Qa = class Jh {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, t) {
    this.schema = e, this.rules = t, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    t.forEach((o) => {
      if (o3(o))
        this.tags.push(o);
      else if (s3(o)) {
        let a = /[^=]*/.exec(o.style)[0];
        r.indexOf(a) < 0 && r.push(a), this.styles.push(o);
      }
    }), this.normalizeLists = !this.tags.some((o) => {
      if (!/^(ul|ol)\b/.test(o.tag) || !o.node)
        return !1;
      let a = e.nodes[o.node];
      return a.contentMatch.matchType(a);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, t = {}) {
    let r = new Mb(this, t, !1);
    return r.addAll(e, Je.none, t.from, t.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, t = {}) {
    let r = new Mb(this, t, !0);
    return r.addAll(e, Je.none, t.from, t.to), ne.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, t, r) {
    for (let o = r ? this.tags.indexOf(r) + 1 : 0; o < this.tags.length; o++) {
      let a = this.tags[o];
      if (c3(e, a.tag) && (a.namespace === void 0 || e.namespaceURI == a.namespace) && (!a.context || t.matchesContext(a.context))) {
        if (a.getAttrs) {
          let l = a.getAttrs(e);
          if (l === !1)
            continue;
          a.attrs = l || void 0;
        }
        return a;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, t, r, o) {
    for (let a = o ? this.styles.indexOf(o) + 1 : 0; a < this.styles.length; a++) {
      let l = this.styles[a], d = l.style;
      if (!(d.indexOf(e) != 0 || l.context && !r.matchesContext(l.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      d.length > e.length && (d.charCodeAt(e.length) != 61 || d.slice(e.length + 1) != t))) {
        if (l.getAttrs) {
          let p = l.getAttrs(t);
          if (p === !1)
            continue;
          l.attrs = p || void 0;
        }
        return l;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let t = [];
    function r(o) {
      let a = o.priority == null ? 50 : o.priority, l = 0;
      for (; l < t.length; l++) {
        let d = t[l];
        if ((d.priority == null ? 50 : d.priority) < a)
          break;
      }
      t.splice(l, 0, o);
    }
    for (let o in e.marks) {
      let a = e.marks[o].spec.parseDOM;
      a && a.forEach((l) => {
        r(l = Ob(l)), l.mark || l.ignore || l.clearMark || (l.mark = o);
      });
    }
    for (let o in e.nodes) {
      let a = e.nodes[o].spec.parseDOM;
      a && a.forEach((l) => {
        r(l = Ob(l)), l.node || l.ignore || l.mark || (l.node = o);
      });
    }
    return t;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new Jh(e, Jh.schemaRules(e)));
  }
};
const Ck = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, a3 = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, Sk = { ol: !0, ul: !0 }, dl = 1, Kh = 2, Za = 4;
function Ib(n, e, t) {
  return e != null ? (e ? dl : 0) | (e === "full" ? Kh : 0) : n && n.whitespace == "pre" ? dl | Kh : t & ~Za;
}
class _c {
  constructor(e, t, r, o, a, l) {
    this.type = e, this.attrs = t, this.marks = r, this.solid = o, this.options = l, this.content = [], this.activeMarks = Je.none, this.match = a || (l & Za ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let t = this.type.contentMatch.fillBefore(X.from(e));
      if (t)
        this.match = this.type.contentMatch.matchFragment(t);
      else {
        let r = this.type.contentMatch, o;
        return (o = r.findWrapping(e.type)) ? (this.match = r, o) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & dl)) {
      let r = this.content[this.content.length - 1], o;
      if (r && r.isText && (o = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let a = r;
        r.text.length == o[0].length ? this.content.pop() : this.content[this.content.length - 1] = a.withText(a.text.slice(0, a.text.length - o[0].length));
      }
    }
    let t = X.from(this.content);
    return !e && this.match && (t = t.append(this.match.fillBefore(X.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !Ck.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class Mb {
  constructor(e, t, r) {
    this.parser = e, this.options = t, this.isOpen = r, this.open = 0, this.localPreserveWS = !1;
    let o = t.topNode, a, l = Ib(null, t.preserveWhitespace, 0) | (r ? Za : 0);
    o ? a = new _c(o.type, o.attrs, Je.none, !0, t.topMatch || o.type.contentMatch, l) : r ? a = new _c(null, null, Je.none, !0, null, l) : a = new _c(e.schema.topNodeType, null, Je.none, !0, null, l), this.nodes = [a], this.find = t.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, t) {
    e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t);
  }
  addTextNode(e, t) {
    let r = e.nodeValue, o = this.top, a = o.options & Kh ? "full" : this.localPreserveWS || (o.options & dl) > 0;
    if (a === "full" || o.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (a)
        a !== "full" ? r = r.replace(/\r?\n|\r/g, " ") : r = r.replace(/\r\n?/g, `
`);
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let l = o.content[o.content.length - 1], d = e.previousSibling;
        (!l || d && d.nodeName == "BR" || l.isText && /[ \t\r\n\u000c]$/.test(l.text)) && (r = r.slice(1));
      }
      r && this.insertNode(this.parser.schema.text(r), t, !/\S/.test(r)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, t, r) {
    let o = this.localPreserveWS, a = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let l = e.nodeName.toLowerCase(), d;
    Sk.hasOwnProperty(l) && this.parser.normalizeLists && l3(e);
    let p = this.options.ruleFromNode && this.options.ruleFromNode(e) || (d = this.parser.matchTag(e, this, r));
    e: if (p ? p.ignore : a3.hasOwnProperty(l))
      this.findInside(e), this.ignoreFallback(e, t);
    else if (!p || p.skip || p.closeParent) {
      p && p.closeParent ? this.open = Math.max(0, this.open - 1) : p && p.skip.nodeType && (e = p.skip);
      let f, m = this.needsBlock;
      if (Ck.hasOwnProperty(l))
        a.content.length && a.content[0].isInline && this.open && (this.open--, a = this.top), f = !0, a.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, t);
        break e;
      }
      let y = p && p.skip ? t : this.readStyles(e, t);
      y && this.addAll(e, y), f && this.sync(a), this.needsBlock = m;
    } else {
      let f = this.readStyles(e, t);
      f && this.addElementByRule(e, p, f, p.consuming === !1 ? d : void 0);
    }
    this.localPreserveWS = o;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, t) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t);
  }
  // Called for ignored nodes
  ignoreFallback(e, t) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t, !0);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, t) {
    let r = e.style;
    if (r && r.length)
      for (let o = 0; o < this.parser.matchedStyles.length; o++) {
        let a = this.parser.matchedStyles[o], l = r.getPropertyValue(a);
        if (l)
          for (let d = void 0; ; ) {
            let p = this.parser.matchStyle(a, l, this, d);
            if (!p)
              break;
            if (p.ignore)
              return null;
            if (p.clearMark ? t = t.filter((f) => !p.clearMark(f)) : t = t.concat(this.parser.schema.marks[p.mark].create(p.attrs)), p.consuming === !1)
              d = p;
            else
              break;
          }
      }
    return t;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, t, r, o) {
    let a, l;
    if (t.node)
      if (l = this.parser.schema.nodes[t.node], l.isLeaf)
        this.insertNode(l.create(t.attrs), r, e.nodeName == "BR") || this.leafFallback(e, r);
      else {
        let p = this.enter(l, t.attrs || null, r, t.preserveWhitespace);
        p && (a = !0, r = p);
      }
    else {
      let p = this.parser.schema.marks[t.mark];
      r = r.concat(p.create(t.attrs));
    }
    let d = this.top;
    if (l && l.isLeaf)
      this.findInside(e);
    else if (o)
      this.addElement(e, r, o);
    else if (t.getContent)
      this.findInside(e), t.getContent(e, this.parser.schema).forEach((p) => this.insertNode(p, r, !1));
    else {
      let p = e;
      typeof t.contentElement == "string" ? p = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? p = t.contentElement(e) : t.contentElement && (p = t.contentElement), this.findAround(e, p, !0), this.addAll(p, r), this.findAround(e, p, !1);
    }
    a && this.sync(d) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, t, r, o) {
    let a = r || 0;
    for (let l = r ? e.childNodes[r] : e.firstChild, d = o == null ? null : e.childNodes[o]; l != d; l = l.nextSibling, ++a)
      this.findAtPoint(e, a), this.addDOM(l, t);
    this.findAtPoint(e, a);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, t, r) {
    let o, a;
    for (let l = this.open, d = 0; l >= 0; l--) {
      let p = this.nodes[l], f = p.findWrapping(e);
      if (f && (!o || o.length > f.length + d) && (o = f, a = p, !f.length))
        break;
      if (p.solid) {
        if (r)
          break;
        d += 2;
      }
    }
    if (!o)
      return null;
    this.sync(a);
    for (let l = 0; l < o.length; l++)
      t = this.enterInner(o[l], null, t, !1);
    return t;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, t, r) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let a = this.textblockFromContext();
      a && (t = this.enterInner(a, null, t));
    }
    let o = this.findPlace(e, t, r);
    if (o) {
      this.closeExtra();
      let a = this.top;
      a.match && (a.match = a.match.matchType(e.type));
      let l = Je.none;
      for (let d of o.concat(e.marks))
        (a.type ? a.type.allowsMarkType(d.type) : Db(d.type, e.type)) && (l = d.addToSet(l));
      return a.content.push(e.mark(l)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, t, r, o) {
    let a = this.findPlace(e.create(t), r, !1);
    return a && (a = this.enterInner(e, t, r, !0, o)), a;
  }
  // Open a node of the given type
  enterInner(e, t, r, o = !1, a) {
    this.closeExtra();
    let l = this.top;
    l.match = l.match && l.match.matchType(e);
    let d = Ib(e, a, l.options);
    l.options & Za && l.content.length == 0 && (d |= Za);
    let p = Je.none;
    return r = r.filter((f) => (l.type ? l.type.allowsMarkType(f.type) : Db(f.type, e)) ? (p = f.addToSet(p), !1) : !0), this.nodes.push(new _c(e, t, p, o, null, d)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let t = this.nodes.length - 1;
    if (t > this.open) {
      for (; t > this.open; t--)
        this.nodes[t - 1].content.push(this.nodes[t].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let t = this.open; t >= 0; t--) {
      if (this.nodes[t] == e)
        return this.open = t, !0;
      this.localPreserveWS && (this.nodes[t].options |= dl);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let t = this.open; t >= 0; t--) {
      let r = this.nodes[t].content;
      for (let o = r.length - 1; o >= 0; o--)
        e += r[o].nodeSize;
      t && e++;
    }
    return e;
  }
  findAtPoint(e, t) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == t && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos);
  }
  findAround(e, t, r) {
    if (e != t && this.find)
      for (let o = 0; o < this.find.length; o++)
        this.find[o].pos == null && e.nodeType == 1 && e.contains(this.find[o].node) && t.compareDocumentPosition(this.find[o].node) & (r ? 2 : 4) && (this.find[o].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let t = e.split("/"), r = this.options.context, o = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), a = -(r ? r.depth + 1 : 0) + (o ? 0 : 1), l = (d, p) => {
      for (; d >= 0; d--) {
        let f = t[d];
        if (f == "") {
          if (d == t.length - 1 || d == 0)
            continue;
          for (; p >= a; p--)
            if (l(d - 1, p))
              return !0;
          return !1;
        } else {
          let m = p > 0 || p == 0 && o ? this.nodes[p].type : r && p >= a ? r.node(p - a).type : null;
          if (!m || m.name != f && !m.isInGroup(f))
            return !1;
          p--;
        }
      }
      return !0;
    };
    return l(t.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let t = e.depth; t >= 0; t--) {
        let r = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let t in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[t];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function l3(n) {
  for (let e = n.firstChild, t = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && Sk.hasOwnProperty(r) && t ? (t.appendChild(e), e = t) : r == "li" ? t = e : r && (t = null);
  }
}
function c3(n, e) {
  return (n.matches || n.msMatchesSelector || n.webkitMatchesSelector || n.mozMatchesSelector).call(n, e);
}
function Ob(n) {
  let e = {};
  for (let t in n)
    e[t] = n[t];
  return e;
}
function Db(n, e) {
  let t = e.schema.nodes;
  for (let r in t) {
    let o = t[r];
    if (!o.allowsMarkType(n))
      continue;
    let a = [], l = (d) => {
      a.push(d);
      for (let p = 0; p < d.edgeCount; p++) {
        let { type: f, next: m } = d.edge(p);
        if (f == e || a.indexOf(m) < 0 && l(m))
          return !0;
      }
    };
    if (l(o.contentMatch))
      return !0;
  }
}
class Uo {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, t) {
    this.nodes = e, this.marks = t;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, t = {}, r) {
    r || (r = ah(t).createDocumentFragment());
    let o = r, a = [];
    return e.forEach((l) => {
      if (a.length || l.marks.length) {
        let d = 0, p = 0;
        for (; d < a.length && p < l.marks.length; ) {
          let f = l.marks[p];
          if (!this.marks[f.type.name]) {
            p++;
            continue;
          }
          if (!f.eq(a[d][0]) || f.type.spec.spanning === !1)
            break;
          d++, p++;
        }
        for (; d < a.length; )
          o = a.pop()[1];
        for (; p < l.marks.length; ) {
          let f = l.marks[p++], m = this.serializeMark(f, l.isInline, t);
          m && (a.push([f, o]), o.appendChild(m.dom), o = m.contentDOM || m.dom);
        }
      }
      o.appendChild(this.serializeNodeInner(l, t));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, t) {
    let { dom: r, contentDOM: o } = uu(ah(t), this.nodes[e.type.name](e), null, e.attrs);
    if (o) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, t, o);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, t = {}) {
    let r = this.serializeNodeInner(e, t);
    for (let o = e.marks.length - 1; o >= 0; o--) {
      let a = this.serializeMark(e.marks[o], e.isInline, t);
      a && ((a.contentDOM || a.dom).appendChild(r), r = a.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, t, r = {}) {
    let o = this.marks[e.type.name];
    return o && uu(ah(r), o(e, t), null, e.attrs);
  }
  static renderSpec(e, t, r = null, o) {
    return uu(e, t, r, o);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new Uo(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let t = Rb(e.nodes);
    return t.text || (t.text = (r) => r.text), t;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return Rb(e.marks);
  }
}
function Rb(n) {
  let e = {};
  for (let t in n) {
    let r = n[t].spec.toDOM;
    r && (e[t] = r);
  }
  return e;
}
function ah(n) {
  return n.document || window.document;
}
const Fb = /* @__PURE__ */ new WeakMap();
function u3(n) {
  let e = Fb.get(n);
  return e === void 0 && Fb.set(n, e = d3(n)), e;
}
function d3(n) {
  let e = null;
  function t(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          e || (e = []), e.push(r);
        else
          for (let o = 0; o < r.length; o++)
            t(r[o]);
      else
        for (let o in r)
          t(r[o]);
  }
  return t(n), e;
}
function uu(n, e, t, r) {
  if (typeof e == "string")
    return { dom: n.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let o = e[0], a;
  if (typeof o != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (a = u3(r)) && a.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let l = o.indexOf(" ");
  l > 0 && (t = o.slice(0, l), o = o.slice(l + 1));
  let d, p = t ? n.createElementNS(t, o) : n.createElement(o), f = e[1], m = 1;
  if (f && typeof f == "object" && f.nodeType == null && !Array.isArray(f)) {
    m = 2;
    for (let y in f)
      if (f[y] != null) {
        let v = y.indexOf(" ");
        v > 0 ? p.setAttributeNS(y.slice(0, v), y.slice(v + 1), f[y]) : y == "style" && p.style ? p.style.cssText = f[y] : p.setAttribute(y, f[y]);
      }
  }
  for (let y = m; y < e.length; y++) {
    let v = e[y];
    if (v === 0) {
      if (y < e.length - 1 || y > m)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: p, contentDOM: p };
    } else {
      let { dom: k, contentDOM: A } = uu(n, v, t, r);
      if (p.appendChild(k), A) {
        if (d)
          throw new RangeError("Multiple content holes");
        d = A;
      }
    }
  }
  return { dom: p, contentDOM: d };
}
const Ek = 65535, Tk = Math.pow(2, 16);
function p3(n, e) {
  return n + e * Tk;
}
function Pb(n) {
  return n & Ek;
}
function h3(n) {
  return (n - (n & Ek)) / Tk;
}
const Nk = 1, Bk = 2, du = 4, Ik = 8;
class Wh {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.pos = e, this.delInfo = t, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & Ik) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (Nk | du)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (Bk | du)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & du) > 0;
  }
}
class Cn {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, t = !1) {
    if (this.ranges = e, this.inverted = t, !e.length && Cn.empty)
      return Cn.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let t = 0, r = Pb(e);
    if (!this.inverted)
      for (let o = 0; o < r; o++)
        t += this.ranges[o * 3 + 2] - this.ranges[o * 3 + 1];
    return this.ranges[r * 3] + t + h3(e);
  }
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  map(e, t = 1) {
    return this._map(e, t, !0);
  }
  /**
  @internal
  */
  _map(e, t, r) {
    let o = 0, a = this.inverted ? 2 : 1, l = this.inverted ? 1 : 2;
    for (let d = 0; d < this.ranges.length; d += 3) {
      let p = this.ranges[d] - (this.inverted ? o : 0);
      if (p > e)
        break;
      let f = this.ranges[d + a], m = this.ranges[d + l], y = p + f;
      if (e <= y) {
        let v = f ? e == p ? -1 : e == y ? 1 : t : t, k = p + o + (v < 0 ? 0 : m);
        if (r)
          return k;
        let A = e == (t < 0 ? p : y) ? null : p3(d / 3, e - p), S = e == p ? Bk : e == y ? Nk : du;
        return (t < 0 ? e != p : e != y) && (S |= Ik), new Wh(k, S, A);
      }
      o += m - f;
    }
    return r ? e + o : new Wh(e + o, 0, null);
  }
  /**
  @internal
  */
  touches(e, t) {
    let r = 0, o = Pb(t), a = this.inverted ? 2 : 1, l = this.inverted ? 1 : 2;
    for (let d = 0; d < this.ranges.length; d += 3) {
      let p = this.ranges[d] - (this.inverted ? r : 0);
      if (p > e)
        break;
      let f = this.ranges[d + a], m = p + f;
      if (e <= m && d == o * 3)
        return !0;
      r += this.ranges[d + l] - f;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let t = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let o = 0, a = 0; o < this.ranges.length; o += 3) {
      let l = this.ranges[o], d = l - (this.inverted ? a : 0), p = l + (this.inverted ? 0 : a), f = this.ranges[o + t], m = this.ranges[o + r];
      e(d, d + f, p, p + m), a += m - f;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new Cn(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? Cn.empty : new Cn(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
Cn.empty = new Cn([]);
class pl {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e, t, r = 0, o = e ? e.length : 0) {
    this.mirror = t, this.from = r, this.to = o, this._maps = e || [], this.ownData = !(e || t);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, t = this.maps.length) {
    return new pl(this._maps, this.mirror, e, t);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, t) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), t != null && this.setMirror(this._maps.length - 1, t);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let t = 0, r = this._maps.length; t < e._maps.length; t++) {
      let o = e.getMirror(t);
      this.appendMap(e._maps[t], o != null && o < t ? r + o : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let t = 0; t < this.mirror.length; t++)
        if (this.mirror[t] == e)
          return this.mirror[t + (t % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, t) {
    this.mirror || (this.mirror = []), this.mirror.push(e, t);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let t = e.maps.length - 1, r = this._maps.length + e._maps.length; t >= 0; t--) {
      let o = e.getMirror(t);
      this.appendMap(e._maps[t].invert(), o != null && o > t ? r - o - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new pl();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, t = 1) {
    if (this.mirror)
      return this._map(e, t, !0);
    for (let r = this.from; r < this.to; r++)
      e = this._maps[r].map(e, t);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  /**
  @internal
  */
  _map(e, t, r) {
    let o = 0;
    for (let a = this.from; a < this.to; a++) {
      let l = this._maps[a], d = l.mapResult(e, t);
      if (d.recover != null) {
        let p = this.getMirror(a);
        if (p != null && p > a && p < this.to) {
          a = p, e = this._maps[p].recover(d.recover);
          continue;
        }
      }
      o |= d.delInfo, e = d.pos;
    }
    return r ? e : new Wh(e, o, null);
  }
}
const lh = /* @__PURE__ */ Object.create(null);
class Yt {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return Cn.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, t) {
    if (!t || !t.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = lh[t.stepType];
    if (!r)
      throw new RangeError(`No step type ${t.stepType} defined`);
    return r.fromJSON(e, t);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, t) {
    if (e in lh)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return lh[e] = t, t.prototype.jsonID = e, t;
  }
}
class Ct {
  /**
  @internal
  */
  constructor(e, t) {
    this.doc = e, this.failed = t;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new Ct(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new Ct(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, t, r, o) {
    try {
      return Ct.ok(e.replace(t, r, o));
    } catch (a) {
      if (a instanceof Cu)
        return Ct.fail(a.message);
      throw a;
    }
  }
}
function qf(n, e, t) {
  let r = [];
  for (let o = 0; o < n.childCount; o++) {
    let a = n.child(o);
    a.content.size && (a = a.copy(qf(a.content, e, a))), a.isInline && (a = e(a, t, o)), r.push(a);
  }
  return X.fromArray(r);
}
class Ei extends Yt {
  /**
  Create a mark step.
  */
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = e.resolve(this.from), o = r.node(r.sharedDepth(this.to)), a = new ne(qf(t.content, (l, d) => !l.isAtom || !d.type.allowsMarkType(this.mark.type) ? l : l.mark(this.mark.addToSet(l.marks)), o), t.openStart, t.openEnd);
    return Ct.fromReplace(e, this.from, this.to, a);
  }
  invert() {
    return new Jn(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new Ei(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Ei && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Ei(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new Ei(t.from, t.to, e.markFromJSON(t.mark));
  }
}
Yt.jsonID("addMark", Ei);
class Jn extends Yt {
  /**
  Create a mark-removing step.
  */
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = new ne(qf(t.content, (o) => o.mark(this.mark.removeFromSet(o.marks)), e), t.openStart, t.openEnd);
    return Ct.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new Ei(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new Jn(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Jn && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Jn(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new Jn(t.from, t.to, e.markFromJSON(t.mark));
  }
}
Yt.jsonID("removeMark", Jn);
class Ti extends Yt {
  /**
  Create a node mark step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return Ct.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
    return Ct.fromReplace(e, this.pos, this.pos + 1, new ne(X.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    if (t) {
      let r = this.mark.addToSet(t.marks);
      if (r.length == t.marks.length) {
        for (let o = 0; o < t.marks.length; o++)
          if (!t.marks[o].isInSet(r))
            return new Ti(this.pos, t.marks[o]);
        return new Ti(this.pos, this.mark);
      }
    }
    return new No(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new Ti(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new Ti(t.pos, e.markFromJSON(t.mark));
  }
}
Yt.jsonID("addNodeMark", Ti);
class No extends Yt {
  /**
  Create a mark-removing step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return Ct.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
    return Ct.fromReplace(e, this.pos, this.pos + 1, new ne(X.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    return !t || !this.mark.isInSet(t.marks) ? this : new Ti(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new No(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new No(t.pos, e.markFromJSON(t.mark));
  }
}
Yt.jsonID("removeNodeMark", No);
class At extends Yt {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, t, r, o = !1) {
    super(), this.from = e, this.to = t, this.slice = r, this.structure = o;
  }
  apply(e) {
    return this.structure && Yh(e, this.from, this.to) ? Ct.fail("Structure replace would overwrite content") : Ct.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new Cn([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new At(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deletedAcross && r.deletedAcross ? null : new At(t.pos, Math.max(t.pos, r.pos), this.slice, this.structure);
  }
  merge(e) {
    if (!(e instanceof At) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let t = this.slice.size + e.slice.size == 0 ? ne.empty : new ne(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new At(this.from, this.to + (e.to - e.from), t, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let t = this.slice.size + e.slice.size == 0 ? ne.empty : new ne(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new At(e.from, this.to, t, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new At(t.from, t.to, ne.fromJSON(e, t.slice), !!t.structure);
  }
}
Yt.jsonID("replace", At);
class Mt extends Yt {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, t, r, o, a, l, d = !1) {
    super(), this.from = e, this.to = t, this.gapFrom = r, this.gapTo = o, this.slice = a, this.insert = l, this.structure = d;
  }
  apply(e) {
    if (this.structure && (Yh(e, this.from, this.gapFrom) || Yh(e, this.gapTo, this.to)))
      return Ct.fail("Structure gap-replace would overwrite content");
    let t = e.slice(this.gapFrom, this.gapTo);
    if (t.openStart || t.openEnd)
      return Ct.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, t.content);
    return r ? Ct.fromReplace(e, this.from, this.to, r) : Ct.fail("Content does not fit in gap");
  }
  getMap() {
    return new Cn([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let t = this.gapTo - this.gapFrom;
    return new Mt(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), o = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), a = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return t.deletedAcross && r.deletedAcross || o < t.pos || a > r.pos ? null : new Mt(t.pos, r.pos, o, a, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Mt(t.from, t.to, t.gapFrom, t.gapTo, ne.fromJSON(e, t.slice), t.insert, !!t.structure);
  }
}
Yt.jsonID("replaceAround", Mt);
function Yh(n, e, t) {
  let r = n.resolve(e), o = t - e, a = r.depth;
  for (; o > 0 && a > 0 && r.indexAfter(a) == r.node(a).childCount; )
    a--, o--;
  if (o > 0) {
    let l = r.node(a).maybeChild(r.indexAfter(a));
    for (; o > 0; ) {
      if (!l || l.isLeaf)
        return !0;
      l = l.firstChild, o--;
    }
  }
  return !1;
}
function f3(n, e, t, r) {
  let o = [], a = [], l, d;
  n.doc.nodesBetween(e, t, (p, f, m) => {
    if (!p.isInline)
      return;
    let y = p.marks;
    if (!r.isInSet(y) && m.type.allowsMarkType(r.type)) {
      let v = Math.max(f, e), k = Math.min(f + p.nodeSize, t), A = r.addToSet(y);
      for (let S = 0; S < y.length; S++)
        y[S].isInSet(A) || (l && l.to == v && l.mark.eq(y[S]) ? l.to = k : o.push(l = new Jn(v, k, y[S])));
      d && d.to == v ? d.to = k : a.push(d = new Ei(v, k, r));
    }
  }), o.forEach((p) => n.step(p)), a.forEach((p) => n.step(p));
}
function m3(n, e, t, r) {
  let o = [], a = 0;
  n.doc.nodesBetween(e, t, (l, d) => {
    if (!l.isInline)
      return;
    a++;
    let p = null;
    if (r instanceof td) {
      let f = l.marks, m;
      for (; m = r.isInSet(f); )
        (p || (p = [])).push(m), f = m.removeFromSet(f);
    } else r ? r.isInSet(l.marks) && (p = [r]) : p = l.marks;
    if (p && p.length) {
      let f = Math.min(d + l.nodeSize, t);
      for (let m = 0; m < p.length; m++) {
        let y = p[m], v;
        for (let k = 0; k < o.length; k++) {
          let A = o[k];
          A.step == a - 1 && y.eq(o[k].style) && (v = A);
        }
        v ? (v.to = f, v.step = a) : o.push({ style: y, from: Math.max(d, e), to: f, step: a });
      }
    }
  }), o.forEach((l) => n.step(new Jn(l.from, l.to, l.style)));
}
function Vf(n, e, t, r = t.contentMatch, o = !0) {
  let a = n.doc.nodeAt(e), l = [], d = e + 1;
  for (let p = 0; p < a.childCount; p++) {
    let f = a.child(p), m = d + f.nodeSize, y = r.matchType(f.type);
    if (!y)
      l.push(new At(d, m, ne.empty));
    else {
      r = y;
      for (let v = 0; v < f.marks.length; v++)
        t.allowsMarkType(f.marks[v].type) || n.step(new Jn(d, m, f.marks[v]));
      if (o && f.isText && t.whitespace != "pre") {
        let v, k = /\r?\n|\r/g, A;
        for (; v = k.exec(f.text); )
          A || (A = new ne(X.from(t.schema.text(" ", t.allowedMarks(f.marks))), 0, 0)), l.push(new At(d + v.index, d + v.index + v[0].length, A));
      }
    }
    d = m;
  }
  if (!r.validEnd) {
    let p = r.fillBefore(X.empty, !0);
    n.replace(d, d, new ne(p, 0, 0));
  }
  for (let p = l.length - 1; p >= 0; p--)
    n.step(l[p]);
}
function g3(n, e, t) {
  return (e == 0 || n.canReplace(e, n.childCount)) && (t == n.childCount || n.canReplace(0, t));
}
function aa(n) {
  let t = n.parent.content.cutByIndex(n.startIndex, n.endIndex);
  for (let r = n.depth; ; --r) {
    let o = n.$from.node(r), a = n.$from.index(r), l = n.$to.indexAfter(r);
    if (r < n.depth && o.canReplace(a, l, t))
      return r;
    if (r == 0 || o.type.spec.isolating || !g3(o, a, l))
      break;
  }
  return null;
}
function y3(n, e, t) {
  let { $from: r, $to: o, depth: a } = e, l = r.before(a + 1), d = o.after(a + 1), p = l, f = d, m = X.empty, y = 0;
  for (let A = a, S = !1; A > t; A--)
    S || r.index(A) > 0 ? (S = !0, m = X.from(r.node(A).copy(m)), y++) : p--;
  let v = X.empty, k = 0;
  for (let A = a, S = !1; A > t; A--)
    S || o.after(A + 1) < o.end(A) ? (S = !0, v = X.from(o.node(A).copy(v)), k++) : f++;
  n.step(new Mt(p, f, l, d, new ne(m.append(v), y, k), m.size - y, !0));
}
function Xf(n, e, t = null, r = n) {
  let o = w3(n, e), a = o && b3(r, e);
  return a ? o.map($b).concat({ type: e, attrs: t }).concat(a.map($b)) : null;
}
function $b(n) {
  return { type: n, attrs: null };
}
function w3(n, e) {
  let { parent: t, startIndex: r, endIndex: o } = n, a = t.contentMatchAt(r).findWrapping(e);
  if (!a)
    return null;
  let l = a.length ? a[0] : e;
  return t.canReplaceWith(r, o, l) ? a : null;
}
function b3(n, e) {
  let { parent: t, startIndex: r, endIndex: o } = n, a = t.child(r), l = e.contentMatch.findWrapping(a.type);
  if (!l)
    return null;
  let p = (l.length ? l[l.length - 1] : e).contentMatch;
  for (let f = r; p && f < o; f++)
    p = p.matchType(t.child(f).type);
  return !p || !p.validEnd ? null : l;
}
function v3(n, e, t) {
  let r = X.empty;
  for (let l = t.length - 1; l >= 0; l--) {
    if (r.size) {
      let d = t[l].type.contentMatch.matchFragment(r);
      if (!d || !d.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = X.from(t[l].type.create(t[l].attrs, r));
  }
  let o = e.start, a = e.end;
  n.step(new Mt(o, a, o, a, new ne(r, 0, 0), t.length, !0));
}
function x3(n, e, t, r, o) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let a = n.steps.length;
  n.doc.nodesBetween(e, t, (l, d) => {
    let p = typeof o == "function" ? o(l) : o;
    if (l.isTextblock && !l.hasMarkup(r, p) && k3(n.doc, n.mapping.slice(a).map(d), r)) {
      let f = null;
      if (r.schema.linebreakReplacement) {
        let k = r.whitespace == "pre", A = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        k && !A ? f = !1 : !k && A && (f = !0);
      }
      f === !1 && Ok(n, l, d, a), Vf(n, n.mapping.slice(a).map(d, 1), r, void 0, f === null);
      let m = n.mapping.slice(a), y = m.map(d, 1), v = m.map(d + l.nodeSize, 1);
      return n.step(new Mt(y, v, y + 1, v - 1, new ne(X.from(r.create(p, null, l.marks)), 0, 0), 1, !0)), f === !0 && Mk(n, l, d, a), !1;
    }
  });
}
function Mk(n, e, t, r) {
  e.forEach((o, a) => {
    if (o.isText) {
      let l, d = /\r?\n|\r/g;
      for (; l = d.exec(o.text); ) {
        let p = n.mapping.slice(r).map(t + 1 + a + l.index);
        n.replaceWith(p, p + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function Ok(n, e, t, r) {
  e.forEach((o, a) => {
    if (o.type == o.type.schema.linebreakReplacement) {
      let l = n.mapping.slice(r).map(t + 1 + a);
      n.replaceWith(l, l + 1, e.type.schema.text(`
`));
    }
  });
}
function k3(n, e, t) {
  let r = n.resolve(e), o = r.index();
  return r.parent.canReplaceWith(o, o + 1, t);
}
function A3(n, e, t, r, o) {
  let a = n.doc.nodeAt(e);
  if (!a)
    throw new RangeError("No node at given position");
  t || (t = a.type);
  let l = t.create(r, null, o || a.marks);
  if (a.isLeaf)
    return n.replaceWith(e, e + a.nodeSize, l);
  if (!t.validContent(a.content))
    throw new RangeError("Invalid content for node type " + t.name);
  n.step(new Mt(e, e + a.nodeSize, e + 1, e + a.nodeSize - 1, new ne(X.from(l), 0, 0), 1, !0));
}
function Vr(n, e, t = 1, r) {
  let o = n.resolve(e), a = o.depth - t, l = r && r[r.length - 1] || o.parent;
  if (a < 0 || o.parent.type.spec.isolating || !o.parent.canReplace(o.index(), o.parent.childCount) || !l.type.validContent(o.parent.content.cutByIndex(o.index(), o.parent.childCount)))
    return !1;
  for (let f = o.depth - 1, m = t - 2; f > a; f--, m--) {
    let y = o.node(f), v = o.index(f);
    if (y.type.spec.isolating)
      return !1;
    let k = y.content.cutByIndex(v, y.childCount), A = r && r[m + 1];
    A && (k = k.replaceChild(0, A.type.create(A.attrs)));
    let S = r && r[m] || y;
    if (!y.canReplace(v + 1, y.childCount) || !S.type.validContent(k))
      return !1;
  }
  let d = o.indexAfter(a), p = r && r[0];
  return o.node(a).canReplaceWith(d, d, p ? p.type : o.node(a + 1).type);
}
function C3(n, e, t = 1, r) {
  let o = n.doc.resolve(e), a = X.empty, l = X.empty;
  for (let d = o.depth, p = o.depth - t, f = t - 1; d > p; d--, f--) {
    a = X.from(o.node(d).copy(a));
    let m = r && r[f];
    l = X.from(m ? m.type.create(m.attrs, l) : o.node(d).copy(l));
  }
  n.step(new At(e, e, new ne(a.append(l), t, t), !0));
}
function Hi(n, e) {
  let t = n.resolve(e), r = t.index();
  return Dk(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(r, r + 1);
}
function S3(n, e) {
  e.content.size || n.type.compatibleContent(e.type);
  let t = n.contentMatchAt(n.childCount), { linebreakReplacement: r } = n.type.schema;
  for (let o = 0; o < e.childCount; o++) {
    let a = e.child(o), l = a.type == r ? n.type.schema.nodes.text : a.type;
    if (t = t.matchType(l), !t || !n.type.allowsMarks(a.marks))
      return !1;
  }
  return t.validEnd;
}
function Dk(n, e) {
  return !!(n && e && !n.isLeaf && S3(n, e));
}
function nd(n, e, t = -1) {
  let r = n.resolve(e);
  for (let o = r.depth; ; o--) {
    let a, l, d = r.index(o);
    if (o == r.depth ? (a = r.nodeBefore, l = r.nodeAfter) : t > 0 ? (a = r.node(o + 1), d++, l = r.node(o).maybeChild(d)) : (a = r.node(o).maybeChild(d - 1), l = r.node(o + 1)), a && !a.isTextblock && Dk(a, l) && r.node(o).canReplace(d, d + 1))
      return e;
    if (o == 0)
      break;
    e = t < 0 ? r.before(o) : r.after(o);
  }
}
function E3(n, e, t) {
  let r = null, { linebreakReplacement: o } = n.doc.type.schema, a = n.doc.resolve(e - t), l = a.node().type;
  if (o && l.inlineContent) {
    let m = l.whitespace == "pre", y = !!l.contentMatch.matchType(o);
    m && !y ? r = !1 : !m && y && (r = !0);
  }
  let d = n.steps.length;
  if (r === !1) {
    let m = n.doc.resolve(e + t);
    Ok(n, m.node(), m.before(), d);
  }
  l.inlineContent && Vf(n, e + t - 1, l, a.node().contentMatchAt(a.index()), r == null);
  let p = n.mapping.slice(d), f = p.map(e - t);
  if (n.step(new At(f, p.map(e + t, -1), ne.empty, !0)), r === !0) {
    let m = n.doc.resolve(f);
    Mk(n, m.node(), m.before(), n.steps.length);
  }
  return n;
}
function T3(n, e, t) {
  let r = n.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), t))
    return e;
  if (r.parentOffset == 0)
    for (let o = r.depth - 1; o >= 0; o--) {
      let a = r.index(o);
      if (r.node(o).canReplaceWith(a, a, t))
        return r.before(o + 1);
      if (a > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let o = r.depth - 1; o >= 0; o--) {
      let a = r.indexAfter(o);
      if (r.node(o).canReplaceWith(a, a, t))
        return r.after(o + 1);
      if (a < r.node(o).childCount)
        return null;
    }
  return null;
}
function Rk(n, e, t) {
  let r = n.resolve(e);
  if (!t.content.size)
    return e;
  let o = t.content;
  for (let a = 0; a < t.openStart; a++)
    o = o.firstChild.content;
  for (let a = 1; a <= (t.openStart == 0 && t.size ? 2 : 1); a++)
    for (let l = r.depth; l >= 0; l--) {
      let d = l == r.depth ? 0 : r.pos <= (r.start(l + 1) + r.end(l + 1)) / 2 ? -1 : 1, p = r.index(l) + (d > 0 ? 1 : 0), f = r.node(l), m = !1;
      if (a == 1)
        m = f.canReplace(p, p, o);
      else {
        let y = f.contentMatchAt(p).findWrapping(o.firstChild.type);
        m = y && f.canReplaceWith(p, p, y[0]);
      }
      if (m)
        return d == 0 ? r.pos : d < 0 ? r.before(l + 1) : r.after(l + 1);
    }
  return null;
}
function rd(n, e, t = e, r = ne.empty) {
  if (e == t && !r.size)
    return null;
  let o = n.resolve(e), a = n.resolve(t);
  return Fk(o, a, r) ? new At(e, t, r) : new N3(o, a, r).fit();
}
function Fk(n, e, t) {
  return !t.openStart && !t.openEnd && n.start() == e.start() && n.parent.canReplace(n.index(), e.index(), t.content);
}
class N3 {
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.unplaced = r, this.frontier = [], this.placed = X.empty;
    for (let o = 0; o <= e.depth; o++) {
      let a = e.node(o);
      this.frontier.push({
        type: a.type,
        match: a.contentMatchAt(e.indexAfter(o))
      });
    }
    for (let o = e.depth; o > 0; o--)
      this.placed = X.from(e.node(o).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let f = this.findFittable();
      f ? this.placeNodes(f) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, r = this.$from, o = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!o)
      return null;
    let a = this.placed, l = r.depth, d = o.depth;
    for (; l && d && a.childCount == 1; )
      a = a.firstChild.content, l--, d--;
    let p = new ne(a, l, d);
    return e > -1 ? new Mt(r.pos, e, this.$to.pos, this.$to.end(), p, t) : p.size || r.pos != this.$to.pos ? new At(r.pos, o.pos, p) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let t = this.unplaced.content, r = 0, o = this.unplaced.openEnd; r < e; r++) {
      let a = t.firstChild;
      if (t.childCount > 1 && (o = 0), a.type.spec.isolating && o <= r) {
        e = r;
        break;
      }
      t = a.content;
    }
    for (let t = 1; t <= 2; t++)
      for (let r = t == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let o, a = null;
        r ? (a = ch(this.unplaced.content, r - 1).firstChild, o = a.content) : o = this.unplaced.content;
        let l = o.firstChild;
        for (let d = this.depth; d >= 0; d--) {
          let { type: p, match: f } = this.frontier[d], m, y = null;
          if (t == 1 && (l ? f.matchType(l.type) || (y = f.fillBefore(X.from(l), !1)) : a && p.compatibleContent(a.type)))
            return { sliceDepth: r, frontierDepth: d, parent: a, inject: y };
          if (t == 2 && l && (m = f.findWrapping(l.type)))
            return { sliceDepth: r, frontierDepth: d, parent: a, wrap: m };
          if (a && f.matchType(a.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, o = ch(e, t);
    return !o.childCount || o.firstChild.isLeaf ? !1 : (this.unplaced = new ne(e, t + 1, Math.max(r, o.size + t >= e.size - r ? t + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, o = ch(e, t);
    if (o.childCount <= 1 && t > 0) {
      let a = e.size - t <= t + o.size;
      this.unplaced = new ne(Ja(e, t - 1, 1), t - 1, a ? t - 1 : r);
    } else
      this.unplaced = new ne(Ja(e, t, 1), t, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: t, parent: r, inject: o, wrap: a }) {
    for (; this.depth > t; )
      this.closeFrontierNode();
    if (a)
      for (let S = 0; S < a.length; S++)
        this.openFrontierNode(a[S]);
    let l = this.unplaced, d = r ? r.content : l.content, p = l.openStart - e, f = 0, m = [], { match: y, type: v } = this.frontier[t];
    if (o) {
      for (let S = 0; S < o.childCount; S++)
        m.push(o.child(S));
      y = y.matchFragment(o);
    }
    let k = d.size + e - (l.content.size - l.openEnd);
    for (; f < d.childCount; ) {
      let S = d.child(f), B = y.matchType(S.type);
      if (!B)
        break;
      f++, (f > 1 || p == 0 || S.content.size) && (y = B, m.push(Pk(S.mark(v.allowedMarks(S.marks)), f == 1 ? p : 0, f == d.childCount ? k : -1)));
    }
    let A = f == d.childCount;
    A || (k = -1), this.placed = Ka(this.placed, t, X.from(m)), this.frontier[t].match = y, A && k < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let S = 0, B = d; S < k; S++) {
      let O = B.lastChild;
      this.frontier.push({ type: O.type, match: O.contentMatchAt(O.childCount) }), B = O.content;
    }
    this.unplaced = A ? e == 0 ? ne.empty : new ne(Ja(l.content, e - 1, 1), e - 1, k < 0 ? l.openEnd : e - 1) : new ne(Ja(l.content, e, f), l.openStart, l.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], t;
    if (!e.type.isTextblock || !uh(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, o = this.$to.after(r);
    for (; r > 1 && o == this.$to.end(--r); )
      ++o;
    return o;
  }
  findCloseLevel(e) {
    e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
      let { match: r, type: o } = this.frontier[t], a = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), l = uh(e, t, o, r, a);
      if (l) {
        for (let d = t - 1; d >= 0; d--) {
          let { match: p, type: f } = this.frontier[d], m = uh(e, d, f, p, !0);
          if (!m || m.childCount)
            continue e;
        }
        return { depth: t, fit: l, move: a ? e.doc.resolve(e.after(t + 1)) : e };
      }
    }
  }
  close(e) {
    let t = this.findCloseLevel(e);
    if (!t)
      return null;
    for (; this.depth > t.depth; )
      this.closeFrontierNode();
    t.fit.childCount && (this.placed = Ka(this.placed, t.depth, t.fit)), e = t.move;
    for (let r = t.depth + 1; r <= e.depth; r++) {
      let o = e.node(r), a = o.type.contentMatch.fillBefore(o.content, !0, e.index(r));
      this.openFrontierNode(o.type, o.attrs, a);
    }
    return e;
  }
  openFrontierNode(e, t = null, r) {
    let o = this.frontier[this.depth];
    o.match = o.match.matchType(e), this.placed = Ka(this.placed, this.depth, X.from(e.create(t, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let t = this.frontier.pop().match.fillBefore(X.empty, !0);
    t.childCount && (this.placed = Ka(this.placed, this.frontier.length, t));
  }
}
function Ja(n, e, t) {
  return e == 0 ? n.cutByIndex(t, n.childCount) : n.replaceChild(0, n.firstChild.copy(Ja(n.firstChild.content, e - 1, t)));
}
function Ka(n, e, t) {
  return e == 0 ? n.append(t) : n.replaceChild(n.childCount - 1, n.lastChild.copy(Ka(n.lastChild.content, e - 1, t)));
}
function ch(n, e) {
  for (let t = 0; t < e; t++)
    n = n.firstChild.content;
  return n;
}
function Pk(n, e, t) {
  if (e <= 0)
    return n;
  let r = n.content;
  return e > 1 && (r = r.replaceChild(0, Pk(r.firstChild, e - 1, r.childCount == 1 ? t - 1 : 0))), e > 0 && (r = n.type.contentMatch.fillBefore(r).append(r), t <= 0 && (r = r.append(n.type.contentMatch.matchFragment(r).fillBefore(X.empty, !0)))), n.copy(r);
}
function uh(n, e, t, r, o) {
  let a = n.node(e), l = o ? n.indexAfter(e) : n.index(e);
  if (l == a.childCount && !t.compatibleContent(a.type))
    return null;
  let d = r.fillBefore(a.content, !0, l);
  return d && !B3(t, a.content, l) ? d : null;
}
function B3(n, e, t) {
  for (let r = t; r < e.childCount; r++)
    if (!n.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function I3(n) {
  return n.spec.defining || n.spec.definingForContent;
}
function M3(n, e, t, r) {
  if (!r.size)
    return n.deleteRange(e, t);
  let o = n.doc.resolve(e), a = n.doc.resolve(t);
  if (Fk(o, a, r))
    return n.step(new At(e, t, r));
  let l = jk(o, n.doc.resolve(t));
  l[l.length - 1] == 0 && l.pop();
  let d = -(o.depth + 1);
  l.unshift(d);
  for (let v = o.depth, k = o.pos - 1; v > 0; v--, k--) {
    let A = o.node(v).type.spec;
    if (A.defining || A.definingAsContext || A.isolating)
      break;
    l.indexOf(v) > -1 ? d = v : o.before(v) == k && l.splice(1, 0, -v);
  }
  let p = l.indexOf(d), f = [], m = r.openStart;
  for (let v = r.content, k = 0; ; k++) {
    let A = v.firstChild;
    if (f.push(A), k == r.openStart)
      break;
    v = A.content;
  }
  for (let v = m - 1; v >= 0; v--) {
    let k = f[v], A = I3(k.type);
    if (A && !k.sameMarkup(o.node(Math.abs(d) - 1)))
      m = v;
    else if (A || !k.type.isTextblock)
      break;
  }
  for (let v = r.openStart; v >= 0; v--) {
    let k = (v + m + 1) % (r.openStart + 1), A = f[k];
    if (A)
      for (let S = 0; S < l.length; S++) {
        let B = l[(S + p) % l.length], O = !0;
        B < 0 && (O = !1, B = -B);
        let L = o.node(B - 1), G = o.index(B - 1);
        if (L.canReplaceWith(G, G, A.type, A.marks))
          return n.replace(o.before(B), O ? a.after(B) : t, new ne($k(r.content, 0, r.openStart, k), k, r.openEnd));
      }
  }
  let y = n.steps.length;
  for (let v = l.length - 1; v >= 0 && (n.replace(e, t, r), !(n.steps.length > y)); v--) {
    let k = l[v];
    k < 0 || (e = o.before(k), t = a.after(k));
  }
}
function $k(n, e, t, r, o) {
  if (e < t) {
    let a = n.firstChild;
    n = n.replaceChild(0, a.copy($k(a.content, e + 1, t, r, a)));
  }
  if (e > r) {
    let a = o.contentMatchAt(0), l = a.fillBefore(n).append(n);
    n = l.append(a.matchFragment(l).fillBefore(X.empty, !0));
  }
  return n;
}
function O3(n, e, t, r) {
  if (!r.isInline && e == t && n.doc.resolve(e).parent.content.size) {
    let o = T3(n.doc, e, r.type);
    o != null && (e = t = o);
  }
  n.replaceRange(e, t, new ne(X.from(r), 0, 0));
}
function D3(n, e, t) {
  let r = n.doc.resolve(e), o = n.doc.resolve(t), a = jk(r, o);
  for (let l = 0; l < a.length; l++) {
    let d = a[l], p = l == a.length - 1;
    if (p && d == 0 || r.node(d).type.contentMatch.validEnd)
      return n.delete(r.start(d), o.end(d));
    if (d > 0 && (p || r.node(d - 1).canReplace(r.index(d - 1), o.indexAfter(d - 1))))
      return n.delete(r.before(d), o.after(d));
  }
  for (let l = 1; l <= r.depth && l <= o.depth; l++)
    if (e - r.start(l) == r.depth - l && t > r.end(l) && o.end(l) - t != o.depth - l && r.start(l - 1) == o.start(l - 1) && r.node(l - 1).canReplace(r.index(l - 1), o.index(l - 1)))
      return n.delete(r.before(l), t);
  n.delete(e, t);
}
function jk(n, e) {
  let t = [], r = Math.min(n.depth, e.depth);
  for (let o = r; o >= 0; o--) {
    let a = n.start(o);
    if (a < n.pos - (n.depth - o) || e.end(o) > e.pos + (e.depth - o) || n.node(o).type.spec.isolating || e.node(o).type.spec.isolating)
      break;
    (a == e.start(o) || o == n.depth && o == e.depth && n.parent.inlineContent && e.parent.inlineContent && o && e.start(o - 1) == a - 1) && t.push(o);
  }
  return t;
}
class $s extends Yt {
  /**
  Construct an attribute step.
  */
  constructor(e, t, r) {
    super(), this.pos = e, this.attr = t, this.value = r;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return Ct.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let a in t.attrs)
      r[a] = t.attrs[a];
    r[this.attr] = this.value;
    let o = t.type.create(r, null, t.marks);
    return Ct.fromReplace(e, this.pos, this.pos + 1, new ne(X.from(o), 0, t.isLeaf ? 0 : 1));
  }
  getMap() {
    return Cn.empty;
  }
  invert(e) {
    return new $s(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new $s(t.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.pos != "number" || typeof t.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new $s(t.pos, t.attr, t.value);
  }
}
Yt.jsonID("attr", $s);
class hl extends Yt {
  /**
  Construct an attribute step.
  */
  constructor(e, t) {
    super(), this.attr = e, this.value = t;
  }
  apply(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let o in e.attrs)
      t[o] = e.attrs[o];
    t[this.attr] = this.value;
    let r = e.type.create(t, e.content, e.marks);
    return Ct.ok(r);
  }
  getMap() {
    return Cn.empty;
  }
  invert(e) {
    return new hl(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new hl(t.attr, t.value);
  }
}
Yt.jsonID("docAttr", hl);
let Vs = class extends Error {
};
Vs = function n(e) {
  let t = Error.call(this, e);
  return t.__proto__ = n.prototype, t;
};
Vs.prototype = Object.create(Error.prototype);
Vs.prototype.constructor = Vs;
Vs.prototype.name = "TransformError";
class Jf {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new pl();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let t = this.maybeStep(e);
    if (t.failed)
      throw new Vs(t.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let t = e.apply(this.doc);
    return t.failed || this.addStep(e, t.doc), t;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, t = e, r = ne.empty) {
    let o = rd(this.doc, e, t, r);
    return o && this.step(o), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, t, r) {
    return this.replace(e, t, new ne(X.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, t) {
    return this.replace(e, t, ne.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, t) {
    return this.replaceWith(e, e, t);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, t, r) {
    return M3(this, e, t, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, t, r) {
    return O3(this, e, t, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, t) {
    return D3(this, e, t), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, t) {
    return y3(this, e, t), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, t = 1) {
    return E3(this, e, t), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, t) {
    return v3(this, e, t), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, t = e, r, o = null) {
    return x3(this, e, t, r, o), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, t, r = null, o) {
    return A3(this, e, t, r, o), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, t, r) {
    return this.step(new $s(e, t, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, t) {
    return this.step(new hl(e, t)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, t) {
    return this.step(new Ti(e, t)), this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, t) {
    let r = this.doc.nodeAt(e);
    if (!r)
      throw new RangeError("No node at position " + e);
    if (t instanceof Je)
      t.isInSet(r.marks) && this.step(new No(e, t));
    else {
      let o = r.marks, a, l = [];
      for (; a = t.isInSet(o); )
        l.push(new No(e, a)), o = a.removeFromSet(o);
      for (let d = l.length - 1; d >= 0; d--)
        this.step(l[d]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(e, t = 1, r) {
    return C3(this, e, t, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, t, r) {
    return f3(this, e, t, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, t, r) {
    return m3(this, e, t, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, t, r) {
    return Vf(this, e, t, r), this;
  }
}
const dh = /* @__PURE__ */ Object.create(null);
class ve {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, t, r) {
    this.$anchor = e, this.$head = t, this.ranges = r || [new Uk(e.min(t), e.max(t))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let t = 0; t < e.length; t++)
      if (e[t].$from.pos != e[t].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, t = ne.empty) {
    let r = t.content.lastChild, o = null;
    for (let d = 0; d < t.openEnd; d++)
      o = r, r = r.lastChild;
    let a = e.steps.length, l = this.ranges;
    for (let d = 0; d < l.length; d++) {
      let { $from: p, $to: f } = l[d], m = e.mapping.slice(a);
      e.replaceRange(m.map(p.pos), m.map(f.pos), d ? ne.empty : t), d == 0 && Lb(e, a, (r ? r.isInline : o && o.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, t) {
    let r = e.steps.length, o = this.ranges;
    for (let a = 0; a < o.length; a++) {
      let { $from: l, $to: d } = o[a], p = e.mapping.slice(r), f = p.map(l.pos), m = p.map(d.pos);
      a ? e.deleteRange(f, m) : (e.replaceRangeWith(f, m, t), Lb(e, r, t.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, t, r = !1) {
    let o = e.parent.inlineContent ? new ge(e) : Is(e.node(0), e.parent, e.pos, e.index(), t, r);
    if (o)
      return o;
    for (let a = e.depth - 1; a >= 0; a--) {
      let l = t < 0 ? Is(e.node(0), e.node(a), e.before(a + 1), e.index(a), t, r) : Is(e.node(0), e.node(a), e.after(a + 1), e.index(a) + 1, t, r);
      if (l)
        return l;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, t = 1) {
    return this.findFrom(e, t) || this.findFrom(e, -t) || new gn(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return Is(e, e, 0, 0, 1) || new gn(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return Is(e, e, e.content.size, e.childCount, -1) || new gn(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, t) {
    if (!t || !t.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = dh[t.type];
    if (!r)
      throw new RangeError(`No selection type ${t.type} defined`);
    return r.fromJSON(e, t);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, t) {
    if (e in dh)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return dh[e] = t, t.prototype.jsonID = e, t;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return ge.between(this.$anchor, this.$head).getBookmark();
  }
}
ve.prototype.visible = !0;
class Uk {
  /**
  Create a range.
  */
  constructor(e, t) {
    this.$from = e, this.$to = t;
  }
}
let jb = !1;
function Ub(n) {
  !jb && !n.parent.inlineContent && (jb = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + n.parent.type.name + ")"));
}
class ge extends ve {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, t = e) {
    Ub(e), Ub(t), super(e, t);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    if (!r.parent.inlineContent)
      return ve.near(r);
    let o = e.resolve(t.map(this.anchor));
    return new ge(o.parent.inlineContent ? o : r, r);
  }
  replace(e, t = ne.empty) {
    if (super.replace(e, t), t == ne.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof ge && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new id(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new ge(e.resolve(t.anchor), e.resolve(t.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, t, r = t) {
    let o = e.resolve(t);
    return new this(o, r == t ? o : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, t, r) {
    let o = e.pos - t.pos;
    if ((!r || o) && (r = o >= 0 ? 1 : -1), !t.parent.inlineContent) {
      let a = ve.findFrom(t, r, !0) || ve.findFrom(t, -r, !0);
      if (a)
        t = a.$head;
      else
        return ve.near(t, r);
    }
    return e.parent.inlineContent || (o == 0 ? e = t : (e = (ve.findFrom(e, -r, !0) || ve.findFrom(e, r, !0)).$anchor, e.pos < t.pos != o < 0 && (e = t))), new ge(e, t);
  }
}
ve.jsonID("text", ge);
class id {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new id(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return ge.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class fe extends ve {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let t = e.nodeAfter, r = e.node(0).resolve(e.pos + t.nodeSize);
    super(e, r), this.node = t;
  }
  map(e, t) {
    let { deleted: r, pos: o } = t.mapResult(this.anchor), a = e.resolve(o);
    return r ? ve.near(a) : new fe(a);
  }
  content() {
    return new ne(X.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof fe && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new Kf(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new fe(e.resolve(t.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, t) {
    return new fe(e.resolve(t));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
fe.prototype.visible = !1;
ve.jsonID("node", fe);
class Kf {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: t, pos: r } = e.mapResult(this.anchor);
    return t ? new id(r, r) : new Kf(r);
  }
  resolve(e) {
    let t = e.resolve(this.anchor), r = t.nodeAfter;
    return r && fe.isSelectable(r) ? new fe(t) : ve.near(t);
  }
}
class gn extends ve {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, t = ne.empty) {
    if (t == ne.empty) {
      e.delete(0, e.doc.content.size);
      let r = ve.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, t);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new gn(e);
  }
  map(e) {
    return new gn(e);
  }
  eq(e) {
    return e instanceof gn;
  }
  getBookmark() {
    return R3;
  }
}
ve.jsonID("all", gn);
const R3 = {
  map() {
    return this;
  },
  resolve(n) {
    return new gn(n);
  }
};
function Is(n, e, t, r, o, a = !1) {
  if (e.inlineContent)
    return ge.create(n, t);
  for (let l = r - (o > 0 ? 0 : 1); o > 0 ? l < e.childCount : l >= 0; l += o) {
    let d = e.child(l);
    if (d.isAtom) {
      if (!a && fe.isSelectable(d))
        return fe.create(n, t - (o < 0 ? d.nodeSize : 0));
    } else {
      let p = Is(n, d, t + o, o < 0 ? d.childCount : 0, o, a);
      if (p)
        return p;
    }
    t += d.nodeSize * o;
  }
  return null;
}
function Lb(n, e, t) {
  let r = n.steps.length - 1;
  if (r < e)
    return;
  let o = n.steps[r];
  if (!(o instanceof At || o instanceof Mt))
    return;
  let a = n.mapping.maps[r], l;
  a.forEach((d, p, f, m) => {
    l == null && (l = m);
  }), n.setSelection(ve.near(n.doc.resolve(l), t));
}
const Hb = 1, zc = 2, Gb = 4;
let F3 = class extends Jf {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | Hb) & ~zc, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & Hb) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= zc, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return Je.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & zc) > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    super.addStep(e, t), this.updated = this.updated & ~zc, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, t = !0) {
    let r = this.selection;
    return t && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Je.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, t, r) {
    let o = this.doc.type.schema;
    if (t == null)
      return e ? this.replaceSelectionWith(o.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = t), r = r ?? t, !e)
        return this.deleteRange(t, r);
      let a = this.storedMarks;
      if (!a) {
        let l = this.doc.resolve(t);
        a = r == t ? l.marks() : l.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(t, r, o.text(e, a)), this.selection.empty || this.setSelection(ve.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, t) {
    return this.meta[typeof e == "string" ? e : e.key] = t, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= Gb, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & Gb) > 0;
  }
};
function _b(n, e) {
  return !e || !n ? n : n.bind(e);
}
class Wa {
  constructor(e, t, r) {
    this.name = e, this.init = _b(t.init, r), this.apply = _b(t.apply, r);
  }
}
const P3 = [
  new Wa("doc", {
    init(n) {
      return n.doc || n.schema.topNodeType.createAndFill();
    },
    apply(n) {
      return n.doc;
    }
  }),
  new Wa("selection", {
    init(n, e) {
      return n.selection || ve.atStart(e.doc);
    },
    apply(n) {
      return n.selection;
    }
  }),
  new Wa("storedMarks", {
    init(n) {
      return n.storedMarks || null;
    },
    apply(n, e, t, r) {
      return r.selection.$cursor ? n.storedMarks : null;
    }
  }),
  new Wa("scrollToSelection", {
    init() {
      return 0;
    },
    apply(n, e) {
      return n.scrolledIntoView ? e + 1 : e;
    }
  })
];
class ph {
  constructor(e, t) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = P3.slice(), t && t.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new Wa(r.key, r.spec.state, r));
    });
  }
}
class Rs {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, t = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != t) {
        let o = this.config.plugins[r];
        if (o.spec.filterTransaction && !o.spec.filterTransaction.call(o, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let t = [e], r = this.applyInner(e), o = null;
    for (; ; ) {
      let a = !1;
      for (let l = 0; l < this.config.plugins.length; l++) {
        let d = this.config.plugins[l];
        if (d.spec.appendTransaction) {
          let p = o ? o[l].n : 0, f = o ? o[l].state : this, m = p < t.length && d.spec.appendTransaction.call(d, p ? t.slice(p) : t, f, r);
          if (m && r.filterTransaction(m, l)) {
            if (m.setMeta("appendedTransaction", e), !o) {
              o = [];
              for (let y = 0; y < this.config.plugins.length; y++)
                o.push(y < l ? { state: r, n: t.length } : { state: this, n: 0 });
            }
            t.push(m), r = r.applyInner(m), a = !0;
          }
          o && (o[l] = { state: r, n: t.length });
        }
      }
      if (!a)
        return { state: r, transactions: t };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let t = new Rs(this.config), r = this.config.fields;
    for (let o = 0; o < r.length; o++) {
      let a = r[o];
      t[a.name] = a.apply(e, this[a.name], this, t);
    }
    return t;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new F3(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let t = new ph(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new Rs(t);
    for (let o = 0; o < t.fields.length; o++)
      r[t.fields[o].name] = t.fields[o].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let t = new ph(this.schema, e.plugins), r = t.fields, o = new Rs(t);
    for (let a = 0; a < r.length; a++) {
      let l = r[a].name;
      o[l] = this.hasOwnProperty(l) ? this[l] : r[a].init(e, o);
    }
    return o;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (t.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let o = e[r], a = o.spec.state;
        a && a.toJSON && (t[r] = a.toJSON.call(o, this[o.key]));
      }
    return t;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, t, r) {
    if (!t)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let o = new ph(e.schema, e.plugins), a = new Rs(o);
    return o.fields.forEach((l) => {
      if (l.name == "doc")
        a.doc = Ii.fromJSON(e.schema, t.doc);
      else if (l.name == "selection")
        a.selection = ve.fromJSON(a.doc, t.selection);
      else if (l.name == "storedMarks")
        t.storedMarks && (a.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let d in r) {
            let p = r[d], f = p.spec.state;
            if (p.key == l.name && f && f.fromJSON && Object.prototype.hasOwnProperty.call(t, d)) {
              a[l.name] = f.fromJSON.call(p, e, t[d], a);
              return;
            }
          }
        a[l.name] = l.init(e, a);
      }
    }), a;
  }
}
function Lk(n, e, t) {
  for (let r in n) {
    let o = n[r];
    o instanceof Function ? o = o.bind(e) : r == "handleDOMEvents" && (o = Lk(o, e, {})), t[r] = o;
  }
  return t;
}
class ot {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && Lk(e.props, this, this.props), this.key = e.key ? e.key.key : Hk("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const hh = /* @__PURE__ */ Object.create(null);
function Hk(n) {
  return n in hh ? n + "$" + ++hh[n] : (hh[n] = 0, n + "$");
}
class pt {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = Hk(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Lt = function(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}, Xs = function(n) {
  let e = n.assignedSlot || n.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let Qh = null;
const _r = function(n, e, t) {
  let r = Qh || (Qh = document.createRange());
  return r.setEnd(n, t ?? n.nodeValue.length), r.setStart(n, e || 0), r;
}, $3 = function() {
  Qh = null;
}, Bo = function(n, e, t, r) {
  return t && (zb(n, e, t, r, -1) || zb(n, e, t, r, 1));
}, j3 = /^(img|br|input|textarea|hr)$/i;
function zb(n, e, t, r, o) {
  for (var a; ; ) {
    if (n == t && e == r)
      return !0;
    if (e == (o < 0 ? 0 : Mn(n))) {
      let l = n.parentNode;
      if (!l || l.nodeType != 1 || Pl(n) || j3.test(n.nodeName) || n.contentEditable == "false")
        return !1;
      e = Lt(n) + (o < 0 ? 0 : 1), n = l;
    } else if (n.nodeType == 1) {
      let l = n.childNodes[e + (o < 0 ? -1 : 0)];
      if (l.nodeType == 1 && l.contentEditable == "false")
        if (!((a = l.pmViewDesc) === null || a === void 0) && a.ignoreForSelection)
          e += o;
        else
          return !1;
      else
        n = l, e = o < 0 ? Mn(n) : 0;
    } else
      return !1;
  }
}
function Mn(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function U3(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e)
      return n;
    if (n.nodeType == 1 && e > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e - 1], e = Mn(n);
    } else if (n.parentNode && !Pl(n))
      e = Lt(n), n = n.parentNode;
    else
      return null;
  }
}
function L3(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e < n.nodeValue.length)
      return n;
    if (n.nodeType == 1 && e < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e], e = 0;
    } else if (n.parentNode && !Pl(n))
      e = Lt(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
function H3(n, e, t) {
  for (let r = e == 0, o = e == Mn(n); r || o; ) {
    if (n == t)
      return !0;
    let a = Lt(n);
    if (n = n.parentNode, !n)
      return !1;
    r = r && a == 0, o = o && a == Mn(n);
  }
}
function Pl(n) {
  let e;
  for (let t = n; t && !(e = t.pmViewDesc); t = t.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == n || e.contentDOM == n);
}
const od = function(n) {
  return n.focusNode && Bo(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset);
};
function fo(n, e) {
  let t = document.createEvent("Event");
  return t.initEvent("keydown", !0, !0), t.keyCode = n, t.key = t.code = e, t;
}
function G3(n) {
  let e = n.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function _3(n, e, t) {
  if (n.caretPositionFromPoint)
    try {
      let r = n.caretPositionFromPoint(e, t);
      if (r)
        return { node: r.offsetNode, offset: Math.min(Mn(r.offsetNode), r.offset) };
    } catch {
    }
  if (n.caretRangeFromPoint) {
    let r = n.caretRangeFromPoint(e, t);
    if (r)
      return { node: r.startContainer, offset: Math.min(Mn(r.startContainer), r.startOffset) };
  }
}
const Sr = typeof navigator < "u" ? navigator : null, qb = typeof document < "u" ? document : null, Gi = Sr && Sr.userAgent || "", Zh = /Edge\/(\d+)/.exec(Gi), Gk = /MSIE \d/.exec(Gi), ef = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Gi), yn = !!(Gk || ef || Zh), Mi = Gk ? document.documentMode : ef ? +ef[1] : Zh ? +Zh[1] : 0, Rn = !yn && /gecko\/(\d+)/i.test(Gi);
Rn && +(/Firefox\/(\d+)/.exec(Gi) || [0, 0])[1];
const tf = !yn && /Chrome\/(\d+)/.exec(Gi), Xt = !!tf, _k = tf ? +tf[1] : 0, an = !yn && !!Sr && /Apple Computer/.test(Sr.vendor), Js = an && (/Mobile\/\w+/.test(Gi) || !!Sr && Sr.maxTouchPoints > 2), In = Js || (Sr ? /Mac/.test(Sr.platform) : !1), z3 = Sr ? /Win/.test(Sr.platform) : !1, zr = /Android \d/.test(Gi), $l = !!qb && "webkitFontSmoothing" in qb.documentElement.style, q3 = $l ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function V3(n) {
  let e = n.defaultView && n.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: n.documentElement.clientWidth,
    top: 0,
    bottom: n.documentElement.clientHeight
  };
}
function Lr(n, e) {
  return typeof n == "number" ? n : n[e];
}
function X3(n) {
  let e = n.getBoundingClientRect(), t = e.width / n.offsetWidth || 1, r = e.height / n.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + n.clientWidth * t,
    top: e.top,
    bottom: e.top + n.clientHeight * r
  };
}
function Vb(n, e, t) {
  let r = n.someProp("scrollThreshold") || 0, o = n.someProp("scrollMargin") || 5, a = n.dom.ownerDocument;
  for (let l = t || n.dom; l; ) {
    if (l.nodeType != 1) {
      l = Xs(l);
      continue;
    }
    let d = l, p = d == a.body, f = p ? V3(a) : X3(d), m = 0, y = 0;
    if (e.top < f.top + Lr(r, "top") ? y = -(f.top - e.top + Lr(o, "top")) : e.bottom > f.bottom - Lr(r, "bottom") && (y = e.bottom - e.top > f.bottom - f.top ? e.top + Lr(o, "top") - f.top : e.bottom - f.bottom + Lr(o, "bottom")), e.left < f.left + Lr(r, "left") ? m = -(f.left - e.left + Lr(o, "left")) : e.right > f.right - Lr(r, "right") && (m = e.right - f.right + Lr(o, "right")), m || y)
      if (p)
        a.defaultView.scrollBy(m, y);
      else {
        let k = d.scrollLeft, A = d.scrollTop;
        y && (d.scrollTop += y), m && (d.scrollLeft += m);
        let S = d.scrollLeft - k, B = d.scrollTop - A;
        e = { left: e.left - S, top: e.top - B, right: e.right - S, bottom: e.bottom - B };
      }
    let v = p ? "fixed" : getComputedStyle(l).position;
    if (/^(fixed|sticky)$/.test(v))
      break;
    l = v == "absolute" ? l.offsetParent : Xs(l);
  }
}
function J3(n) {
  let e = n.dom.getBoundingClientRect(), t = Math.max(0, e.top), r, o;
  for (let a = (e.left + e.right) / 2, l = t + 1; l < Math.min(innerHeight, e.bottom); l += 5) {
    let d = n.root.elementFromPoint(a, l);
    if (!d || d == n.dom || !n.dom.contains(d))
      continue;
    let p = d.getBoundingClientRect();
    if (p.top >= t - 20) {
      r = d, o = p.top;
      break;
    }
  }
  return { refDOM: r, refTop: o, stack: zk(n.dom) };
}
function zk(n) {
  let e = [], t = n.ownerDocument;
  for (let r = n; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), n != t); r = Xs(r))
    ;
  return e;
}
function K3({ refDOM: n, refTop: e, stack: t }) {
  let r = n ? n.getBoundingClientRect().top : 0;
  qk(t, r == 0 ? 0 : r - e);
}
function qk(n, e) {
  for (let t = 0; t < n.length; t++) {
    let { dom: r, top: o, left: a } = n[t];
    r.scrollTop != o + e && (r.scrollTop = o + e), r.scrollLeft != a && (r.scrollLeft = a);
  }
}
let Ss = null;
function W3(n) {
  if (n.setActive)
    return n.setActive();
  if (Ss)
    return n.focus(Ss);
  let e = zk(n);
  n.focus(Ss == null ? {
    get preventScroll() {
      return Ss = { preventScroll: !0 }, !0;
    }
  } : void 0), Ss || (Ss = !1, qk(e, 0));
}
function Vk(n, e) {
  let t, r = 2e8, o, a = 0, l = e.top, d = e.top, p, f;
  for (let m = n.firstChild, y = 0; m; m = m.nextSibling, y++) {
    let v;
    if (m.nodeType == 1)
      v = m.getClientRects();
    else if (m.nodeType == 3)
      v = _r(m).getClientRects();
    else
      continue;
    for (let k = 0; k < v.length; k++) {
      let A = v[k];
      if (A.top <= l && A.bottom >= d) {
        l = Math.max(A.bottom, l), d = Math.min(A.top, d);
        let S = A.left > e.left ? A.left - e.left : A.right < e.left ? e.left - A.right : 0;
        if (S < r) {
          t = m, r = S, o = S && t.nodeType == 3 ? {
            left: A.right < e.left ? A.right : A.left,
            top: e.top
          } : e, m.nodeType == 1 && S && (a = y + (e.left >= (A.left + A.right) / 2 ? 1 : 0));
          continue;
        }
      } else A.top > e.top && !p && A.left <= e.left && A.right >= e.left && (p = m, f = { left: Math.max(A.left, Math.min(A.right, e.left)), top: A.top });
      !t && (e.left >= A.right && e.top >= A.top || e.left >= A.left && e.top >= A.bottom) && (a = y + 1);
    }
  }
  return !t && p && (t = p, o = f, r = 0), t && t.nodeType == 3 ? Y3(t, o) : !t || r && t.nodeType == 1 ? { node: n, offset: a } : Vk(t, o);
}
function Y3(n, e) {
  let t = n.nodeValue.length, r = document.createRange();
  for (let o = 0; o < t; o++) {
    r.setEnd(n, o + 1), r.setStart(n, o);
    let a = vi(r, 1);
    if (a.top != a.bottom && Wf(e, a))
      return { node: n, offset: o + (e.left >= (a.left + a.right) / 2 ? 1 : 0) };
  }
  return { node: n, offset: 0 };
}
function Wf(n, e) {
  return n.left >= e.left - 1 && n.left <= e.right + 1 && n.top >= e.top - 1 && n.top <= e.bottom + 1;
}
function Q3(n, e) {
  let t = n.parentNode;
  return t && /^li$/i.test(t.nodeName) && e.left < n.getBoundingClientRect().left ? t : n;
}
function Z3(n, e, t) {
  let { node: r, offset: o } = Vk(e, t), a = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let l = r.getBoundingClientRect();
    a = l.left != l.right && t.left > (l.left + l.right) / 2 ? 1 : -1;
  }
  return n.docView.posFromDOM(r, o, a);
}
function eF(n, e, t, r) {
  let o = -1;
  for (let a = e, l = !1; a != n.dom; ) {
    let d = n.docView.nearestDesc(a, !0), p;
    if (!d)
      return null;
    if (d.dom.nodeType == 1 && (d.node.isBlock && d.parent || !d.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((p = d.dom.getBoundingClientRect()).width || p.height) && (d.node.isBlock && d.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(d.dom.nodeName) && (!l && p.left > r.left || p.top > r.top ? o = d.posBefore : (!l && p.right < r.left || p.bottom < r.top) && (o = d.posAfter), l = !0), !d.contentDOM && o < 0 && !d.node.isText))
      return (d.node.isBlock ? r.top < (p.top + p.bottom) / 2 : r.left < (p.left + p.right) / 2) ? d.posBefore : d.posAfter;
    a = d.dom.parentNode;
  }
  return o > -1 ? o : n.docView.posFromDOM(e, t, -1);
}
function Xk(n, e, t) {
  let r = n.childNodes.length;
  if (r && t.top < t.bottom)
    for (let o = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - t.top) / (t.bottom - t.top)) - 2)), a = o; ; ) {
      let l = n.childNodes[a];
      if (l.nodeType == 1) {
        let d = l.getClientRects();
        for (let p = 0; p < d.length; p++) {
          let f = d[p];
          if (Wf(e, f))
            return Xk(l, e, f);
        }
      }
      if ((a = (a + 1) % r) == o)
        break;
    }
  return n;
}
function tF(n, e) {
  let t = n.dom.ownerDocument, r, o = 0, a = _3(t, e.left, e.top);
  a && ({ node: r, offset: o } = a);
  let l = (n.root.elementFromPoint ? n.root : t).elementFromPoint(e.left, e.top), d;
  if (!l || !n.dom.contains(l.nodeType != 1 ? l.parentNode : l)) {
    let f = n.dom.getBoundingClientRect();
    if (!Wf(e, f) || (l = Xk(n.dom, e, f), !l))
      return null;
  }
  if (an)
    for (let f = l; r && f; f = Xs(f))
      f.draggable && (r = void 0);
  if (l = Q3(l, e), r) {
    if (Rn && r.nodeType == 1 && (o = Math.min(o, r.childNodes.length), o < r.childNodes.length)) {
      let m = r.childNodes[o], y;
      m.nodeName == "IMG" && (y = m.getBoundingClientRect()).right <= e.left && y.bottom > e.top && o++;
    }
    let f;
    $l && o && r.nodeType == 1 && (f = r.childNodes[o - 1]).nodeType == 1 && f.contentEditable == "false" && f.getBoundingClientRect().top >= e.top && o--, r == n.dom && o == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? d = n.state.doc.content.size : (o == 0 || r.nodeType != 1 || r.childNodes[o - 1].nodeName != "BR") && (d = eF(n, r, o, e));
  }
  d == null && (d = Z3(n, l, e));
  let p = n.docView.nearestDesc(l, !0);
  return { pos: d, inside: p ? p.posAtStart - p.border : -1 };
}
function Xb(n) {
  return n.top < n.bottom || n.left < n.right;
}
function vi(n, e) {
  let t = n.getClientRects();
  if (t.length) {
    let r = t[e < 0 ? 0 : t.length - 1];
    if (Xb(r))
      return r;
  }
  return Array.prototype.find.call(t, Xb) || n.getBoundingClientRect();
}
const nF = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function Jk(n, e, t) {
  let { node: r, offset: o, atom: a } = n.docView.domFromPos(e, t < 0 ? -1 : 1), l = $l || Rn;
  if (r.nodeType == 3)
    if (l && (nF.test(r.nodeValue) || (t < 0 ? !o : o == r.nodeValue.length))) {
      let p = vi(_r(r, o, o), t);
      if (Rn && o && /\s/.test(r.nodeValue[o - 1]) && o < r.nodeValue.length) {
        let f = vi(_r(r, o - 1, o - 1), -1);
        if (f.top == p.top) {
          let m = vi(_r(r, o, o + 1), -1);
          if (m.top != p.top)
            return Ga(m, m.left < f.left);
        }
      }
      return p;
    } else {
      let p = o, f = o, m = t < 0 ? 1 : -1;
      return t < 0 && !o ? (f++, m = -1) : t >= 0 && o == r.nodeValue.length ? (p--, m = 1) : t < 0 ? p-- : f++, Ga(vi(_r(r, p, f), m), m < 0);
    }
  if (!n.state.doc.resolve(e - (a || 0)).parent.inlineContent) {
    if (a == null && o && (t < 0 || o == Mn(r))) {
      let p = r.childNodes[o - 1];
      if (p.nodeType == 1)
        return fh(p.getBoundingClientRect(), !1);
    }
    if (a == null && o < Mn(r)) {
      let p = r.childNodes[o];
      if (p.nodeType == 1)
        return fh(p.getBoundingClientRect(), !0);
    }
    return fh(r.getBoundingClientRect(), t >= 0);
  }
  if (a == null && o && (t < 0 || o == Mn(r))) {
    let p = r.childNodes[o - 1], f = p.nodeType == 3 ? _r(p, Mn(p) - (l ? 0 : 1)) : p.nodeType == 1 && (p.nodeName != "BR" || !p.nextSibling) ? p : null;
    if (f)
      return Ga(vi(f, 1), !1);
  }
  if (a == null && o < Mn(r)) {
    let p = r.childNodes[o];
    for (; p.pmViewDesc && p.pmViewDesc.ignoreForCoords; )
      p = p.nextSibling;
    let f = p ? p.nodeType == 3 ? _r(p, 0, l ? 0 : 1) : p.nodeType == 1 ? p : null : null;
    if (f)
      return Ga(vi(f, -1), !0);
  }
  return Ga(vi(r.nodeType == 3 ? _r(r) : r, -t), t >= 0);
}
function Ga(n, e) {
  if (n.width == 0)
    return n;
  let t = e ? n.left : n.right;
  return { top: n.top, bottom: n.bottom, left: t, right: t };
}
function fh(n, e) {
  if (n.height == 0)
    return n;
  let t = e ? n.top : n.bottom;
  return { top: t, bottom: t, left: n.left, right: n.right };
}
function Kk(n, e, t) {
  let r = n.state, o = n.root.activeElement;
  r != e && n.updateState(e), o != n.dom && n.focus();
  try {
    return t();
  } finally {
    r != e && n.updateState(r), o != n.dom && o && o.focus();
  }
}
function rF(n, e, t) {
  let r = e.selection, o = t == "up" ? r.$from : r.$to;
  return Kk(n, e, () => {
    let { node: a } = n.docView.domFromPos(o.pos, t == "up" ? -1 : 1);
    for (; ; ) {
      let d = n.docView.nearestDesc(a, !0);
      if (!d)
        break;
      if (d.node.isBlock) {
        a = d.contentDOM || d.dom;
        break;
      }
      a = d.dom.parentNode;
    }
    let l = Jk(n, o.pos, 1);
    for (let d = a.firstChild; d; d = d.nextSibling) {
      let p;
      if (d.nodeType == 1)
        p = d.getClientRects();
      else if (d.nodeType == 3)
        p = _r(d, 0, d.nodeValue.length).getClientRects();
      else
        continue;
      for (let f = 0; f < p.length; f++) {
        let m = p[f];
        if (m.bottom > m.top + 1 && (t == "up" ? l.top - m.top > (m.bottom - l.top) * 2 : m.bottom - l.bottom > (l.bottom - m.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const iF = /[\u0590-\u08ac]/;
function oF(n, e, t) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let o = r.parentOffset, a = !o, l = o == r.parent.content.size, d = n.domSelection();
  return d ? !iF.test(r.parent.textContent) || !d.modify ? t == "left" || t == "backward" ? a : l : Kk(n, e, () => {
    let { focusNode: p, focusOffset: f, anchorNode: m, anchorOffset: y } = n.domSelectionRange(), v = d.caretBidiLevel;
    d.modify("move", t, "character");
    let k = r.depth ? n.docView.domAfterPos(r.before()) : n.dom, { focusNode: A, focusOffset: S } = n.domSelectionRange(), B = A && !k.contains(A.nodeType == 1 ? A : A.parentNode) || p == A && f == S;
    try {
      d.collapse(m, y), p && (p != m || f != y) && d.extend && d.extend(p, f);
    } catch {
    }
    return v != null && (d.caretBidiLevel = v), B;
  }) : r.pos == r.start() || r.pos == r.end();
}
let Jb = null, Kb = null, Wb = !1;
function sF(n, e, t) {
  return Jb == e && Kb == t ? Wb : (Jb = e, Kb = t, Wb = t == "up" || t == "down" ? rF(n, e, t) : oF(n, e, t));
}
const Fn = 0, Yb = 1, go = 2, Er = 3;
class jl {
  constructor(e, t, r, o) {
    this.parent = e, this.children = t, this.dom = r, this.contentDOM = o, this.dirty = Fn, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, t, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let t = 0; t < this.children.length; t++)
      e += this.children[t].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let t = 0, r = this.posAtStart; ; t++) {
      let o = this.children[t];
      if (o == e)
        return r;
      r += o.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, t, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let a, l;
        if (e == this.contentDOM)
          a = e.childNodes[t - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          a = e.previousSibling;
        }
        for (; a && !((l = a.pmViewDesc) && l.parent == this); )
          a = a.previousSibling;
        return a ? this.posBeforeChild(l) + l.size : this.posAtStart;
      } else {
        let a, l;
        if (e == this.contentDOM)
          a = e.childNodes[t];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          a = e.nextSibling;
        }
        for (; a && !((l = a.pmViewDesc) && l.parent == this); )
          a = a.nextSibling;
        return a ? this.posBeforeChild(l) : this.posAtEnd;
      }
    let o;
    if (e == this.dom && this.contentDOM)
      o = t > Lt(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      o = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (t == 0)
        for (let a = e; ; a = a.parentNode) {
          if (a == this.dom) {
            o = !1;
            break;
          }
          if (a.previousSibling)
            break;
        }
      if (o == null && t == e.childNodes.length)
        for (let a = e; ; a = a.parentNode) {
          if (a == this.dom) {
            o = !0;
            break;
          }
          if (a.nextSibling)
            break;
        }
    }
    return o ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, t = !1) {
    for (let r = !0, o = e; o; o = o.parentNode) {
      let a = this.getDesc(o), l;
      if (a && (!t || a.node))
        if (r && (l = a.nodeDOM) && !(l.nodeType == 1 ? l.contains(e.nodeType == 1 ? e : e.parentNode) : l == e))
          r = !1;
        else
          return a;
    }
  }
  getDesc(e) {
    let t = e.pmViewDesc;
    for (let r = t; r; r = r.parent)
      if (r == this)
        return t;
  }
  posFromDOM(e, t, r) {
    for (let o = e; o; o = o.parentNode) {
      let a = this.getDesc(o);
      if (a)
        return a.localPosFromDOM(e, t, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let t = 0, r = 0; t < this.children.length; t++) {
      let o = this.children[t], a = r + o.size;
      if (r == e && a != r) {
        for (; !o.border && o.children.length; )
          for (let l = 0; l < o.children.length; l++) {
            let d = o.children[l];
            if (d.size) {
              o = d;
              break;
            }
          }
        return o;
      }
      if (e < a)
        return o.descAt(e - r - o.border);
      r = a;
    }
  }
  domFromPos(e, t) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, o = 0;
    for (let a = 0; r < this.children.length; r++) {
      let l = this.children[r], d = a + l.size;
      if (d > e || l instanceof Yk) {
        o = e - a;
        break;
      }
      a = d;
    }
    if (o)
      return this.children[r].domFromPos(o - this.children[r].border, t);
    for (let a; r && !(a = this.children[r - 1]).size && a instanceof Wk && a.side >= 0; r--)
      ;
    if (t <= 0) {
      let a, l = !0;
      for (; a = r ? this.children[r - 1] : null, !(!a || a.dom.parentNode == this.contentDOM); r--, l = !1)
        ;
      return a && t && l && !a.border && !a.domAtom ? a.domFromPos(a.size, t) : { node: this.contentDOM, offset: a ? Lt(a.dom) + 1 : 0 };
    } else {
      let a, l = !0;
      for (; a = r < this.children.length ? this.children[r] : null, !(!a || a.dom.parentNode == this.contentDOM); r++, l = !1)
        ;
      return a && l && !a.border && !a.domAtom ? a.domFromPos(0, t) : { node: this.contentDOM, offset: a ? Lt(a.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, t, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let o = -1, a = -1;
    for (let l = r, d = 0; ; d++) {
      let p = this.children[d], f = l + p.size;
      if (o == -1 && e <= f) {
        let m = l + p.border;
        if (e >= m && t <= f - p.border && p.node && p.contentDOM && this.contentDOM.contains(p.contentDOM))
          return p.parseRange(e, t, m);
        e = l;
        for (let y = d; y > 0; y--) {
          let v = this.children[y - 1];
          if (v.size && v.dom.parentNode == this.contentDOM && !v.emptyChildAt(1)) {
            o = Lt(v.dom) + 1;
            break;
          }
          e -= v.size;
        }
        o == -1 && (o = 0);
      }
      if (o > -1 && (f > t || d == this.children.length - 1)) {
        t = f;
        for (let m = d + 1; m < this.children.length; m++) {
          let y = this.children[m];
          if (y.size && y.dom.parentNode == this.contentDOM && !y.emptyChildAt(-1)) {
            a = Lt(y.dom);
            break;
          }
          t += y.size;
        }
        a == -1 && (a = this.contentDOM.childNodes.length);
        break;
      }
      l = f;
    }
    return { node: this.contentDOM, from: e, to: t, fromOffset: o, toOffset: a };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let t = this.children[e < 0 ? 0 : this.children.length - 1];
    return t.size == 0 || t.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: t, offset: r } = this.domFromPos(e, 0);
    if (t.nodeType != 1 || r == t.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return t.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, t, r, o = !1) {
    let a = Math.min(e, t), l = Math.max(e, t);
    for (let k = 0, A = 0; k < this.children.length; k++) {
      let S = this.children[k], B = A + S.size;
      if (a > A && l < B)
        return S.setSelection(e - A - S.border, t - A - S.border, r, o);
      A = B;
    }
    let d = this.domFromPos(e, e ? -1 : 1), p = t == e ? d : this.domFromPos(t, t ? -1 : 1), f = r.root.getSelection(), m = r.domSelectionRange(), y = !1;
    if ((Rn || an) && e == t) {
      let { node: k, offset: A } = d;
      if (k.nodeType == 3) {
        if (y = !!(A && k.nodeValue[A - 1] == `
`), y && A == k.nodeValue.length)
          for (let S = k, B; S; S = S.parentNode) {
            if (B = S.nextSibling) {
              B.nodeName == "BR" && (d = p = { node: B.parentNode, offset: Lt(B) + 1 });
              break;
            }
            let O = S.pmViewDesc;
            if (O && O.node && O.node.isBlock)
              break;
          }
      } else {
        let S = k.childNodes[A - 1];
        y = S && (S.nodeName == "BR" || S.contentEditable == "false");
      }
    }
    if (Rn && m.focusNode && m.focusNode != p.node && m.focusNode.nodeType == 1) {
      let k = m.focusNode.childNodes[m.focusOffset];
      k && k.contentEditable == "false" && (o = !0);
    }
    if (!(o || y && an) && Bo(d.node, d.offset, m.anchorNode, m.anchorOffset) && Bo(p.node, p.offset, m.focusNode, m.focusOffset))
      return;
    let v = !1;
    if ((f.extend || e == t) && !(y && Rn)) {
      f.collapse(d.node, d.offset);
      try {
        e != t && f.extend(p.node, p.offset), v = !0;
      } catch {
      }
    }
    if (!v) {
      if (e > t) {
        let A = d;
        d = p, p = A;
      }
      let k = document.createRange();
      k.setEnd(p.node, p.offset), k.setStart(d.node, d.offset), f.removeAllRanges(), f.addRange(k);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, t) {
    for (let r = 0, o = 0; o < this.children.length; o++) {
      let a = this.children[o], l = r + a.size;
      if (r == l ? e <= l && t >= r : e < l && t > r) {
        let d = r + a.border, p = l - a.border;
        if (e >= d && t <= p) {
          this.dirty = e == r || t == l ? go : Yb, e == d && t == p && (a.contentLost || a.dom.parentNode != this.contentDOM) ? a.dirty = Er : a.markDirty(e - d, t - d);
          return;
        } else
          a.dirty = a.dom == a.contentDOM && a.dom.parentNode == this.contentDOM && !a.children.length ? go : Er;
      }
      r = l;
    }
    this.dirty = go;
  }
  markParentsDirty() {
    let e = 1;
    for (let t = this.parent; t; t = t.parent, e++) {
      let r = e == 1 ? go : Yb;
      t.dirty < r && (t.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  get ignoreForSelection() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class Wk extends jl {
  constructor(e, t, r, o) {
    let a, l = t.type.toDOM;
    if (typeof l == "function" && (l = l(r, () => {
      if (!a)
        return o;
      if (a.parent)
        return a.parent.posBeforeChild(a);
    })), !t.type.spec.raw) {
      if (l.nodeType != 1) {
        let d = document.createElement("span");
        d.appendChild(l), l = d;
      }
      l.contentEditable = "false", l.classList.add("ProseMirror-widget");
    }
    super(e, [], l, null), this.widget = t, this.widget = t, a = this;
  }
  matchesWidget(e) {
    return this.dirty == Fn && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let t = this.widget.spec.stopEvent;
    return t ? t(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class aF extends jl {
  constructor(e, t, r, o) {
    super(e, [], t, null), this.textDOM = r, this.text = o;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, t) {
    return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class Io extends jl {
  constructor(e, t, r, o, a) {
    super(e, [], r, o), this.mark = t, this.spec = a;
  }
  static create(e, t, r, o) {
    let a = o.nodeViews[t.type.name], l = a && a(t, o, r);
    return (!l || !l.dom) && (l = Uo.renderSpec(document, t.type.spec.toDOM(t, r), null, t.attrs)), new Io(e, t, l.dom, l.contentDOM || l.dom, l);
  }
  parseRule() {
    return this.dirty & Er || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != Er && this.mark.eq(e);
  }
  markDirty(e, t) {
    if (super.markDirty(e, t), this.dirty != Fn) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = Fn;
    }
  }
  slice(e, t, r) {
    let o = Io.create(this.parent, this.mark, !0, r), a = this.children, l = this.size;
    t < l && (a = rf(a, t, l, r)), e > 0 && (a = rf(a, 0, e, r));
    for (let d = 0; d < a.length; d++)
      a[d].parent = o;
    return o.children = a, o;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class Oi extends jl {
  constructor(e, t, r, o, a, l, d, p, f) {
    super(e, [], a, l), this.node = t, this.outerDeco = r, this.innerDeco = o, this.nodeDOM = d;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, t, r, o, a, l) {
    let d = a.nodeViews[t.type.name], p, f = d && d(t, a, () => {
      if (!p)
        return l;
      if (p.parent)
        return p.parent.posBeforeChild(p);
    }, r, o), m = f && f.dom, y = f && f.contentDOM;
    if (t.isText) {
      if (!m)
        m = document.createTextNode(t.text);
      else if (m.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else m || ({ dom: m, contentDOM: y } = Uo.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs));
    !y && !t.isText && m.nodeName != "BR" && (m.hasAttribute("contenteditable") || (m.contentEditable = "false"), t.type.spec.draggable && (m.draggable = !0));
    let v = m;
    return m = e1(m, r, t), f ? p = new lF(e, t, r, o, m, y || null, v, f, a, l + 1) : t.isText ? new sd(e, t, r, o, m, v, a) : new Oi(e, t, r, o, m, y || null, v, a, l + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let t = this.children.length - 1; t >= 0; t--) {
        let r = this.children[t];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => X.empty);
    }
    return e;
  }
  matchesNode(e, t, r) {
    return this.dirty == Fn && e.eq(this.node) && Nu(t, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, t) {
    let r = this.node.inlineContent, o = t, a = e.composing ? this.localCompositionInfo(e, t) : null, l = a && a.pos > -1 ? a : null, d = a && a.pos < 0, p = new uF(this, l && l.node, e);
    hF(this.node, this.innerDeco, (f, m, y) => {
      f.spec.marks ? p.syncToMarks(f.spec.marks, r, e) : f.type.side >= 0 && !y && p.syncToMarks(m == this.node.childCount ? Je.none : this.node.child(m).marks, r, e), p.placeWidget(f, e, o);
    }, (f, m, y, v) => {
      p.syncToMarks(f.marks, r, e);
      let k;
      p.findNodeMatch(f, m, y, v) || d && e.state.selection.from > o && e.state.selection.to < o + f.nodeSize && (k = p.findIndexWithChild(a.node)) > -1 && p.updateNodeAt(f, m, y, k, e) || p.updateNextNode(f, m, y, e, v, o) || p.addNode(f, m, y, e, o), o += f.nodeSize;
    }), p.syncToMarks([], r, e), this.node.isTextblock && p.addTextblockHacks(), p.destroyRest(), (p.changed || this.dirty == go) && (l && this.protectLocalComposition(e, l), Qk(this.contentDOM, this.children, e), Js && fF(this.dom));
  }
  localCompositionInfo(e, t) {
    let { from: r, to: o } = e.state.selection;
    if (!(e.state.selection instanceof ge) || r < t || o > t + this.node.content.size)
      return null;
    let a = e.input.compositionNode;
    if (!a || !this.dom.contains(a.parentNode))
      return null;
    if (this.node.inlineContent) {
      let l = a.nodeValue, d = mF(this.node.content, l, r - t, o - t);
      return d < 0 ? null : { node: a, pos: d, text: l };
    } else
      return { node: a, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: t, pos: r, text: o }) {
    if (this.getDesc(t))
      return;
    let a = t;
    for (; a.parentNode != this.contentDOM; a = a.parentNode) {
      for (; a.previousSibling; )
        a.parentNode.removeChild(a.previousSibling);
      for (; a.nextSibling; )
        a.parentNode.removeChild(a.nextSibling);
      a.pmViewDesc && (a.pmViewDesc = void 0);
    }
    let l = new aF(this, a, t, o);
    e.input.compositionNodes.push(l), this.children = rf(this.children, r, r + o.length, e, l);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, t, r, o) {
    return this.dirty == Er || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, t, r, o), !0);
  }
  updateInner(e, t, r, o) {
    this.updateOuterDeco(t), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(o, this.posAtStart), this.dirty = Fn;
  }
  updateOuterDeco(e) {
    if (Nu(e, this.outerDeco))
      return;
    let t = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = Zk(this.dom, this.nodeDOM, nf(this.outerDeco, this.node, t), nf(e, this.node, t)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function Qb(n, e, t, r, o) {
  e1(r, e, n);
  let a = new Oi(void 0, n, e, t, r, r, r, o, 0);
  return a.contentDOM && a.updateChildren(o, 0), a;
}
class sd extends Oi {
  constructor(e, t, r, o, a, l, d) {
    super(e, t, r, o, a, null, l, d, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, t, r, o) {
    return this.dirty == Er || this.dirty != Fn && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(t), (this.dirty != Fn || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, o.trackWrites == this.nodeDOM && (o.trackWrites = null)), this.node = e, this.dirty = Fn, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let t = this.nodeDOM; t; t = t.parentNode)
      if (t == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, t, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, t, r) {
    let o = this.node.cut(e, t), a = document.createTextNode(o.text);
    return new sd(this.parent, o, this.outerDeco, this.innerDeco, a, a, r);
  }
  markDirty(e, t) {
    super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = Er);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class Yk extends jl {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == Fn && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class lF extends Oi {
  constructor(e, t, r, o, a, l, d, p, f, m) {
    super(e, t, r, o, a, l, d, f, m), this.spec = p;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, t, r, o) {
    if (this.dirty == Er)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let a = this.spec.update(e, t, r);
      return a && this.updateInner(e, t, r, o), a;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, t, r, o);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, t, r, o) {
    this.spec.setSelection ? this.spec.setSelection(e, t, r.root) : super.setSelection(e, t, r, o);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function Qk(n, e, t) {
  let r = n.firstChild, o = !1;
  for (let a = 0; a < e.length; a++) {
    let l = e[a], d = l.dom;
    if (d.parentNode == n) {
      for (; d != r; )
        r = Zb(r), o = !0;
      r = r.nextSibling;
    } else
      o = !0, n.insertBefore(d, r);
    if (l instanceof Io) {
      let p = r ? r.previousSibling : n.lastChild;
      Qk(l.contentDOM, l.children, t), r = p ? p.nextSibling : n.firstChild;
    }
  }
  for (; r; )
    r = Zb(r), o = !0;
  o && t.trackWrites == n && (t.trackWrites = null);
}
const el = function(n) {
  n && (this.nodeName = n);
};
el.prototype = /* @__PURE__ */ Object.create(null);
const yo = [new el()];
function nf(n, e, t) {
  if (n.length == 0)
    return yo;
  let r = t ? yo[0] : new el(), o = [r];
  for (let a = 0; a < n.length; a++) {
    let l = n[a].type.attrs;
    if (l) {
      l.nodeName && o.push(r = new el(l.nodeName));
      for (let d in l) {
        let p = l[d];
        p != null && (t && o.length == 1 && o.push(r = new el(e.isInline ? "span" : "div")), d == "class" ? r.class = (r.class ? r.class + " " : "") + p : d == "style" ? r.style = (r.style ? r.style + ";" : "") + p : d != "nodeName" && (r[d] = p));
      }
    }
  }
  return o;
}
function Zk(n, e, t, r) {
  if (t == yo && r == yo)
    return e;
  let o = e;
  for (let a = 0; a < r.length; a++) {
    let l = r[a], d = t[a];
    if (a) {
      let p;
      d && d.nodeName == l.nodeName && o != n && (p = o.parentNode) && p.nodeName.toLowerCase() == l.nodeName || (p = document.createElement(l.nodeName), p.pmIsDeco = !0, p.appendChild(o), d = yo[0]), o = p;
    }
    cF(o, d || yo[0], l);
  }
  return o;
}
function cF(n, e, t) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in t) && n.removeAttribute(r);
  for (let r in t)
    r != "class" && r != "style" && r != "nodeName" && t[r] != e[r] && n.setAttribute(r, t[r]);
  if (e.class != t.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], o = t.class ? t.class.split(" ").filter(Boolean) : [];
    for (let a = 0; a < r.length; a++)
      o.indexOf(r[a]) == -1 && n.classList.remove(r[a]);
    for (let a = 0; a < o.length; a++)
      r.indexOf(o[a]) == -1 && n.classList.add(o[a]);
    n.classList.length == 0 && n.removeAttribute("class");
  }
  if (e.style != t.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, o;
      for (; o = r.exec(e.style); )
        n.style.removeProperty(o[1]);
    }
    t.style && (n.style.cssText += t.style);
  }
}
function e1(n, e, t) {
  return Zk(n, n, yo, nf(e, t, n.nodeType != 1));
}
function Nu(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].type.eq(e[t].type))
      return !1;
  return !0;
}
function Zb(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class uF {
  constructor(e, t, r) {
    this.lock = t, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = dF(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, t) {
    if (e != t) {
      for (let r = e; r < t; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, t - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, t, r) {
    let o = 0, a = this.stack.length >> 1, l = Math.min(a, e.length);
    for (; o < l && (o == a - 1 ? this.top : this.stack[o + 1 << 1]).matchesMark(e[o]) && e[o].type.spec.spanning !== !1; )
      o++;
    for (; o < a; )
      this.destroyRest(), this.top.dirty = Fn, this.index = this.stack.pop(), this.top = this.stack.pop(), a--;
    for (; a < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let d = -1;
      for (let p = this.index; p < Math.min(this.index + 3, this.top.children.length); p++) {
        let f = this.top.children[p];
        if (f.matchesMark(e[a]) && !this.isLocked(f.dom)) {
          d = p;
          break;
        }
      }
      if (d > -1)
        d > this.index && (this.changed = !0, this.destroyBetween(this.index, d)), this.top = this.top.children[this.index];
      else {
        let p = Io.create(this.top, e[a], t, r);
        this.top.children.splice(this.index, 0, p), this.top = p, this.changed = !0;
      }
      this.index = 0, a++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, t, r, o) {
    let a = -1, l;
    if (o >= this.preMatch.index && (l = this.preMatch.matches[o - this.preMatch.index]).parent == this.top && l.matchesNode(e, t, r))
      a = this.top.children.indexOf(l, this.index);
    else
      for (let d = this.index, p = Math.min(this.top.children.length, d + 5); d < p; d++) {
        let f = this.top.children[d];
        if (f.matchesNode(e, t, r) && !this.preMatch.matched.has(f)) {
          a = d;
          break;
        }
      }
    return a < 0 ? !1 : (this.destroyBetween(this.index, a), this.index++, !0);
  }
  updateNodeAt(e, t, r, o, a) {
    let l = this.top.children[o];
    return l.dirty == Er && l.dom == l.contentDOM && (l.dirty = go), l.update(e, t, r, a) ? (this.destroyBetween(this.index, o), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let t = e.parentNode;
      if (!t)
        return -1;
      if (t == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let o = this.index; o < this.top.children.length; o++)
            if (this.top.children[o] == r)
              return o;
        }
        return -1;
      }
      e = t;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, t, r, o, a, l) {
    for (let d = this.index; d < this.top.children.length; d++) {
      let p = this.top.children[d];
      if (p instanceof Oi) {
        let f = this.preMatch.matched.get(p);
        if (f != null && f != a)
          return !1;
        let m = p.dom, y, v = this.isLocked(m) && !(e.isText && p.node && p.node.isText && p.nodeDOM.nodeValue == e.text && p.dirty != Er && Nu(t, p.outerDeco));
        if (!v && p.update(e, t, r, o))
          return this.destroyBetween(this.index, d), p.dom != m && (this.changed = !0), this.index++, !0;
        if (!v && (y = this.recreateWrapper(p, e, t, r, o, l)))
          return this.destroyBetween(this.index, d), this.top.children[this.index] = y, y.contentDOM && (y.dirty = go, y.updateChildren(o, l + 1), y.dirty = Fn), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, t, r, o, a, l) {
    if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !Nu(r, e.outerDeco) || !o.eq(e.innerDeco))
      return null;
    let d = Oi.create(this.top, t, r, o, a, l);
    if (d.contentDOM) {
      d.children = e.children, e.children = [];
      for (let p of d.children)
        p.parent = d;
    }
    return e.destroy(), d;
  }
  // Insert the node as a newly created node desc.
  addNode(e, t, r, o, a) {
    let l = Oi.create(this.top, e, t, r, o, a);
    l.contentDOM && l.updateChildren(o, a + 1), this.top.children.splice(this.index++, 0, l), this.changed = !0;
  }
  placeWidget(e, t, r) {
    let o = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (o && o.matchesWidget(e) && (e == o.widget || !o.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let a = new Wk(this.top, e, t, r);
      this.top.children.splice(this.index++, 0, a), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], t = this.top;
    for (; e instanceof Io; )
      t = e, e = t.children[t.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof sd) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((an || Xt) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top));
  }
  addHackNode(e, t) {
    if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let o = new Yk(this.top, [], r, null);
      t != this.top ? t.children.push(o) : t.children.splice(this.index++, 0, o), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function dF(n, e) {
  let t = e, r = t.children.length, o = n.childCount, a = /* @__PURE__ */ new Map(), l = [];
  e: for (; o > 0; ) {
    let d;
    for (; ; )
      if (r) {
        let f = t.children[r - 1];
        if (f instanceof Io)
          t = f, r = f.children.length;
        else {
          d = f, r--;
          break;
        }
      } else {
        if (t == e)
          break e;
        r = t.parent.children.indexOf(t), t = t.parent;
      }
    let p = d.node;
    if (p) {
      if (p != n.child(o - 1))
        break;
      --o, a.set(d, o), l.push(d);
    }
  }
  return { index: o, matched: a, matches: l.reverse() };
}
function pF(n, e) {
  return n.type.side - e.type.side;
}
function hF(n, e, t, r) {
  let o = e.locals(n), a = 0;
  if (o.length == 0) {
    for (let f = 0; f < n.childCount; f++) {
      let m = n.child(f);
      r(m, o, e.forChild(a, m), f), a += m.nodeSize;
    }
    return;
  }
  let l = 0, d = [], p = null;
  for (let f = 0; ; ) {
    let m, y;
    for (; l < o.length && o[l].to == a; ) {
      let B = o[l++];
      B.widget && (m ? (y || (y = [m])).push(B) : m = B);
    }
    if (m)
      if (y) {
        y.sort(pF);
        for (let B = 0; B < y.length; B++)
          t(y[B], f, !!p);
      } else
        t(m, f, !!p);
    let v, k;
    if (p)
      k = -1, v = p, p = null;
    else if (f < n.childCount)
      k = f, v = n.child(f++);
    else
      break;
    for (let B = 0; B < d.length; B++)
      d[B].to <= a && d.splice(B--, 1);
    for (; l < o.length && o[l].from <= a && o[l].to > a; )
      d.push(o[l++]);
    let A = a + v.nodeSize;
    if (v.isText) {
      let B = A;
      l < o.length && o[l].from < B && (B = o[l].from);
      for (let O = 0; O < d.length; O++)
        d[O].to < B && (B = d[O].to);
      B < A && (p = v.cut(B - a), v = v.cut(0, B - a), A = B, k = -1);
    } else
      for (; l < o.length && o[l].to < A; )
        l++;
    let S = v.isInline && !v.isLeaf ? d.filter((B) => !B.inline) : d.slice();
    r(v, S, e.forChild(a, v), k), a = A;
  }
}
function fF(n) {
  if (n.nodeName == "UL" || n.nodeName == "OL") {
    let e = n.style.cssText;
    n.style.cssText = e + "; list-style: square !important", window.getComputedStyle(n).listStyle, n.style.cssText = e;
  }
}
function mF(n, e, t, r) {
  for (let o = 0, a = 0; o < n.childCount && a <= r; ) {
    let l = n.child(o++), d = a;
    if (a += l.nodeSize, !l.isText)
      continue;
    let p = l.text;
    for (; o < n.childCount; ) {
      let f = n.child(o++);
      if (a += f.nodeSize, !f.isText)
        break;
      p += f.text;
    }
    if (a >= t) {
      if (a >= r && p.slice(r - e.length - d, r - d) == e)
        return r - e.length;
      let f = d < r ? p.lastIndexOf(e, r - d - 1) : -1;
      if (f >= 0 && f + e.length + d >= t)
        return d + f;
      if (t == r && p.length >= r + e.length - d && p.slice(r - d, r - d + e.length) == e)
        return r;
    }
  }
  return -1;
}
function rf(n, e, t, r, o) {
  let a = [];
  for (let l = 0, d = 0; l < n.length; l++) {
    let p = n[l], f = d, m = d += p.size;
    f >= t || m <= e ? a.push(p) : (f < e && a.push(p.slice(0, e - f, r)), o && (a.push(o), o = void 0), m > t && a.push(p.slice(t - f, p.size, r)));
  }
  return a;
}
function Yf(n, e = null) {
  let t = n.domSelectionRange(), r = n.state.doc;
  if (!t.focusNode)
    return null;
  let o = n.docView.nearestDesc(t.focusNode), a = o && o.size == 0, l = n.docView.posFromDOM(t.focusNode, t.focusOffset, 1);
  if (l < 0)
    return null;
  let d = r.resolve(l), p, f;
  if (od(t)) {
    for (p = l; o && !o.node; )
      o = o.parent;
    let y = o.node;
    if (o && y.isAtom && fe.isSelectable(y) && o.parent && !(y.isInline && H3(t.focusNode, t.focusOffset, o.dom))) {
      let v = o.posBefore;
      f = new fe(l == v ? d : r.resolve(v));
    }
  } else {
    if (t instanceof n.dom.ownerDocument.defaultView.Selection && t.rangeCount > 1) {
      let y = l, v = l;
      for (let k = 0; k < t.rangeCount; k++) {
        let A = t.getRangeAt(k);
        y = Math.min(y, n.docView.posFromDOM(A.startContainer, A.startOffset, 1)), v = Math.max(v, n.docView.posFromDOM(A.endContainer, A.endOffset, -1));
      }
      if (y < 0)
        return null;
      [p, l] = v == n.state.selection.anchor ? [v, y] : [y, v], d = r.resolve(l);
    } else
      p = n.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1);
    if (p < 0)
      return null;
  }
  let m = r.resolve(p);
  if (!f) {
    let y = e == "pointer" || n.state.selection.head < d.pos && !a ? 1 : -1;
    f = Qf(n, m, d, y);
  }
  return f;
}
function t1(n) {
  return n.editable ? n.hasFocus() : r1(n) && document.activeElement && document.activeElement.contains(n.dom);
}
function Xr(n, e = !1) {
  let t = n.state.selection;
  if (n1(n, t), !!t1(n)) {
    if (!e && n.input.mouseDown && n.input.mouseDown.allowDefault && Xt) {
      let r = n.domSelectionRange(), o = n.domObserver.currentSelection;
      if (r.anchorNode && o.anchorNode && Bo(r.anchorNode, r.anchorOffset, o.anchorNode, o.anchorOffset)) {
        n.input.mouseDown.delayedSelectionSync = !0, n.domObserver.setCurSelection();
        return;
      }
    }
    if (n.domObserver.disconnectSelection(), n.cursorWrapper)
      yF(n);
    else {
      let { anchor: r, head: o } = t, a, l;
      ev && !(t instanceof ge) && (t.$from.parent.inlineContent || (a = tv(n, t.from)), !t.empty && !t.$from.parent.inlineContent && (l = tv(n, t.to))), n.docView.setSelection(r, o, n, e), ev && (a && nv(a), l && nv(l)), t.visible ? n.dom.classList.remove("ProseMirror-hideselection") : (n.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && gF(n));
    }
    n.domObserver.setCurSelection(), n.domObserver.connectSelection();
  }
}
const ev = an || Xt && _k < 63;
function tv(n, e) {
  let { node: t, offset: r } = n.docView.domFromPos(e, 0), o = r < t.childNodes.length ? t.childNodes[r] : null, a = r ? t.childNodes[r - 1] : null;
  if (an && o && o.contentEditable == "false")
    return mh(o);
  if ((!o || o.contentEditable == "false") && (!a || a.contentEditable == "false")) {
    if (o)
      return mh(o);
    if (a)
      return mh(a);
  }
}
function mh(n) {
  return n.contentEditable = "true", an && n.draggable && (n.draggable = !1, n.wasDraggable = !0), n;
}
function nv(n) {
  n.contentEditable = "false", n.wasDraggable && (n.draggable = !0, n.wasDraggable = null);
}
function gF(n) {
  let e = n.dom.ownerDocument;
  e.removeEventListener("selectionchange", n.input.hideSelectionGuard);
  let t = n.domSelectionRange(), r = t.anchorNode, o = t.anchorOffset;
  e.addEventListener("selectionchange", n.input.hideSelectionGuard = () => {
    (t.anchorNode != r || t.anchorOffset != o) && (e.removeEventListener("selectionchange", n.input.hideSelectionGuard), setTimeout(() => {
      (!t1(n) || n.state.selection.visible) && n.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function yF(n) {
  let e = n.domSelection();
  if (!e)
    return;
  let t = n.cursorWrapper.dom, r = t.nodeName == "IMG";
  r ? e.collapse(t.parentNode, Lt(t) + 1) : e.collapse(t, 0), !r && !n.state.selection.visible && yn && Mi <= 11 && (t.disabled = !0, t.disabled = !1);
}
function n1(n, e) {
  if (e instanceof fe) {
    let t = n.docView.descAt(e.from);
    t != n.lastSelectedViewDesc && (rv(n), t && t.selectNode(), n.lastSelectedViewDesc = t);
  } else
    rv(n);
}
function rv(n) {
  n.lastSelectedViewDesc && (n.lastSelectedViewDesc.parent && n.lastSelectedViewDesc.deselectNode(), n.lastSelectedViewDesc = void 0);
}
function Qf(n, e, t, r) {
  return n.someProp("createSelectionBetween", (o) => o(n, e, t)) || ge.between(e, t, r);
}
function iv(n) {
  return n.editable && !n.hasFocus() ? !1 : r1(n);
}
function r1(n) {
  let e = n.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return n.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (n.editable || n.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function wF(n) {
  let e = n.docView.domFromPos(n.state.selection.anchor, 0), t = n.domSelectionRange();
  return Bo(e.node, e.offset, t.anchorNode, t.anchorOffset);
}
function of(n, e) {
  let { $anchor: t, $head: r } = n.selection, o = e > 0 ? t.max(r) : t.min(r), a = o.parent.inlineContent ? o.depth ? n.doc.resolve(e > 0 ? o.after() : o.before()) : null : o;
  return a && ve.findFrom(a, e);
}
function xi(n, e) {
  return n.dispatch(n.state.tr.setSelection(e).scrollIntoView()), !0;
}
function ov(n, e, t) {
  let r = n.state.selection;
  if (r instanceof ge)
    if (t.indexOf("s") > -1) {
      let { $head: o } = r, a = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter;
      if (!a || a.isText || !a.isLeaf)
        return !1;
      let l = n.state.doc.resolve(o.pos + a.nodeSize * (e < 0 ? -1 : 1));
      return xi(n, new ge(r.$anchor, l));
    } else if (r.empty) {
      if (n.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let o = of(n.state, e);
        return o && o instanceof fe ? xi(n, o) : !1;
      } else if (!(In && t.indexOf("m") > -1)) {
        let o = r.$head, a = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter, l;
        if (!a || a.isText)
          return !1;
        let d = e < 0 ? o.pos - a.nodeSize : o.pos;
        return a.isAtom || (l = n.docView.descAt(d)) && !l.contentDOM ? fe.isSelectable(a) ? xi(n, new fe(e < 0 ? n.state.doc.resolve(o.pos - a.nodeSize) : o)) : $l ? xi(n, new ge(n.state.doc.resolve(e < 0 ? d : d + a.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof fe && r.node.isInline)
      return xi(n, new ge(e > 0 ? r.$to : r.$from));
    {
      let o = of(n.state, e);
      return o ? xi(n, o) : !1;
    }
  }
}
function Bu(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function tl(n, e) {
  let t = n.pmViewDesc;
  return t && t.size == 0 && (e < 0 || n.nextSibling || n.nodeName != "BR");
}
function Es(n, e) {
  return e < 0 ? bF(n) : vF(n);
}
function bF(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let o, a, l = !1;
  for (Rn && t.nodeType == 1 && r < Bu(t) && tl(t.childNodes[r], -1) && (l = !0); ; )
    if (r > 0) {
      if (t.nodeType != 1)
        break;
      {
        let d = t.childNodes[r - 1];
        if (tl(d, -1))
          o = t, a = --r;
        else if (d.nodeType == 3)
          t = d, r = t.nodeValue.length;
        else
          break;
      }
    } else {
      if (i1(t))
        break;
      {
        let d = t.previousSibling;
        for (; d && tl(d, -1); )
          o = t.parentNode, a = Lt(d), d = d.previousSibling;
        if (d)
          t = d, r = Bu(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = 0;
        }
      }
    }
  l ? sf(n, t, r) : o && sf(n, o, a);
}
function vF(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let o = Bu(t), a, l;
  for (; ; )
    if (r < o) {
      if (t.nodeType != 1)
        break;
      let d = t.childNodes[r];
      if (tl(d, 1))
        a = t, l = ++r;
      else
        break;
    } else {
      if (i1(t))
        break;
      {
        let d = t.nextSibling;
        for (; d && tl(d, 1); )
          a = d.parentNode, l = Lt(d) + 1, d = d.nextSibling;
        if (d)
          t = d, r = 0, o = Bu(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = o = 0;
        }
      }
    }
  a && sf(n, a, l);
}
function i1(n) {
  let e = n.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function xF(n, e) {
  for (; n && e == n.childNodes.length && !Pl(n); )
    e = Lt(n) + 1, n = n.parentNode;
  for (; n && e < n.childNodes.length; ) {
    let t = n.childNodes[e];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = 0;
  }
}
function kF(n, e) {
  for (; n && !e && !Pl(n); )
    e = Lt(n), n = n.parentNode;
  for (; n && e; ) {
    let t = n.childNodes[e - 1];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = n.childNodes.length;
  }
}
function sf(n, e, t) {
  if (e.nodeType != 3) {
    let a, l;
    (l = xF(e, t)) ? (e = l, t = 0) : (a = kF(e, t)) && (e = a, t = a.nodeValue.length);
  }
  let r = n.domSelection();
  if (!r)
    return;
  if (od(r)) {
    let a = document.createRange();
    a.setEnd(e, t), a.setStart(e, t), r.removeAllRanges(), r.addRange(a);
  } else r.extend && r.extend(e, t);
  n.domObserver.setCurSelection();
  let { state: o } = n;
  setTimeout(() => {
    n.state == o && Xr(n);
  }, 50);
}
function sv(n, e) {
  let t = n.state.doc.resolve(e);
  if (!(Xt || z3) && t.parent.inlineContent) {
    let o = n.coordsAtPos(e);
    if (e > t.start()) {
      let a = n.coordsAtPos(e - 1), l = (a.top + a.bottom) / 2;
      if (l > o.top && l < o.bottom && Math.abs(a.left - o.left) > 1)
        return a.left < o.left ? "ltr" : "rtl";
    }
    if (e < t.end()) {
      let a = n.coordsAtPos(e + 1), l = (a.top + a.bottom) / 2;
      if (l > o.top && l < o.bottom && Math.abs(a.left - o.left) > 1)
        return a.left > o.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(n.dom).direction == "rtl" ? "rtl" : "ltr";
}
function av(n, e, t) {
  let r = n.state.selection;
  if (r instanceof ge && !r.empty || t.indexOf("s") > -1 || In && t.indexOf("m") > -1)
    return !1;
  let { $from: o, $to: a } = r;
  if (!o.parent.inlineContent || n.endOfTextblock(e < 0 ? "up" : "down")) {
    let l = of(n.state, e);
    if (l && l instanceof fe)
      return xi(n, l);
  }
  if (!o.parent.inlineContent) {
    let l = e < 0 ? o : a, d = r instanceof gn ? ve.near(l, e) : ve.findFrom(l, e);
    return d ? xi(n, d) : !1;
  }
  return !1;
}
function lv(n, e) {
  if (!(n.state.selection instanceof ge))
    return !0;
  let { $head: t, $anchor: r, empty: o } = n.state.selection;
  if (!t.sameParent(r))
    return !0;
  if (!o)
    return !1;
  if (n.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let a = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter);
  if (a && !a.isText) {
    let l = n.state.tr;
    return e < 0 ? l.delete(t.pos - a.nodeSize, t.pos) : l.delete(t.pos, t.pos + a.nodeSize), n.dispatch(l), !0;
  }
  return !1;
}
function cv(n, e, t) {
  n.domObserver.stop(), e.contentEditable = t, n.domObserver.start();
}
function AF(n) {
  if (!an || n.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: t } = n.domSelectionRange();
  if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    cv(n, r, "true"), setTimeout(() => cv(n, r, "false"), 20);
  }
  return !1;
}
function CF(n) {
  let e = "";
  return n.ctrlKey && (e += "c"), n.metaKey && (e += "m"), n.altKey && (e += "a"), n.shiftKey && (e += "s"), e;
}
function SF(n, e) {
  let t = e.keyCode, r = CF(e);
  if (t == 8 || In && t == 72 && r == "c")
    return lv(n, -1) || Es(n, -1);
  if (t == 46 && !e.shiftKey || In && t == 68 && r == "c")
    return lv(n, 1) || Es(n, 1);
  if (t == 13 || t == 27)
    return !0;
  if (t == 37 || In && t == 66 && r == "c") {
    let o = t == 37 ? sv(n, n.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return ov(n, o, r) || Es(n, o);
  } else if (t == 39 || In && t == 70 && r == "c") {
    let o = t == 39 ? sv(n, n.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return ov(n, o, r) || Es(n, o);
  } else {
    if (t == 38 || In && t == 80 && r == "c")
      return av(n, -1, r) || Es(n, -1);
    if (t == 40 || In && t == 78 && r == "c")
      return AF(n) || av(n, 1, r) || Es(n, 1);
    if (r == (In ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90))
      return !0;
  }
  return !1;
}
function Zf(n, e) {
  n.someProp("transformCopied", (k) => {
    e = k(e, n);
  });
  let t = [], { content: r, openStart: o, openEnd: a } = e;
  for (; o > 1 && a > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    o--, a--;
    let k = r.firstChild;
    t.push(k.type.name, k.attrs != k.type.defaultAttrs ? k.attrs : null), r = k.content;
  }
  let l = n.someProp("clipboardSerializer") || Uo.fromSchema(n.state.schema), d = u1(), p = d.createElement("div");
  p.appendChild(l.serializeFragment(r, { document: d }));
  let f = p.firstChild, m, y = 0;
  for (; f && f.nodeType == 1 && (m = c1[f.nodeName.toLowerCase()]); ) {
    for (let k = m.length - 1; k >= 0; k--) {
      let A = d.createElement(m[k]);
      for (; p.firstChild; )
        A.appendChild(p.firstChild);
      p.appendChild(A), y++;
    }
    f = p.firstChild;
  }
  f && f.nodeType == 1 && f.setAttribute("data-pm-slice", `${o} ${a}${y ? ` -${y}` : ""} ${JSON.stringify(t)}`);
  let v = n.someProp("clipboardTextSerializer", (k) => k(e, n)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: p, text: v, slice: e };
}
function o1(n, e, t, r, o) {
  let a = o.parent.type.spec.code, l, d;
  if (!t && !e)
    return null;
  let p = !!e && (r || a || !t);
  if (p) {
    if (n.someProp("transformPastedText", (v) => {
      e = v(e, a || r, n);
    }), a)
      return d = new ne(X.from(n.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0), n.someProp("transformPasted", (v) => {
        d = v(d, n, !0);
      }), d;
    let y = n.someProp("clipboardTextParser", (v) => v(e, o, r, n));
    if (y)
      d = y;
    else {
      let v = o.marks(), { schema: k } = n.state, A = Uo.fromSchema(k);
      l = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((S) => {
        let B = l.appendChild(document.createElement("p"));
        S && B.appendChild(A.serializeNode(k.text(S, v)));
      });
    }
  } else
    n.someProp("transformPastedHTML", (y) => {
      t = y(t, n);
    }), l = BF(t), $l && IF(l);
  let f = l && l.querySelector("[data-pm-slice]"), m = f && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(f.getAttribute("data-pm-slice") || "");
  if (m && m[3])
    for (let y = +m[3]; y > 0; y--) {
      let v = l.firstChild;
      for (; v && v.nodeType != 1; )
        v = v.nextSibling;
      if (!v)
        break;
      l = v;
    }
  if (d || (d = (n.someProp("clipboardParser") || n.someProp("domParser") || Qa.fromSchema(n.state.schema)).parseSlice(l, {
    preserveWhitespace: !!(p || m),
    context: o,
    ruleFromNode(v) {
      return v.nodeName == "BR" && !v.nextSibling && v.parentNode && !EF.test(v.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), m)
    d = MF(uv(d, +m[1], +m[2]), m[4]);
  else if (d = ne.maxOpen(TF(d.content, o), !0), d.openStart || d.openEnd) {
    let y = 0, v = 0;
    for (let k = d.content.firstChild; y < d.openStart && !k.type.spec.isolating; y++, k = k.firstChild)
      ;
    for (let k = d.content.lastChild; v < d.openEnd && !k.type.spec.isolating; v++, k = k.lastChild)
      ;
    d = uv(d, y, v);
  }
  return n.someProp("transformPasted", (y) => {
    d = y(d, n, p);
  }), d;
}
const EF = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function TF(n, e) {
  if (n.childCount < 2)
    return n;
  for (let t = e.depth; t >= 0; t--) {
    let o = e.node(t).contentMatchAt(e.index(t)), a, l = [];
    if (n.forEach((d) => {
      if (!l)
        return;
      let p = o.findWrapping(d.type), f;
      if (!p)
        return l = null;
      if (f = l.length && a.length && a1(p, a, d, l[l.length - 1], 0))
        l[l.length - 1] = f;
      else {
        l.length && (l[l.length - 1] = l1(l[l.length - 1], a.length));
        let m = s1(d, p);
        l.push(m), o = o.matchType(m.type), a = p;
      }
    }), l)
      return X.from(l);
  }
  return n;
}
function s1(n, e, t = 0) {
  for (let r = e.length - 1; r >= t; r--)
    n = e[r].create(null, X.from(n));
  return n;
}
function a1(n, e, t, r, o) {
  if (o < n.length && o < e.length && n[o] == e[o]) {
    let a = a1(n, e, t, r.lastChild, o + 1);
    if (a)
      return r.copy(r.content.replaceChild(r.childCount - 1, a));
    if (r.contentMatchAt(r.childCount).matchType(o == n.length - 1 ? t.type : n[o + 1]))
      return r.copy(r.content.append(X.from(s1(t, n, o + 1))));
  }
}
function l1(n, e) {
  if (e == 0)
    return n;
  let t = n.content.replaceChild(n.childCount - 1, l1(n.lastChild, e - 1)), r = n.contentMatchAt(n.childCount).fillBefore(X.empty, !0);
  return n.copy(t.append(r));
}
function af(n, e, t, r, o, a) {
  let l = e < 0 ? n.firstChild : n.lastChild, d = l.content;
  return n.childCount > 1 && (a = 0), o < r - 1 && (d = af(d, e, t, r, o + 1, a)), o >= t && (d = e < 0 ? l.contentMatchAt(0).fillBefore(d, a <= o).append(d) : d.append(l.contentMatchAt(l.childCount).fillBefore(X.empty, !0))), n.replaceChild(e < 0 ? 0 : n.childCount - 1, l.copy(d));
}
function uv(n, e, t) {
  return e < n.openStart && (n = new ne(af(n.content, -1, e, n.openStart, 0, n.openEnd), e, n.openEnd)), t < n.openEnd && (n = new ne(af(n.content, 1, t, n.openEnd, 0, 0), n.openStart, t)), n;
}
const c1 = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let dv = null;
function u1() {
  return dv || (dv = document.implementation.createHTMLDocument("title"));
}
let gh = null;
function NF(n) {
  let e = window.trustedTypes;
  return e ? (gh || (gh = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", { createHTML: (t) => t })), gh.createHTML(n)) : n;
}
function BF(n) {
  let e = /^(\s*<meta [^>]*>)*/.exec(n);
  e && (n = n.slice(e[0].length));
  let t = u1().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(n), o;
  if ((o = r && c1[r[1].toLowerCase()]) && (n = o.map((a) => "<" + a + ">").join("") + n + o.map((a) => "</" + a + ">").reverse().join("")), t.innerHTML = NF(n), o)
    for (let a = 0; a < o.length; a++)
      t = t.querySelector(o[a]) || t;
  return t;
}
function IF(n) {
  let e = n.querySelectorAll(Xt ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(n.ownerDocument.createTextNode(" "), r);
  }
}
function MF(n, e) {
  if (!n.size)
    return n;
  let t = n.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return n;
  }
  let { content: o, openStart: a, openEnd: l } = n;
  for (let d = r.length - 2; d >= 0; d -= 2) {
    let p = t.nodes[r[d]];
    if (!p || p.hasRequiredAttrs())
      break;
    o = X.from(p.create(r[d + 1], o)), a++, l++;
  }
  return new ne(o, a, l);
}
const ln = {}, cn = {}, OF = { touchstart: !0, touchmove: !0 };
class DF {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function RF(n) {
  for (let e in ln) {
    let t = ln[e];
    n.dom.addEventListener(e, n.input.eventHandlers[e] = (r) => {
      PF(n, r) && !em(n, r) && (n.editable || !(r.type in cn)) && t(n, r);
    }, OF[e] ? { passive: !0 } : void 0);
  }
  an && n.dom.addEventListener("input", () => null), lf(n);
}
function Ni(n, e) {
  n.input.lastSelectionOrigin = e, n.input.lastSelectionTime = Date.now();
}
function FF(n) {
  n.domObserver.stop();
  for (let e in n.input.eventHandlers)
    n.dom.removeEventListener(e, n.input.eventHandlers[e]);
  clearTimeout(n.input.composingTimeout), clearTimeout(n.input.lastIOSEnterFallbackTimeout);
}
function lf(n) {
  n.someProp("handleDOMEvents", (e) => {
    for (let t in e)
      n.input.eventHandlers[t] || n.dom.addEventListener(t, n.input.eventHandlers[t] = (r) => em(n, r));
  });
}
function em(n, e) {
  return n.someProp("handleDOMEvents", (t) => {
    let r = t[e.type];
    return r ? r(n, e) || e.defaultPrevented : !1;
  });
}
function PF(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target; t != n.dom; t = t.parentNode)
    if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function $F(n, e) {
  !em(n, e) && ln[e.type] && (n.editable || !(e.type in cn)) && ln[e.type](n, e);
}
cn.keydown = (n, e) => {
  let t = e;
  if (n.input.shiftKey = t.keyCode == 16 || t.shiftKey, !p1(n, t) && (n.input.lastKeyCode = t.keyCode, n.input.lastKeyCodeTime = Date.now(), !(zr && Xt && t.keyCode == 13)))
    if (t.keyCode != 229 && n.domObserver.forceFlush(), Js && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) {
      let r = Date.now();
      n.input.lastIOSEnter = r, n.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        n.input.lastIOSEnter == r && (n.someProp("handleKeyDown", (o) => o(n, fo(13, "Enter"))), n.input.lastIOSEnter = 0);
      }, 200);
    } else n.someProp("handleKeyDown", (r) => r(n, t)) || SF(n, t) ? t.preventDefault() : Ni(n, "key");
};
cn.keyup = (n, e) => {
  e.keyCode == 16 && (n.input.shiftKey = !1);
};
cn.keypress = (n, e) => {
  let t = e;
  if (p1(n, t) || !t.charCode || t.ctrlKey && !t.altKey || In && t.metaKey)
    return;
  if (n.someProp("handleKeyPress", (o) => o(n, t))) {
    t.preventDefault();
    return;
  }
  let r = n.state.selection;
  if (!(r instanceof ge) || !r.$from.sameParent(r.$to)) {
    let o = String.fromCharCode(t.charCode), a = () => n.state.tr.insertText(o).scrollIntoView();
    !/[\r\n]/.test(o) && !n.someProp("handleTextInput", (l) => l(n, r.$from.pos, r.$to.pos, o, a)) && n.dispatch(a()), t.preventDefault();
  }
};
function ad(n) {
  return { left: n.clientX, top: n.clientY };
}
function jF(n, e) {
  let t = e.x - n.clientX, r = e.y - n.clientY;
  return t * t + r * r < 100;
}
function tm(n, e, t, r, o) {
  if (r == -1)
    return !1;
  let a = n.state.doc.resolve(r);
  for (let l = a.depth + 1; l > 0; l--)
    if (n.someProp(e, (d) => l > a.depth ? d(n, t, a.nodeAfter, a.before(l), o, !0) : d(n, t, a.node(l), a.before(l), o, !1)))
      return !0;
  return !1;
}
function js(n, e, t) {
  if (n.focused || n.focus(), n.state.selection.eq(e))
    return;
  let r = n.state.tr.setSelection(e);
  r.setMeta("pointer", !0), n.dispatch(r);
}
function UF(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.doc.resolve(e), r = t.nodeAfter;
  return r && r.isAtom && fe.isSelectable(r) ? (js(n, new fe(t)), !0) : !1;
}
function LF(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.selection, r, o;
  t instanceof fe && (r = t.node);
  let a = n.state.doc.resolve(e);
  for (let l = a.depth + 1; l > 0; l--) {
    let d = l > a.depth ? a.nodeAfter : a.node(l);
    if (fe.isSelectable(d)) {
      r && t.$from.depth > 0 && l >= t.$from.depth && a.before(t.$from.depth + 1) == t.$from.pos ? o = a.before(t.$from.depth) : o = a.before(l);
      break;
    }
  }
  return o != null ? (js(n, fe.create(n.state.doc, o)), !0) : !1;
}
function HF(n, e, t, r, o) {
  return tm(n, "handleClickOn", e, t, r) || n.someProp("handleClick", (a) => a(n, e, r)) || (o ? LF(n, t) : UF(n, t));
}
function GF(n, e, t, r) {
  return tm(n, "handleDoubleClickOn", e, t, r) || n.someProp("handleDoubleClick", (o) => o(n, e, r));
}
function _F(n, e, t, r) {
  return tm(n, "handleTripleClickOn", e, t, r) || n.someProp("handleTripleClick", (o) => o(n, e, r)) || zF(n, t, r);
}
function zF(n, e, t) {
  if (t.button != 0)
    return !1;
  let r = n.state.doc;
  if (e == -1)
    return r.inlineContent ? (js(n, ge.create(r, 0, r.content.size)), !0) : !1;
  let o = r.resolve(e);
  for (let a = o.depth + 1; a > 0; a--) {
    let l = a > o.depth ? o.nodeAfter : o.node(a), d = o.before(a);
    if (l.inlineContent)
      js(n, ge.create(r, d + 1, d + 1 + l.content.size));
    else if (fe.isSelectable(l))
      js(n, fe.create(r, d));
    else
      continue;
    return !0;
  }
}
function nm(n) {
  return Iu(n);
}
const d1 = In ? "metaKey" : "ctrlKey";
ln.mousedown = (n, e) => {
  let t = e;
  n.input.shiftKey = t.shiftKey;
  let r = nm(n), o = Date.now(), a = "singleClick";
  o - n.input.lastClick.time < 500 && jF(t, n.input.lastClick) && !t[d1] && n.input.lastClick.button == t.button && (n.input.lastClick.type == "singleClick" ? a = "doubleClick" : n.input.lastClick.type == "doubleClick" && (a = "tripleClick")), n.input.lastClick = { time: o, x: t.clientX, y: t.clientY, type: a, button: t.button };
  let l = n.posAtCoords(ad(t));
  l && (a == "singleClick" ? (n.input.mouseDown && n.input.mouseDown.done(), n.input.mouseDown = new qF(n, l, t, !!r)) : (a == "doubleClick" ? GF : _F)(n, l.pos, l.inside, t) ? t.preventDefault() : Ni(n, "pointer"));
};
class qF {
  constructor(e, t, r, o) {
    this.view = e, this.pos = t, this.event = r, this.flushed = o, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[d1], this.allowDefault = r.shiftKey;
    let a, l;
    if (t.inside > -1)
      a = e.state.doc.nodeAt(t.inside), l = t.inside;
    else {
      let m = e.state.doc.resolve(t.pos);
      a = m.parent, l = m.depth ? m.before() : 0;
    }
    const d = o ? null : r.target, p = d ? e.docView.nearestDesc(d, !0) : null;
    this.target = p && p.dom.nodeType == 1 ? p.dom : null;
    let { selection: f } = e.state;
    (r.button == 0 && a.type.spec.draggable && a.type.spec.selectable !== !1 || f instanceof fe && f.from <= l && f.to > l) && (this.mightDrag = {
      node: a,
      pos: l,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && Rn && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Ni(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Xr(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let t = this.pos;
    this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(ad(e))), this.updateAllowDefault(e), this.allowDefault || !t ? Ni(this.view, "pointer") : HF(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    an && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    Xt && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (js(this.view, ve.near(this.view.state.doc.resolve(t.pos))), e.preventDefault()) : Ni(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), Ni(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
ln.touchstart = (n) => {
  n.input.lastTouch = Date.now(), nm(n), Ni(n, "pointer");
};
ln.touchmove = (n) => {
  n.input.lastTouch = Date.now(), Ni(n, "pointer");
};
ln.contextmenu = (n) => nm(n);
function p1(n, e) {
  return n.composing ? !0 : an && Math.abs(e.timeStamp - n.input.compositionEndedAt) < 500 ? (n.input.compositionEndedAt = -2e8, !0) : !1;
}
const VF = zr ? 5e3 : -1;
cn.compositionstart = cn.compositionupdate = (n) => {
  if (!n.composing) {
    n.domObserver.flush();
    let { state: e } = n, t = e.selection.$to;
    if (e.selection instanceof ge && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      n.markCursor = n.state.storedMarks || t.marks(), Iu(n, !0), n.markCursor = null;
    else if (Iu(n, !e.selection.empty), Rn && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) {
      let r = n.domSelectionRange();
      for (let o = r.focusNode, a = r.focusOffset; o && o.nodeType == 1 && a != 0; ) {
        let l = a < 0 ? o.lastChild : o.childNodes[a - 1];
        if (!l)
          break;
        if (l.nodeType == 3) {
          let d = n.domSelection();
          d && d.collapse(l, l.nodeValue.length);
          break;
        } else
          o = l, a = -1;
      }
    }
    n.input.composing = !0;
  }
  h1(n, VF);
};
cn.compositionend = (n, e) => {
  n.composing && (n.input.composing = !1, n.input.compositionEndedAt = e.timeStamp, n.input.compositionPendingChanges = n.domObserver.pendingRecords().length ? n.input.compositionID : 0, n.input.compositionNode = null, n.input.compositionPendingChanges && Promise.resolve().then(() => n.domObserver.flush()), n.input.compositionID++, h1(n, 20));
};
function h1(n, e) {
  clearTimeout(n.input.composingTimeout), e > -1 && (n.input.composingTimeout = setTimeout(() => Iu(n), e));
}
function f1(n) {
  for (n.composing && (n.input.composing = !1, n.input.compositionEndedAt = JF()); n.input.compositionNodes.length > 0; )
    n.input.compositionNodes.pop().markParentsDirty();
}
function XF(n) {
  let e = n.domSelectionRange();
  if (!e.focusNode)
    return null;
  let t = U3(e.focusNode, e.focusOffset), r = L3(e.focusNode, e.focusOffset);
  if (t && r && t != r) {
    let o = r.pmViewDesc, a = n.domObserver.lastChangedTextNode;
    if (t == a || r == a)
      return a;
    if (!o || !o.isText(r.nodeValue))
      return r;
    if (n.input.compositionNode == r) {
      let l = t.pmViewDesc;
      if (!(!l || !l.isText(t.nodeValue)))
        return r;
    }
  }
  return t || r;
}
function JF() {
  let n = document.createEvent("Event");
  return n.initEvent("event", !0, !0), n.timeStamp;
}
function Iu(n, e = !1) {
  if (!(zr && n.domObserver.flushingSoon >= 0)) {
    if (n.domObserver.forceFlush(), f1(n), e || n.docView && n.docView.dirty) {
      let t = Yf(n), r = n.state.selection;
      return t && !t.eq(r) ? n.dispatch(n.state.tr.setSelection(t)) : (n.markCursor || e) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? n.dispatch(n.state.tr.deleteSelection()) : n.updateState(n.state), !0;
    }
    return !1;
  }
}
function KF(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.dom.parentNode.appendChild(document.createElement("div"));
  t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), o = document.createRange();
  o.selectNodeContents(e), n.dom.blur(), r.removeAllRanges(), r.addRange(o), setTimeout(() => {
    t.parentNode && t.parentNode.removeChild(t), n.focus();
  }, 50);
}
const fl = yn && Mi < 15 || Js && q3 < 604;
ln.copy = cn.cut = (n, e) => {
  let t = e, r = n.state.selection, o = t.type == "cut";
  if (r.empty)
    return;
  let a = fl ? null : t.clipboardData, l = r.content(), { dom: d, text: p } = Zf(n, l);
  a ? (t.preventDefault(), a.clearData(), a.setData("text/html", d.innerHTML), a.setData("text/plain", p)) : KF(n, d), o && n.dispatch(n.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function WF(n) {
  return n.openStart == 0 && n.openEnd == 0 && n.content.childCount == 1 ? n.content.firstChild : null;
}
function YF(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.input.shiftKey || n.state.selection.$from.parent.type.spec.code, r = n.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div"));
  t || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let o = n.input.shiftKey && n.input.lastKeyCode != 45;
  setTimeout(() => {
    n.focus(), r.parentNode && r.parentNode.removeChild(r), t ? ml(n, r.value, null, o, e) : ml(n, r.textContent, r.innerHTML, o, e);
  }, 50);
}
function ml(n, e, t, r, o) {
  let a = o1(n, e, t, r, n.state.selection.$from);
  if (n.someProp("handlePaste", (p) => p(n, o, a || ne.empty)))
    return !0;
  if (!a)
    return !1;
  let l = WF(a), d = l ? n.state.tr.replaceSelectionWith(l, r) : n.state.tr.replaceSelection(a);
  return n.dispatch(d.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function m1(n) {
  let e = n.getData("text/plain") || n.getData("Text");
  if (e)
    return e;
  let t = n.getData("text/uri-list");
  return t ? t.replace(/\r?\n/g, " ") : "";
}
cn.paste = (n, e) => {
  let t = e;
  if (n.composing && !zr)
    return;
  let r = fl ? null : t.clipboardData, o = n.input.shiftKey && n.input.lastKeyCode != 45;
  r && ml(n, m1(r), r.getData("text/html"), o, t) ? t.preventDefault() : YF(n, t);
};
class g1 {
  constructor(e, t, r) {
    this.slice = e, this.move = t, this.node = r;
  }
}
const QF = In ? "altKey" : "ctrlKey";
function y1(n, e) {
  let t = n.someProp("dragCopies", (r) => !r(e));
  return t ?? !e[QF];
}
ln.dragstart = (n, e) => {
  let t = e, r = n.input.mouseDown;
  if (r && r.done(), !t.dataTransfer)
    return;
  let o = n.state.selection, a = o.empty ? null : n.posAtCoords(ad(t)), l;
  if (!(a && a.pos >= o.from && a.pos <= (o instanceof fe ? o.to - 1 : o.to))) {
    if (r && r.mightDrag)
      l = fe.create(n.state.doc, r.mightDrag.pos);
    else if (t.target && t.target.nodeType == 1) {
      let y = n.docView.nearestDesc(t.target, !0);
      y && y.node.type.spec.draggable && y != n.docView && (l = fe.create(n.state.doc, y.posBefore));
    }
  }
  let d = (l || n.state.selection).content(), { dom: p, text: f, slice: m } = Zf(n, d);
  (!t.dataTransfer.files.length || !Xt || _k > 120) && t.dataTransfer.clearData(), t.dataTransfer.setData(fl ? "Text" : "text/html", p.innerHTML), t.dataTransfer.effectAllowed = "copyMove", fl || t.dataTransfer.setData("text/plain", f), n.dragging = new g1(m, y1(n, t), l);
};
ln.dragend = (n) => {
  let e = n.dragging;
  window.setTimeout(() => {
    n.dragging == e && (n.dragging = null);
  }, 50);
};
cn.dragover = cn.dragenter = (n, e) => e.preventDefault();
cn.drop = (n, e) => {
  let t = e, r = n.dragging;
  if (n.dragging = null, !t.dataTransfer)
    return;
  let o = n.posAtCoords(ad(t));
  if (!o)
    return;
  let a = n.state.doc.resolve(o.pos), l = r && r.slice;
  l ? n.someProp("transformPasted", (A) => {
    l = A(l, n, !1);
  }) : l = o1(n, m1(t.dataTransfer), fl ? null : t.dataTransfer.getData("text/html"), !1, a);
  let d = !!(r && y1(n, t));
  if (n.someProp("handleDrop", (A) => A(n, t, l || ne.empty, d))) {
    t.preventDefault();
    return;
  }
  if (!l)
    return;
  t.preventDefault();
  let p = l ? Rk(n.state.doc, a.pos, l) : a.pos;
  p == null && (p = a.pos);
  let f = n.state.tr;
  if (d) {
    let { node: A } = r;
    A ? A.replace(f) : f.deleteSelection();
  }
  let m = f.mapping.map(p), y = l.openStart == 0 && l.openEnd == 0 && l.content.childCount == 1, v = f.doc;
  if (y ? f.replaceRangeWith(m, m, l.content.firstChild) : f.replaceRange(m, m, l), f.doc.eq(v))
    return;
  let k = f.doc.resolve(m);
  if (y && fe.isSelectable(l.content.firstChild) && k.nodeAfter && k.nodeAfter.sameMarkup(l.content.firstChild))
    f.setSelection(new fe(k));
  else {
    let A = f.mapping.map(p);
    f.mapping.maps[f.mapping.maps.length - 1].forEach((S, B, O, L) => A = L), f.setSelection(Qf(n, k, f.doc.resolve(A)));
  }
  n.focus(), n.dispatch(f.setMeta("uiEvent", "drop"));
};
ln.focus = (n) => {
  n.input.lastFocus = Date.now(), n.focused || (n.domObserver.stop(), n.dom.classList.add("ProseMirror-focused"), n.domObserver.start(), n.focused = !0, setTimeout(() => {
    n.docView && n.hasFocus() && !n.domObserver.currentSelection.eq(n.domSelectionRange()) && Xr(n);
  }, 20));
};
ln.blur = (n, e) => {
  let t = e;
  n.focused && (n.domObserver.stop(), n.dom.classList.remove("ProseMirror-focused"), n.domObserver.start(), t.relatedTarget && n.dom.contains(t.relatedTarget) && n.domObserver.currentSelection.clear(), n.focused = !1);
};
ln.beforeinput = (n, e) => {
  if (Xt && zr && e.inputType == "deleteContentBackward") {
    n.domObserver.flushSoon();
    let { domChangeCount: r } = n.input;
    setTimeout(() => {
      if (n.input.domChangeCount != r || (n.dom.blur(), n.focus(), n.someProp("handleKeyDown", (a) => a(n, fo(8, "Backspace")))))
        return;
      let { $cursor: o } = n.state.selection;
      o && o.pos > 0 && n.dispatch(n.state.tr.delete(o.pos - 1, o.pos).scrollIntoView());
    }, 50);
  }
};
for (let n in cn)
  ln[n] = cn[n];
function gl(n, e) {
  if (n == e)
    return !0;
  for (let t in n)
    if (n[t] !== e[t])
      return !1;
  for (let t in e)
    if (!(t in n))
      return !1;
  return !0;
}
class Mu {
  constructor(e, t) {
    this.toDOM = e, this.spec = t || vo, this.side = this.spec.side || 0;
  }
  map(e, t, r, o) {
    let { pos: a, deleted: l } = e.mapResult(t.from + o, this.side < 0 ? -1 : 1);
    return l ? null : new It(a - r, a - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof Mu && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && gl(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class Di {
  constructor(e, t) {
    this.attrs = e, this.spec = t || vo;
  }
  map(e, t, r, o) {
    let a = e.map(t.from + o, this.spec.inclusiveStart ? -1 : 1) - r, l = e.map(t.to + o, this.spec.inclusiveEnd ? 1 : -1) - r;
    return a >= l ? null : new It(a, l, this);
  }
  valid(e, t) {
    return t.from < t.to;
  }
  eq(e) {
    return this == e || e instanceof Di && gl(this.attrs, e.attrs) && gl(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Di;
  }
  destroy() {
  }
}
class rm {
  constructor(e, t) {
    this.attrs = e, this.spec = t || vo;
  }
  map(e, t, r, o) {
    let a = e.mapResult(t.from + o, 1);
    if (a.deleted)
      return null;
    let l = e.mapResult(t.to + o, -1);
    return l.deleted || l.pos <= a.pos ? null : new It(a.pos - r, l.pos - r, this);
  }
  valid(e, t) {
    let { index: r, offset: o } = e.content.findIndex(t.from), a;
    return o == t.from && !(a = e.child(r)).isText && o + a.nodeSize == t.to;
  }
  eq(e) {
    return this == e || e instanceof rm && gl(this.attrs, e.attrs) && gl(this.spec, e.spec);
  }
  destroy() {
  }
}
class It {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.type = r;
  }
  /**
  @internal
  */
  copy(e, t) {
    return new It(e, t, this.type);
  }
  /**
  @internal
  */
  eq(e, t = 0) {
    return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to;
  }
  /**
  @internal
  */
  map(e, t, r) {
    return this.type.map(e, this, t, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, t, r) {
    return new It(e, e, new Mu(t, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, t, r, o) {
    return new It(e, t, new Di(r, o));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, t, r, o) {
    return new It(e, t, new rm(r, o));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Di;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof Mu;
  }
}
const Ms = [], vo = {};
class rt {
  /**
  @internal
  */
  constructor(e, t) {
    this.local = e.length ? e : Ms, this.children = t.length ? t : Ms;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, t) {
    return t.length ? Ou(t, e, 0, vo) : Vt;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, t, r) {
    let o = [];
    return this.findInner(e ?? 0, t ?? 1e9, o, 0, r), o;
  }
  findInner(e, t, r, o, a) {
    for (let l = 0; l < this.local.length; l++) {
      let d = this.local[l];
      d.from <= t && d.to >= e && (!a || a(d.spec)) && r.push(d.copy(d.from + o, d.to + o));
    }
    for (let l = 0; l < this.children.length; l += 3)
      if (this.children[l] < t && this.children[l + 1] > e) {
        let d = this.children[l] + 1;
        this.children[l + 2].findInner(e - d, t - d, r, o + d, a);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, t, r) {
    return this == Vt || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, r || vo);
  }
  /**
  @internal
  */
  mapInner(e, t, r, o, a) {
    let l;
    for (let d = 0; d < this.local.length; d++) {
      let p = this.local[d].map(e, r, o);
      p && p.type.valid(t, p) ? (l || (l = [])).push(p) : a.onRemove && a.onRemove(this.local[d].spec);
    }
    return this.children.length ? ZF(this.children, l || [], e, t, r, o, a) : l ? new rt(l.sort(xo), Ms) : Vt;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, t) {
    return t.length ? this == Vt ? rt.create(e, t) : this.addInner(e, t, 0) : this;
  }
  addInner(e, t, r) {
    let o, a = 0;
    e.forEach((d, p) => {
      let f = p + r, m;
      if (m = b1(t, d, f)) {
        for (o || (o = this.children.slice()); a < o.length && o[a] < p; )
          a += 3;
        o[a] == p ? o[a + 2] = o[a + 2].addInner(d, m, f + 1) : o.splice(a, 0, p, p + d.nodeSize, Ou(m, d, f + 1, vo)), a += 3;
      }
    });
    let l = w1(a ? v1(t) : t, -r);
    for (let d = 0; d < l.length; d++)
      l[d].type.valid(e, l[d]) || l.splice(d--, 1);
    return new rt(l.length ? this.local.concat(l).sort(xo) : this.local, o || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == Vt ? this : this.removeInner(e, 0);
  }
  removeInner(e, t) {
    let r = this.children, o = this.local;
    for (let a = 0; a < r.length; a += 3) {
      let l, d = r[a] + t, p = r[a + 1] + t;
      for (let m = 0, y; m < e.length; m++)
        (y = e[m]) && y.from > d && y.to < p && (e[m] = null, (l || (l = [])).push(y));
      if (!l)
        continue;
      r == this.children && (r = this.children.slice());
      let f = r[a + 2].removeInner(l, d + 1);
      f != Vt ? r[a + 2] = f : (r.splice(a, 3), a -= 3);
    }
    if (o.length) {
      for (let a = 0, l; a < e.length; a++)
        if (l = e[a])
          for (let d = 0; d < o.length; d++)
            o[d].eq(l, t) && (o == this.local && (o = this.local.slice()), o.splice(d--, 1));
    }
    return r == this.children && o == this.local ? this : o.length || r.length ? new rt(o, r) : Vt;
  }
  forChild(e, t) {
    if (this == Vt)
      return this;
    if (t.isLeaf)
      return rt.empty;
    let r, o;
    for (let d = 0; d < this.children.length; d += 3)
      if (this.children[d] >= e) {
        this.children[d] == e && (r = this.children[d + 2]);
        break;
      }
    let a = e + 1, l = a + t.content.size;
    for (let d = 0; d < this.local.length; d++) {
      let p = this.local[d];
      if (p.from < l && p.to > a && p.type instanceof Di) {
        let f = Math.max(a, p.from) - a, m = Math.min(l, p.to) - a;
        f < m && (o || (o = [])).push(p.copy(f, m));
      }
    }
    if (o) {
      let d = new rt(o.sort(xo), Ms);
      return r ? new Ai([d, r]) : d;
    }
    return r || Vt;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof rt) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let t = 0; t < this.local.length; t++)
      if (!this.local[t].eq(e.local[t]))
        return !1;
    for (let t = 0; t < this.children.length; t += 3)
      if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return im(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == Vt)
      return Ms;
    if (e.inlineContent || !this.local.some(Di.is))
      return this.local;
    let t = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof Di || t.push(this.local[r]);
    return t;
  }
  forEachSet(e) {
    e(this);
  }
}
rt.empty = new rt([], []);
rt.removeOverlap = im;
const Vt = rt.empty;
class Ai {
  constructor(e) {
    this.members = e;
  }
  map(e, t) {
    const r = this.members.map((o) => o.map(e, t, vo));
    return Ai.from(r);
  }
  forChild(e, t) {
    if (t.isLeaf)
      return rt.empty;
    let r = [];
    for (let o = 0; o < this.members.length; o++) {
      let a = this.members[o].forChild(e, t);
      a != Vt && (a instanceof Ai ? r = r.concat(a.members) : r.push(a));
    }
    return Ai.from(r);
  }
  eq(e) {
    if (!(e instanceof Ai) || e.members.length != this.members.length)
      return !1;
    for (let t = 0; t < this.members.length; t++)
      if (!this.members[t].eq(e.members[t]))
        return !1;
    return !0;
  }
  locals(e) {
    let t, r = !0;
    for (let o = 0; o < this.members.length; o++) {
      let a = this.members[o].localsInner(e);
      if (a.length)
        if (!t)
          t = a;
        else {
          r && (t = t.slice(), r = !1);
          for (let l = 0; l < a.length; l++)
            t.push(a[l]);
        }
    }
    return t ? im(r ? t : t.sort(xo)) : Ms;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return Vt;
      case 1:
        return e[0];
      default:
        return new Ai(e.every((t) => t instanceof rt) ? e : e.reduce((t, r) => t.concat(r instanceof rt ? r : r.members), []));
    }
  }
  forEachSet(e) {
    for (let t = 0; t < this.members.length; t++)
      this.members[t].forEachSet(e);
  }
}
function ZF(n, e, t, r, o, a, l) {
  let d = n.slice();
  for (let f = 0, m = a; f < t.maps.length; f++) {
    let y = 0;
    t.maps[f].forEach((v, k, A, S) => {
      let B = S - A - (k - v);
      for (let O = 0; O < d.length; O += 3) {
        let L = d[O + 1];
        if (L < 0 || v > L + m - y)
          continue;
        let G = d[O] + m - y;
        k >= G ? d[O + 1] = v <= G ? -2 : -1 : v >= m && B && (d[O] += B, d[O + 1] += B);
      }
      y += B;
    }), m = t.maps[f].map(m, -1);
  }
  let p = !1;
  for (let f = 0; f < d.length; f += 3)
    if (d[f + 1] < 0) {
      if (d[f + 1] == -2) {
        p = !0, d[f + 1] = -1;
        continue;
      }
      let m = t.map(n[f] + a), y = m - o;
      if (y < 0 || y >= r.content.size) {
        p = !0;
        continue;
      }
      let v = t.map(n[f + 1] + a, -1), k = v - o, { index: A, offset: S } = r.content.findIndex(y), B = r.maybeChild(A);
      if (B && S == y && S + B.nodeSize == k) {
        let O = d[f + 2].mapInner(t, B, m + 1, n[f] + a + 1, l);
        O != Vt ? (d[f] = y, d[f + 1] = k, d[f + 2] = O) : (d[f + 1] = -2, p = !0);
      } else
        p = !0;
    }
  if (p) {
    let f = eP(d, n, e, t, o, a, l), m = Ou(f, r, 0, l);
    e = m.local;
    for (let y = 0; y < d.length; y += 3)
      d[y + 1] < 0 && (d.splice(y, 3), y -= 3);
    for (let y = 0, v = 0; y < m.children.length; y += 3) {
      let k = m.children[y];
      for (; v < d.length && d[v] < k; )
        v += 3;
      d.splice(v, 0, m.children[y], m.children[y + 1], m.children[y + 2]);
    }
  }
  return new rt(e.sort(xo), d);
}
function w1(n, e) {
  if (!e || !n.length)
    return n;
  let t = [];
  for (let r = 0; r < n.length; r++) {
    let o = n[r];
    t.push(new It(o.from + e, o.to + e, o.type));
  }
  return t;
}
function eP(n, e, t, r, o, a, l) {
  function d(p, f) {
    for (let m = 0; m < p.local.length; m++) {
      let y = p.local[m].map(r, o, f);
      y ? t.push(y) : l.onRemove && l.onRemove(p.local[m].spec);
    }
    for (let m = 0; m < p.children.length; m += 3)
      d(p.children[m + 2], p.children[m] + f + 1);
  }
  for (let p = 0; p < n.length; p += 3)
    n[p + 1] == -1 && d(n[p + 2], e[p] + a + 1);
  return t;
}
function b1(n, e, t) {
  if (e.isLeaf)
    return null;
  let r = t + e.nodeSize, o = null;
  for (let a = 0, l; a < n.length; a++)
    (l = n[a]) && l.from > t && l.to < r && ((o || (o = [])).push(l), n[a] = null);
  return o;
}
function v1(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    n[t] != null && e.push(n[t]);
  return e;
}
function Ou(n, e, t, r) {
  let o = [], a = !1;
  e.forEach((d, p) => {
    let f = b1(n, d, p + t);
    if (f) {
      a = !0;
      let m = Ou(f, d, t + p + 1, r);
      m != Vt && o.push(p, p + d.nodeSize, m);
    }
  });
  let l = w1(a ? v1(n) : n, -t).sort(xo);
  for (let d = 0; d < l.length; d++)
    l[d].type.valid(e, l[d]) || (r.onRemove && r.onRemove(l[d].spec), l.splice(d--, 1));
  return l.length || o.length ? new rt(l, o) : Vt;
}
function xo(n, e) {
  return n.from - e.from || n.to - e.to;
}
function im(n) {
  let e = n;
  for (let t = 0; t < e.length - 1; t++) {
    let r = e[t];
    if (r.from != r.to)
      for (let o = t + 1; o < e.length; o++) {
        let a = e[o];
        if (a.from == r.from) {
          a.to != r.to && (e == n && (e = n.slice()), e[o] = a.copy(a.from, r.to), pv(e, o + 1, a.copy(r.to, a.to)));
          continue;
        } else {
          a.from < r.to && (e == n && (e = n.slice()), e[t] = r.copy(r.from, a.from), pv(e, o, r.copy(a.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function pv(n, e, t) {
  for (; e < n.length && xo(t, n[e]) > 0; )
    e++;
  n.splice(e, 0, t);
}
function yh(n) {
  let e = [];
  return n.someProp("decorations", (t) => {
    let r = t(n.state);
    r && r != Vt && e.push(r);
  }), n.cursorWrapper && e.push(rt.create(n.state.doc, [n.cursorWrapper.deco])), Ai.from(e);
}
const tP = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, nP = yn && Mi <= 11;
class rP {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class iP {
  constructor(e, t) {
    this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new rP(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let o = 0; o < r.length; o++)
        this.queue.push(r[o]);
      yn && Mi <= 11 && r.some((o) => o.type == "childList" && o.removedNodes.length || o.type == "characterData" && o.oldValue.length > o.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), nP && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, tP)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let t = 0; t < e.length; t++)
          this.queue.push(e[t]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (iv(this.view)) {
      if (this.suppressingSelectionUpdates)
        return Xr(this.view);
      if (yn && Mi <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && Bo(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let t = /* @__PURE__ */ new Set(), r;
    for (let a = e.focusNode; a; a = Xs(a))
      t.add(a);
    for (let a = e.anchorNode; a; a = Xs(a))
      if (t.has(a)) {
        r = a;
        break;
      }
    let o = r && this.view.docView.nearestDesc(r);
    if (o && o.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let r = e.domSelectionRange(), o = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && iv(e) && !this.ignoreSelectionChange(r), a = -1, l = -1, d = !1, p = [];
    if (e.editable)
      for (let m = 0; m < t.length; m++) {
        let y = this.registerMutation(t[m], p);
        y && (a = a < 0 ? y.from : Math.min(y.from, a), l = l < 0 ? y.to : Math.max(y.to, l), y.typeOver && (d = !0));
      }
    if (Rn && p.length) {
      let m = p.filter((y) => y.nodeName == "BR");
      if (m.length == 2) {
        let [y, v] = m;
        y.parentNode && y.parentNode.parentNode == v.parentNode ? v.remove() : y.remove();
      } else {
        let { focusNode: y } = this.currentSelection;
        for (let v of m) {
          let k = v.parentNode;
          k && k.nodeName == "LI" && (!y || aP(e, y) != k) && v.remove();
        }
      }
    }
    let f = null;
    a < 0 && o && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && od(r) && (f = Yf(e)) && f.eq(ve.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Xr(e), this.currentSelection.set(r), e.scrollToSelection()) : (a > -1 || o) && (a > -1 && (e.docView.markDirty(a, l), oP(e)), this.handleDOMChange(a, l, d, p), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || Xr(e), this.currentSelection.set(r));
  }
  registerMutation(e, t) {
    if (t.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let m = 0; m < e.addedNodes.length; m++) {
        let y = e.addedNodes[m];
        t.push(y), y.nodeType == 3 && (this.lastChangedTextNode = y);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let o = e.previousSibling, a = e.nextSibling;
      if (yn && Mi <= 11 && e.addedNodes.length)
        for (let m = 0; m < e.addedNodes.length; m++) {
          let { previousSibling: y, nextSibling: v } = e.addedNodes[m];
          (!y || Array.prototype.indexOf.call(e.addedNodes, y) < 0) && (o = y), (!v || Array.prototype.indexOf.call(e.addedNodes, v) < 0) && (a = v);
        }
      let l = o && o.parentNode == e.target ? Lt(o) + 1 : 0, d = r.localPosFromDOM(e.target, l, -1), p = a && a.parentNode == e.target ? Lt(a) : e.target.childNodes.length, f = r.localPosFromDOM(e.target, p, 1);
      return { from: d, to: f };
    } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}
let hv = /* @__PURE__ */ new WeakMap(), fv = !1;
function oP(n) {
  if (!hv.has(n) && (hv.set(n, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(n.dom).whiteSpace) !== -1)) {
    if (n.requiresGeckoHackNode = Rn, fv)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), fv = !0;
  }
}
function mv(n, e) {
  let t = e.startContainer, r = e.startOffset, o = e.endContainer, a = e.endOffset, l = n.domAtPos(n.state.selection.anchor);
  return Bo(l.node, l.offset, o, a) && ([t, r, o, a] = [o, a, t, r]), { anchorNode: t, anchorOffset: r, focusNode: o, focusOffset: a };
}
function sP(n, e) {
  if (e.getComposedRanges) {
    let o = e.getComposedRanges(n.root)[0];
    if (o)
      return mv(n, o);
  }
  let t;
  function r(o) {
    o.preventDefault(), o.stopImmediatePropagation(), t = o.getTargetRanges()[0];
  }
  return n.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), n.dom.removeEventListener("beforeinput", r, !0), t ? mv(n, t) : null;
}
function aP(n, e) {
  for (let t = e.parentNode; t && t != n.dom; t = t.parentNode) {
    let r = n.docView.nearestDesc(t, !0);
    if (r && r.node.isBlock)
      return t;
  }
  return null;
}
function lP(n, e, t) {
  let { node: r, fromOffset: o, toOffset: a, from: l, to: d } = n.docView.parseRange(e, t), p = n.domSelectionRange(), f, m = p.anchorNode;
  if (m && n.dom.contains(m.nodeType == 1 ? m : m.parentNode) && (f = [{ node: m, offset: p.anchorOffset }], od(p) || f.push({ node: p.focusNode, offset: p.focusOffset })), Xt && n.input.lastKeyCode === 8)
    for (let B = a; B > o; B--) {
      let O = r.childNodes[B - 1], L = O.pmViewDesc;
      if (O.nodeName == "BR" && !L) {
        a = B;
        break;
      }
      if (!L || L.size)
        break;
    }
  let y = n.state.doc, v = n.someProp("domParser") || Qa.fromSchema(n.state.schema), k = y.resolve(l), A = null, S = v.parse(r, {
    topNode: k.parent,
    topMatch: k.parent.contentMatchAt(k.index()),
    topOpen: !0,
    from: o,
    to: a,
    preserveWhitespace: k.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: f,
    ruleFromNode: cP,
    context: k
  });
  if (f && f[0].pos != null) {
    let B = f[0].pos, O = f[1] && f[1].pos;
    O == null && (O = B), A = { anchor: B + l, head: O + l };
  }
  return { doc: S, sel: A, from: l, to: d };
}
function cP(n) {
  let e = n.pmViewDesc;
  if (e)
    return e.parseRule();
  if (n.nodeName == "BR" && n.parentNode) {
    if (an && /^(ul|ol)$/i.test(n.parentNode.nodeName)) {
      let t = document.createElement("div");
      return t.appendChild(document.createElement("li")), { skip: t };
    } else if (n.parentNode.lastChild == n || an && /^(tr|table)$/i.test(n.parentNode.nodeName))
      return { ignore: !0 };
  } else if (n.nodeName == "IMG" && n.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const uP = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function dP(n, e, t, r, o) {
  let a = n.input.compositionPendingChanges || (n.composing ? n.input.compositionID : 0);
  if (n.input.compositionPendingChanges = 0, e < 0) {
    let U = n.input.lastSelectionTime > Date.now() - 50 ? n.input.lastSelectionOrigin : null, K = Yf(n, U);
    if (K && !n.state.selection.eq(K)) {
      if (Xt && zr && n.input.lastKeyCode === 13 && Date.now() - 100 < n.input.lastKeyCodeTime && n.someProp("handleKeyDown", (H) => H(n, fo(13, "Enter"))))
        return;
      let Q = n.state.tr.setSelection(K);
      U == "pointer" ? Q.setMeta("pointer", !0) : U == "key" && Q.scrollIntoView(), a && Q.setMeta("composition", a), n.dispatch(Q);
    }
    return;
  }
  let l = n.state.doc.resolve(e), d = l.sharedDepth(t);
  e = l.before(d + 1), t = n.state.doc.resolve(t).after(d + 1);
  let p = n.state.selection, f = lP(n, e, t), m = n.state.doc, y = m.slice(f.from, f.to), v, k;
  n.input.lastKeyCode === 8 && Date.now() - 100 < n.input.lastKeyCodeTime ? (v = n.state.selection.to, k = "end") : (v = n.state.selection.from, k = "start"), n.input.lastKeyCode = null;
  let A = fP(y.content, f.doc.content, f.from, v, k);
  if (A && n.input.domChangeCount++, (Js && n.input.lastIOSEnter > Date.now() - 225 || zr) && o.some((U) => U.nodeType == 1 && !uP.test(U.nodeName)) && (!A || A.endA >= A.endB) && n.someProp("handleKeyDown", (U) => U(n, fo(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (!A)
    if (r && p instanceof ge && !p.empty && p.$head.sameParent(p.$anchor) && !n.composing && !(f.sel && f.sel.anchor != f.sel.head))
      A = { start: p.from, endA: p.to, endB: p.to };
    else {
      if (f.sel) {
        let U = gv(n, n.state.doc, f.sel);
        if (U && !U.eq(n.state.selection)) {
          let K = n.state.tr.setSelection(U);
          a && K.setMeta("composition", a), n.dispatch(K);
        }
      }
      return;
    }
  n.state.selection.from < n.state.selection.to && A.start == A.endB && n.state.selection instanceof ge && (A.start > n.state.selection.from && A.start <= n.state.selection.from + 2 && n.state.selection.from >= f.from ? A.start = n.state.selection.from : A.endA < n.state.selection.to && A.endA >= n.state.selection.to - 2 && n.state.selection.to <= f.to && (A.endB += n.state.selection.to - A.endA, A.endA = n.state.selection.to)), yn && Mi <= 11 && A.endB == A.start + 1 && A.endA == A.start && A.start > f.from && f.doc.textBetween(A.start - f.from - 1, A.start - f.from + 1) == "  " && (A.start--, A.endA--, A.endB--);
  let S = f.doc.resolveNoCache(A.start - f.from), B = f.doc.resolveNoCache(A.endB - f.from), O = m.resolve(A.start), L = S.sameParent(B) && S.parent.inlineContent && O.end() >= A.endA, G;
  if ((Js && n.input.lastIOSEnter > Date.now() - 225 && (!L || o.some((U) => U.nodeName == "DIV" || U.nodeName == "P")) || !L && S.pos < f.doc.content.size && (!S.sameParent(B) || !S.parent.inlineContent) && !/\S/.test(f.doc.textBetween(S.pos, B.pos, "", "")) && (G = ve.findFrom(f.doc.resolve(S.pos + 1), 1, !0)) && G.head > S.pos) && n.someProp("handleKeyDown", (U) => U(n, fo(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (n.state.selection.anchor > A.start && hP(m, A.start, A.endA, S, B) && n.someProp("handleKeyDown", (U) => U(n, fo(8, "Backspace")))) {
    zr && Xt && n.domObserver.suppressSelectionUpdates();
    return;
  }
  Xt && A.endB == A.start && (n.input.lastChromeDelete = Date.now()), zr && !L && S.start() != B.start() && B.parentOffset == 0 && S.depth == B.depth && f.sel && f.sel.anchor == f.sel.head && f.sel.head == A.endA && (A.endB -= 2, B = f.doc.resolveNoCache(A.endB - f.from), setTimeout(() => {
    n.someProp("handleKeyDown", function(U) {
      return U(n, fo(13, "Enter"));
    });
  }, 20));
  let Y = A.start, z = A.endA, M = (U) => {
    let K = U || n.state.tr.replace(Y, z, f.doc.slice(A.start - f.from, A.endB - f.from));
    if (f.sel) {
      let Q = gv(n, K.doc, f.sel);
      Q && !(Xt && n.composing && Q.empty && (A.start != A.endB || n.input.lastChromeDelete < Date.now() - 100) && (Q.head == Y || Q.head == K.mapping.map(z) - 1) || yn && Q.empty && Q.head == Y) && K.setSelection(Q);
    }
    return a && K.setMeta("composition", a), K.scrollIntoView();
  }, ee;
  if (L) {
    if (S.pos == B.pos) {
      yn && Mi <= 11 && S.parentOffset == 0 && (n.domObserver.suppressSelectionUpdates(), setTimeout(() => Xr(n), 20));
      let U = M(n.state.tr.delete(Y, z)), K = m.resolve(A.start).marksAcross(m.resolve(A.endA));
      K && U.ensureMarks(K), n.dispatch(U);
    } else if (
      // Adding or removing a mark
      A.endA == A.endB && (ee = pP(S.parent.content.cut(S.parentOffset, B.parentOffset), O.parent.content.cut(O.parentOffset, A.endA - O.start())))
    ) {
      let U = M(n.state.tr);
      ee.type == "add" ? U.addMark(Y, z, ee.mark) : U.removeMark(Y, z, ee.mark), n.dispatch(U);
    } else if (S.parent.child(S.index()).isText && S.index() == B.index() - (B.textOffset ? 0 : 1)) {
      let U = S.parent.textBetween(S.parentOffset, B.parentOffset), K = () => M(n.state.tr.insertText(U, Y, z));
      n.someProp("handleTextInput", (Q) => Q(n, Y, z, U, K)) || n.dispatch(K());
    }
  } else
    n.dispatch(M());
}
function gv(n, e, t) {
  return Math.max(t.anchor, t.head) > e.content.size ? null : Qf(n, e.resolve(t.anchor), e.resolve(t.head));
}
function pP(n, e) {
  let t = n.firstChild.marks, r = e.firstChild.marks, o = t, a = r, l, d, p;
  for (let m = 0; m < r.length; m++)
    o = r[m].removeFromSet(o);
  for (let m = 0; m < t.length; m++)
    a = t[m].removeFromSet(a);
  if (o.length == 1 && a.length == 0)
    d = o[0], l = "add", p = (m) => m.mark(d.addToSet(m.marks));
  else if (o.length == 0 && a.length == 1)
    d = a[0], l = "remove", p = (m) => m.mark(d.removeFromSet(m.marks));
  else
    return null;
  let f = [];
  for (let m = 0; m < e.childCount; m++)
    f.push(p(e.child(m)));
  if (X.from(f).eq(n))
    return { mark: d, type: l };
}
function hP(n, e, t, r, o) {
  if (
    // The content must have shrunk
    t - e <= o.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    wh(r, !0, !1) < o.pos
  )
    return !1;
  let a = n.resolve(e);
  if (!r.parent.isTextblock) {
    let d = a.nodeAfter;
    return d != null && t == e + d.nodeSize;
  }
  if (a.parentOffset < a.parent.content.size || !a.parent.isTextblock)
    return !1;
  let l = n.resolve(wh(a, !0, !0));
  return !l.parent.isTextblock || l.pos > t || wh(l, !0, !1) < t ? !1 : r.parent.content.cut(r.parentOffset).eq(l.parent.content);
}
function wh(n, e, t) {
  let r = n.depth, o = e ? n.end() : n.pos;
  for (; r > 0 && (e || n.indexAfter(r) == n.node(r).childCount); )
    r--, o++, e = !1;
  if (t) {
    let a = n.node(r).maybeChild(n.indexAfter(r));
    for (; a && !a.isLeaf; )
      a = a.firstChild, o++;
  }
  return o;
}
function fP(n, e, t, r, o) {
  let a = n.findDiffStart(e, t);
  if (a == null)
    return null;
  let { a: l, b: d } = n.findDiffEnd(e, t + n.size, t + e.size);
  if (o == "end") {
    let p = Math.max(0, a - Math.min(l, d));
    r -= l + p - a;
  }
  if (l < a && n.size < e.size) {
    let p = r <= a && r >= l ? a - r : 0;
    a -= p, a && a < e.size && yv(e.textBetween(a - 1, a + 1)) && (a += p ? 1 : -1), d = a + (d - l), l = a;
  } else if (d < a) {
    let p = r <= a && r >= d ? a - r : 0;
    a -= p, a && a < n.size && yv(n.textBetween(a - 1, a + 1)) && (a += p ? 1 : -1), l = a + (l - d), d = a;
  }
  return { start: a, endA: l, endB: d };
}
function yv(n) {
  if (n.length != 2)
    return !1;
  let e = n.charCodeAt(0), t = n.charCodeAt(1);
  return e >= 56320 && e <= 57343 && t >= 55296 && t <= 56319;
}
class x1 {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, t) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new DF(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(kv), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = vv(this), bv(this), this.nodeViews = xv(this), this.docView = Qb(this.state.doc, wv(this), yh(this), this.dom, this), this.domObserver = new iP(this, (r, o, a, l) => dP(this, r, o, a, l)), this.domObserver.start(), RF(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let t in e)
        this._props[t] = e[t];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && lf(this);
    let t = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(kv), this.directPlugins = e.plugins), this.updateStateInner(e.state, t);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let t = {};
    for (let r in this._props)
      t[r] = this._props[r];
    t.state = this.state;
    for (let r in e)
      t[r] = e[r];
    this.update(t);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, t) {
    var r;
    let o = this.state, a = !1, l = !1;
    e.storedMarks && this.composing && (f1(this), l = !0), this.state = e;
    let d = o.plugins != e.plugins || this._props.plugins != t.plugins;
    if (d || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
      let k = xv(this);
      gP(k, this.nodeViews) && (this.nodeViews = k, a = !0);
    }
    (d || t.handleDOMEvents != this._props.handleDOMEvents) && lf(this), this.editable = vv(this), bv(this);
    let p = yh(this), f = wv(this), m = o.plugins != e.plugins && !o.doc.eq(e.doc) ? "reset" : e.scrollToSelection > o.scrollToSelection ? "to selection" : "preserve", y = a || !this.docView.matchesNode(e.doc, f, p);
    (y || !e.selection.eq(o.selection)) && (l = !0);
    let v = m == "preserve" && l && this.dom.style.overflowAnchor == null && J3(this);
    if (l) {
      this.domObserver.stop();
      let k = y && (yn || Xt) && !this.composing && !o.selection.empty && !e.selection.empty && mP(o.selection, e.selection);
      if (y) {
        let A = Xt ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = XF(this)), (a || !this.docView.update(e.doc, f, p, this)) && (this.docView.updateOuterDeco(f), this.docView.destroy(), this.docView = Qb(e.doc, f, p, this.dom, this)), A && !this.trackWrites && (k = !0);
      }
      k || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && wF(this)) ? Xr(this, k) : (n1(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(o), !((r = this.dragging) === null || r === void 0) && r.node && !o.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, o), m == "reset" ? this.dom.scrollTop = 0 : m == "to selection" ? this.scrollToSelection() : v && K3(v);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (t) => t(this))) if (this.state.selection instanceof fe) {
        let t = this.docView.domAfterPos(this.state.selection.from);
        t.nodeType == 1 && Vb(this, t.getBoundingClientRect(), e);
      } else
        Vb(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let t = 0; t < this.directPlugins.length; t++) {
        let r = this.directPlugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let t = 0; t < this.state.plugins.length; t++) {
        let r = this.state.plugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let t = 0; t < this.pluginViews.length; t++) {
        let r = this.pluginViews[t];
        r.update && r.update(this, e);
      }
  }
  updateDraggedNode(e, t) {
    let r = e.node, o = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      o = r.from;
    else {
      let a = r.from + (this.state.doc.content.size - t.doc.content.size);
      (a > 0 && this.state.doc.nodeAt(a)) == r.node && (o = a);
    }
    this.dragging = new g1(e.slice, e.move, o < 0 ? void 0 : fe.create(this.state.doc, o));
  }
  someProp(e, t) {
    let r = this._props && this._props[e], o;
    if (r != null && (o = t ? t(r) : r))
      return o;
    for (let l = 0; l < this.directPlugins.length; l++) {
      let d = this.directPlugins[l].props[e];
      if (d != null && (o = t ? t(d) : d))
        return o;
    }
    let a = this.state.plugins;
    if (a)
      for (let l = 0; l < a.length; l++) {
        let d = a[l].props[e];
        if (d != null && (o = t ? t(d) : d))
          return o;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (yn) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && W3(this.dom), Xr(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let t = this.dom.parentNode; t; t = t.parentNode)
        if (t.nodeType == 9 || t.nodeType == 11 && t.host)
          return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return tF(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, t = 1) {
    return Jk(this, e, t);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, t = 0) {
    return this.docView.domFromPos(e, t);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let t = this.docView.descAt(e);
    return t ? t.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, t, r = -1) {
    let o = this.docView.posFromDOM(e, t, r);
    if (o == null)
      throw new RangeError("DOM position not inside the editor");
    return o;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, t) {
    return sF(this, t || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, t) {
    return ml(this, "", e, !1, t || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, t) {
    return ml(this, e, null, !0, t || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(e) {
    return Zf(this, e);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (FF(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], yh(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, $3());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return $F(this, e);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? an && this.root.nodeType === 11 && G3(this.dom.ownerDocument) == this.dom && sP(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
x1.prototype.dispatch = function(n) {
  let e = this._props.dispatchTransaction;
  e ? e.call(this, n) : this.updateState(this.state.apply(n));
};
function wv(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(n.editable), n.someProp("attributes", (t) => {
    if (typeof t == "function" && (t = t(n.state)), t)
      for (let r in t)
        r == "class" ? e.class += " " + t[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + t[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(t[r]));
  }), e.translate || (e.translate = "no"), [It.node(0, n.state.doc.content.size, e)];
}
function bv(n) {
  if (n.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), n.cursorWrapper = { dom: e, deco: It.widget(n.state.selection.from, e, { raw: !0, marks: n.markCursor }) };
  } else
    n.cursorWrapper = null;
}
function vv(n) {
  return !n.someProp("editable", (e) => e(n.state) === !1);
}
function mP(n, e) {
  let t = Math.min(n.$anchor.sharedDepth(n.head), e.$anchor.sharedDepth(e.head));
  return n.$anchor.start(t) != e.$anchor.start(t);
}
function xv(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    for (let o in r)
      Object.prototype.hasOwnProperty.call(e, o) || (e[o] = r[o]);
  }
  return n.someProp("nodeViews", t), n.someProp("markViews", t), e;
}
function gP(n, e) {
  let t = 0, r = 0;
  for (let o in n) {
    if (n[o] != e[o])
      return !0;
    t++;
  }
  for (let o in e)
    r++;
  return t != r;
}
function kv(n) {
  if (n.spec.state || n.spec.filterTransaction || n.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Ri = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Du = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, yP = typeof navigator < "u" && /Mac/.test(navigator.platform), wP = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Ht = 0; Ht < 10; Ht++) Ri[48 + Ht] = Ri[96 + Ht] = String(Ht);
for (var Ht = 1; Ht <= 24; Ht++) Ri[Ht + 111] = "F" + Ht;
for (var Ht = 65; Ht <= 90; Ht++)
  Ri[Ht] = String.fromCharCode(Ht + 32), Du[Ht] = String.fromCharCode(Ht);
for (var bh in Ri) Du.hasOwnProperty(bh) || (Du[bh] = Ri[bh]);
function bP(n) {
  var e = yP && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || wP && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? Du : Ri)[n.keyCode] || n.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
const vP = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), xP = typeof navigator < "u" && /Win/.test(navigator.platform);
function kP(n) {
  let e = n.split(/-(?!$)/), t = e[e.length - 1];
  t == "Space" && (t = " ");
  let r, o, a, l;
  for (let d = 0; d < e.length - 1; d++) {
    let p = e[d];
    if (/^(cmd|meta|m)$/i.test(p))
      l = !0;
    else if (/^a(lt)?$/i.test(p))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(p))
      o = !0;
    else if (/^s(hift)?$/i.test(p))
      a = !0;
    else if (/^mod$/i.test(p))
      vP ? l = !0 : o = !0;
    else
      throw new Error("Unrecognized modifier name: " + p);
  }
  return r && (t = "Alt-" + t), o && (t = "Ctrl-" + t), l && (t = "Meta-" + t), a && (t = "Shift-" + t), t;
}
function AP(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n)
    e[kP(t)] = n[t];
  return e;
}
function vh(n, e, t = !0) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t && e.shiftKey && (n = "Shift-" + n), n;
}
function CP(n) {
  return new ot({ props: { handleKeyDown: om(n) } });
}
function om(n) {
  let e = AP(n);
  return function(t, r) {
    let o = bP(r), a, l = e[vh(o, r)];
    if (l && l(t.state, t.dispatch, t))
      return !0;
    if (o.length == 1 && o != " ") {
      if (r.shiftKey) {
        let d = e[vh(o, r, !1)];
        if (d && d(t.state, t.dispatch, t))
          return !0;
      }
      if ((r.altKey || r.metaKey || r.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(xP && r.ctrlKey && r.altKey) && (a = Ri[r.keyCode]) && a != o) {
        let d = e[vh(a, r)];
        if (d && d(t.state, t.dispatch, t))
          return !0;
      }
    }
    return !1;
  };
}
const sm = (n, e) => n.selection.empty ? !1 : (e && e(n.tr.deleteSelection().scrollIntoView()), !0);
function k1(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("backward", n) : t.parentOffset > 0) ? null : t;
}
const A1 = (n, e, t) => {
  let r = k1(n, t);
  if (!r)
    return !1;
  let o = am(r);
  if (!o) {
    let l = r.blockRange(), d = l && aa(l);
    return d == null ? !1 : (e && e(n.tr.lift(l, d).scrollIntoView()), !0);
  }
  let a = o.nodeBefore;
  if (O1(n, o, e, -1))
    return !0;
  if (r.parent.content.size == 0 && (Ks(a, "end") || fe.isSelectable(a)))
    for (let l = r.depth; ; l--) {
      let d = rd(n.doc, r.before(l), r.after(l), ne.empty);
      if (d && d.slice.size < d.to - d.from) {
        if (e) {
          let p = n.tr.step(d);
          p.setSelection(Ks(a, "end") ? ve.findFrom(p.doc.resolve(p.mapping.map(o.pos, -1)), -1) : fe.create(p.doc, o.pos - a.nodeSize)), e(p.scrollIntoView());
        }
        return !0;
      }
      if (l == 1 || r.node(l - 1).childCount > 1)
        break;
    }
  return a.isAtom && o.depth == r.depth - 1 ? (e && e(n.tr.delete(o.pos - a.nodeSize, o.pos).scrollIntoView()), !0) : !1;
}, SP = (n, e, t) => {
  let r = k1(n, t);
  if (!r)
    return !1;
  let o = am(r);
  return o ? C1(n, o, e) : !1;
}, EP = (n, e, t) => {
  let r = E1(n, t);
  if (!r)
    return !1;
  let o = lm(r);
  return o ? C1(n, o, e) : !1;
};
function C1(n, e, t) {
  let r = e.nodeBefore, o = r, a = e.pos - 1;
  for (; !o.isTextblock; a--) {
    if (o.type.spec.isolating)
      return !1;
    let m = o.lastChild;
    if (!m)
      return !1;
    o = m;
  }
  let l = e.nodeAfter, d = l, p = e.pos + 1;
  for (; !d.isTextblock; p++) {
    if (d.type.spec.isolating)
      return !1;
    let m = d.firstChild;
    if (!m)
      return !1;
    d = m;
  }
  let f = rd(n.doc, a, p, ne.empty);
  if (!f || f.from != a || f instanceof At && f.slice.size >= p - a)
    return !1;
  if (t) {
    let m = n.tr.step(f);
    m.setSelection(ge.create(m.doc, a)), t(m.scrollIntoView());
  }
  return !0;
}
function Ks(n, e, t = !1) {
  for (let r = n; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (t && r.childCount != 1)
      return !1;
  }
  return !1;
}
const S1 = (n, e, t) => {
  let { $head: r, empty: o } = n.selection, a = r;
  if (!o)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("backward", n) : r.parentOffset > 0)
      return !1;
    a = am(r);
  }
  let l = a && a.nodeBefore;
  return !l || !fe.isSelectable(l) ? !1 : (e && e(n.tr.setSelection(fe.create(n.doc, a.pos - l.nodeSize)).scrollIntoView()), !0);
};
function am(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      if (n.index(e) > 0)
        return n.doc.resolve(n.before(e + 1));
      if (n.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function E1(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("forward", n) : t.parentOffset < t.parent.content.size) ? null : t;
}
const T1 = (n, e, t) => {
  let r = E1(n, t);
  if (!r)
    return !1;
  let o = lm(r);
  if (!o)
    return !1;
  let a = o.nodeAfter;
  if (O1(n, o, e, 1))
    return !0;
  if (r.parent.content.size == 0 && (Ks(a, "start") || fe.isSelectable(a))) {
    let l = rd(n.doc, r.before(), r.after(), ne.empty);
    if (l && l.slice.size < l.to - l.from) {
      if (e) {
        let d = n.tr.step(l);
        d.setSelection(Ks(a, "start") ? ve.findFrom(d.doc.resolve(d.mapping.map(o.pos)), 1) : fe.create(d.doc, d.mapping.map(o.pos))), e(d.scrollIntoView());
      }
      return !0;
    }
  }
  return a.isAtom && o.depth == r.depth - 1 ? (e && e(n.tr.delete(o.pos, o.pos + a.nodeSize).scrollIntoView()), !0) : !1;
}, N1 = (n, e, t) => {
  let { $head: r, empty: o } = n.selection, a = r;
  if (!o)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("forward", n) : r.parentOffset < r.parent.content.size)
      return !1;
    a = lm(r);
  }
  let l = a && a.nodeAfter;
  return !l || !fe.isSelectable(l) ? !1 : (e && e(n.tr.setSelection(fe.create(n.doc, a.pos)).scrollIntoView()), !0);
};
function lm(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      let t = n.node(e);
      if (n.index(e) + 1 < t.childCount)
        return n.doc.resolve(n.after(e + 1));
      if (t.type.spec.isolating)
        break;
    }
  return null;
}
const TP = (n, e) => {
  let t = n.selection, r = t instanceof fe, o;
  if (r) {
    if (t.node.isTextblock || !Hi(n.doc, t.from))
      return !1;
    o = t.from;
  } else if (o = nd(n.doc, t.from, -1), o == null)
    return !1;
  if (e) {
    let a = n.tr.join(o);
    r && a.setSelection(fe.create(a.doc, o - n.doc.resolve(o).nodeBefore.nodeSize)), e(a.scrollIntoView());
  }
  return !0;
}, NP = (n, e) => {
  let t = n.selection, r;
  if (t instanceof fe) {
    if (t.node.isTextblock || !Hi(n.doc, t.to))
      return !1;
    r = t.to;
  } else if (r = nd(n.doc, t.to, 1), r == null)
    return !1;
  return e && e(n.tr.join(r).scrollIntoView()), !0;
}, BP = (n, e) => {
  let { $from: t, $to: r } = n.selection, o = t.blockRange(r), a = o && aa(o);
  return a == null ? !1 : (e && e(n.tr.lift(o, a).scrollIntoView()), !0);
}, B1 = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  return !t.parent.type.spec.code || !t.sameParent(r) ? !1 : (e && e(n.tr.insertText(`
`).scrollIntoView()), !0);
};
function cm(n) {
  for (let e = 0; e < n.edgeCount; e++) {
    let { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
const IP = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  if (!t.parent.type.spec.code || !t.sameParent(r))
    return !1;
  let o = t.node(-1), a = t.indexAfter(-1), l = cm(o.contentMatchAt(a));
  if (!l || !o.canReplaceWith(a, a, l))
    return !1;
  if (e) {
    let d = t.after(), p = n.tr.replaceWith(d, d, l.createAndFill());
    p.setSelection(ve.near(p.doc.resolve(d), 1)), e(p.scrollIntoView());
  }
  return !0;
}, I1 = (n, e) => {
  let t = n.selection, { $from: r, $to: o } = t;
  if (t instanceof gn || r.parent.inlineContent || o.parent.inlineContent)
    return !1;
  let a = cm(o.parent.contentMatchAt(o.indexAfter()));
  if (!a || !a.isTextblock)
    return !1;
  if (e) {
    let l = (!r.parentOffset && o.index() < o.parent.childCount ? r : o).pos, d = n.tr.insert(l, a.createAndFill());
    d.setSelection(ge.create(d.doc, l + 1)), e(d.scrollIntoView());
  }
  return !0;
}, M1 = (n, e) => {
  let { $cursor: t } = n.selection;
  if (!t || t.parent.content.size)
    return !1;
  if (t.depth > 1 && t.after() != t.end(-1)) {
    let a = t.before();
    if (Vr(n.doc, a))
      return e && e(n.tr.split(a).scrollIntoView()), !0;
  }
  let r = t.blockRange(), o = r && aa(r);
  return o == null ? !1 : (e && e(n.tr.lift(r, o).scrollIntoView()), !0);
};
function MP(n) {
  return (e, t) => {
    let { $from: r, $to: o } = e.selection;
    if (e.selection instanceof fe && e.selection.node.isBlock)
      return !r.parentOffset || !Vr(e.doc, r.pos) ? !1 : (t && t(e.tr.split(r.pos).scrollIntoView()), !0);
    if (!r.depth)
      return !1;
    let a = [], l, d, p = !1, f = !1;
    for (let k = r.depth; ; k--)
      if (r.node(k).isBlock) {
        p = r.end(k) == r.pos + (r.depth - k), f = r.start(k) == r.pos - (r.depth - k), d = cm(r.node(k - 1).contentMatchAt(r.indexAfter(k - 1))), a.unshift(p && d ? { type: d } : null), l = k;
        break;
      } else {
        if (k == 1)
          return !1;
        a.unshift(null);
      }
    let m = e.tr;
    (e.selection instanceof ge || e.selection instanceof gn) && m.deleteSelection();
    let y = m.mapping.map(r.pos), v = Vr(m.doc, y, a.length, a);
    if (v || (a[0] = d ? { type: d } : null, v = Vr(m.doc, y, a.length, a)), !v)
      return !1;
    if (m.split(y, a.length, a), !p && f && r.node(l).type != d) {
      let k = m.mapping.map(r.before(l)), A = m.doc.resolve(k);
      d && r.node(l - 1).canReplaceWith(A.index(), A.index() + 1, d) && m.setNodeMarkup(m.mapping.map(r.before(l)), d);
    }
    return t && t(m.scrollIntoView()), !0;
  };
}
const OP = MP(), DP = (n, e) => {
  let { $from: t, to: r } = n.selection, o, a = t.sharedDepth(r);
  return a == 0 ? !1 : (o = t.before(a), e && e(n.tr.setSelection(fe.create(n.doc, o))), !0);
};
function RP(n, e, t) {
  let r = e.nodeBefore, o = e.nodeAfter, a = e.index();
  return !r || !o || !r.type.compatibleContent(o.type) ? !1 : !r.content.size && e.parent.canReplace(a - 1, a) ? (t && t(n.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(a, a + 1) || !(o.isTextblock || Hi(n.doc, e.pos)) ? !1 : (t && t(n.tr.join(e.pos).scrollIntoView()), !0);
}
function O1(n, e, t, r) {
  let o = e.nodeBefore, a = e.nodeAfter, l, d, p = o.type.spec.isolating || a.type.spec.isolating;
  if (!p && RP(n, e, t))
    return !0;
  let f = !p && e.parent.canReplace(e.index(), e.index() + 1);
  if (f && (l = (d = o.contentMatchAt(o.childCount)).findWrapping(a.type)) && d.matchType(l[0] || a.type).validEnd) {
    if (t) {
      let k = e.pos + a.nodeSize, A = X.empty;
      for (let O = l.length - 1; O >= 0; O--)
        A = X.from(l[O].create(null, A));
      A = X.from(o.copy(A));
      let S = n.tr.step(new Mt(e.pos - 1, k, e.pos, k, new ne(A, 1, 0), l.length, !0)), B = S.doc.resolve(k + 2 * l.length);
      B.nodeAfter && B.nodeAfter.type == o.type && Hi(S.doc, B.pos) && S.join(B.pos), t(S.scrollIntoView());
    }
    return !0;
  }
  let m = a.type.spec.isolating || r > 0 && p ? null : ve.findFrom(e, 1), y = m && m.$from.blockRange(m.$to), v = y && aa(y);
  if (v != null && v >= e.depth)
    return t && t(n.tr.lift(y, v).scrollIntoView()), !0;
  if (f && Ks(a, "start", !0) && Ks(o, "end")) {
    let k = o, A = [];
    for (; A.push(k), !k.isTextblock; )
      k = k.lastChild;
    let S = a, B = 1;
    for (; !S.isTextblock; S = S.firstChild)
      B++;
    if (k.canReplace(k.childCount, k.childCount, S.content)) {
      if (t) {
        let O = X.empty;
        for (let G = A.length - 1; G >= 0; G--)
          O = X.from(A[G].copy(O));
        let L = n.tr.step(new Mt(e.pos - A.length, e.pos + a.nodeSize, e.pos + B, e.pos + a.nodeSize - B, new ne(O, A.length, 0), 0, !0));
        t(L.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function D1(n) {
  return function(e, t) {
    let r = e.selection, o = n < 0 ? r.$from : r.$to, a = o.depth;
    for (; o.node(a).isInline; ) {
      if (!a)
        return !1;
      a--;
    }
    return o.node(a).isTextblock ? (t && t(e.tr.setSelection(ge.create(e.doc, n < 0 ? o.start(a) : o.end(a)))), !0) : !1;
  };
}
const FP = D1(-1), PP = D1(1);
function $P(n, e = null) {
  return function(t, r) {
    let { $from: o, $to: a } = t.selection, l = o.blockRange(a), d = l && Xf(l, n, e);
    return d ? (r && r(t.tr.wrap(l, d).scrollIntoView()), !0) : !1;
  };
}
function Av(n, e = null) {
  return function(t, r) {
    let o = !1;
    for (let a = 0; a < t.selection.ranges.length && !o; a++) {
      let { $from: { pos: l }, $to: { pos: d } } = t.selection.ranges[a];
      t.doc.nodesBetween(l, d, (p, f) => {
        if (o)
          return !1;
        if (!(!p.isTextblock || p.hasMarkup(n, e)))
          if (p.type == n)
            o = !0;
          else {
            let m = t.doc.resolve(f), y = m.index();
            o = m.parent.canReplaceWith(y, y + 1, n);
          }
      });
    }
    if (!o)
      return !1;
    if (r) {
      let a = t.tr;
      for (let l = 0; l < t.selection.ranges.length; l++) {
        let { $from: { pos: d }, $to: { pos: p } } = t.selection.ranges[l];
        a.setBlockType(d, p, n, e);
      }
      r(a.scrollIntoView());
    }
    return !0;
  };
}
function um(...n) {
  return function(e, t, r) {
    for (let o = 0; o < n.length; o++)
      if (n[o](e, t, r))
        return !0;
    return !1;
  };
}
um(sm, A1, S1);
um(sm, T1, N1);
um(B1, I1, M1, OP);
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function jP(n, e = null) {
  return function(t, r) {
    let { $from: o, $to: a } = t.selection, l = o.blockRange(a);
    if (!l)
      return !1;
    let d = r ? t.tr : null;
    return UP(d, l, n, e) ? (r && r(d.scrollIntoView()), !0) : !1;
  };
}
function UP(n, e, t, r = null) {
  let o = !1, a = e, l = e.$from.doc;
  if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(t) && e.startIndex == 0) {
    if (e.$from.index(e.depth - 1) == 0)
      return !1;
    let p = l.resolve(e.start - 2);
    a = new Eu(p, p, e.depth), e.endIndex < e.parent.childCount && (e = new Eu(e.$from, l.resolve(e.$to.end(e.depth)), e.depth)), o = !0;
  }
  let d = Xf(a, t, r, e);
  return d ? (n && LP(n, e, d, o, t), !0) : !1;
}
function LP(n, e, t, r, o) {
  let a = X.empty;
  for (let m = t.length - 1; m >= 0; m--)
    a = X.from(t[m].type.create(t[m].attrs, a));
  n.step(new Mt(e.start - (r ? 2 : 0), e.end, e.start, e.end, new ne(a, 0, 0), t.length, !0));
  let l = 0;
  for (let m = 0; m < t.length; m++)
    t[m].type == o && (l = m + 1);
  let d = t.length - l, p = e.start + t.length - (r ? 2 : 0), f = e.parent;
  for (let m = e.startIndex, y = e.endIndex, v = !0; m < y; m++, v = !1)
    !v && Vr(n.doc, p, d) && (n.split(p, d), p += 2 * d), p += f.child(m).nodeSize;
  return n;
}
function HP(n) {
  return function(e, t) {
    let { $from: r, $to: o } = e.selection, a = r.blockRange(o, (l) => l.childCount > 0 && l.firstChild.type == n);
    return a ? t ? r.node(a.depth - 1).type == n ? GP(e, t, n, a) : _P(e, t, a) : !0 : !1;
  };
}
function GP(n, e, t, r) {
  let o = n.tr, a = r.end, l = r.$to.end(r.depth);
  a < l && (o.step(new Mt(a - 1, l, a, l, new ne(X.from(t.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new Eu(o.doc.resolve(r.$from.pos), o.doc.resolve(l), r.depth));
  const d = aa(r);
  if (d == null)
    return !1;
  o.lift(r, d);
  let p = o.doc.resolve(o.mapping.map(a, -1) - 1);
  return Hi(o.doc, p.pos) && p.nodeBefore.type == p.nodeAfter.type && o.join(p.pos), e(o.scrollIntoView()), !0;
}
function _P(n, e, t) {
  let r = n.tr, o = t.parent;
  for (let k = t.end, A = t.endIndex - 1, S = t.startIndex; A > S; A--)
    k -= o.child(A).nodeSize, r.delete(k - 1, k + 1);
  let a = r.doc.resolve(t.start), l = a.nodeAfter;
  if (r.mapping.map(t.end) != t.start + a.nodeAfter.nodeSize)
    return !1;
  let d = t.startIndex == 0, p = t.endIndex == o.childCount, f = a.node(-1), m = a.index(-1);
  if (!f.canReplace(m + (d ? 0 : 1), m + 1, l.content.append(p ? X.empty : X.from(o))))
    return !1;
  let y = a.pos, v = y + l.nodeSize;
  return r.step(new Mt(y - (d ? 1 : 0), v + (p ? 1 : 0), y + 1, v - 1, new ne((d ? X.empty : X.from(o.copy(X.empty))).append(p ? X.empty : X.from(o.copy(X.empty))), d ? 0 : 1, p ? 0 : 1), d ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function zP(n) {
  return function(e, t) {
    let { $from: r, $to: o } = e.selection, a = r.blockRange(o, (f) => f.childCount > 0 && f.firstChild.type == n);
    if (!a)
      return !1;
    let l = a.startIndex;
    if (l == 0)
      return !1;
    let d = a.parent, p = d.child(l - 1);
    if (p.type != n)
      return !1;
    if (t) {
      let f = p.lastChild && p.lastChild.type == d.type, m = X.from(f ? n.create() : null), y = new ne(X.from(n.create(null, X.from(d.type.create(null, m)))), f ? 3 : 1, 0), v = a.start, k = a.end;
      t(e.tr.step(new Mt(v - (f ? 3 : 1), k, v, k, y, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
var qP = Object.defineProperty, R1 = (n, e) => {
  for (var t in e)
    qP(n, t, { get: e[t], enumerable: !0 });
};
function ld(n) {
  const { state: e, transaction: t } = n;
  let { selection: r } = t, { doc: o } = t, { storedMarks: a } = t;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return a;
    },
    get selection() {
      return r;
    },
    get doc() {
      return o;
    },
    get tr() {
      return r = t.selection, o = t.doc, a = t.storedMarks, t;
    }
  };
}
var cd = class {
  constructor(n) {
    this.editor = n.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = n.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: n, editor: e, state: t } = this, { view: r } = e, { tr: o } = t, a = this.buildProps(o);
    return Object.fromEntries(
      Object.entries(n).map(([l, d]) => [l, (...f) => {
        const m = d(...f)(a);
        return !o.getMeta("preventDispatch") && !this.hasCustomState && r.dispatch(o), m;
      }])
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(n, e = !0) {
    const { rawCommands: t, editor: r, state: o } = this, { view: a } = r, l = [], d = !!n, p = n || o.tr, f = () => (!d && e && !p.getMeta("preventDispatch") && !this.hasCustomState && a.dispatch(p), l.every((y) => y === !0)), m = {
      ...Object.fromEntries(
        Object.entries(t).map(([y, v]) => [y, (...A) => {
          const S = this.buildProps(p, e), B = v(...A)(S);
          return l.push(B), m;
        }])
      ),
      run: f
    };
    return m;
  }
  createCan(n) {
    const { rawCommands: e, state: t } = this, r = !1, o = n || t.tr, a = this.buildProps(o, r);
    return {
      ...Object.fromEntries(
        Object.entries(e).map(([d, p]) => [d, (...f) => p(...f)({ ...a, dispatch: void 0 })])
      ),
      chain: () => this.createChain(o, r)
    };
  }
  buildProps(n, e = !0) {
    const { rawCommands: t, editor: r, state: o } = this, { view: a } = r, l = {
      tr: n,
      editor: r,
      view: a,
      state: ld({
        state: o,
        transaction: n
      }),
      dispatch: e ? () => {
      } : void 0,
      chain: () => this.createChain(n, e),
      can: () => this.createCan(n),
      get commands() {
        return Object.fromEntries(
          Object.entries(t).map(([d, p]) => [d, (...f) => p(...f)(l)])
        );
      }
    };
    return l;
  }
}, VP = class {
  constructor() {
    this.callbacks = {};
  }
  on(e, t) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this;
  }
  emit(e, ...t) {
    const r = this.callbacks[e];
    return r && r.forEach((o) => o.apply(this, t)), this;
  }
  off(e, t) {
    const r = this.callbacks[e];
    return r && (t ? this.callbacks[e] = r.filter((o) => o !== t) : delete this.callbacks[e]), this;
  }
  once(e, t) {
    const r = (...o) => {
      this.off(e, r), t.apply(this, o);
    };
    return this.on(e, r);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
function XP(n, e) {
  const t = new Jf(n);
  return e.forEach((r) => {
    r.steps.forEach((o) => {
      t.step(o);
    });
  }), t;
}
var F1 = (n) => {
  const e = n.childNodes;
  for (let t = e.length - 1; t >= 0; t -= 1) {
    const r = e[t];
    r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? n.removeChild(r) : r.nodeType === 1 && F1(r);
  }
  return n;
};
function qc(n) {
  if (typeof window > "u")
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  const e = `<body>${n}</body>`, t = new window.DOMParser().parseFromString(e, "text/html").body;
  return F1(t);
}
function Mo(n, e, t) {
  if (n instanceof Ii || n instanceof X)
    return n;
  t = {
    slice: !0,
    parseOptions: {},
    ...t
  };
  const r = typeof n == "object" && n !== null, o = typeof n == "string";
  if (r)
    try {
      if (Array.isArray(n) && n.length > 0)
        return X.fromArray(n.map((d) => e.nodeFromJSON(d)));
      const l = e.nodeFromJSON(n);
      return t.errorOnInvalidContent && l.check(), l;
    } catch (a) {
      if (t.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: a });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", n, "Error:", a), Mo("", e, t);
    }
  if (o) {
    if (t.errorOnInvalidContent) {
      let l = !1, d = "";
      const p = new Ak({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (f) => (l = !0, d = typeof f == "string" ? f : f.outerHTML, null)
              }
            ]
          }
        })
      });
      if (t.slice ? Qa.fromSchema(p).parseSlice(qc(n), t.parseOptions) : Qa.fromSchema(p).parse(qc(n), t.parseOptions), t.errorOnInvalidContent && l)
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${d}`)
        });
    }
    const a = Qa.fromSchema(e);
    return t.slice ? a.parseSlice(qc(n), t.parseOptions).content : a.parse(qc(n), t.parseOptions);
  }
  return Mo("", e, t);
}
function cf(n, e, t = {}, r = {}) {
  return Mo(n, e, {
    slice: !1,
    parseOptions: t,
    errorOnInvalidContent: r.errorOnInvalidContent
  });
}
function JP(n) {
  for (let e = 0; e < n.edgeCount; e += 1) {
    const { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
function Cv(n, e) {
  const t = [];
  return n.descendants((r, o) => {
    e(r) && t.push({
      node: r,
      pos: o
    });
  }), t;
}
function ko(n, e) {
  for (let t = n.depth; t > 0; t -= 1) {
    const r = n.node(t);
    if (e(r))
      return {
        pos: t > 0 ? n.before(t) : 0,
        start: n.start(t),
        depth: t,
        node: r
      };
  }
}
function dm(n) {
  return (e) => ko(e.$from, n);
}
function pe(n, e, t) {
  return n.config[e] === void 0 && n.parent ? pe(n.parent, e, t) : typeof n.config[e] == "function" ? n.config[e].bind({
    ...t,
    parent: n.parent ? pe(n.parent, e, t) : null
  }) : n.config[e];
}
function pm(n) {
  return n.map((e) => {
    const t = {
      name: e.name,
      options: e.options,
      storage: e.storage
    }, r = pe(e, "addExtensions", t);
    return r ? [e, ...pm(r())] : e;
  }).flat(10);
}
function hm(n, e) {
  const t = Uo.fromSchema(e).serializeFragment(n), o = document.implementation.createHTMLDocument().createElement("div");
  return o.appendChild(t), o.innerHTML;
}
function P1(n) {
  return typeof n == "function";
}
function Ze(n, e = void 0, ...t) {
  return P1(n) ? e ? n.bind(e)(...t) : n(...t) : n;
}
function KP(n = {}) {
  return Object.keys(n).length === 0 && n.constructor === Object;
}
function yl(n) {
  const e = n.filter((o) => o.type === "extension"), t = n.filter((o) => o.type === "node"), r = n.filter((o) => o.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: t,
    markExtensions: r
  };
}
function $1(n) {
  const e = [], { nodeExtensions: t, markExtensions: r } = yl(n), o = [...t, ...r], a = {
    default: null,
    validate: void 0,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return n.forEach((l) => {
    const d = {
      name: l.name,
      options: l.options,
      storage: l.storage,
      extensions: o
    }, p = pe(
      l,
      "addGlobalAttributes",
      d
    );
    if (!p)
      return;
    p().forEach((m) => {
      m.types.forEach((y) => {
        Object.entries(m.attributes).forEach(([v, k]) => {
          e.push({
            type: y,
            name: v,
            attribute: {
              ...a,
              ...k
            }
          });
        });
      });
    });
  }), o.forEach((l) => {
    const d = {
      name: l.name,
      options: l.options,
      storage: l.storage
    }, p = pe(
      l,
      "addAttributes",
      d
    );
    if (!p)
      return;
    const f = p();
    Object.entries(f).forEach(([m, y]) => {
      const v = {
        ...a,
        ...y
      };
      typeof (v == null ? void 0 : v.default) == "function" && (v.default = v.default()), v != null && v.isRequired && (v == null ? void 0 : v.default) === void 0 && delete v.default, e.push({
        type: l.name,
        name: m,
        attribute: v
      });
    });
  }), e;
}
function fm(...n) {
  return n.filter((e) => !!e).reduce((e, t) => {
    const r = { ...e };
    return Object.entries(t).forEach(([o, a]) => {
      if (!r[o]) {
        r[o] = a;
        return;
      }
      if (o === "class") {
        const d = a ? String(a).split(" ") : [], p = r[o] ? r[o].split(" ") : [], f = d.filter((m) => !p.includes(m));
        r[o] = [...p, ...f].join(" ");
      } else if (o === "style") {
        const d = a ? a.split(";").map((m) => m.trim()).filter(Boolean) : [], p = r[o] ? r[o].split(";").map((m) => m.trim()).filter(Boolean) : [], f = /* @__PURE__ */ new Map();
        p.forEach((m) => {
          const [y, v] = m.split(":").map((k) => k.trim());
          f.set(y, v);
        }), d.forEach((m) => {
          const [y, v] = m.split(":").map((k) => k.trim());
          f.set(y, v);
        }), r[o] = Array.from(f.entries()).map(([m, y]) => `${m}: ${y}`).join("; ");
      } else
        r[o] = a;
    }), r;
  }, {});
}
function Ru(n, e) {
  return e.filter((t) => t.type === n.type.name).filter((t) => t.attribute.rendered).map((t) => t.attribute.renderHTML ? t.attribute.renderHTML(n.attrs) || {} : {
    [t.name]: n.attrs[t.name]
  }).reduce((t, r) => fm(t, r), {});
}
function WP(n) {
  return typeof n != "string" ? n : n.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(n) : n === "true" ? !0 : n === "false" ? !1 : n;
}
function Sv(n, e) {
  return "style" in n ? n : {
    ...n,
    getAttrs: (t) => {
      const r = n.getAttrs ? n.getAttrs(t) : n.attrs;
      if (r === !1)
        return !1;
      const o = e.reduce((a, l) => {
        const d = l.attribute.parseHTML ? l.attribute.parseHTML(t) : WP(t.getAttribute(l.name));
        return d == null ? a : {
          ...a,
          [l.name]: d
        };
      }, {});
      return { ...r, ...o };
    }
  };
}
function Ev(n) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(n).filter(([e, t]) => e === "attrs" && KP(t) ? !1 : t != null)
  );
}
function YP(n, e) {
  var t;
  const r = $1(n), { nodeExtensions: o, markExtensions: a } = yl(n), l = (t = o.find((f) => pe(f, "topNode"))) == null ? void 0 : t.name, d = Object.fromEntries(
    o.map((f) => {
      const m = r.filter((O) => O.type === f.name), y = {
        name: f.name,
        options: f.options,
        storage: f.storage,
        editor: e
      }, v = n.reduce((O, L) => {
        const G = pe(L, "extendNodeSchema", y);
        return {
          ...O,
          ...G ? G(f) : {}
        };
      }, {}), k = Ev({
        ...v,
        content: Ze(pe(f, "content", y)),
        marks: Ze(pe(f, "marks", y)),
        group: Ze(pe(f, "group", y)),
        inline: Ze(pe(f, "inline", y)),
        atom: Ze(pe(f, "atom", y)),
        selectable: Ze(pe(f, "selectable", y)),
        draggable: Ze(pe(f, "draggable", y)),
        code: Ze(pe(f, "code", y)),
        whitespace: Ze(pe(f, "whitespace", y)),
        linebreakReplacement: Ze(
          pe(f, "linebreakReplacement", y)
        ),
        defining: Ze(pe(f, "defining", y)),
        isolating: Ze(pe(f, "isolating", y)),
        attrs: Object.fromEntries(
          m.map((O) => {
            var L, G;
            return [
              O.name,
              { default: (L = O == null ? void 0 : O.attribute) == null ? void 0 : L.default, validate: (G = O == null ? void 0 : O.attribute) == null ? void 0 : G.validate }
            ];
          })
        )
      }), A = Ze(pe(f, "parseHTML", y));
      A && (k.parseDOM = A.map(
        (O) => Sv(O, m)
      ));
      const S = pe(f, "renderHTML", y);
      S && (k.toDOM = (O) => S({
        node: O,
        HTMLAttributes: Ru(O, m)
      }));
      const B = pe(f, "renderText", y);
      return B && (k.toText = B), [f.name, k];
    })
  ), p = Object.fromEntries(
    a.map((f) => {
      const m = r.filter((B) => B.type === f.name), y = {
        name: f.name,
        options: f.options,
        storage: f.storage,
        editor: e
      }, v = n.reduce((B, O) => {
        const L = pe(O, "extendMarkSchema", y);
        return {
          ...B,
          ...L ? L(f) : {}
        };
      }, {}), k = Ev({
        ...v,
        inclusive: Ze(pe(f, "inclusive", y)),
        excludes: Ze(pe(f, "excludes", y)),
        group: Ze(pe(f, "group", y)),
        spanning: Ze(pe(f, "spanning", y)),
        code: Ze(pe(f, "code", y)),
        attrs: Object.fromEntries(
          m.map((B) => {
            var O, L;
            return [
              B.name,
              { default: (O = B == null ? void 0 : B.attribute) == null ? void 0 : O.default, validate: (L = B == null ? void 0 : B.attribute) == null ? void 0 : L.validate }
            ];
          })
        )
      }), A = Ze(pe(f, "parseHTML", y));
      A && (k.parseDOM = A.map(
        (B) => Sv(B, m)
      ));
      const S = pe(f, "renderHTML", y);
      return S && (k.toDOM = (B) => S({
        mark: B,
        HTMLAttributes: Ru(B, m)
      })), [f.name, k];
    })
  );
  return new Ak({
    topNode: l,
    nodes: d,
    marks: p
  });
}
function QP(n) {
  const e = n.filter((t, r) => n.indexOf(t) !== r);
  return Array.from(new Set(e));
}
function mm(n) {
  return n.sort((t, r) => {
    const o = pe(t, "priority") || 100, a = pe(r, "priority") || 100;
    return o > a ? -1 : o < a ? 1 : 0;
  });
}
function j1(n) {
  const e = mm(pm(n)), t = QP(e.map((r) => r.name));
  return t.length && console.warn(
    `[tiptap warn]: Duplicate extension names found: [${t.map((r) => `'${r}'`).join(", ")}]. This can lead to issues.`
  ), e;
}
function U1(n, e, t) {
  const { from: r, to: o } = e, { blockSeparator: a = `

`, textSerializers: l = {} } = t || {};
  let d = "";
  return n.nodesBetween(r, o, (p, f, m, y) => {
    var v;
    p.isBlock && f > r && (d += a);
    const k = l == null ? void 0 : l[p.type.name];
    if (k)
      return m && (d += k({
        node: p,
        pos: f,
        parent: m,
        index: y,
        range: e
      })), !1;
    p.isText && (d += (v = p == null ? void 0 : p.text) == null ? void 0 : v.slice(Math.max(r, f) - f, o - f));
  }), d;
}
function ZP(n, e) {
  const t = {
    from: 0,
    to: n.content.size
  };
  return U1(n, t, e);
}
function L1(n) {
  return Object.fromEntries(
    Object.entries(n.nodes).filter(([, e]) => e.spec.toText).map(([e, t]) => [e, t.spec.toText])
  );
}
function ei(n, e) {
  if (typeof n == "string") {
    if (!e.marks[n])
      throw Error(`There is no mark type named '${n}'. Maybe you forgot to add the extension?`);
    return e.marks[n];
  }
  return n;
}
function H1(n, e) {
  const t = ei(e, n.schema), { from: r, to: o, empty: a } = n.selection, l = [];
  a ? (n.storedMarks && l.push(...n.storedMarks), l.push(...n.selection.$head.marks())) : n.doc.nodesBetween(r, o, (p) => {
    l.push(...p.marks);
  });
  const d = l.find((p) => p.type.name === t.name);
  return d ? { ...d.attrs } : {};
}
function Rt(n, e) {
  if (typeof n == "string") {
    if (!e.nodes[n])
      throw Error(`There is no node type named '${n}'. Maybe you forgot to add the extension?`);
    return e.nodes[n];
  }
  return n;
}
function e$(n, e) {
  const t = Rt(e, n.schema), { from: r, to: o } = n.selection, a = [];
  n.doc.nodesBetween(r, o, (d) => {
    a.push(d);
  });
  const l = a.reverse().find((d) => d.type.name === t.name);
  return l ? { ...l.attrs } : {};
}
function ud(n, e) {
  return e.nodes[n] ? "node" : e.marks[n] ? "mark" : null;
}
function t$(n, e) {
  const t = ud(
    typeof e == "string" ? e : e.name,
    n.schema
  );
  return t === "node" ? e$(n, e) : t === "mark" ? H1(n, e) : {};
}
function n$(n, e = JSON.stringify) {
  const t = {};
  return n.filter((r) => {
    const o = e(r);
    return Object.prototype.hasOwnProperty.call(t, o) ? !1 : t[o] = !0;
  });
}
function r$(n) {
  const e = n$(n);
  return e.length === 1 ? e : e.filter((t, r) => !e.filter((a, l) => l !== r).some((a) => t.oldRange.from >= a.oldRange.from && t.oldRange.to <= a.oldRange.to && t.newRange.from >= a.newRange.from && t.newRange.to <= a.newRange.to));
}
function i$(n) {
  const { mapping: e, steps: t } = n, r = [];
  return e.maps.forEach((o, a) => {
    const l = [];
    if (o.ranges.length)
      o.forEach((d, p) => {
        l.push({ from: d, to: p });
      });
    else {
      const { from: d, to: p } = t[a];
      if (d === void 0 || p === void 0)
        return;
      l.push({ from: d, to: p });
    }
    l.forEach(({ from: d, to: p }) => {
      const f = e.slice(a).map(d, -1), m = e.slice(a).map(p), y = e.invert().map(f, -1), v = e.invert().map(m);
      r.push({
        oldRange: {
          from: y,
          to: v
        },
        newRange: {
          from: f,
          to: m
        }
      });
    });
  }), r$(r);
}
function gm(n) {
  return Object.prototype.toString.call(n) === "[object RegExp]";
}
function Fu(n, e, t = { strict: !0 }) {
  const r = Object.keys(e);
  return r.length ? r.every((o) => t.strict ? e[o] === n[o] : gm(e[o]) ? e[o].test(n[o]) : e[o] === n[o]) : !0;
}
function G1(n, e, t = {}) {
  return n.find((r) => r.type === e && Fu(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(t).map((o) => [o, r.attrs[o]])),
    t
  ));
}
function Tv(n, e, t = {}) {
  return !!G1(n, e, t);
}
function ym(n, e, t) {
  var r;
  if (!n || !e)
    return;
  let o = n.parent.childAfter(n.parentOffset);
  if ((!o.node || !o.node.marks.some((m) => m.type === e)) && (o = n.parent.childBefore(n.parentOffset)), !o.node || !o.node.marks.some((m) => m.type === e) || (t = t || ((r = o.node.marks[0]) == null ? void 0 : r.attrs), !G1([...o.node.marks], e, t)))
    return;
  let l = o.index, d = n.start() + o.offset, p = l + 1, f = d + o.node.nodeSize;
  for (; l > 0 && Tv([...n.parent.child(l - 1).marks], e, t); )
    l -= 1, d -= n.parent.child(l).nodeSize;
  for (; p < n.parent.childCount && Tv([...n.parent.child(p).marks], e, t); )
    f += n.parent.child(p).nodeSize, p += 1;
  return {
    from: d,
    to: f
  };
}
function xh(n, e) {
  return e.nodes[n] || e.marks[n] || null;
}
function pu(n, e, t) {
  return Object.fromEntries(
    Object.entries(t).filter(([r]) => {
      const o = n.find((a) => a.type === e && a.name === r);
      return o ? o.attribute.keepOnSplit : !1;
    })
  );
}
var o$ = (n, e = 500) => {
  let t = "";
  const r = n.parentOffset;
  return n.parent.nodesBetween(Math.max(0, r - e), r, (o, a, l, d) => {
    var p, f;
    const m = ((f = (p = o.type.spec).toText) == null ? void 0 : f.call(p, {
      node: o,
      pos: a,
      parent: l,
      index: d
    })) || o.textContent || "%leaf%";
    t += o.isAtom && !o.isText ? m : m.slice(0, Math.max(0, r - a));
  }), t;
};
function uf(n, e, t = {}) {
  const { empty: r, ranges: o } = n.selection, a = e ? ei(e, n.schema) : null;
  if (r)
    return !!(n.storedMarks || n.selection.$from.marks()).filter((y) => a ? a.name === y.type.name : !0).find((y) => Fu(y.attrs, t, { strict: !1 }));
  let l = 0;
  const d = [];
  if (o.forEach(({ $from: y, $to: v }) => {
    const k = y.pos, A = v.pos;
    n.doc.nodesBetween(k, A, (S, B) => {
      if (!S.isText && !S.marks.length)
        return;
      const O = Math.max(k, B), L = Math.min(A, B + S.nodeSize), G = L - O;
      l += G, d.push(
        ...S.marks.map((Y) => ({
          mark: Y,
          from: O,
          to: L
        }))
      );
    });
  }), l === 0)
    return !1;
  const p = d.filter((y) => a ? a.name === y.mark.type.name : !0).filter((y) => Fu(y.mark.attrs, t, { strict: !1 })).reduce((y, v) => y + v.to - v.from, 0), f = d.filter((y) => a ? y.mark.type !== a && y.mark.type.excludes(a) : !0).reduce((y, v) => y + v.to - v.from, 0);
  return (p > 0 ? p + f : p) >= l;
}
function wl(n, e, t = {}) {
  const { from: r, to: o, empty: a } = n.selection, l = e ? Rt(e, n.schema) : null, d = [];
  n.doc.nodesBetween(r, o, (y, v) => {
    if (y.isText)
      return;
    const k = Math.max(r, v), A = Math.min(o, v + y.nodeSize);
    d.push({
      node: y,
      from: k,
      to: A
    });
  });
  const p = o - r, f = d.filter((y) => l ? l.name === y.node.type.name : !0).filter((y) => Fu(y.node.attrs, t, { strict: !1 }));
  return a ? !!f.length : f.reduce((y, v) => y + v.to - v.from, 0) >= p;
}
function s$(n, e, t = {}) {
  if (!e)
    return wl(n, null, t) || uf(n, null, t);
  const r = ud(e, n.schema);
  return r === "node" ? wl(n, e, t) : r === "mark" ? uf(n, e, t) : !1;
}
function Nv(n, e) {
  return Array.isArray(e) ? e.some((t) => (typeof t == "string" ? t : t.name) === n.name) : e;
}
function Bv(n, e) {
  const { nodeExtensions: t } = yl(e), r = t.find((l) => l.name === n);
  if (!r)
    return !1;
  const o = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, a = Ze(pe(r, "group", o));
  return typeof a != "string" ? !1 : a.split(" ").includes("list");
}
function dd(n, {
  checkChildren: e = !0,
  ignoreWhitespace: t = !1
} = {}) {
  var r;
  if (t) {
    if (n.type.name === "hardBreak")
      return !0;
    if (n.isText)
      return /^\s*$/m.test((r = n.text) != null ? r : "");
  }
  if (n.isText)
    return !n.text;
  if (n.isAtom || n.isLeaf)
    return !1;
  if (n.content.childCount === 0)
    return !0;
  if (e) {
    let o = !0;
    return n.content.forEach((a) => {
      o !== !1 && (dd(a, { ignoreWhitespace: t, checkChildren: e }) || (o = !1));
    }), o;
  }
  return !1;
}
function a$(n) {
  return n instanceof fe;
}
function wm(n) {
  return n instanceof ge;
}
function qr(n = 0, e = 0, t = 0) {
  return Math.min(Math.max(n, e), t);
}
function l$(n, e, t) {
  const o = n.state.doc.content.size, a = qr(e, 0, o), l = qr(t, 0, o), d = n.coordsAtPos(a), p = n.coordsAtPos(l, -1), f = Math.min(d.top, p.top), m = Math.max(d.bottom, p.bottom), y = Math.min(d.left, p.left), v = Math.max(d.right, p.right), k = v - y, A = m - f, O = {
    top: f,
    bottom: m,
    left: y,
    right: v,
    width: k,
    height: A,
    x: y,
    y: f
  };
  return {
    ...O,
    toJSON: () => O
  };
}
function _1(n, e = null) {
  if (!e)
    return null;
  const t = ve.atStart(n), r = ve.atEnd(n);
  if (e === "start" || e === !0)
    return t;
  if (e === "end")
    return r;
  const o = t.from, a = r.to;
  return e === "all" ? ge.create(n, qr(0, o, a), qr(n.content.size, o, a)) : ge.create(n, qr(e, o, a), qr(e, o, a));
}
function c$(n, e, t) {
  const r = n.steps.length - 1;
  if (r < e)
    return;
  const o = n.steps[r];
  if (!(o instanceof At || o instanceof Mt))
    return;
  const a = n.mapping.maps[r];
  let l = 0;
  a.forEach((d, p, f, m) => {
    l === 0 && (l = m);
  }), n.setSelection(ve.near(n.doc.resolve(l), t));
}
var bm = class {
  constructor(n) {
    this.find = n.find, this.handler = n.handler;
  }
}, u$ = (n, e) => {
  if (gm(e))
    return e.exec(n);
  const t = e(n);
  if (!t)
    return null;
  const r = [t.text];
  return r.index = t.index, r.input = n, r.data = t.data, t.replaceWith && (t.text.includes(t.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(t.replaceWith)), r;
};
function Vc(n) {
  var e;
  const { editor: t, from: r, to: o, text: a, rules: l, plugin: d } = n, { view: p } = t;
  if (p.composing)
    return !1;
  const f = p.state.doc.resolve(r);
  if (
    // check for code node
    f.parent.type.spec.code || (e = f.nodeBefore || f.nodeAfter) != null && e.marks.find((v) => v.type.spec.code)
  )
    return !1;
  let m = !1;
  const y = o$(f) + a;
  return l.forEach((v) => {
    if (m)
      return;
    const k = u$(y, v.find);
    if (!k)
      return;
    const A = p.state.tr, S = ld({
      state: p.state,
      transaction: A
    }), B = {
      from: r - (k[0].length - a.length),
      to: o
    }, { commands: O, chain: L, can: G } = new cd({
      editor: t,
      state: S
    });
    v.handler({
      state: S,
      range: B,
      match: k,
      commands: O,
      chain: L,
      can: G
    }) === null || !A.steps.length || (A.setMeta(d, {
      transform: A,
      from: r,
      to: o,
      text: a
    }), p.dispatch(A), m = !0);
  }), m;
}
function d$(n) {
  const { editor: e, rules: t } = n, r = new ot({
    state: {
      init() {
        return null;
      },
      apply(o, a, l) {
        const d = o.getMeta(r);
        if (d)
          return d;
        const p = o.getMeta("applyInputRules");
        return !!p && setTimeout(() => {
          let { text: m } = p;
          typeof m == "string" ? m = m : m = hm(X.from(m), l.schema);
          const { from: y } = p, v = y + m.length;
          Vc({
            editor: e,
            from: y,
            to: v,
            text: m,
            rules: t,
            plugin: r
          });
        }), o.selectionSet || o.docChanged ? null : a;
      }
    },
    props: {
      handleTextInput(o, a, l, d) {
        return Vc({
          editor: e,
          from: a,
          to: l,
          text: d,
          rules: t,
          plugin: r
        });
      },
      handleDOMEvents: {
        compositionend: (o) => (setTimeout(() => {
          const { $cursor: a } = o.state.selection;
          a && Vc({
            editor: e,
            from: a.pos,
            to: a.pos,
            text: "",
            rules: t,
            plugin: r
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(o, a) {
        if (a.key !== "Enter")
          return !1;
        const { $cursor: l } = o.state.selection;
        return l ? Vc({
          editor: e,
          from: l.pos,
          to: l.pos,
          text: `
`,
          rules: t,
          plugin: r
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return r;
}
function p$(n) {
  return Object.prototype.toString.call(n).slice(8, -1);
}
function Xc(n) {
  return p$(n) !== "Object" ? !1 : n.constructor === Object && Object.getPrototypeOf(n) === Object.prototype;
}
function z1(n, e) {
  const t = { ...n };
  return Xc(n) && Xc(e) && Object.keys(e).forEach((r) => {
    Xc(e[r]) && Xc(n[r]) ? t[r] = z1(n[r], e[r]) : t[r] = e[r];
  }), t;
}
var vm = class {
  constructor(n = {}) {
    this.type = "extendable", this.parent = null, this.child = null, this.name = "", this.config = {
      name: this.name
    }, this.config = {
      ...this.config,
      ...n
    }, this.name = this.config.name;
  }
  get options() {
    return {
      ...Ze(
        pe(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...Ze(
        pe(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(n = {}) {
    const e = this.extend({
      ...this.config,
      addOptions: () => z1(this.options, n)
    });
    return e.name = this.name, e.parent = this.parent, e;
  }
  extend(n = {}) {
    const e = new this.constructor({ ...this.config, ...n });
    return e.parent = this, this.child = e, e.name = "name" in n ? n.name : e.parent.name, e;
  }
}, q1 = class V1 extends vm {
  constructor() {
    super(...arguments), this.type = "mark";
  }
  /**
   * Create a new Mark instance
   * @param config - Mark configuration object or a function that returns a configuration object
   */
  static create(e = {}) {
    const t = typeof e == "function" ? e() : e;
    return new V1(t);
  }
  static handleExit({ editor: e, mark: t }) {
    const { tr: r } = e.state, o = e.state.selection.$from;
    if (o.pos === o.end()) {
      const l = o.marks();
      if (!!!l.find((f) => (f == null ? void 0 : f.type.name) === t.name))
        return !1;
      const p = l.find((f) => (f == null ? void 0 : f.type.name) === t.name);
      return p && r.removeStoredMark(p), r.insertText(" ", o.pos), e.view.dispatch(r), !0;
    }
    return !1;
  }
  configure(e) {
    return super.configure(e);
  }
  extend(e) {
    const t = typeof e == "function" ? e() : e;
    return super.extend(t);
  }
};
function h$(n) {
  return typeof n == "number";
}
var f$ = (n, e, t) => {
  if (gm(e))
    return [...n.matchAll(e)];
  const r = e(n, t);
  return r ? r.map((o) => {
    const a = [o.text];
    return a.index = o.index, a.input = n, a.data = o.data, o.replaceWith && (o.text.includes(o.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), a.push(o.replaceWith)), a;
  }) : [];
};
function m$(n) {
  const { editor: e, state: t, from: r, to: o, rule: a, pasteEvent: l, dropEvent: d } = n, { commands: p, chain: f, can: m } = new cd({
    editor: e,
    state: t
  }), y = [];
  return t.doc.nodesBetween(r, o, (k, A) => {
    var S, B, O, L, G;
    if ((B = (S = k.type) == null ? void 0 : S.spec) != null && B.code || !(k.isText || k.isTextblock || k.isInline))
      return;
    const Y = (G = (L = (O = k.content) == null ? void 0 : O.size) != null ? L : k.nodeSize) != null ? G : 0, z = Math.max(r, A), M = Math.min(o, A + Y);
    if (z >= M)
      return;
    const ee = k.isText ? k.text || "" : k.textBetween(z - A, M - A, void 0, "￼");
    f$(ee, a.find, l).forEach((K) => {
      if (K.index === void 0)
        return;
      const Q = z + K.index + 1, H = Q + K[0].length, j = {
        from: t.tr.mapping.map(Q),
        to: t.tr.mapping.map(H)
      }, ce = a.handler({
        state: t,
        range: j,
        match: K,
        commands: p,
        chain: f,
        can: m,
        pasteEvent: l,
        dropEvent: d
      });
      y.push(ce);
    });
  }), y.every((k) => k !== null);
}
var Jc = null, g$ = (n) => {
  var e;
  const t = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (e = t.clipboardData) == null || e.setData("text/html", n), t;
};
function y$(n) {
  const { editor: e, rules: t } = n;
  let r = null, o = !1, a = !1, l = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, d;
  try {
    d = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    d = null;
  }
  const p = ({
    state: m,
    from: y,
    to: v,
    rule: k,
    pasteEvt: A
  }) => {
    const S = m.tr, B = ld({
      state: m,
      transaction: S
    });
    if (!(!m$({
      editor: e,
      state: B,
      from: Math.max(y - 1, 0),
      to: v.b - 1,
      rule: k,
      pasteEvent: A,
      dropEvent: d
    }) || !S.steps.length)) {
      try {
        d = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        d = null;
      }
      return l = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, S;
    }
  };
  return t.map((m) => new ot({
    // we register a global drag handler to track the current drag source element
    view(y) {
      const v = (A) => {
        var S;
        r = (S = y.dom.parentElement) != null && S.contains(A.target) ? y.dom.parentElement : null, r && (Jc = e);
      }, k = () => {
        Jc && (Jc = null);
      };
      return window.addEventListener("dragstart", v), window.addEventListener("dragend", k), {
        destroy() {
          window.removeEventListener("dragstart", v), window.removeEventListener("dragend", k);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (y, v) => {
          if (a = r === y.dom.parentElement, d = v, !a) {
            const k = Jc;
            k != null && k.isEditable && setTimeout(() => {
              const A = k.state.selection;
              A && k.commands.deleteRange({ from: A.from, to: A.to });
            }, 10);
          }
          return !1;
        },
        paste: (y, v) => {
          var k;
          const A = (k = v.clipboardData) == null ? void 0 : k.getData("text/html");
          return l = v, o = !!(A != null && A.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (y, v, k) => {
      const A = y[0], S = A.getMeta("uiEvent") === "paste" && !o, B = A.getMeta("uiEvent") === "drop" && !a, O = A.getMeta("applyPasteRules"), L = !!O;
      if (!S && !B && !L)
        return;
      if (L) {
        let { text: z } = O;
        typeof z == "string" ? z = z : z = hm(X.from(z), k.schema);
        const { from: M } = O, ee = M + z.length, U = g$(z);
        return p({
          rule: m,
          state: k,
          from: M,
          to: { b: ee },
          pasteEvt: U
        });
      }
      const G = v.doc.content.findDiffStart(k.doc.content), Y = v.doc.content.findDiffEnd(k.doc.content);
      if (!(!h$(G) || !Y || G === Y.b))
        return p({
          rule: m,
          state: k,
          from: G,
          to: Y,
          pasteEvt: l
        });
    }
  }));
}
var pd = class {
  constructor(n, e) {
    this.splittableMarks = [], this.editor = e, this.extensions = j1(n), this.schema = YP(this.extensions, e), this.setupExtensions();
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((n, e) => {
      const t = {
        name: e.name,
        options: e.options,
        storage: this.editor.extensionStorage[e.name],
        editor: this.editor,
        type: xh(e.name, this.schema)
      }, r = pe(e, "addCommands", t);
      return r ? {
        ...n,
        ...r()
      } : n;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: n } = this;
    return mm([...this.extensions].reverse()).map((r) => {
      const o = {
        name: r.name,
        options: r.options,
        storage: this.editor.extensionStorage[r.name],
        editor: n,
        type: xh(r.name, this.schema)
      }, a = [], l = pe(
        r,
        "addKeyboardShortcuts",
        o
      );
      let d = {};
      if (r.type === "mark" && pe(r, "exitable", o) && (d.ArrowRight = () => q1.handleExit({ editor: n, mark: r })), l) {
        const v = Object.fromEntries(
          Object.entries(l()).map(([k, A]) => [k, () => A({ editor: n })])
        );
        d = { ...d, ...v };
      }
      const p = CP(d);
      a.push(p);
      const f = pe(r, "addInputRules", o);
      if (Nv(r, n.options.enableInputRules) && f) {
        const v = f();
        if (v && v.length) {
          const k = d$({
            editor: n,
            rules: v
          }), A = Array.isArray(k) ? k : [k];
          a.push(...A);
        }
      }
      const m = pe(r, "addPasteRules", o);
      if (Nv(r, n.options.enablePasteRules) && m) {
        const v = m();
        if (v && v.length) {
          const k = y$({ editor: n, rules: v });
          a.push(...k);
        }
      }
      const y = pe(
        r,
        "addProseMirrorPlugins",
        o
      );
      if (y) {
        const v = y();
        a.push(...v);
      }
      return a;
    }).flat();
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return $1(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: n } = this, { nodeExtensions: e } = yl(this.extensions);
    return Object.fromEntries(
      e.filter((t) => !!pe(t, "addNodeView")).map((t) => {
        const r = this.attributes.filter((d) => d.type === t.name), o = {
          name: t.name,
          options: t.options,
          storage: this.editor.extensionStorage[t.name],
          editor: n,
          type: Rt(t.name, this.schema)
        }, a = pe(t, "addNodeView", o);
        if (!a)
          return [];
        const l = (d, p, f, m, y) => {
          const v = Ru(d, r);
          return a()({
            // pass-through
            node: d,
            view: p,
            getPos: f,
            decorations: m,
            innerDecorations: y,
            // tiptap-specific
            editor: n,
            extension: t,
            HTMLAttributes: v
          });
        };
        return [t.name, l];
      })
    );
  }
  get markViews() {
    const { editor: n } = this, { markExtensions: e } = yl(this.extensions);
    return Object.fromEntries(
      e.filter((t) => !!pe(t, "addMarkView")).map((t) => {
        const r = this.attributes.filter((d) => d.type === t.name), o = {
          name: t.name,
          options: t.options,
          storage: this.editor.extensionStorage[t.name],
          editor: n,
          type: ei(t.name, this.schema)
        }, a = pe(t, "addMarkView", o);
        if (!a)
          return [];
        const l = (d, p, f) => {
          const m = Ru(d, r);
          return a()({
            // pass-through
            mark: d,
            view: p,
            inline: f,
            // tiptap-specific
            editor: n,
            extension: t,
            HTMLAttributes: m,
            updateAttributes: (y) => {
              D5(d, n, y);
            }
          });
        };
        return [t.name, l];
      })
    );
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    const n = this.extensions;
    this.editor.extensionStorage = Object.fromEntries(
      n.map((e) => [e.name, e.storage])
    ), n.forEach((e) => {
      var t;
      const r = {
        name: e.name,
        options: e.options,
        storage: this.editor.extensionStorage[e.name],
        editor: this.editor,
        type: xh(e.name, this.schema)
      };
      e.type === "mark" && ((t = Ze(pe(e, "keepOnSplit", r))) == null || t) && this.splittableMarks.push(e.name);
      const o = pe(e, "onBeforeCreate", r), a = pe(e, "onCreate", r), l = pe(e, "onUpdate", r), d = pe(
        e,
        "onSelectionUpdate",
        r
      ), p = pe(e, "onTransaction", r), f = pe(e, "onFocus", r), m = pe(e, "onBlur", r), y = pe(e, "onDestroy", r);
      o && this.editor.on("beforeCreate", o), a && this.editor.on("create", a), l && this.editor.on("update", l), d && this.editor.on("selectionUpdate", d), p && this.editor.on("transaction", p), f && this.editor.on("focus", f), m && this.editor.on("blur", m), y && this.editor.on("destroy", y);
    });
  }
};
pd.resolve = j1;
pd.sort = mm;
pd.flatten = pm;
var w$ = {};
R1(w$, {
  ClipboardTextSerializer: () => J1,
  Commands: () => Y1,
  Delete: () => Q1,
  Drop: () => Z1,
  Editable: () => eA,
  FocusEvents: () => nA,
  Keymap: () => rA,
  Paste: () => iA,
  Tabindex: () => oA,
  focusEventsPluginKey: () => tA
});
var yt = class X1 extends vm {
  constructor() {
    super(...arguments), this.type = "extension";
  }
  /**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */
  static create(e = {}) {
    const t = typeof e == "function" ? e() : e;
    return new X1(t);
  }
  configure(e) {
    return super.configure(e);
  }
  extend(e) {
    const t = typeof e == "function" ? e() : e;
    return super.extend(t);
  }
}, J1 = yt.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new ot({
        key: new pt("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: n } = this, { state: e, schema: t } = n, { doc: r, selection: o } = e, { ranges: a } = o, l = Math.min(...a.map((m) => m.$from.pos)), d = Math.max(...a.map((m) => m.$to.pos)), p = L1(t);
            return U1(r, { from: l, to: d }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: p
            });
          }
        }
      })
    ];
  }
}), K1 = {};
R1(K1, {
  blur: () => b$,
  clearContent: () => v$,
  clearNodes: () => x$,
  command: () => k$,
  createParagraphNear: () => A$,
  cut: () => C$,
  deleteCurrentNode: () => S$,
  deleteNode: () => E$,
  deleteRange: () => T$,
  deleteSelection: () => N$,
  enter: () => B$,
  exitCode: () => I$,
  extendMarkRange: () => M$,
  first: () => O$,
  focus: () => R$,
  forEach: () => F$,
  insertContent: () => P$,
  insertContentAt: () => j$,
  joinBackward: () => H$,
  joinDown: () => L$,
  joinForward: () => G$,
  joinItemBackward: () => _$,
  joinItemForward: () => z$,
  joinTextblockBackward: () => q$,
  joinTextblockForward: () => V$,
  joinUp: () => U$,
  keyboardShortcut: () => J$,
  lift: () => K$,
  liftEmptyBlock: () => W$,
  liftListItem: () => Y$,
  newlineInCode: () => Q$,
  resetAttributes: () => Z$,
  scrollIntoView: () => e5,
  selectAll: () => t5,
  selectNodeBackward: () => n5,
  selectNodeForward: () => r5,
  selectParentNode: () => i5,
  selectTextblockEnd: () => o5,
  selectTextblockStart: () => s5,
  setContent: () => a5,
  setMark: () => c5,
  setMeta: () => u5,
  setNode: () => d5,
  setNodeSelection: () => p5,
  setTextSelection: () => h5,
  sinkListItem: () => f5,
  splitBlock: () => m5,
  splitListItem: () => g5,
  toggleList: () => y5,
  toggleMark: () => w5,
  toggleNode: () => b5,
  toggleWrap: () => v5,
  undoInputRule: () => x5,
  unsetAllMarks: () => k5,
  unsetMark: () => A5,
  updateAttributes: () => C5,
  wrapIn: () => S5,
  wrapInList: () => E5
});
var b$ = () => ({ editor: n, view: e }) => (requestAnimationFrame(() => {
  var t;
  n.isDestroyed || (e.dom.blur(), (t = window == null ? void 0 : window.getSelection()) == null || t.removeAllRanges());
}), !0), v$ = (n = !0) => ({ commands: e }) => e.setContent("", { emitUpdate: n }), x$ = () => ({ state: n, tr: e, dispatch: t }) => {
  const { selection: r } = e, { ranges: o } = r;
  return t && o.forEach(({ $from: a, $to: l }) => {
    n.doc.nodesBetween(a.pos, l.pos, (d, p) => {
      if (d.type.isText)
        return;
      const { doc: f, mapping: m } = e, y = f.resolve(m.map(p)), v = f.resolve(m.map(p + d.nodeSize)), k = y.blockRange(v);
      if (!k)
        return;
      const A = aa(k);
      if (d.type.isTextblock) {
        const { defaultType: S } = y.parent.contentMatchAt(y.index());
        e.setNodeMarkup(k.start, S);
      }
      (A || A === 0) && e.lift(k, A);
    });
  }), !0;
}, k$ = (n) => (e) => n(e), A$ = () => ({ state: n, dispatch: e }) => I1(n, e), C$ = (n, e) => ({ editor: t, tr: r }) => {
  const { state: o } = t, a = o.doc.slice(n.from, n.to);
  r.deleteRange(n.from, n.to);
  const l = r.mapping.map(e);
  return r.insert(l, a.content), r.setSelection(new ge(r.doc.resolve(Math.max(l - 1, 0)))), !0;
}, S$ = () => ({ tr: n, dispatch: e }) => {
  const { selection: t } = n, r = t.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const o = n.selection.$anchor;
  for (let a = o.depth; a > 0; a -= 1)
    if (o.node(a).type === r.type) {
      if (e) {
        const d = o.before(a), p = o.after(a);
        n.delete(d, p).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, E$ = (n) => ({ tr: e, state: t, dispatch: r }) => {
  const o = Rt(n, t.schema), a = e.selection.$anchor;
  for (let l = a.depth; l > 0; l -= 1)
    if (a.node(l).type === o) {
      if (r) {
        const p = a.before(l), f = a.after(l);
        e.delete(p, f).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, T$ = (n) => ({ tr: e, dispatch: t }) => {
  const { from: r, to: o } = n;
  return t && e.delete(r, o), !0;
}, N$ = () => ({ state: n, dispatch: e }) => sm(n, e), B$ = () => ({ commands: n }) => n.keyboardShortcut("Enter"), I$ = () => ({ state: n, dispatch: e }) => IP(n, e), M$ = (n, e = {}) => ({ tr: t, state: r, dispatch: o }) => {
  const a = ei(n, r.schema), { doc: l, selection: d } = t, { $from: p, from: f, to: m } = d;
  if (o) {
    const y = ym(p, a, e);
    if (y && y.from <= f && y.to >= m) {
      const v = ge.create(l, y.from, y.to);
      t.setSelection(v);
    }
  }
  return !0;
}, O$ = (n) => (e) => {
  const t = typeof n == "function" ? n(e) : n;
  for (let r = 0; r < t.length; r += 1)
    if (t[r](e))
      return !0;
  return !1;
};
function D$() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function xm() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var R$ = (n = null, e = {}) => ({ editor: t, view: r, tr: o, dispatch: a }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const l = () => {
    (xm() || D$()) && r.dom.focus(), requestAnimationFrame(() => {
      t.isDestroyed || (r.focus(), e != null && e.scrollIntoView && t.commands.scrollIntoView());
    });
  };
  if (r.hasFocus() && n === null || n === !1)
    return !0;
  if (a && n === null && !wm(t.state.selection))
    return l(), !0;
  const d = _1(o.doc, n) || t.state.selection, p = t.state.selection.eq(d);
  return a && (p || o.setSelection(d), p && o.storedMarks && o.setStoredMarks(o.storedMarks), l()), !0;
}, F$ = (n, e) => (t) => n.every((r, o) => e(r, { ...t, index: o })), P$ = (n, e) => ({ tr: t, commands: r }) => r.insertContentAt({ from: t.selection.from, to: t.selection.to }, n, e), $$ = (n) => !("type" in n), j$ = (n, e, t) => ({ tr: r, dispatch: o, editor: a }) => {
  var l;
  if (o) {
    t = {
      parseOptions: a.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...t
    };
    let d;
    const p = (B) => {
      a.emit("contentError", {
        editor: a,
        error: B,
        disableCollaboration: () => {
          "collaboration" in a.storage && typeof a.storage.collaboration == "object" && a.storage.collaboration && (a.storage.collaboration.isDisabled = !0);
        }
      });
    }, f = {
      preserveWhitespace: "full",
      ...t.parseOptions
    };
    if (!t.errorOnInvalidContent && !a.options.enableContentCheck && a.options.emitContentError)
      try {
        Mo(e, a.schema, {
          parseOptions: f,
          errorOnInvalidContent: !0
        });
      } catch (B) {
        p(B);
      }
    try {
      d = Mo(e, a.schema, {
        parseOptions: f,
        errorOnInvalidContent: (l = t.errorOnInvalidContent) != null ? l : a.options.enableContentCheck
      });
    } catch (B) {
      return p(B), !1;
    }
    let { from: m, to: y } = typeof n == "number" ? { from: n, to: n } : { from: n.from, to: n.to }, v = !0, k = !0;
    if (($$(d) ? d : [d]).forEach((B) => {
      B.check(), v = v ? B.isText && B.marks.length === 0 : !1, k = k ? B.isBlock : !1;
    }), m === y && k) {
      const { parent: B } = r.doc.resolve(m);
      B.isTextblock && !B.type.spec.code && !B.childCount && (m -= 1, y += 1);
    }
    let S;
    if (v) {
      if (Array.isArray(e))
        S = e.map((B) => B.text || "").join("");
      else if (e instanceof X) {
        let B = "";
        e.forEach((O) => {
          O.text && (B += O.text);
        }), S = B;
      } else typeof e == "object" && e && e.text ? S = e.text : S = e;
      r.insertText(S, m, y);
    } else {
      S = d;
      const B = r.doc.resolve(m), O = B.node(), L = B.parentOffset === 0, G = O.isText || O.isTextblock, Y = O.content.size > 0;
      L && G && Y && (m = Math.max(0, m - 1)), r.replaceWith(m, y, S);
    }
    t.updateSelection && c$(r, r.steps.length - 1, -1), t.applyInputRules && r.setMeta("applyInputRules", { from: m, text: S }), t.applyPasteRules && r.setMeta("applyPasteRules", { from: m, text: S });
  }
  return !0;
}, U$ = () => ({ state: n, dispatch: e }) => TP(n, e), L$ = () => ({ state: n, dispatch: e }) => NP(n, e), H$ = () => ({ state: n, dispatch: e }) => A1(n, e), G$ = () => ({ state: n, dispatch: e }) => T1(n, e), _$ = () => ({ state: n, dispatch: e, tr: t }) => {
  try {
    const r = nd(n.doc, n.selection.$from.pos, -1);
    return r == null ? !1 : (t.join(r, 2), e && e(t), !0);
  } catch {
    return !1;
  }
}, z$ = () => ({ state: n, dispatch: e, tr: t }) => {
  try {
    const r = nd(n.doc, n.selection.$from.pos, 1);
    return r == null ? !1 : (t.join(r, 2), e && e(t), !0);
  } catch {
    return !1;
  }
}, q$ = () => ({ state: n, dispatch: e }) => SP(n, e), V$ = () => ({ state: n, dispatch: e }) => EP(n, e);
function W1() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function X$(n) {
  const e = n.split(/-(?!$)/);
  let t = e[e.length - 1];
  t === "Space" && (t = " ");
  let r, o, a, l;
  for (let d = 0; d < e.length - 1; d += 1) {
    const p = e[d];
    if (/^(cmd|meta|m)$/i.test(p))
      l = !0;
    else if (/^a(lt)?$/i.test(p))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(p))
      o = !0;
    else if (/^s(hift)?$/i.test(p))
      a = !0;
    else if (/^mod$/i.test(p))
      xm() || W1() ? l = !0 : o = !0;
    else
      throw new Error(`Unrecognized modifier name: ${p}`);
  }
  return r && (t = `Alt-${t}`), o && (t = `Ctrl-${t}`), l && (t = `Meta-${t}`), a && (t = `Shift-${t}`), t;
}
var J$ = (n) => ({ editor: e, view: t, tr: r, dispatch: o }) => {
  const a = X$(n).split(/-(?!$)/), l = a.find((f) => !["Alt", "Ctrl", "Meta", "Shift"].includes(f)), d = new KeyboardEvent("keydown", {
    key: l === "Space" ? " " : l,
    altKey: a.includes("Alt"),
    ctrlKey: a.includes("Ctrl"),
    metaKey: a.includes("Meta"),
    shiftKey: a.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), p = e.captureTransaction(() => {
    t.someProp("handleKeyDown", (f) => f(t, d));
  });
  return p == null || p.steps.forEach((f) => {
    const m = f.map(r.mapping);
    m && o && r.maybeStep(m);
  }), !0;
}, K$ = (n, e = {}) => ({ state: t, dispatch: r }) => {
  const o = Rt(n, t.schema);
  return wl(t, o, e) ? BP(t, r) : !1;
}, W$ = () => ({ state: n, dispatch: e }) => M1(n, e), Y$ = (n) => ({ state: e, dispatch: t }) => {
  const r = Rt(n, e.schema);
  return HP(r)(e, t);
}, Q$ = () => ({ state: n, dispatch: e }) => B1(n, e);
function Iv(n, e) {
  const t = typeof e == "string" ? [e] : e;
  return Object.keys(n).reduce((r, o) => (t.includes(o) || (r[o] = n[o]), r), {});
}
var Z$ = (n, e) => ({ tr: t, state: r, dispatch: o }) => {
  let a = null, l = null;
  const d = ud(
    typeof n == "string" ? n : n.name,
    r.schema
  );
  return d ? (d === "node" && (a = Rt(n, r.schema)), d === "mark" && (l = ei(n, r.schema)), o && t.selection.ranges.forEach((p) => {
    r.doc.nodesBetween(p.$from.pos, p.$to.pos, (f, m) => {
      a && a === f.type && t.setNodeMarkup(m, void 0, Iv(f.attrs, e)), l && f.marks.length && f.marks.forEach((y) => {
        l === y.type && t.addMark(m, m + f.nodeSize, l.create(Iv(y.attrs, e)));
      });
    });
  }), !0) : !1;
}, e5 = () => ({ tr: n, dispatch: e }) => (e && n.scrollIntoView(), !0), t5 = () => ({ tr: n, dispatch: e }) => {
  if (e) {
    const t = new gn(n.doc);
    n.setSelection(t);
  }
  return !0;
}, n5 = () => ({ state: n, dispatch: e }) => S1(n, e), r5 = () => ({ state: n, dispatch: e }) => N1(n, e), i5 = () => ({ state: n, dispatch: e }) => DP(n, e), o5 = () => ({ state: n, dispatch: e }) => PP(n, e), s5 = () => ({ state: n, dispatch: e }) => FP(n, e), a5 = (n, { errorOnInvalidContent: e, emitUpdate: t = !0, parseOptions: r = {} } = {}) => ({ editor: o, tr: a, dispatch: l, commands: d }) => {
  const { doc: p } = a;
  if (r.preserveWhitespace !== "full") {
    const f = cf(n, o.schema, r, {
      errorOnInvalidContent: e ?? o.options.enableContentCheck
    });
    return l && a.replaceWith(0, p.content.size, f).setMeta("preventUpdate", !t), !0;
  }
  return l && a.setMeta("preventUpdate", !t), d.insertContentAt({ from: 0, to: p.content.size }, n, {
    parseOptions: r,
    errorOnInvalidContent: e ?? o.options.enableContentCheck
  });
};
function l5(n, e, t) {
  var r;
  const { selection: o } = e;
  let a = null;
  if (wm(o) && (a = o.$cursor), a) {
    const d = (r = n.storedMarks) != null ? r : a.marks();
    return a.parent.type.allowsMarkType(t) && (!!t.isInSet(d) || !d.some((f) => f.type.excludes(t)));
  }
  const { ranges: l } = o;
  return l.some(({ $from: d, $to: p }) => {
    let f = d.depth === 0 ? n.doc.inlineContent && n.doc.type.allowsMarkType(t) : !1;
    return n.doc.nodesBetween(d.pos, p.pos, (m, y, v) => {
      if (f)
        return !1;
      if (m.isInline) {
        const k = !v || v.type.allowsMarkType(t), A = !!t.isInSet(m.marks) || !m.marks.some((S) => S.type.excludes(t));
        f = k && A;
      }
      return !f;
    }), f;
  });
}
var c5 = (n, e = {}) => ({ tr: t, state: r, dispatch: o }) => {
  const { selection: a } = t, { empty: l, ranges: d } = a, p = ei(n, r.schema);
  if (o)
    if (l) {
      const f = H1(r, p);
      t.addStoredMark(
        p.create({
          ...f,
          ...e
        })
      );
    } else
      d.forEach((f) => {
        const m = f.$from.pos, y = f.$to.pos;
        r.doc.nodesBetween(m, y, (v, k) => {
          const A = Math.max(k, m), S = Math.min(k + v.nodeSize, y);
          v.marks.find((O) => O.type === p) ? v.marks.forEach((O) => {
            p === O.type && t.addMark(
              A,
              S,
              p.create({
                ...O.attrs,
                ...e
              })
            );
          }) : t.addMark(A, S, p.create(e));
        });
      });
  return l5(r, t, p);
}, u5 = (n, e) => ({ tr: t }) => (t.setMeta(n, e), !0), d5 = (n, e = {}) => ({ state: t, dispatch: r, chain: o }) => {
  const a = Rt(n, t.schema);
  let l;
  return t.selection.$anchor.sameParent(t.selection.$head) && (l = t.selection.$anchor.parent.attrs), a.isTextblock ? o().command(({ commands: d }) => Av(a, { ...l, ...e })(t) ? !0 : d.clearNodes()).command(({ state: d }) => Av(a, { ...l, ...e })(d, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, p5 = (n) => ({ tr: e, dispatch: t }) => {
  if (t) {
    const { doc: r } = e, o = qr(n, 0, r.content.size), a = fe.create(r, o);
    e.setSelection(a);
  }
  return !0;
}, h5 = (n) => ({ tr: e, dispatch: t }) => {
  if (t) {
    const { doc: r } = e, { from: o, to: a } = typeof n == "number" ? { from: n, to: n } : n, l = ge.atStart(r).from, d = ge.atEnd(r).to, p = qr(o, l, d), f = qr(a, l, d), m = ge.create(r, p, f);
    e.setSelection(m);
  }
  return !0;
}, f5 = (n) => ({ state: e, dispatch: t }) => {
  const r = Rt(n, e.schema);
  return zP(r)(e, t);
};
function Mv(n, e) {
  const t = n.storedMarks || n.selection.$to.parentOffset && n.selection.$from.marks();
  if (t) {
    const r = t.filter((o) => e == null ? void 0 : e.includes(o.type.name));
    n.tr.ensureMarks(r);
  }
}
var m5 = ({ keepMarks: n = !0 } = {}) => ({ tr: e, state: t, dispatch: r, editor: o }) => {
  const { selection: a, doc: l } = e, { $from: d, $to: p } = a, f = o.extensionManager.attributes, m = pu(f, d.node().type.name, d.node().attrs);
  if (a instanceof fe && a.node.isBlock)
    return !d.parentOffset || !Vr(l, d.pos) ? !1 : (r && (n && Mv(t, o.extensionManager.splittableMarks), e.split(d.pos).scrollIntoView()), !0);
  if (!d.parent.isBlock)
    return !1;
  const y = p.parentOffset === p.parent.content.size, v = d.depth === 0 ? void 0 : JP(d.node(-1).contentMatchAt(d.indexAfter(-1)));
  let k = y && v ? [
    {
      type: v,
      attrs: m
    }
  ] : void 0, A = Vr(e.doc, e.mapping.map(d.pos), 1, k);
  if (!k && !A && Vr(e.doc, e.mapping.map(d.pos), 1, v ? [{ type: v }] : void 0) && (A = !0, k = v ? [
    {
      type: v,
      attrs: m
    }
  ] : void 0), r) {
    if (A && (a instanceof ge && e.deleteSelection(), e.split(e.mapping.map(d.pos), 1, k), v && !y && !d.parentOffset && d.parent.type !== v)) {
      const S = e.mapping.map(d.before()), B = e.doc.resolve(S);
      d.node(-1).canReplaceWith(B.index(), B.index() + 1, v) && e.setNodeMarkup(e.mapping.map(d.before()), v);
    }
    n && Mv(t, o.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return A;
}, g5 = (n, e = {}) => ({ tr: t, state: r, dispatch: o, editor: a }) => {
  var l;
  const d = Rt(n, r.schema), { $from: p, $to: f } = r.selection, m = r.selection.node;
  if (m && m.isBlock || p.depth < 2 || !p.sameParent(f))
    return !1;
  const y = p.node(-1);
  if (y.type !== d)
    return !1;
  const v = a.extensionManager.attributes;
  if (p.parent.content.size === 0 && p.node(-1).childCount === p.indexAfter(-1)) {
    if (p.depth === 2 || p.node(-3).type !== d || p.index(-2) !== p.node(-2).childCount - 1)
      return !1;
    if (o) {
      let O = X.empty;
      const L = p.index(-1) ? 1 : p.index(-2) ? 2 : 3;
      for (let U = p.depth - L; U >= p.depth - 3; U -= 1)
        O = X.from(p.node(U).copy(O));
      const G = (
        // eslint-disable-next-line no-nested-ternary
        p.indexAfter(-1) < p.node(-2).childCount ? 1 : p.indexAfter(-2) < p.node(-3).childCount ? 2 : 3
      ), Y = {
        ...pu(v, p.node().type.name, p.node().attrs),
        ...e
      }, z = ((l = d.contentMatch.defaultType) == null ? void 0 : l.createAndFill(Y)) || void 0;
      O = O.append(X.from(d.createAndFill(null, z) || void 0));
      const M = p.before(p.depth - (L - 1));
      t.replace(M, p.after(-G), new ne(O, 4 - L, 0));
      let ee = -1;
      t.doc.nodesBetween(M, t.doc.content.size, (U, K) => {
        if (ee > -1)
          return !1;
        U.isTextblock && U.content.size === 0 && (ee = K + 1);
      }), ee > -1 && t.setSelection(ge.near(t.doc.resolve(ee))), t.scrollIntoView();
    }
    return !0;
  }
  const k = f.pos === p.end() ? y.contentMatchAt(0).defaultType : null, A = {
    ...pu(v, y.type.name, y.attrs),
    ...e
  }, S = {
    ...pu(v, p.node().type.name, p.node().attrs),
    ...e
  };
  t.delete(p.pos, f.pos);
  const B = k ? [
    { type: d, attrs: A },
    { type: k, attrs: S }
  ] : [{ type: d, attrs: A }];
  if (!Vr(t.doc, p.pos, 2))
    return !1;
  if (o) {
    const { selection: O, storedMarks: L } = r, { splittableMarks: G } = a.extensionManager, Y = L || O.$to.parentOffset && O.$from.marks();
    if (t.split(p.pos, 2, B).scrollIntoView(), !Y || !o)
      return !0;
    const z = Y.filter((M) => G.includes(M.type.name));
    t.ensureMarks(z);
  }
  return !0;
}, kh = (n, e) => {
  const t = dm((l) => l.type === e)(n.selection);
  if (!t)
    return !0;
  const r = n.doc.resolve(Math.max(0, t.pos - 1)).before(t.depth);
  if (r === void 0)
    return !0;
  const o = n.doc.nodeAt(r);
  return t.node.type === (o == null ? void 0 : o.type) && Hi(n.doc, t.pos) && n.join(t.pos), !0;
}, Ah = (n, e) => {
  const t = dm((l) => l.type === e)(n.selection);
  if (!t)
    return !0;
  const r = n.doc.resolve(t.start).after(t.depth);
  if (r === void 0)
    return !0;
  const o = n.doc.nodeAt(r);
  return t.node.type === (o == null ? void 0 : o.type) && Hi(n.doc, r) && n.join(r), !0;
}, y5 = (n, e, t, r = {}) => ({ editor: o, tr: a, state: l, dispatch: d, chain: p, commands: f, can: m }) => {
  const { extensions: y, splittableMarks: v } = o.extensionManager, k = Rt(n, l.schema), A = Rt(e, l.schema), { selection: S, storedMarks: B } = l, { $from: O, $to: L } = S, G = O.blockRange(L), Y = B || S.$to.parentOffset && S.$from.marks();
  if (!G)
    return !1;
  const z = dm((M) => Bv(M.type.name, y))(S);
  if (G.depth >= 1 && z && G.depth - z.depth <= 1) {
    if (z.node.type === k)
      return f.liftListItem(A);
    if (Bv(z.node.type.name, y) && k.validContent(z.node.content) && d)
      return p().command(() => (a.setNodeMarkup(z.pos, k), !0)).command(() => kh(a, k)).command(() => Ah(a, k)).run();
  }
  return !t || !Y || !d ? p().command(() => m().wrapInList(k, r) ? !0 : f.clearNodes()).wrapInList(k, r).command(() => kh(a, k)).command(() => Ah(a, k)).run() : p().command(() => {
    const M = m().wrapInList(k, r), ee = Y.filter((U) => v.includes(U.type.name));
    return a.ensureMarks(ee), M ? !0 : f.clearNodes();
  }).wrapInList(k, r).command(() => kh(a, k)).command(() => Ah(a, k)).run();
}, w5 = (n, e = {}, t = {}) => ({ state: r, commands: o }) => {
  const { extendEmptyMarkRange: a = !1 } = t, l = ei(n, r.schema);
  return uf(r, l, e) ? o.unsetMark(l, { extendEmptyMarkRange: a }) : o.setMark(l, e);
}, b5 = (n, e, t = {}) => ({ state: r, commands: o }) => {
  const a = Rt(n, r.schema), l = Rt(e, r.schema), d = wl(r, a, t);
  let p;
  return r.selection.$anchor.sameParent(r.selection.$head) && (p = r.selection.$anchor.parent.attrs), d ? o.setNode(l, p) : o.setNode(a, { ...p, ...t });
}, v5 = (n, e = {}) => ({ state: t, commands: r }) => {
  const o = Rt(n, t.schema);
  return wl(t, o, e) ? r.lift(o) : r.wrapIn(o, e);
}, x5 = () => ({ state: n, dispatch: e }) => {
  const t = n.plugins;
  for (let r = 0; r < t.length; r += 1) {
    const o = t[r];
    let a;
    if (o.spec.isInputRules && (a = o.getState(n))) {
      if (e) {
        const l = n.tr, d = a.transform;
        for (let p = d.steps.length - 1; p >= 0; p -= 1)
          l.step(d.steps[p].invert(d.docs[p]));
        if (a.text) {
          const p = l.doc.resolve(a.from).marks();
          l.replaceWith(a.from, a.to, n.schema.text(a.text, p));
        } else
          l.delete(a.from, a.to);
      }
      return !0;
    }
  }
  return !1;
}, k5 = () => ({ tr: n, dispatch: e }) => {
  const { selection: t } = n, { empty: r, ranges: o } = t;
  return r || e && o.forEach((a) => {
    n.removeMark(a.$from.pos, a.$to.pos);
  }), !0;
}, A5 = (n, e = {}) => ({ tr: t, state: r, dispatch: o }) => {
  var a;
  const { extendEmptyMarkRange: l = !1 } = e, { selection: d } = t, p = ei(n, r.schema), { $from: f, empty: m, ranges: y } = d;
  if (!o)
    return !0;
  if (m && l) {
    let { from: v, to: k } = d;
    const A = (a = f.marks().find((B) => B.type === p)) == null ? void 0 : a.attrs, S = ym(f, p, A);
    S && (v = S.from, k = S.to), t.removeMark(v, k, p);
  } else
    y.forEach((v) => {
      t.removeMark(v.$from.pos, v.$to.pos, p);
    });
  return t.removeStoredMark(p), !0;
}, C5 = (n, e = {}) => ({ tr: t, state: r, dispatch: o }) => {
  let a = null, l = null;
  const d = ud(
    typeof n == "string" ? n : n.name,
    r.schema
  );
  return d ? (d === "node" && (a = Rt(n, r.schema)), d === "mark" && (l = ei(n, r.schema)), o && t.selection.ranges.forEach((p) => {
    const f = p.$from.pos, m = p.$to.pos;
    let y, v, k, A;
    t.selection.empty ? r.doc.nodesBetween(f, m, (S, B) => {
      a && a === S.type && (k = Math.max(B, f), A = Math.min(B + S.nodeSize, m), y = B, v = S);
    }) : r.doc.nodesBetween(f, m, (S, B) => {
      B < f && a && a === S.type && (k = Math.max(B, f), A = Math.min(B + S.nodeSize, m), y = B, v = S), B >= f && B <= m && (a && a === S.type && t.setNodeMarkup(B, void 0, {
        ...S.attrs,
        ...e
      }), l && S.marks.length && S.marks.forEach((O) => {
        if (l === O.type) {
          const L = Math.max(B, f), G = Math.min(B + S.nodeSize, m);
          t.addMark(
            L,
            G,
            l.create({
              ...O.attrs,
              ...e
            })
          );
        }
      }));
    }), v && (y !== void 0 && t.setNodeMarkup(y, void 0, {
      ...v.attrs,
      ...e
    }), l && v.marks.length && v.marks.forEach((S) => {
      l === S.type && t.addMark(
        k,
        A,
        l.create({
          ...S.attrs,
          ...e
        })
      );
    }));
  }), !0) : !1;
}, S5 = (n, e = {}) => ({ state: t, dispatch: r }) => {
  const o = Rt(n, t.schema);
  return $P(o, e)(t, r);
}, E5 = (n, e = {}) => ({ state: t, dispatch: r }) => {
  const o = Rt(n, t.schema);
  return jP(o, e)(t, r);
}, Y1 = yt.create({
  name: "commands",
  addCommands() {
    return {
      ...K1
    };
  }
}), Q1 = yt.create({
  name: "delete",
  onUpdate({ transaction: n, appendedTransactions: e }) {
    var t, r, o;
    const a = () => {
      var l, d, p, f;
      if ((f = (p = (d = (l = this.editor.options.coreExtensionOptions) == null ? void 0 : l.delete) == null ? void 0 : d.filterTransaction) == null ? void 0 : p.call(d, n)) != null ? f : n.getMeta("y-sync$"))
        return;
      const m = XP(n.before, [n, ...e]);
      i$(m).forEach((k) => {
        m.mapping.mapResult(k.oldRange.from).deletedAfter && m.mapping.mapResult(k.oldRange.to).deletedBefore && m.before.nodesBetween(k.oldRange.from, k.oldRange.to, (A, S) => {
          const B = S + A.nodeSize - 2, O = k.oldRange.from <= S && B <= k.oldRange.to;
          this.editor.emit("delete", {
            type: "node",
            node: A,
            from: S,
            to: B,
            newFrom: m.mapping.map(S),
            newTo: m.mapping.map(B),
            deletedRange: k.oldRange,
            newRange: k.newRange,
            partial: !O,
            editor: this.editor,
            transaction: n,
            combinedTransform: m
          });
        });
      });
      const v = m.mapping;
      m.steps.forEach((k, A) => {
        var S, B;
        if (k instanceof Jn) {
          const O = v.slice(A).map(k.from, -1), L = v.slice(A).map(k.to), G = v.invert().map(O, -1), Y = v.invert().map(L), z = (S = m.doc.nodeAt(O - 1)) == null ? void 0 : S.marks.some((ee) => ee.eq(k.mark)), M = (B = m.doc.nodeAt(L)) == null ? void 0 : B.marks.some((ee) => ee.eq(k.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: k.mark,
            from: k.from,
            to: k.to,
            deletedRange: {
              from: G,
              to: Y
            },
            newRange: {
              from: O,
              to: L
            },
            partial: !!(M || z),
            editor: this.editor,
            transaction: n,
            combinedTransform: m
          });
        }
      });
    };
    (o = (r = (t = this.editor.options.coreExtensionOptions) == null ? void 0 : t.delete) == null ? void 0 : r.async) == null || o ? setTimeout(a, 0) : a();
  }
}), Z1 = yt.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new ot({
        key: new pt("tiptapDrop"),
        props: {
          handleDrop: (n, e, t, r) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: t,
              moved: r
            });
          }
        }
      })
    ];
  }
}), eA = yt.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new ot({
        key: new pt("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), tA = new pt("focusEvents"), nA = yt.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: n } = this;
    return [
      new ot({
        key: tA,
        props: {
          handleDOMEvents: {
            focus: (e, t) => {
              n.isFocused = !0;
              const r = n.state.tr.setMeta("focus", { event: t }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            },
            blur: (e, t) => {
              n.isFocused = !1;
              const r = n.state.tr.setMeta("blur", { event: t }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), rA = yt.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const n = () => this.editor.commands.first(({ commands: l }) => [
      () => l.undoInputRule(),
      // maybe convert first text block node to default node
      () => l.command(({ tr: d }) => {
        const { selection: p, doc: f } = d, { empty: m, $anchor: y } = p, { pos: v, parent: k } = y, A = y.parent.isTextblock && v > 0 ? d.doc.resolve(v - 1) : y, S = A.parent.type.spec.isolating, B = y.pos - y.parentOffset, O = S && A.parent.childCount === 1 ? B === y.pos : ve.atStart(f).from === v;
        return !m || !k.type.isTextblock || k.textContent.length || !O || O && y.parent.type.name === "paragraph" ? !1 : l.clearNodes();
      }),
      () => l.deleteSelection(),
      () => l.joinBackward(),
      () => l.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: l }) => [
      () => l.deleteSelection(),
      () => l.deleteCurrentNode(),
      () => l.joinForward(),
      () => l.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: l }) => [
        () => l.newlineInCode(),
        () => l.createParagraphNear(),
        () => l.liftEmptyBlock(),
        () => l.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: n,
      "Mod-Backspace": n,
      "Shift-Backspace": n,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, o = {
      ...r
    }, a = {
      ...r,
      "Ctrl-h": n,
      "Alt-Backspace": n,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return xm() || W1() ? a : o;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new ot({
        key: new pt("clearDocument"),
        appendTransaction: (n, e, t) => {
          if (n.some((S) => S.getMeta("composition")))
            return;
          const r = n.some((S) => S.docChanged) && !e.doc.eq(t.doc), o = n.some((S) => S.getMeta("preventClearDocument"));
          if (!r || o)
            return;
          const { empty: a, from: l, to: d } = e.selection, p = ve.atStart(e.doc).from, f = ve.atEnd(e.doc).to;
          if (a || !(l === p && d === f) || !dd(t.doc))
            return;
          const v = t.tr, k = ld({
            state: t,
            transaction: v
          }), { commands: A } = new cd({
            editor: this.editor,
            state: k
          });
          if (A.clearNodes(), !!v.steps.length)
            return v;
        }
      })
    ];
  }
}), iA = yt.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new ot({
        key: new pt("tiptapPaste"),
        props: {
          handlePaste: (n, e, t) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: t
            });
          }
        }
      })
    ];
  }
}), oA = yt.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new ot({
        key: new pt("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
}), T5 = class Os {
  constructor(e, t, r = !1, o = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = e, this.editor = t, this.currentNode = o;
  }
  get name() {
    return this.node.type.name;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) != null ? e : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let t = this.from, r = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      t = this.from + 1, r = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: t, to: r }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1), t = this.resolvedPos.doc.resolve(e);
    return new Os(t, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new Os(e, this.editor);
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new Os(e, this.editor);
  }
  get children() {
    const e = [];
    return this.node.content.forEach((t, r) => {
      const o = t.isBlock && !t.isTextblock, a = t.isAtom && !t.isText, l = this.pos + r + (a ? 0 : 1);
      if (l < 0 || l > this.resolvedPos.doc.nodeSize - 2)
        return;
      const d = this.resolvedPos.doc.resolve(l);
      if (!o && d.depth <= this.depth)
        return;
      const p = new Os(d, this.editor, o, o ? t : null);
      o && (p.actualDepth = this.depth + 1), e.push(new Os(d, this.editor, o, o ? t : null));
    }), e;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, t = {}) {
    let r = null, o = this.parent;
    for (; o && !r; ) {
      if (o.node.type.name === e)
        if (Object.keys(t).length > 0) {
          const a = o.node.attrs, l = Object.keys(t);
          for (let d = 0; d < l.length; d += 1) {
            const p = l[d];
            if (a[p] !== t[p])
              break;
          }
        } else
          r = o;
      o = o.parent;
    }
    return r;
  }
  querySelector(e, t = {}) {
    return this.querySelectorAll(e, t, !0)[0] || null;
  }
  querySelectorAll(e, t = {}, r = !1) {
    let o = [];
    if (!this.children || this.children.length === 0)
      return o;
    const a = Object.keys(t);
    return this.children.forEach((l) => {
      r && o.length > 0 || (l.node.type.name === e && a.every((p) => t[p] === l.node.attrs[p]) && o.push(l), !(r && o.length > 0) && (o = o.concat(l.querySelectorAll(e, t, r))));
    }), o;
  }
  setAttribute(e) {
    const { tr: t } = this.editor.state;
    t.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...e
    }), this.editor.view.dispatch(t);
  }
}, N5 = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}`;
function B5(n, e, t) {
  const r = document.querySelector("style[data-tiptap-style]");
  if (r !== null)
    return r;
  const o = document.createElement("style");
  return e && o.setAttribute("nonce", e), o.setAttribute("data-tiptap-style", ""), o.innerHTML = n, document.getElementsByTagName("head")[0].appendChild(o), o;
}
var I5 = class extends VP {
  constructor(n = {}) {
    super(), this.css = null, this.editorView = null, this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.instanceId = Math.random().toString(36).slice(2, 9), this.options = {
      element: typeof document < "u" ? document.createElement("div") : null,
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      emitContentError: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onMount: () => null,
      onUnmount: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: r }) => {
        throw r;
      },
      onPaste: () => null,
      onDrop: () => null,
      onDelete: () => null
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(n), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("mount", this.options.onMount), this.on("unmount", this.options.onUnmount), this.on("contentError", this.options.onContentError), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: r, slice: o, moved: a }) => this.options.onDrop(r, o, a)), this.on("paste", ({ event: r, slice: o }) => this.options.onPaste(r, o)), this.on("delete", this.options.onDelete);
    const e = this.createDoc(), t = _1(e, this.options.autofocus);
    this.editorState = Rs.create({
      doc: e,
      schema: this.schema,
      selection: t || void 0
    }), this.options.element && this.mount(this.options.element);
  }
  /**
   * Attach the editor to the DOM, creating a new editor view.
   */
  mount(n) {
    if (typeof document > "u")
      throw new Error(
        "[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment."
      );
    this.createView(n), this.emit("mount", { editor: this }), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Remove the editor from the DOM, but still allow remounting at a different point in time
   */
  unmount() {
    if (this.editorView) {
      const n = this.editorView.dom;
      n != null && n.editor && delete n.editor, this.editorView.destroy();
    }
    if (this.editorView = null, this.isInitialized = !1, this.css)
      try {
        typeof this.css.remove == "function" ? this.css.remove() : this.css.parentNode && this.css.parentNode.removeChild(this.css);
      } catch (n) {
        console.warn("Failed to remove CSS element:", n);
      }
    this.css = null, this.emit("unmount", { editor: this });
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && typeof document < "u" && (this.css = B5(N5, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(n = {}) {
    this.options = {
      ...this.options,
      ...n
    }, !(!this.editorView || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(n, e = !0) {
    this.setOptions({ editable: n }), e && this.emit("update", { editor: this, transaction: this.state.tr, appendedTransactions: [] });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get view() {
    return this.editorView ? this.editorView : new Proxy(
      {
        state: this.editorState,
        updateState: (n) => {
          this.editorState = n;
        },
        dispatch: (n) => {
          this.editorState = this.state.apply(n);
        },
        // Stub some commonly accessed properties to prevent errors
        composing: !1,
        dragging: null,
        editable: !0,
        isDestroyed: !1
      },
      {
        get: (n, e) => {
          if (e === "state")
            return this.editorState;
          if (e in n)
            return Reflect.get(n, e);
          throw new Error(
            `[tiptap error]: The editor view is not available. Cannot access view['${e}']. The editor may not be mounted yet.`
          );
        }
      }
    );
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.editorView && (this.editorState = this.view.state), this.editorState;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(n, e) {
    const t = P1(e) ? e(n, [...this.state.plugins]) : [...this.state.plugins, n], r = this.state.reconfigure({ plugins: t });
    return this.view.updateState(r), r;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(n) {
    if (this.isDestroyed)
      return;
    const e = this.state.plugins;
    let t = e;
    if ([].concat(n).forEach((o) => {
      const a = typeof o == "string" ? `${o}$` : o.key;
      t = t.filter((l) => !l.key.startsWith(a));
    }), e.length === t.length)
      return;
    const r = this.state.reconfigure({
      plugins: t
    });
    return this.view.updateState(r), r;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var n, e;
    const r = [...this.options.enableCoreExtensions ? [
      eA,
      J1.configure({
        blockSeparator: (e = (n = this.options.coreExtensionOptions) == null ? void 0 : n.clipboardTextSerializer) == null ? void 0 : e.blockSeparator
      }),
      Y1,
      nA,
      rA,
      oA,
      Z1,
      iA,
      Q1
    ].filter((o) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[o.name] !== !1 : !0) : [], ...this.options.extensions].filter((o) => ["extension", "node", "mark"].includes(o == null ? void 0 : o.type));
    this.extensionManager = new pd(r, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new cd({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates the initial document.
   */
  createDoc() {
    let n;
    try {
      n = cf(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck
      });
    } catch (e) {
      if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message))
        throw e;
      this.emit("contentError", {
        editor: this,
        error: e,
        disableCollaboration: () => {
          "collaboration" in this.storage && typeof this.storage.collaboration == "object" && this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((t) => t.name !== "collaboration"), this.createExtensionManager();
        }
      }), n = cf(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: !1
      });
    }
    return n;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView(n) {
    var e;
    this.editorView = new x1(n, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(e = this.options.editorProps) == null ? void 0 : e.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: this.editorState,
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
    const t = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(t), this.prependClass(), this.injectCSS();
    const r = this.view.dom;
    r.editor = this;
  }
  /**
   * Creates all node and mark views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(n) {
    this.isCapturingTransaction = !0, n(), this.isCapturingTransaction = !1;
    const e = this.capturedTransaction;
    return this.capturedTransaction = null, e;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(n) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = n;
        return;
      }
      n.steps.forEach((f) => {
        var m;
        return (m = this.capturedTransaction) == null ? void 0 : m.step(f);
      });
      return;
    }
    const { state: e, transactions: t } = this.state.applyTransaction(n), r = !this.state.selection.eq(e.selection), o = t.includes(n), a = this.state;
    if (this.emit("beforeTransaction", {
      editor: this,
      transaction: n,
      nextState: e
    }), !o)
      return;
    this.view.updateState(e), this.emit("transaction", {
      editor: this,
      transaction: n,
      appendedTransactions: t.slice(1)
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: n
    });
    const l = t.findLast((f) => f.getMeta("focus") || f.getMeta("blur")), d = l == null ? void 0 : l.getMeta("focus"), p = l == null ? void 0 : l.getMeta("blur");
    d && this.emit("focus", {
      editor: this,
      event: d.event,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      transaction: l
    }), p && this.emit("blur", {
      editor: this,
      event: p.event,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      transaction: l
    }), !(n.getMeta("preventUpdate") || !t.some((f) => f.docChanged) || a.doc.eq(e.doc)) && this.emit("update", {
      editor: this,
      transaction: n,
      appendedTransactions: t.slice(1)
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(n) {
    return t$(this.state, n);
  }
  isActive(n, e) {
    const t = typeof n == "string" ? n : null, r = typeof n == "string" ? e : n;
    return s$(this.state, t, r);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return hm(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(n) {
    const { blockSeparator: e = `

`, textSerializers: t = {} } = n || {};
    return ZP(this.state.doc, {
      blockSeparator: e,
      textSerializers: {
        ...L1(this.schema),
        ...t
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return dd(this.state.doc);
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy"), this.unmount(), this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var n, e;
    return (e = (n = this.editorView) == null ? void 0 : n.isDestroyed) != null ? e : !0;
  }
  $node(n, e) {
    var t;
    return ((t = this.$doc) == null ? void 0 : t.querySelector(n, e)) || null;
  }
  $nodes(n, e) {
    var t;
    return ((t = this.$doc) == null ? void 0 : t.querySelectorAll(n, e)) || null;
  }
  $pos(n) {
    const e = this.state.doc.resolve(n);
    return new T5(e, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function M5(n) {
  return new bm({
    find: n.find,
    handler: ({ state: e, range: t, match: r }) => {
      const o = e.doc.resolve(t.from), a = Ze(n.getAttributes, void 0, r) || {};
      if (!o.node(-1).canReplaceWith(o.index(-1), o.indexAfter(-1), n.type))
        return null;
      e.tr.delete(t.from, t.to).setBlockType(t.from, t.from, n.type, a);
    }
  });
}
function sA(n) {
  return new bm({
    find: n.find,
    handler: ({ state: e, range: t, match: r }) => {
      let o = n.replace, a = t.from;
      const l = t.to;
      if (r[1]) {
        const d = r[0].lastIndexOf(r[1]);
        o += r[0].slice(d + r[1].length), a += d;
        const p = a - l;
        p > 0 && (o = r[0].slice(d - p, d) + o, a = l);
      }
      e.tr.insertText(o, a, l);
    }
  });
}
function O5(n) {
  return new bm({
    find: n.find,
    handler: ({ state: e, range: t, match: r, chain: o }) => {
      const a = Ze(n.getAttributes, void 0, r) || {}, l = e.tr.delete(t.from, t.to), p = l.doc.resolve(t.from).blockRange(), f = p && Xf(p, n.type, a);
      if (!f)
        return null;
      if (l.wrap(p, f), n.keepMarks && n.editor) {
        const { selection: y, storedMarks: v } = e, { splittableMarks: k } = n.editor.extensionManager, A = v || y.$to.parentOffset && y.$from.marks();
        if (A) {
          const S = A.filter((B) => k.includes(B.type.name));
          l.ensureMarks(S);
        }
      }
      if (n.keepAttributes) {
        const y = n.type.name === "bulletList" || n.type.name === "orderedList" ? "listItem" : "taskList";
        o().updateAttributes(y, a).run();
      }
      const m = l.doc.resolve(t.from - 1).nodeBefore;
      m && m.type === n.type && Hi(l.doc, t.from - 1) && (!n.joinPredicate || n.joinPredicate(r, m)) && l.join(t.from - 1);
    }
  });
}
function D5(n, e, t = {}) {
  const { state: r } = e, { doc: o, tr: a } = r, l = n;
  o.descendants((d, p) => {
    const f = a.mapping.map(p), m = a.mapping.map(p) + d.nodeSize;
    let y = null;
    if (d.marks.forEach((k) => {
      if (k !== l)
        return !1;
      y = k;
    }), !y)
      return;
    let v = !1;
    if (Object.keys(t).forEach((k) => {
      t[k] !== y.attrs[k] && (v = !0);
    }), v) {
      const k = n.type.create({
        ...n.attrs,
        ...t
      });
      a.removeMark(f, m, n.type), a.addMark(f, m, k);
    }
  }), a.docChanged && e.view.dispatch(a);
}
var la = class aA extends vm {
  constructor() {
    super(...arguments), this.type = "node";
  }
  /**
   * Create a new Node instance
   * @param config - Node configuration object or a function that returns a configuration object
   */
  static create(e = {}) {
    const t = typeof e == "function" ? e() : e;
    return new aA(t);
  }
  configure(e) {
    return super.configure(e);
  }
  extend(e) {
    const t = typeof e == "function" ? e() : e;
    return super.extend(t);
  }
};
function R5(n = {}) {
  return new ot({
    view(e) {
      return new F5(e, n);
    }
  });
}
class F5 {
  constructor(e, t) {
    var r;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = t.width) !== null && r !== void 0 ? r : 1, this.color = t.color === !1 ? void 0 : t.color || "black", this.class = t.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((o) => {
      let a = (l) => {
        this[o](l);
      };
      return e.dom.addEventListener(o, a), { name: o, handler: a };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t));
  }
  update(e, t) {
    this.cursorPos != null && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), t = !e.parent.inlineContent, r, o = this.editorView.dom, a = o.getBoundingClientRect(), l = a.width / o.offsetWidth, d = a.height / o.offsetHeight;
    if (t) {
      let y = e.nodeBefore, v = e.nodeAfter;
      if (y || v) {
        let k = this.editorView.nodeDOM(this.cursorPos - (y ? y.nodeSize : 0));
        if (k) {
          let A = k.getBoundingClientRect(), S = y ? A.bottom : A.top;
          y && v && (S = (S + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2);
          let B = this.width / 2 * d;
          r = { left: A.left, right: A.right, top: S - B, bottom: S + B };
        }
      }
    }
    if (!r) {
      let y = this.editorView.coordsAtPos(this.cursorPos), v = this.width / 2 * l;
      r = { left: y.left - v, right: y.left + v, top: y.top, bottom: y.bottom };
    }
    let p = this.editorView.dom.offsetParent;
    this.element || (this.element = p.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", t), this.element.classList.toggle("prosemirror-dropcursor-inline", !t);
    let f, m;
    if (!p || p == document.body && getComputedStyle(p).position == "static")
      f = -pageXOffset, m = -pageYOffset;
    else {
      let y = p.getBoundingClientRect(), v = y.width / p.offsetWidth, k = y.height / p.offsetHeight;
      f = y.left - p.scrollLeft * v, m = y.top - p.scrollTop * k;
    }
    this.element.style.left = (r.left - f) / l + "px", this.element.style.top = (r.top - m) / d + "px", this.element.style.width = (r.right - r.left) / l + "px", this.element.style.height = (r.bottom - r.top) / d + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let t = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), o = r && r.type.spec.disableDropCursor, a = typeof o == "function" ? o(this.editorView, t, e) : o;
    if (t && !a) {
      let l = t.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let d = Rk(this.editorView.state.doc, l, this.editorView.dragging.slice);
        d != null && (l = d);
      }
      this.setCursor(l), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null);
  }
}
class wt extends ve {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    return wt.valid(r) ? new wt(r) : ve.near(r);
  }
  content() {
    return ne.empty;
  }
  eq(e) {
    return e instanceof wt && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new wt(e.resolve(t.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new km(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let t = e.parent;
    if (t.isTextblock || !P5(e) || !$5(e))
      return !1;
    let r = t.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let o = t.contentMatchAt(e.index()).defaultType;
    return o && o.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, t, r = !1) {
    e: for (; ; ) {
      if (!r && wt.valid(e))
        return e;
      let o = e.pos, a = null;
      for (let l = e.depth; ; l--) {
        let d = e.node(l);
        if (t > 0 ? e.indexAfter(l) < d.childCount : e.index(l) > 0) {
          a = d.child(t > 0 ? e.indexAfter(l) : e.index(l) - 1);
          break;
        } else if (l == 0)
          return null;
        o += t;
        let p = e.doc.resolve(o);
        if (wt.valid(p))
          return p;
      }
      for (; ; ) {
        let l = t > 0 ? a.firstChild : a.lastChild;
        if (!l) {
          if (a.isAtom && !a.isText && !fe.isSelectable(a)) {
            e = e.doc.resolve(o + a.nodeSize * t), r = !1;
            continue e;
          }
          break;
        }
        a = l, o += t;
        let d = e.doc.resolve(o);
        if (wt.valid(d))
          return d;
      }
      return null;
    }
  }
}
wt.prototype.visible = !1;
wt.findFrom = wt.findGapCursorFrom;
ve.jsonID("gapcursor", wt);
class km {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new km(e.map(this.pos));
  }
  resolve(e) {
    let t = e.resolve(this.pos);
    return wt.valid(t) ? new wt(t) : ve.near(t);
  }
}
function P5(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.index(e), r = n.node(e);
    if (t == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let o = r.child(t - 1); ; o = o.lastChild) {
      if (o.childCount == 0 && !o.inlineContent || o.isAtom || o.type.spec.isolating)
        return !0;
      if (o.inlineContent)
        return !1;
    }
  }
  return !0;
}
function $5(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.indexAfter(e), r = n.node(e);
    if (t == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let o = r.child(t); ; o = o.firstChild) {
      if (o.childCount == 0 && !o.inlineContent || o.isAtom || o.type.spec.isolating)
        return !0;
      if (o.inlineContent)
        return !1;
    }
  }
  return !0;
}
function j5() {
  return new ot({
    props: {
      decorations: G5,
      createSelectionBetween(n, e, t) {
        return e.pos == t.pos && wt.valid(t) ? new wt(t) : null;
      },
      handleClick: L5,
      handleKeyDown: U5,
      handleDOMEvents: { beforeinput: H5 }
    }
  });
}
const U5 = om({
  ArrowLeft: Kc("horiz", -1),
  ArrowRight: Kc("horiz", 1),
  ArrowUp: Kc("vert", -1),
  ArrowDown: Kc("vert", 1)
});
function Kc(n, e) {
  const t = n == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, o, a) {
    let l = r.selection, d = e > 0 ? l.$to : l.$from, p = l.empty;
    if (l instanceof ge) {
      if (!a.endOfTextblock(t) || d.depth == 0)
        return !1;
      p = !1, d = r.doc.resolve(e > 0 ? d.after() : d.before());
    }
    let f = wt.findGapCursorFrom(d, e, p);
    return f ? (o && o(r.tr.setSelection(new wt(f))), !0) : !1;
  };
}
function L5(n, e, t) {
  if (!n || !n.editable)
    return !1;
  let r = n.state.doc.resolve(e);
  if (!wt.valid(r))
    return !1;
  let o = n.posAtCoords({ left: t.clientX, top: t.clientY });
  return o && o.inside > -1 && fe.isSelectable(n.state.doc.nodeAt(o.inside)) ? !1 : (n.dispatch(n.state.tr.setSelection(new wt(r))), !0);
}
function H5(n, e) {
  if (e.inputType != "insertCompositionText" || !(n.state.selection instanceof wt))
    return !1;
  let { $from: t } = n.state.selection, r = t.parent.contentMatchAt(t.index()).findWrapping(n.state.schema.nodes.text);
  if (!r)
    return !1;
  let o = X.empty;
  for (let l = r.length - 1; l >= 0; l--)
    o = X.from(r[l].createAndFill(null, o));
  let a = n.state.tr.replace(t.pos, t.pos, new ne(o, 0, 0));
  return a.setSelection(ge.near(a.doc.resolve(t.pos + 1))), n.dispatch(a), !1;
}
function G5(n) {
  if (!(n.selection instanceof wt))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", rt.create(n.doc, [It.widget(n.selection.head, e, { key: "gapcursor" })]);
}
var Pu = 200, Ot = function() {
};
Ot.prototype.append = function(e) {
  return e.length ? (e = Ot.from(e), !this.length && e || e.length < Pu && this.leafAppend(e) || this.length < Pu && e.leafPrepend(this) || this.appendInner(e)) : this;
};
Ot.prototype.prepend = function(e) {
  return e.length ? Ot.from(e).append(this) : this;
};
Ot.prototype.appendInner = function(e) {
  return new _5(this, e);
};
Ot.prototype.slice = function(e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? Ot.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t));
};
Ot.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
Ot.prototype.forEach = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length), t <= r ? this.forEachInner(e, t, r, 0) : this.forEachInvertedInner(e, t, r, 0);
};
Ot.prototype.map = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length);
  var o = [];
  return this.forEach(function(a, l) {
    return o.push(e(a, l));
  }, t, r), o;
};
Ot.from = function(e) {
  return e instanceof Ot ? e : e && e.length ? new lA(e) : Ot.empty;
};
var lA = /* @__PURE__ */ function(n) {
  function e(r) {
    n.call(this), this.values = r;
  }
  n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e;
  var t = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(o, a) {
    return o == 0 && a == this.length ? this : new e(this.values.slice(o, a));
  }, e.prototype.getInner = function(o) {
    return this.values[o];
  }, e.prototype.forEachInner = function(o, a, l, d) {
    for (var p = a; p < l; p++)
      if (o(this.values[p], d + p) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(o, a, l, d) {
    for (var p = a - 1; p >= l; p--)
      if (o(this.values[p], d + p) === !1)
        return !1;
  }, e.prototype.leafAppend = function(o) {
    if (this.length + o.length <= Pu)
      return new e(this.values.concat(o.flatten()));
  }, e.prototype.leafPrepend = function(o) {
    if (this.length + o.length <= Pu)
      return new e(o.flatten().concat(this.values));
  }, t.length.get = function() {
    return this.values.length;
  }, t.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, t), e;
}(Ot);
Ot.empty = new lA([]);
var _5 = /* @__PURE__ */ function(n) {
  function e(t, r) {
    n.call(this), this.left = t, this.right = r, this.length = t.length + r.length, this.depth = Math.max(t.depth, r.depth) + 1;
  }
  return n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, o, a, l) {
    var d = this.left.length;
    if (o < d && this.left.forEachInner(r, o, Math.min(a, d), l) === !1 || a > d && this.right.forEachInner(r, Math.max(o - d, 0), Math.min(this.length, a) - d, l + d) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, o, a, l) {
    var d = this.left.length;
    if (o > d && this.right.forEachInvertedInner(r, o - d, Math.max(a, d) - d, l + d) === !1 || a < d && this.left.forEachInvertedInner(r, Math.min(o, d), a, l) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, o) {
    if (r == 0 && o == this.length)
      return this;
    var a = this.left.length;
    return o <= a ? this.left.slice(r, o) : r >= a ? this.right.slice(r - a, o - a) : this.left.slice(r, a).append(this.right.slice(0, o - a));
  }, e.prototype.leafAppend = function(r) {
    var o = this.right.leafAppend(r);
    if (o)
      return new e(this.left, o);
  }, e.prototype.leafPrepend = function(r) {
    var o = this.left.leafPrepend(r);
    if (o)
      return new e(o, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
}(Ot);
const z5 = 500;
class Xn {
  constructor(e, t) {
    this.items = e, this.eventCount = t;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, t) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let o, a;
    t && (o = this.remapping(r, this.items.length), a = o.maps.length);
    let l = e.tr, d, p, f = [], m = [];
    return this.items.forEach((y, v) => {
      if (!y.step) {
        o || (o = this.remapping(r, v + 1), a = o.maps.length), a--, m.push(y);
        return;
      }
      if (o) {
        m.push(new wi(y.map));
        let k = y.step.map(o.slice(a)), A;
        k && l.maybeStep(k).doc && (A = l.mapping.maps[l.mapping.maps.length - 1], f.push(new wi(A, void 0, void 0, f.length + m.length))), a--, A && o.appendMap(A, a);
      } else
        l.maybeStep(y.step);
      if (y.selection)
        return d = o ? y.selection.map(o.slice(a)) : y.selection, p = new Xn(this.items.slice(0, r).append(m.reverse().concat(f)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: p, transform: l, selection: d };
  }
  // Create a new branch with the given transform added.
  addTransform(e, t, r, o) {
    let a = [], l = this.eventCount, d = this.items, p = !o && d.length ? d.get(d.length - 1) : null;
    for (let m = 0; m < e.steps.length; m++) {
      let y = e.steps[m].invert(e.docs[m]), v = new wi(e.mapping.maps[m], y, t), k;
      (k = p && p.merge(v)) && (v = k, m ? a.pop() : d = d.slice(0, d.length - 1)), a.push(v), t && (l++, t = void 0), o || (p = v);
    }
    let f = l - r.depth;
    return f > V5 && (d = q5(d, f), l -= f), new Xn(d.append(a), l);
  }
  remapping(e, t) {
    let r = new pl();
    return this.items.forEach((o, a) => {
      let l = o.mirrorOffset != null && a - o.mirrorOffset >= e ? r.maps.length - o.mirrorOffset : void 0;
      r.appendMap(o.map, l);
    }, e, t), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new Xn(this.items.append(e.map((t) => new wi(t))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, t) {
    if (!this.eventCount)
      return this;
    let r = [], o = Math.max(0, this.items.length - t), a = e.mapping, l = e.steps.length, d = this.eventCount;
    this.items.forEach((v) => {
      v.selection && d--;
    }, o);
    let p = t;
    this.items.forEach((v) => {
      let k = a.getMirror(--p);
      if (k == null)
        return;
      l = Math.min(l, k);
      let A = a.maps[k];
      if (v.step) {
        let S = e.steps[k].invert(e.docs[k]), B = v.selection && v.selection.map(a.slice(p + 1, k));
        B && d++, r.push(new wi(A, S, B));
      } else
        r.push(new wi(A));
    }, o);
    let f = [];
    for (let v = t; v < l; v++)
      f.push(new wi(a.maps[v]));
    let m = this.items.slice(0, o).append(f).append(r), y = new Xn(m, d);
    return y.emptyItemCount() > z5 && (y = y.compress(this.items.length - r.length)), y;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((t) => {
      t.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let t = this.remapping(0, e), r = t.maps.length, o = [], a = 0;
    return this.items.forEach((l, d) => {
      if (d >= e)
        o.push(l), l.selection && a++;
      else if (l.step) {
        let p = l.step.map(t.slice(r)), f = p && p.getMap();
        if (r--, f && t.appendMap(f, r), p) {
          let m = l.selection && l.selection.map(t.slice(r));
          m && a++;
          let y = new wi(f.invert(), p, m), v, k = o.length - 1;
          (v = o.length && o[k].merge(y)) ? o[k] = v : o.push(y);
        }
      } else l.map && r--;
    }, this.items.length, 0), new Xn(Ot.from(o.reverse()), a);
  }
}
Xn.empty = new Xn(Ot.empty, 0);
function q5(n, e) {
  let t;
  return n.forEach((r, o) => {
    if (r.selection && e-- == 0)
      return t = o, !1;
  }), n.slice(t);
}
let wi = class cA {
  constructor(e, t, r, o) {
    this.map = e, this.step = t, this.selection = r, this.mirrorOffset = o;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let t = e.step.merge(this.step);
      if (t)
        return new cA(t.getMap().invert(), t, this.selection);
    }
  }
};
class ki {
  constructor(e, t, r, o, a) {
    this.done = e, this.undone = t, this.prevRanges = r, this.prevTime = o, this.prevComposition = a;
  }
}
const V5 = 20;
function X5(n, e, t, r) {
  let o = t.getMeta(Ao), a;
  if (o)
    return o.historyState;
  t.getMeta(W5) && (n = new ki(n.done, n.undone, null, 0, -1));
  let l = t.getMeta("appendedTransaction");
  if (t.steps.length == 0)
    return n;
  if (l && l.getMeta(Ao))
    return l.getMeta(Ao).redo ? new ki(n.done.addTransform(t, void 0, r, hu(e)), n.undone, Ov(t.mapping.maps), n.prevTime, n.prevComposition) : new ki(n.done, n.undone.addTransform(t, void 0, r, hu(e)), null, n.prevTime, n.prevComposition);
  if (t.getMeta("addToHistory") !== !1 && !(l && l.getMeta("addToHistory") === !1)) {
    let d = t.getMeta("composition"), p = n.prevTime == 0 || !l && n.prevComposition != d && (n.prevTime < (t.time || 0) - r.newGroupDelay || !J5(t, n.prevRanges)), f = l ? Ch(n.prevRanges, t.mapping) : Ov(t.mapping.maps);
    return new ki(n.done.addTransform(t, p ? e.selection.getBookmark() : void 0, r, hu(e)), Xn.empty, f, t.time, d ?? n.prevComposition);
  } else return (a = t.getMeta("rebased")) ? new ki(n.done.rebased(t, a), n.undone.rebased(t, a), Ch(n.prevRanges, t.mapping), n.prevTime, n.prevComposition) : new ki(n.done.addMaps(t.mapping.maps), n.undone.addMaps(t.mapping.maps), Ch(n.prevRanges, t.mapping), n.prevTime, n.prevComposition);
}
function J5(n, e) {
  if (!e)
    return !1;
  if (!n.docChanged)
    return !0;
  let t = !1;
  return n.mapping.maps[0].forEach((r, o) => {
    for (let a = 0; a < e.length; a += 2)
      r <= e[a + 1] && o >= e[a] && (t = !0);
  }), t;
}
function Ov(n) {
  let e = [];
  for (let t = n.length - 1; t >= 0 && e.length == 0; t--)
    n[t].forEach((r, o, a, l) => e.push(a, l));
  return e;
}
function Ch(n, e) {
  if (!n)
    return null;
  let t = [];
  for (let r = 0; r < n.length; r += 2) {
    let o = e.map(n[r], 1), a = e.map(n[r + 1], -1);
    o <= a && t.push(o, a);
  }
  return t;
}
function K5(n, e, t) {
  let r = hu(e), o = Ao.get(e).spec.config, a = (t ? n.undone : n.done).popEvent(e, r);
  if (!a)
    return null;
  let l = a.selection.resolve(a.transform.doc), d = (t ? n.done : n.undone).addTransform(a.transform, e.selection.getBookmark(), o, r), p = new ki(t ? d : a.remaining, t ? a.remaining : d, null, 0, -1);
  return a.transform.setSelection(l).setMeta(Ao, { redo: t, historyState: p });
}
let Sh = !1, Dv = null;
function hu(n) {
  let e = n.plugins;
  if (Dv != e) {
    Sh = !1, Dv = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].spec.historyPreserveItems) {
        Sh = !0;
        break;
      }
  }
  return Sh;
}
const Ao = new pt("history"), W5 = new pt("closeHistory");
function Y5(n = {}) {
  return n = {
    depth: n.depth || 100,
    newGroupDelay: n.newGroupDelay || 500
  }, new ot({
    key: Ao,
    state: {
      init() {
        return new ki(Xn.empty, Xn.empty, null, 0, -1);
      },
      apply(e, t, r) {
        return X5(t, r, e, n);
      }
    },
    config: n,
    props: {
      handleDOMEvents: {
        beforeinput(e, t) {
          let r = t.inputType, o = r == "historyUndo" ? dA : r == "historyRedo" ? pA : null;
          return o ? (t.preventDefault(), o(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function uA(n, e) {
  return (t, r) => {
    let o = Ao.getState(t);
    if (!o || (n ? o.undone : o.done).eventCount == 0)
      return !1;
    if (r) {
      let a = K5(o, t, n);
      a && r(e ? a.scrollIntoView() : a);
    }
    return !0;
  };
}
const dA = uA(!1, !0), pA = uA(!0, !0);
yt.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (n) => n.length,
      wordCounter: (n) => n.split(" ").filter((e) => e !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (n) => {
      const e = (n == null ? void 0 : n.node) || this.editor.state.doc;
      if (((n == null ? void 0 : n.mode) || this.options.mode) === "textSize") {
        const r = e.textBetween(0, e.content.size, void 0, " ");
        return this.options.textCounter(r);
      }
      return e.nodeSize;
    }, this.storage.words = (n) => {
      const e = (n == null ? void 0 : n.node) || this.editor.state.doc, t = e.textBetween(0, e.content.size, " ", " ");
      return this.options.wordCounter(t);
    };
  },
  addProseMirrorPlugins() {
    let n = !1;
    return [
      new ot({
        key: new pt("characterCount"),
        appendTransaction: (e, t, r) => {
          if (n)
            return;
          const o = this.options.limit;
          if (o == null || o === 0) {
            n = !0;
            return;
          }
          const a = this.storage.characters({ node: r.doc });
          if (a > o) {
            const l = a - o, d = 0, p = l;
            console.warn(
              `[CharacterCount] Initial content exceeded limit of ${o} characters. Content was automatically trimmed.`
            );
            const f = r.tr.deleteRange(d, p);
            return n = !0, f;
          }
          n = !0;
        },
        filterTransaction: (e, t) => {
          const r = this.options.limit;
          if (!e.docChanged || r === 0 || r === null || r === void 0)
            return !0;
          const o = this.storage.characters({ node: t.doc }), a = this.storage.characters({ node: e.doc });
          if (a <= r || o > r && a > r && a <= o)
            return !0;
          if (o > r && a > r && a > o || !e.getMeta("paste"))
            return !1;
          const d = e.selection.$head.pos, p = a - r, f = d - p, m = d;
          return e.deleteRange(f, m), !(this.storage.characters({ node: e.doc }) > r);
        }
      })
    ];
  }
});
yt.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [R5(this.options)];
  }
});
yt.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new ot({
        key: new pt("focus"),
        props: {
          decorations: ({ doc: n, selection: e }) => {
            const { isEditable: t, isFocused: r } = this.editor, { anchor: o } = e, a = [];
            if (!t || !r)
              return rt.create(n, []);
            let l = 0;
            this.options.mode === "deepest" && n.descendants((p, f) => {
              if (p.isText)
                return;
              if (!(o >= f && o <= f + p.nodeSize - 1))
                return !1;
              l += 1;
            });
            let d = 0;
            return n.descendants((p, f) => {
              if (p.isText || !(o >= f && o <= f + p.nodeSize - 1))
                return !1;
              if (d += 1, this.options.mode === "deepest" && l - d > 0 || this.options.mode === "shallowest" && d > 1)
                return this.options.mode === "deepest";
              a.push(
                It.node(f, f + p.nodeSize, {
                  class: this.options.className
                })
              );
            }), rt.create(n, a);
          }
        }
      })
    ];
  }
});
yt.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [j5()];
  },
  extendNodeSchema(n) {
    var e;
    const t = {
      name: n.name,
      options: n.options,
      storage: n.storage
    };
    return {
      allowGapCursor: (e = Ze(pe(n, "allowGapCursor", t))) != null ? e : null
    };
  }
});
var Q5 = yt.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something …",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    return [
      new ot({
        key: new pt("placeholder"),
        props: {
          decorations: ({ doc: n, selection: e }) => {
            const t = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: r } = e, o = [];
            if (!t)
              return null;
            const a = this.editor.isEmpty;
            return n.descendants((l, d) => {
              const p = r >= d && r <= d + l.nodeSize, f = !l.isLeaf && dd(l);
              if ((p || !this.options.showOnlyCurrent) && f) {
                const m = [this.options.emptyNodeClass];
                a && m.push(this.options.emptyEditorClass);
                const y = It.node(d, d + l.nodeSize, {
                  class: m.join(" "),
                  "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: l,
                    pos: d,
                    hasAnchor: p
                  }) : this.options.placeholder
                });
                o.push(y);
              }
              return this.options.includeChildren;
            }), rt.create(n, o);
          }
        }
      })
    ];
  }
});
yt.create({
  name: "selection",
  addOptions() {
    return {
      className: "selection"
    };
  },
  addProseMirrorPlugins() {
    const { editor: n, options: e } = this;
    return [
      new ot({
        key: new pt("selection"),
        props: {
          decorations(t) {
            return t.selection.empty || n.isFocused || !n.isEditable || a$(t.selection) || n.view.dragging ? null : rt.create(t.doc, [
              It.inline(t.selection.from, t.selection.to, {
                class: e.className
              })
            ]);
          }
        }
      })
    ];
  }
});
function Rv({ types: n, node: e }) {
  return e && Array.isArray(n) && n.includes(e.type) || (e == null ? void 0 : e.type) === n;
}
yt.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: "paragraph",
      notAfter: []
    };
  },
  addProseMirrorPlugins() {
    const n = new pt(this.name), e = Object.entries(this.editor.schema.nodes).map(([, t]) => t).filter((t) => (this.options.notAfter || []).concat(this.options.node).includes(t.name));
    return [
      new ot({
        key: n,
        appendTransaction: (t, r, o) => {
          const { doc: a, tr: l, schema: d } = o, p = n.getState(o), f = a.content.size, m = d.nodes[this.options.node];
          if (p)
            return l.insert(f, m.create());
        },
        state: {
          init: (t, r) => {
            const o = r.tr.doc.lastChild;
            return !Rv({ node: o, types: e });
          },
          apply: (t, r) => {
            if (!t.docChanged)
              return r;
            const o = t.doc.lastChild;
            return !Rv({ node: o, types: e });
          }
        }
      })
    ];
  }
});
var Z5 = yt.create({
  name: "undoRedo",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: n, dispatch: e }) => dA(n, e),
      redo: () => ({ state: n, dispatch: e }) => pA(n, e)
    };
  },
  addProseMirrorPlugins() {
    return [Y5(this.options)];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
});
const Pn = () => /* @__PURE__ */ new Map(), df = (n) => {
  const e = Pn();
  return n.forEach((t, r) => {
    e.set(r, t);
  }), e;
}, Br = (n, e, t) => {
  let r = n.get(e);
  return r === void 0 && n.set(e, r = t()), r;
}, ej = (n, e) => {
  const t = [];
  for (const [r, o] of n)
    t.push(e(o, r));
  return t;
}, tj = (n, e) => {
  for (const [t, r] of n)
    if (e(r, t))
      return !0;
  return !1;
}, Oo = () => /* @__PURE__ */ new Set(), Eh = (n) => n[n.length - 1], nj = (n, e) => {
  for (let t = 0; t < e.length; t++)
    n.push(e[t]);
}, Fi = Array.from, rj = (n, e) => {
  for (let t = 0; t < n.length; t++)
    if (e(n[t], t, n))
      return !0;
  return !1;
}, pf = Array.isArray;
class hA {
  constructor() {
    this._observers = Pn();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(e, t) {
    return Br(
      this._observers,
      /** @type {string} */
      e,
      Oo
    ).add(t), t;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(e, t) {
    const r = (...o) => {
      this.off(
        e,
        /** @type {any} */
        r
      ), t(...o);
    };
    this.on(
      e,
      /** @type {any} */
      r
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(e, t) {
    const r = this._observers.get(e);
    r !== void 0 && (r.delete(t), r.size === 0 && this._observers.delete(e));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(e, t) {
    return Fi((this._observers.get(e) || Pn()).values()).forEach((r) => r(...t));
  }
  destroy() {
    this._observers = Pn();
  }
}
const Qr = Math.floor, fu = Math.abs, Jr = (n, e) => n < e ? n : e, Qn = (n, e) => n > e ? n : e, fA = (n) => n !== 0 ? n < 0 : 1 / n < 0, Fv = 1, Pv = 2, Th = 4, Nh = 8, bl = 32, Kr = 64, sn = 128, ij = 1 << 29, hd = 31, hf = 63, Co = 127, oj = 2147483647, mA = Number.MAX_SAFE_INTEGER, sj = Number.isInteger || ((n) => typeof n == "number" && isFinite(n) && Qr(n) === n), aj = String.fromCharCode, lj = (n) => n.toLowerCase(), cj = /^\s*/g, uj = (n) => n.replace(cj, ""), dj = /([A-Z])/g, $v = (n, e) => uj(n.replace(dj, (t) => `${e}${lj(t)}`)), pj = (n) => {
  const e = unescape(encodeURIComponent(n)), t = e.length, r = new Uint8Array(t);
  for (let o = 0; o < t; o++)
    r[o] = /** @type {number} */
    e.codePointAt(o);
  return r;
}, vl = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), hj = (n) => vl.encode(n), fj = vl ? hj : pj;
let nl = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
nl && nl.decode(new Uint8Array()).length === 1 && (nl = null);
let Ul = class {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
};
const Ll = () => new Ul(), mj = (n) => {
  const e = Ll();
  return n(e), Kn(e);
}, gj = (n) => {
  let e = n.cpos;
  for (let t = 0; t < n.bufs.length; t++)
    e += n.bufs[t].length;
  return e;
}, Kn = (n) => {
  const e = new Uint8Array(gj(n));
  let t = 0;
  for (let r = 0; r < n.bufs.length; r++) {
    const o = n.bufs[r];
    e.set(o, t), t += o.length;
  }
  return e.set(new Uint8Array(n.cbuf.buffer, 0, n.cpos), t), e;
}, yj = (n, e) => {
  const t = n.cbuf.length;
  t - n.cpos < e && (n.bufs.push(new Uint8Array(n.cbuf.buffer, 0, n.cpos)), n.cbuf = new Uint8Array(Qn(t, e) * 2), n.cpos = 0);
}, Bt = (n, e) => {
  const t = n.cbuf.length;
  n.cpos === t && (n.bufs.push(n.cbuf), n.cbuf = new Uint8Array(t * 2), n.cpos = 0), n.cbuf[n.cpos++] = e;
}, ff = Bt, Ue = (n, e) => {
  for (; e > Co; )
    Bt(n, sn | Co & e), e = Qr(e / 128);
  Bt(n, Co & e);
}, Am = (n, e) => {
  const t = fA(e);
  for (t && (e = -e), Bt(n, (e > hf ? sn : 0) | (t ? Kr : 0) | hf & e), e = Qr(e / 64); e > 0; )
    Bt(n, (e > Co ? sn : 0) | Co & e), e = Qr(e / 128);
}, mf = new Uint8Array(3e4), wj = mf.length / 3, bj = (n, e) => {
  if (e.length < wj) {
    const t = vl.encodeInto(e, mf).written || 0;
    Ue(n, t);
    for (let r = 0; r < t; r++)
      Bt(n, mf[r]);
  } else
    kn(n, fj(e));
}, vj = (n, e) => {
  const t = unescape(encodeURIComponent(e)), r = t.length;
  Ue(n, r);
  for (let o = 0; o < r; o++)
    Bt(
      n,
      /** @type {number} */
      t.codePointAt(o)
    );
}, Us = vl && /** @type {any} */
vl.encodeInto ? bj : vj, fd = (n, e) => {
  const t = n.cbuf.length, r = n.cpos, o = Jr(t - r, e.length), a = e.length - o;
  n.cbuf.set(e.subarray(0, o), r), n.cpos += o, a > 0 && (n.bufs.push(n.cbuf), n.cbuf = new Uint8Array(Qn(t * 2, a)), n.cbuf.set(e.subarray(o)), n.cpos = a);
}, kn = (n, e) => {
  Ue(n, e.byteLength), fd(n, e);
}, Cm = (n, e) => {
  yj(n, e);
  const t = new DataView(n.cbuf.buffer, n.cpos, e);
  return n.cpos += e, t;
}, xj = (n, e) => Cm(n, 4).setFloat32(0, e, !1), kj = (n, e) => Cm(n, 8).setFloat64(0, e, !1), Aj = (n, e) => (
  /** @type {any} */
  Cm(n, 8).setBigInt64(0, e, !1)
), jv = new DataView(new ArrayBuffer(4)), Cj = (n) => (jv.setFloat32(0, n), jv.getFloat32(0) === n), Ws = (n, e) => {
  switch (typeof e) {
    case "string":
      Bt(n, 119), Us(n, e);
      break;
    case "number":
      sj(e) && fu(e) <= oj ? (Bt(n, 125), Am(n, e)) : Cj(e) ? (Bt(n, 124), xj(n, e)) : (Bt(n, 123), kj(n, e));
      break;
    case "bigint":
      Bt(n, 122), Aj(n, e);
      break;
    case "object":
      if (e === null)
        Bt(n, 126);
      else if (pf(e)) {
        Bt(n, 117), Ue(n, e.length);
        for (let t = 0; t < e.length; t++)
          Ws(n, e[t]);
      } else if (e instanceof Uint8Array)
        Bt(n, 116), kn(n, e);
      else {
        Bt(n, 118);
        const t = Object.keys(e);
        Ue(n, t.length);
        for (let r = 0; r < t.length; r++) {
          const o = t[r];
          Us(n, o), Ws(n, e[o]);
        }
      }
      break;
    case "boolean":
      Bt(n, e ? 120 : 121);
      break;
    default:
      Bt(n, 127);
  }
};
class Uv extends Ul {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(e) {
    super(), this.w = e, this.s = null, this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(e) {
    this.s === e ? this.count++ : (this.count > 0 && Ue(this, this.count - 1), this.count = 1, this.w(this, e), this.s = e);
  }
}
const Lv = (n) => {
  n.count > 0 && (Am(n.encoder, n.count === 1 ? n.s : -n.s), n.count > 1 && Ue(n.encoder, n.count - 2));
};
class mu {
  constructor() {
    this.encoder = new Ul(), this.s = 0, this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.s === e ? this.count++ : (Lv(this), this.count = 1, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return Lv(this), Kn(this.encoder);
  }
}
const Hv = (n) => {
  if (n.count > 0) {
    const e = n.diff * 2 + (n.count === 1 ? 0 : 1);
    Am(n.encoder, e), n.count > 1 && Ue(n.encoder, n.count - 2);
  }
};
class Bh {
  constructor() {
    this.encoder = new Ul(), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.diff === e - this.s ? (this.s = e, this.count++) : (Hv(this), this.count = 1, this.diff = e - this.s, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return Hv(this), Kn(this.encoder);
  }
}
class Sj {
  constructor() {
    this.sarr = [], this.s = "", this.lensE = new mu();
  }
  /**
   * @param {string} string
   */
  write(e) {
    this.s += e, this.s.length > 19 && (this.sarr.push(this.s), this.s = ""), this.lensE.write(e.length);
  }
  toUint8Array() {
    const e = new Ul();
    return this.sarr.push(this.s), this.s = "", Us(e, this.sarr.join("")), fd(e, this.lensE.toUint8Array()), Kn(e);
  }
}
const Pi = (n) => new Error(n), Wn = () => {
  throw Pi("Method unimplemented");
}, bn = () => {
  throw Pi("Unexpected case");
}, gA = Pi("Unexpected end of array"), yA = Pi("Integer out of Range");
let md = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(e) {
    this.arr = e, this.pos = 0;
  }
};
const ca = (n) => new md(n), Ej = (n) => n.pos !== n.arr.length, Tj = (n, e) => {
  const t = new Uint8Array(n.arr.buffer, n.pos + n.arr.byteOffset, e);
  return n.pos += e, t;
}, An = (n) => Tj(n, Re(n)), Ys = (n) => n.arr[n.pos++], Re = (n) => {
  let e = 0, t = 1;
  const r = n.arr.length;
  for (; n.pos < r; ) {
    const o = n.arr[n.pos++];
    if (e = e + (o & Co) * t, t *= 128, o < sn)
      return e;
    if (e > mA)
      throw yA;
  }
  throw gA;
}, Sm = (n) => {
  let e = n.arr[n.pos++], t = e & hf, r = 64;
  const o = (e & Kr) > 0 ? -1 : 1;
  if (!(e & sn))
    return o * t;
  const a = n.arr.length;
  for (; n.pos < a; ) {
    if (e = n.arr[n.pos++], t = t + (e & Co) * r, r *= 128, e < sn)
      return o * t;
    if (t > mA)
      throw yA;
  }
  throw gA;
}, Nj = (n) => {
  let e = Re(n);
  if (e === 0)
    return "";
  {
    let t = String.fromCodePoint(Ys(n));
    if (--e < 100)
      for (; e--; )
        t += String.fromCodePoint(Ys(n));
    else
      for (; e > 0; ) {
        const r = e < 1e4 ? e : 1e4, o = n.arr.subarray(n.pos, n.pos + r);
        n.pos += r, t += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          o
        ), e -= r;
      }
    return decodeURIComponent(escape(t));
  }
}, Bj = (n) => (
  /** @type any */
  nl.decode(An(n))
), Ls = nl ? Bj : Nj, Em = (n, e) => {
  const t = new DataView(n.arr.buffer, n.arr.byteOffset + n.pos, e);
  return n.pos += e, t;
}, Ij = (n) => Em(n, 4).getFloat32(0, !1), Mj = (n) => Em(n, 8).getFloat64(0, !1), Oj = (n) => (
  /** @type {any} */
  Em(n, 8).getBigInt64(0, !1)
), Dj = [
  (n) => {
  },
  // CASE 127: undefined
  (n) => null,
  // CASE 126: null
  Sm,
  // CASE 125: integer
  Ij,
  // CASE 124: float32
  Mj,
  // CASE 123: float64
  Oj,
  // CASE 122: bigint
  (n) => !1,
  // CASE 121: boolean (false)
  (n) => !0,
  // CASE 120: boolean (true)
  Ls,
  // CASE 119: string
  (n) => {
    const e = Re(n), t = {};
    for (let r = 0; r < e; r++) {
      const o = Ls(n);
      t[o] = xl(n);
    }
    return t;
  },
  (n) => {
    const e = Re(n), t = [];
    for (let r = 0; r < e; r++)
      t.push(xl(n));
    return t;
  },
  An
  // CASE 116: Uint8Array
], xl = (n) => Dj[127 - Ys(n)](n);
class Gv extends md {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(e, t) {
    super(e), this.reader = t, this.s = null, this.count = 0;
  }
  read() {
    return this.count === 0 && (this.s = this.reader(this), Ej(this) ? this.count = Re(this) + 1 : this.count = -1), this.count--, /** @type {T} */
    this.s;
  }
}
class gu extends md {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(e) {
    super(e), this.s = 0, this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = Sm(this);
      const e = fA(this.s);
      this.count = 1, e && (this.s = -this.s, this.count = Re(this) + 2);
    }
    return this.count--, /** @type {number} */
    this.s;
  }
}
class Ih extends md {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(e) {
    super(e), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const e = Sm(this), t = e & 1;
      this.diff = Qr(e / 2), this.count = 1, t && (this.count = Re(this) + 2);
    }
    return this.s += this.diff, this.count--, this.s;
  }
}
class Rj {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(e) {
    this.decoder = new gu(e), this.str = Ls(this.decoder), this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const e = this.spos + this.decoder.read(), t = this.str.slice(this.spos, e);
    return this.spos = e, t;
  }
}
const Fj = crypto.getRandomValues.bind(crypto), Pj = Math.random, wA = () => Fj(new Uint32Array(1))[0], $j = (n) => n[Qr(Pj() * n.length)], jj = "10000000-1000-4000-8000" + -1e11, Uj = () => jj.replace(
  /[018]/g,
  /** @param {number} c */
  (n) => (n ^ wA() & 15 >> n / 4).toString(16)
), Lj = Date.now, _v = (n) => (
  /** @type {Promise<T>} */
  new Promise(n)
);
Promise.all.bind(Promise);
const zv = (n) => n === void 0 ? null : n;
class Hj {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(e, t) {
    this.map.set(e, t);
  }
  /**
   * @param {string} key
   */
  getItem(e) {
    return this.map.get(e);
  }
}
let bA = new Hj(), Gj = !0;
try {
  typeof localStorage < "u" && localStorage && (bA = localStorage, Gj = !1);
} catch {
}
const _j = bA, zj = Object.assign, vA = Object.keys, qj = (n, e) => {
  for (const t in n)
    e(n[t], t);
}, qv = (n) => vA(n).length, Vj = (n) => {
  for (const e in n)
    return !1;
  return !0;
}, xA = (n, e) => {
  for (const t in n)
    if (!e(n[t], t))
      return !1;
  return !0;
}, Xj = (n, e) => Object.prototype.hasOwnProperty.call(n, e), Jj = (n, e) => n === e || qv(n) === qv(e) && xA(n, (t, r) => (t !== void 0 || Xj(e, r)) && e[r] === t), Kj = Object.freeze, kA = (n) => {
  for (const e in n) {
    const t = n[e];
    (typeof t == "object" || typeof t == "function") && kA(n[e]);
  }
  return Kj(n);
}, Tm = (n, e, t = 0) => {
  try {
    for (; t < n.length; t++)
      n[t](...e);
  } finally {
    t < n.length && Tm(n, e, t + 1);
  }
}, Wj = (n) => n, Yj = (n, e) => e.includes(n), Qs = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]", AA = typeof window < "u" && typeof document < "u" && !Qs;
let vr;
const Qj = () => {
  if (vr === void 0)
    if (Qs) {
      vr = Pn();
      const n = process.argv;
      let e = null;
      for (let t = 0; t < n.length; t++) {
        const r = n[t];
        r[0] === "-" ? (e !== null && vr.set(e, ""), e = r) : e !== null && (vr.set(e, r), e = null);
      }
      e !== null && vr.set(e, "");
    } else typeof location == "object" ? (vr = Pn(), (location.search || "?").slice(1).split("&").forEach((n) => {
      if (n.length !== 0) {
        const [e, t] = n.split("=");
        vr.set(`--${$v(e, "-")}`, t), vr.set(`-${$v(e, "-")}`, t);
      }
    })) : vr = Pn();
  return vr;
}, gf = (n) => Qj().has(n), $u = (n) => zv(Qs ? process.env[n.toUpperCase().replaceAll("-", "_")] : _j.getItem(n)), CA = (n) => gf("--" + n) || $u(n) !== null;
CA("production");
const Zj = Qs && Yj(process.env.FORCE_COLOR, ["true", "1", "2"]), eU = Zj || !gf("--no-colors") && // @todo deprecate --no-colors
!CA("no-color") && (!Qs || process.stdout.isTTY) && (!Qs || gf("--color") || $u("COLORTERM") !== null || ($u("TERM") || "").includes("color")), tU = (n) => new Uint8Array(n), nU = (n) => {
  let e = "";
  for (let t = 0; t < n.byteLength; t++)
    e += aj(n[t]);
  return btoa(e);
}, rU = (n) => Buffer.from(n.buffer, n.byteOffset, n.byteLength).toString("base64"), iU = AA ? nU : rU, oU = (n) => {
  const e = tU(n.byteLength);
  return e.set(n), e;
}, sU = (n) => mj((e) => Ws(e, n));
class aU {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(e, t) {
    this.left = e, this.right = t;
  }
}
const Hr = (n, e) => new aU(n, e), lU = (
  /** @type {Document} */
  typeof document < "u" ? document : {}
);
typeof DOMParser < "u" && new DOMParser();
const cU = (n) => ej(n, (e, t) => `${t}:${e};`).join(""), uU = (n) => class {
  /**
   * @param {number} timeoutId
   */
  constructor(t) {
    this._ = t;
  }
  destroy() {
    n(this._);
  }
}, dU = uU(clearTimeout), Nm = (n, e) => new dU(setTimeout(e, n)), ti = Symbol, SA = ti(), EA = ti(), pU = ti(), hU = ti(), fU = ti(), TA = ti(), mU = ti(), Bm = ti(), gU = ti(), yU = (n) => {
  var o;
  n.length === 1 && ((o = n[0]) == null ? void 0 : o.constructor) === Function && (n = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  n[0]());
  const e = [], t = [];
  let r = 0;
  for (; r < n.length; r++) {
    const a = n[r];
    if (a === void 0)
      break;
    if (a.constructor === String || a.constructor === Number)
      e.push(a);
    else if (a.constructor === Object)
      break;
  }
  for (r > 0 && t.push(e.join("")); r < n.length; r++) {
    const a = n[r];
    a instanceof Symbol || t.push(a);
  }
  return t;
}, wU = {
  [SA]: Hr("font-weight", "bold"),
  [EA]: Hr("font-weight", "normal"),
  [pU]: Hr("color", "blue"),
  [fU]: Hr("color", "green"),
  [hU]: Hr("color", "grey"),
  [TA]: Hr("color", "red"),
  [mU]: Hr("color", "purple"),
  [Bm]: Hr("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [gU]: Hr("color", "black")
}, bU = (n) => {
  var l;
  n.length === 1 && ((l = n[0]) == null ? void 0 : l.constructor) === Function && (n = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  n[0]());
  const e = [], t = [], r = Pn();
  let o = [], a = 0;
  for (; a < n.length; a++) {
    const d = n[a], p = wU[d];
    if (p !== void 0)
      r.set(p.left, p.right);
    else {
      if (d === void 0)
        break;
      if (d.constructor === String || d.constructor === Number) {
        const f = cU(r);
        a > 0 || f.length > 0 ? (e.push("%c" + d), t.push(f)) : e.push(d);
      } else
        break;
    }
  }
  for (a > 0 && (o = t, o.unshift(e.join(""))); a < n.length; a++) {
    const d = n[a];
    d instanceof Symbol || o.push(d);
  }
  return o;
}, NA = eU ? bU : yU, vU = (...n) => {
  console.log(...NA(n)), IA.forEach((e) => e.print(n));
}, BA = (...n) => {
  console.warn(...NA(n)), n.unshift(Bm), IA.forEach((e) => e.print(n));
}, IA = Oo(), MA = (n) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next: n
}), xU = (n, e) => MA(() => {
  let t;
  do
    t = n.next();
  while (!t.done && !e(t.value));
  return t;
}), Mh = (n, e) => MA(() => {
  const { done: t, value: r } = n.next();
  return { done: t, value: t ? void 0 : e(r) };
});
class Im {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(e, t) {
    this.clock = e, this.len = t;
  }
}
class ua {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
}
const $i = (n, e, t) => e.clients.forEach((r, o) => {
  const a = (
    /** @type {Array<GC|Item>} */
    n.doc.store.clients.get(o)
  );
  if (a != null) {
    const l = a[a.length - 1], d = l.id.clock + l.length;
    for (let p = 0, f = r[p]; p < r.length && f.clock < d; f = r[++p])
      qA(n, a, f.clock, f.len, t);
  }
}), kU = (n, e) => {
  let t = 0, r = n.length - 1;
  for (; t <= r; ) {
    const o = Qr((t + r) / 2), a = n[o], l = a.clock;
    if (l <= e) {
      if (e < l + a.len)
        return o;
      t = o + 1;
    } else
      r = o - 1;
  }
  return null;
}, da = (n, e) => {
  const t = n.clients.get(e.client);
  return t !== void 0 && kU(t, e.clock) !== null;
}, Mm = (n) => {
  n.clients.forEach((e) => {
    e.sort((o, a) => o.clock - a.clock);
    let t, r;
    for (t = 1, r = 1; t < e.length; t++) {
      const o = e[r - 1], a = e[t];
      o.clock + o.len >= a.clock ? o.len = Qn(o.len, a.clock + a.len - o.clock) : (r < t && (e[r] = a), r++);
    }
    e.length = r;
  });
}, yf = (n) => {
  const e = new ua();
  for (let t = 0; t < n.length; t++)
    n[t].clients.forEach((r, o) => {
      if (!e.clients.has(o)) {
        const a = r.slice();
        for (let l = t + 1; l < n.length; l++)
          nj(a, n[l].clients.get(o) || []);
        e.clients.set(o, a);
      }
    });
  return Mm(e), e;
}, kl = (n, e, t, r) => {
  Br(n.clients, e, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new Im(t, r));
}, OA = () => new ua(), DA = (n) => {
  const e = OA();
  return n.clients.forEach((t, r) => {
    const o = [];
    for (let a = 0; a < t.length; a++) {
      const l = t[a];
      if (l.deleted) {
        const d = l.id.clock;
        let p = l.length;
        if (a + 1 < t.length)
          for (let f = t[a + 1]; a + 1 < t.length && f.deleted; f = t[++a + 1])
            p += f.length;
        o.push(new Im(d, p));
      }
    }
    o.length > 0 && e.clients.set(r, o);
  }), e;
}, pa = (n, e) => {
  Ue(n.restEncoder, e.clients.size), Fi(e.clients.entries()).sort((t, r) => r[0] - t[0]).forEach(([t, r]) => {
    n.resetDsCurVal(), Ue(n.restEncoder, t);
    const o = r.length;
    Ue(n.restEncoder, o);
    for (let a = 0; a < o; a++) {
      const l = r[a];
      n.writeDsClock(l.clock), n.writeDsLen(l.len);
    }
  });
}, Om = (n) => {
  const e = new ua(), t = Re(n.restDecoder);
  for (let r = 0; r < t; r++) {
    n.resetDsCurVal();
    const o = Re(n.restDecoder), a = Re(n.restDecoder);
    if (a > 0) {
      const l = Br(e.clients, o, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let d = 0; d < a; d++)
        l.push(new Im(n.readDsClock(), n.readDsLen()));
    }
  }
  return e;
}, Vv = (n, e, t) => {
  const r = new ua(), o = Re(n.restDecoder);
  for (let a = 0; a < o; a++) {
    n.resetDsCurVal();
    const l = Re(n.restDecoder), d = Re(n.restDecoder), p = t.clients.get(l) || [], f = xt(t, l);
    for (let m = 0; m < d; m++) {
      const y = n.readDsClock(), v = y + n.readDsLen();
      if (y < f) {
        f < v && kl(r, l, f, v - f);
        let k = Zn(p, y), A = p[k];
        for (!A.deleted && A.id.clock < y && (p.splice(k + 1, 0, zu(e, A, y - A.id.clock)), k++); k < p.length && (A = p[k++], A.id.clock < v); )
          A.deleted || (v < A.id.clock + A.length && p.splice(k, 0, zu(e, A, v - A.id.clock)), A.delete(e));
      } else
        kl(r, l, y, v - y);
    }
  }
  if (r.clients.size > 0) {
    const a = new Do();
    return Ue(a.restEncoder, 0), pa(a, r), a.toUint8Array();
  }
  return null;
}, RA = wA;
class ni extends hA {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid: e = Uj(), collectionid: t = null, gc: r = !0, gcFilter: o = () => !0, meta: a = null, autoLoad: l = !1, shouldLoad: d = !0 } = {}) {
    super(), this.gc = r, this.gcFilter = o, this.clientID = RA(), this.guid = e, this.collectionid = t, this.share = /* @__PURE__ */ new Map(), this.store = new _A(), this._transaction = null, this._transactionCleanups = [], this.subdocs = /* @__PURE__ */ new Set(), this._item = null, this.shouldLoad = d, this.autoLoad = l, this.meta = a, this.isLoaded = !1, this.isSynced = !1, this.isDestroyed = !1, this.whenLoaded = _v((f) => {
      this.on("load", () => {
        this.isLoaded = !0, f(this);
      });
    });
    const p = () => _v((f) => {
      const m = (y) => {
        (y === void 0 || y === !0) && (this.off("sync", m), f());
      };
      this.on("sync", m);
    });
    this.on("sync", (f) => {
      f === !1 && this.isSynced && (this.whenSynced = p()), this.isSynced = f === void 0 || f === !0, this.isSynced && !this.isLoaded && this.emit("load", [this]);
    }), this.whenSynced = p();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const e = this._item;
    e !== null && !this.shouldLoad && et(
      /** @type {any} */
      e.parent.doc,
      (t) => {
        t.subdocsLoaded.add(this);
      },
      null,
      !0
    ), this.shouldLoad = !0;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(Fi(this.subdocs).map((e) => e.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(e, t = null) {
    return et(this, e, t);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(e, t = (
    /** @type {any} */
    Dt
  )) {
    const r = Br(this.share, e, () => {
      const a = new t();
      return a._integrate(this, null), a;
    }), o = r.constructor;
    if (t !== Dt && o !== t)
      if (o === Dt) {
        const a = new t();
        a._map = r._map, r._map.forEach(
          /** @param {Item?} n */
          (l) => {
            for (; l !== null; l = l.left)
              l.parent = a;
          }
        ), a._start = r._start;
        for (let l = a._start; l !== null; l = l.right)
          l.parent = a;
        return a._length = r._length, this.share.set(e, a), a._integrate(this, null), /** @type {InstanceType<Type>} */
        a;
      } else
        throw new Error(`Type with the name ${e} has already been defined with a different constructor`);
    return (
      /** @type {InstanceType<Type>} */
      r
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(e = "") {
    return (
      /** @type {YArray<T>} */
      this.get(e, _s)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(e = "") {
    return this.get(e, ji);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(e = "") {
    return (
      /** @type {YMap<T>} */
      this.get(e, ea)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(e = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(e, Jt)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(e = "") {
    return this.get(e, Ro);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const e = {};
    return this.share.forEach((t, r) => {
      e[r] = t.toJSON();
    }), e;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    this.isDestroyed = !0, Fi(this.subdocs).forEach((t) => t.destroy());
    const e = this._item;
    if (e !== null) {
      this._item = null;
      const t = (
        /** @type {ContentDoc} */
        e.content
      );
      t.doc = new ni({ guid: this.guid, ...t.opts, shouldLoad: !1 }), t.doc._item = e, et(
        /** @type {any} */
        e.parent.doc,
        (r) => {
          const o = t.doc;
          e.deleted || r.subdocsAdded.add(o), r.subdocsRemoved.add(this);
        },
        null,
        !0
      );
    }
    this.emit("destroyed", [!0]), this.emit("destroy", [this]), super.destroy();
  }
}
class FA {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(e) {
    this.restDecoder = e;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return Re(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return Re(this.restDecoder);
  }
}
class PA extends FA {
  /**
   * @return {ID}
   */
  readLeftID() {
    return Te(Re(this.restDecoder), Re(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return Te(Re(this.restDecoder), Re(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return Re(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return Ys(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return Ls(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return Re(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return Re(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return Re(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return xl(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return oU(An(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(Ls(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return Ls(this.restDecoder);
  }
}
class AU {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(e) {
    this.dsCurrVal = 0, this.restDecoder = e;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return this.dsCurrVal += Re(this.restDecoder), this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const e = Re(this.restDecoder) + 1;
    return this.dsCurrVal += e, e;
  }
}
class Zs extends AU {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(e) {
    super(e), this.keys = [], Re(e), this.keyClockDecoder = new Ih(An(e)), this.clientDecoder = new gu(An(e)), this.leftClockDecoder = new Ih(An(e)), this.rightClockDecoder = new Ih(An(e)), this.infoDecoder = new Gv(An(e), Ys), this.stringDecoder = new Rj(An(e)), this.parentInfoDecoder = new Gv(An(e), Ys), this.typeRefDecoder = new gu(An(e)), this.lenDecoder = new gu(An(e));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new Hs(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new Hs(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return xl(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return An(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return xl(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const e = this.keyClockDecoder.read();
    if (e < this.keys.length)
      return this.keys[e];
    {
      const t = this.stringDecoder.read();
      return this.keys.push(t), t;
    }
  }
}
class $A {
  constructor() {
    this.restEncoder = Ll();
  }
  toUint8Array() {
    return Kn(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    Ue(this.restEncoder, e);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    Ue(this.restEncoder, e);
  }
}
class Hl extends $A {
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    Ue(this.restEncoder, e.client), Ue(this.restEncoder, e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    Ue(this.restEncoder, e.client), Ue(this.restEncoder, e.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(e) {
    Ue(this.restEncoder, e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    ff(this.restEncoder, e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    Us(this.restEncoder, e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    Ue(this.restEncoder, e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    Ue(this.restEncoder, e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    Ue(this.restEncoder, e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    Ws(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    kn(this.restEncoder, e);
  }
  /**
   * @param {any} embed
   */
  writeJSON(e) {
    Us(this.restEncoder, JSON.stringify(e));
  }
  /**
   * @param {string} key
   */
  writeKey(e) {
    Us(this.restEncoder, e);
  }
}
class jA {
  constructor() {
    this.restEncoder = Ll(), this.dsCurrVal = 0;
  }
  toUint8Array() {
    return Kn(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    const t = e - this.dsCurrVal;
    this.dsCurrVal = e, Ue(this.restEncoder, t);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    e === 0 && bn(), Ue(this.restEncoder, e - 1), this.dsCurrVal += e;
  }
}
class Do extends jA {
  constructor() {
    super(), this.keyMap = /* @__PURE__ */ new Map(), this.keyClock = 0, this.keyClockEncoder = new Bh(), this.clientEncoder = new mu(), this.leftClockEncoder = new Bh(), this.rightClockEncoder = new Bh(), this.infoEncoder = new Uv(ff), this.stringEncoder = new Sj(), this.parentInfoEncoder = new Uv(ff), this.typeRefEncoder = new mu(), this.lenEncoder = new mu();
  }
  toUint8Array() {
    const e = Ll();
    return Ue(e, 0), kn(e, this.keyClockEncoder.toUint8Array()), kn(e, this.clientEncoder.toUint8Array()), kn(e, this.leftClockEncoder.toUint8Array()), kn(e, this.rightClockEncoder.toUint8Array()), kn(e, Kn(this.infoEncoder)), kn(e, this.stringEncoder.toUint8Array()), kn(e, Kn(this.parentInfoEncoder)), kn(e, this.typeRefEncoder.toUint8Array()), kn(e, this.lenEncoder.toUint8Array()), fd(e, Kn(this.restEncoder)), Kn(e);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    this.clientEncoder.write(e.client), this.leftClockEncoder.write(e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    this.clientEncoder.write(e.client), this.rightClockEncoder.write(e.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(e) {
    this.clientEncoder.write(e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    this.infoEncoder.write(e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    this.stringEncoder.write(e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    this.parentInfoEncoder.write(e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    this.typeRefEncoder.write(e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    this.lenEncoder.write(e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    Ws(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    kn(this.restEncoder, e);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(e) {
    Ws(this.restEncoder, e);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(e) {
    const t = this.keyMap.get(e);
    t === void 0 ? (this.keyClockEncoder.write(this.keyClock++), this.stringEncoder.write(e)) : this.keyClockEncoder.write(t);
  }
}
const CU = (n, e, t, r) => {
  r = Qn(r, e[0].id.clock);
  const o = Zn(e, r);
  Ue(n.restEncoder, e.length - o), n.writeClient(t), Ue(n.restEncoder, r);
  const a = e[o];
  a.write(n, r - a.id.clock);
  for (let l = o + 1; l < e.length; l++)
    e[l].write(n, 0);
}, Dm = (n, e, t) => {
  const r = /* @__PURE__ */ new Map();
  t.forEach((o, a) => {
    xt(e, a) > o && r.set(a, o);
  }), Gl(e).forEach((o, a) => {
    t.has(a) || r.set(a, 0);
  }), Ue(n.restEncoder, r.size), Fi(r.entries()).sort((o, a) => a[0] - o[0]).forEach(([o, a]) => {
    CU(
      n,
      /** @type {Array<GC|Item>} */
      e.clients.get(o),
      o,
      a
    );
  });
}, SU = (n, e) => {
  const t = Pn(), r = Re(n.restDecoder);
  for (let o = 0; o < r; o++) {
    const a = Re(n.restDecoder), l = new Array(a), d = n.readClient();
    let p = Re(n.restDecoder);
    t.set(d, { i: 0, refs: l });
    for (let f = 0; f < a; f++) {
      const m = n.readInfo();
      switch (hd & m) {
        case 0: {
          const y = n.readLen();
          l[f] = new On(Te(d, p), y), p += y;
          break;
        }
        case 10: {
          const y = Re(n.restDecoder);
          l[f] = new Dn(Te(d, p), y), p += y;
          break;
        }
        default: {
          const y = (m & (Kr | sn)) === 0, v = new Ke(
            Te(d, p),
            null,
            // left
            (m & sn) === sn ? n.readLeftID() : null,
            // origin
            null,
            // right
            (m & Kr) === Kr ? n.readRightID() : null,
            // right origin
            y ? n.readParentInfo() ? e.get(n.readString()) : n.readLeftID() : null,
            // parent
            y && (m & bl) === bl ? n.readString() : null,
            // parentSub
            hC(n, m)
            // item content
          );
          l[f] = v, p += v.length;
        }
      }
    }
  }
  return t;
}, EU = (n, e, t) => {
  const r = [];
  let o = Fi(t.keys()).sort((k, A) => k - A);
  if (o.length === 0)
    return null;
  const a = () => {
    if (o.length === 0)
      return null;
    let k = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      t.get(o[o.length - 1])
    );
    for (; k.refs.length === k.i; )
      if (o.pop(), o.length > 0)
        k = /** @type {{i:number,refs:Array<GC|Item>}} */
        t.get(o[o.length - 1]);
      else
        return null;
    return k;
  };
  let l = a();
  if (l === null)
    return null;
  const d = new _A(), p = /* @__PURE__ */ new Map(), f = (k, A) => {
    const S = p.get(k);
    (S == null || S > A) && p.set(k, A);
  };
  let m = (
    /** @type {any} */
    l.refs[
      /** @type {any} */
      l.i++
    ]
  );
  const y = /* @__PURE__ */ new Map(), v = () => {
    for (const k of r) {
      const A = k.id.client, S = t.get(A);
      S ? (S.i--, d.clients.set(A, S.refs.slice(S.i)), t.delete(A), S.i = 0, S.refs = []) : d.clients.set(A, [k]), o = o.filter((B) => B !== A);
    }
    r.length = 0;
  };
  for (; ; ) {
    if (m.constructor !== Dn) {
      const A = Br(y, m.id.client, () => xt(e, m.id.client)) - m.id.clock;
      if (A < 0)
        r.push(m), f(m.id.client, m.id.clock - 1), v();
      else {
        const S = m.getMissing(n, e);
        if (S !== null) {
          r.push(m);
          const B = t.get(
            /** @type {number} */
            S
          ) || { refs: [], i: 0 };
          if (B.refs.length === B.i)
            f(
              /** @type {number} */
              S,
              xt(e, S)
            ), v();
          else {
            m = B.refs[B.i++];
            continue;
          }
        } else (A === 0 || A < m.length) && (m.integrate(n, A), y.set(m.id.client, m.id.clock + m.length));
      }
    }
    if (r.length > 0)
      m = /** @type {GC|Item} */
      r.pop();
    else if (l !== null && l.i < l.refs.length)
      m = /** @type {GC|Item} */
      l.refs[l.i++];
    else {
      if (l = a(), l === null)
        break;
      m = /** @type {GC|Item} */
      l.refs[l.i++];
    }
  }
  if (d.clients.size > 0) {
    const k = new Do();
    return Dm(k, d, /* @__PURE__ */ new Map()), Ue(k.restEncoder, 0), { missing: p, update: k.toUint8Array() };
  }
  return null;
}, TU = (n, e) => Dm(n, e.doc.store, e.beforeState), NU = (n, e, t, r = new Zs(n)) => et(e, (o) => {
  o.local = !1;
  let a = !1;
  const l = o.doc, d = l.store, p = SU(r, l), f = EU(o, d, p), m = d.pendingStructs;
  if (m) {
    for (const [v, k] of m.missing)
      if (k < xt(d, v)) {
        a = !0;
        break;
      }
    if (f) {
      for (const [v, k] of f.missing) {
        const A = m.missing.get(v);
        (A == null || A > k) && m.missing.set(v, k);
      }
      m.update = Uu([m.update, f.update]);
    }
  } else
    d.pendingStructs = f;
  const y = Vv(r, o, d);
  if (d.pendingDs) {
    const v = new Zs(ca(d.pendingDs));
    Re(v.restDecoder);
    const k = Vv(v, o, d);
    y && k ? d.pendingDs = Uu([y, k]) : d.pendingDs = y || k;
  } else
    d.pendingDs = y;
  if (a) {
    const v = (
      /** @type {{update: Uint8Array}} */
      d.pendingStructs.update
    );
    d.pendingStructs = null, ju(o.doc, v);
  }
}, t, !1), ju = (n, e, t, r = Zs) => {
  const o = ca(e);
  NU(o, n, t, new r(o));
}, BU = (n, e, t) => ju(n, e, t, PA), IU = (n, e, t = /* @__PURE__ */ new Map()) => {
  Dm(n, e.store, t), pa(n, DA(e.store));
}, MU = (n, e = new Uint8Array([0]), t = new Do()) => {
  const r = UA(e);
  IU(t, n, r);
  const o = [t.toUint8Array()];
  if (n.store.pendingDs && o.push(n.store.pendingDs), n.store.pendingStructs && o.push(YU(n.store.pendingStructs.update, e)), o.length > 1) {
    if (t.constructor === Hl)
      return KU(o.map((a, l) => l === 0 ? a : ZU(a)));
    if (t.constructor === Do)
      return Uu(o);
  }
  return o[0];
}, OU = (n, e) => MU(n, e, new Hl()), DU = (n) => {
  const e = /* @__PURE__ */ new Map(), t = Re(n.restDecoder);
  for (let r = 0; r < t; r++) {
    const o = Re(n.restDecoder), a = Re(n.restDecoder);
    e.set(o, a);
  }
  return e;
}, UA = (n) => DU(new FA(ca(n))), LA = (n, e) => (Ue(n.restEncoder, e.size), Fi(e.entries()).sort((t, r) => r[0] - t[0]).forEach(([t, r]) => {
  Ue(n.restEncoder, t), Ue(n.restEncoder, r);
}), n), RU = (n, e) => LA(n, Gl(e.store)), FU = (n, e = new jA()) => (n instanceof Map ? LA(e, n) : RU(e, n), e.toUint8Array()), PU = (n) => FU(n, new $A());
class $U {
  constructor() {
    this.l = [];
  }
}
const Xv = () => new $U(), Jv = (n, e) => n.l.push(e), Kv = (n, e) => {
  const t = n.l, r = t.length;
  n.l = t.filter((o) => e !== o), r === n.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.");
}, HA = (n, e, t) => Tm(n.l, [e, t]);
class Hs {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(e, t) {
    this.client = e, this.clock = t;
  }
}
const Fs = (n, e) => n === e || n !== null && e !== null && n.client === e.client && n.clock === e.clock, Te = (n, e) => new Hs(n, e), Al = (n) => {
  for (const [e, t] of n.doc.share.entries())
    if (t === n)
      return e;
  throw bn();
}, Cl = (n, e) => {
  for (; e !== null; ) {
    if (e.parent === n)
      return !0;
    e = /** @type {AbstractType<any>} */
    e.parent._item;
  }
  return !1;
};
class Sl {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(e, t, r, o = 0) {
    this.type = e, this.tname = t, this.item = r, this.assoc = o;
  }
}
const rl = (n) => new Sl(n.type == null ? null : Te(n.type.client, n.type.clock), n.tname ?? null, n.item == null ? null : Te(n.item.client, n.item.clock), n.assoc == null ? 0 : n.assoc);
class jU {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(e, t, r = 0) {
    this.type = e, this.index = t, this.assoc = r;
  }
}
const UU = (n, e, t = 0) => new jU(n, e, t), Wc = (n, e, t) => {
  let r = null, o = null;
  return n._item === null ? o = Al(n) : r = Te(n._item.id.client, n._item.id.clock), new Sl(r, o, e, t);
}, Oh = (n, e, t = 0) => {
  let r = n._start;
  if (t < 0) {
    if (e === 0)
      return Wc(n, null, t);
    e--;
  }
  for (; r !== null; ) {
    if (!r.deleted && r.countable) {
      if (r.length > e)
        return Wc(n, Te(r.id.client, r.id.clock + e), t);
      e -= r.length;
    }
    if (r.right === null && t < 0)
      return Wc(n, r.lastId, t);
    r = r.right;
  }
  return Wc(n, null, t);
}, LU = (n, e) => {
  const t = Gs(n, e), r = e.clock - t.id.clock;
  return {
    item: t,
    diff: r
  };
}, HU = (n, e, t = !0) => {
  const r = e.store, o = n.item, a = n.type, l = n.tname, d = n.assoc;
  let p = null, f = 0;
  if (o !== null) {
    if (xt(r, o.client) <= o.clock)
      return null;
    const m = t ? xf(r, o) : LU(r, o), y = m.item;
    if (!(y instanceof Ke))
      return null;
    if (p = /** @type {AbstractType<any>} */
    y.parent, p._item === null || !p._item.deleted) {
      f = y.deleted || !y.countable ? 0 : m.diff + (d >= 0 ? 0 : 1);
      let v = y.left;
      for (; v !== null; )
        !v.deleted && v.countable && (f += v.length), v = v.left;
    }
  } else {
    if (l !== null)
      p = e.get(l);
    else if (a !== null) {
      if (xt(r, a.client) <= a.clock)
        return null;
      const { item: m } = t ? xf(r, a) : { item: Gs(r, a) };
      if (m instanceof Ke && m.content instanceof rr)
        p = m.content.type;
      else
        return null;
    } else
      throw bn();
    d >= 0 ? f = p._length : f = 0;
  }
  return UU(p, f, n.assoc);
}, Wv = (n, e) => n === e || n !== null && e !== null && n.tname === e.tname && Fs(n.item, e.item) && Fs(n.type, e.type) && n.assoc === e.assoc;
class Rm {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(e, t) {
    this.ds = e, this.sv = t;
  }
}
const GA = (n, e) => new Rm(n, e), Dh = (n) => GA(DA(n.store), Gl(n.store)), mo = (n, e) => e === void 0 ? !n.deleted : e.sv.has(n.id.client) && (e.sv.get(n.id.client) || 0) > n.id.clock && !da(e.ds, n.id), wf = (n, e) => {
  const t = Br(n.meta, wf, Oo), r = n.doc.store;
  t.has(e) || (e.sv.forEach((o, a) => {
    o < xt(r, a) && mn(n, Te(a, o));
  }), $i(n, e.ds, (o) => {
  }), t.add(e));
};
class _A {
  constructor() {
    this.clients = /* @__PURE__ */ new Map(), this.pendingStructs = null, this.pendingDs = null;
  }
}
const Gl = (n) => {
  const e = /* @__PURE__ */ new Map();
  return n.clients.forEach((t, r) => {
    const o = t[t.length - 1];
    e.set(r, o.id.clock + o.length);
  }), e;
}, xt = (n, e) => {
  const t = n.clients.get(e);
  if (t === void 0)
    return 0;
  const r = t[t.length - 1];
  return r.id.clock + r.length;
}, zA = (n, e) => {
  let t = n.clients.get(e.id.client);
  if (t === void 0)
    t = [], n.clients.set(e.id.client, t);
  else {
    const r = t[t.length - 1];
    if (r.id.clock + r.length !== e.id.clock)
      throw bn();
  }
  t.push(e);
}, Zn = (n, e) => {
  let t = 0, r = n.length - 1, o = n[r], a = o.id.clock;
  if (a === e)
    return r;
  let l = Qr(e / (a + o.length - 1) * r);
  for (; t <= r; ) {
    if (o = n[l], a = o.id.clock, a <= e) {
      if (e < a + o.length)
        return l;
      t = l + 1;
    } else
      r = l - 1;
    l = Qr((t + r) / 2);
  }
  throw bn();
}, GU = (n, e) => {
  const t = n.clients.get(e.client);
  return t[Zn(t, e.clock)];
}, Gs = (
  /** @type {function(StructStore,ID):Item} */
  GU
), bf = (n, e, t) => {
  const r = Zn(e, t), o = e[r];
  return o.id.clock < t && o instanceof Ke ? (e.splice(r + 1, 0, zu(n, o, t - o.id.clock)), r + 1) : r;
}, mn = (n, e) => {
  const t = (
    /** @type {Array<Item>} */
    n.doc.store.clients.get(e.client)
  );
  return t[bf(n, t, e.clock)];
}, Yv = (n, e, t) => {
  const r = e.clients.get(t.client), o = Zn(r, t.clock), a = r[o];
  return t.clock !== a.id.clock + a.length - 1 && a.constructor !== On && r.splice(o + 1, 0, zu(n, a, t.clock - a.id.clock + 1)), a;
}, _U = (n, e, t) => {
  const r = (
    /** @type {Array<GC|Item>} */
    n.clients.get(e.id.client)
  );
  r[Zn(r, e.id.clock)] = t;
}, qA = (n, e, t, r, o) => {
  if (r === 0)
    return;
  const a = t + r;
  let l = bf(n, e, t), d;
  do
    d = e[l++], a < d.id.clock + d.length && bf(n, e, a), o(d);
  while (l < e.length && e[l].id.clock < a);
};
class zU {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(e, t, r) {
    this.doc = e, this.deleteSet = new ua(), this.beforeState = Gl(e.store), this.afterState = /* @__PURE__ */ new Map(), this.changed = /* @__PURE__ */ new Map(), this.changedParentTypes = /* @__PURE__ */ new Map(), this._mergeStructs = [], this.origin = t, this.meta = /* @__PURE__ */ new Map(), this.local = r, this.subdocsAdded = /* @__PURE__ */ new Set(), this.subdocsRemoved = /* @__PURE__ */ new Set(), this.subdocsLoaded = /* @__PURE__ */ new Set(), this._needFormattingCleanup = !1;
  }
}
const Qv = (n, e) => e.deleteSet.clients.size === 0 && !tj(e.afterState, (t, r) => e.beforeState.get(r) !== t) ? !1 : (Mm(e.deleteSet), TU(n, e), pa(n, e.deleteSet), !0), Zv = (n, e, t) => {
  const r = e._item;
  (r === null || r.id.clock < (n.beforeState.get(r.id.client) || 0) && !r.deleted) && Br(n.changed, e, Oo).add(t);
}, yu = (n, e) => {
  let t = n[e], r = n[e - 1], o = e;
  for (; o > 0; t = r, r = n[--o - 1]) {
    if (r.deleted === t.deleted && r.constructor === t.constructor && r.mergeWith(t)) {
      t instanceof Ke && t.parentSub !== null && /** @type {AbstractType<any>} */
      t.parent._map.get(t.parentSub) === t && t.parent._map.set(
        t.parentSub,
        /** @type {Item} */
        r
      );
      continue;
    }
    break;
  }
  const a = e - o;
  return a && n.splice(e + 1 - a, a), a;
}, qU = (n, e, t) => {
  for (const [r, o] of n.clients.entries()) {
    const a = (
      /** @type {Array<GC|Item>} */
      e.clients.get(r)
    );
    for (let l = o.length - 1; l >= 0; l--) {
      const d = o[l], p = d.clock + d.len;
      for (let f = Zn(a, d.clock), m = a[f]; f < a.length && m.id.clock < p; m = a[++f]) {
        const y = a[f];
        if (d.clock + d.len <= y.id.clock)
          break;
        y instanceof Ke && y.deleted && !y.keep && t(y) && y.gc(e, !1);
      }
    }
  }
}, VU = (n, e) => {
  n.clients.forEach((t, r) => {
    const o = (
      /** @type {Array<GC|Item>} */
      e.clients.get(r)
    );
    for (let a = t.length - 1; a >= 0; a--) {
      const l = t[a], d = Jr(o.length - 1, 1 + Zn(o, l.clock + l.len - 1));
      for (let p = d, f = o[p]; p > 0 && f.id.clock >= l.clock; f = o[p])
        p -= 1 + yu(o, p);
    }
  });
}, VA = (n, e) => {
  if (e < n.length) {
    const t = n[e], r = t.doc, o = r.store, a = t.deleteSet, l = t._mergeStructs;
    try {
      Mm(a), t.afterState = Gl(t.doc.store), r.emit("beforeObserverCalls", [t, r]);
      const d = [];
      t.changed.forEach(
        (p, f) => d.push(() => {
          (f._item === null || !f._item.deleted) && f._callObserver(t, p);
        })
      ), d.push(() => {
        t.changedParentTypes.forEach((p, f) => {
          f._dEH.l.length > 0 && (f._item === null || !f._item.deleted) && (p = p.filter(
            (m) => m.target._item === null || !m.target._item.deleted
          ), p.forEach((m) => {
            m.currentTarget = f, m._path = null;
          }), p.sort((m, y) => m.path.length - y.path.length), HA(f._dEH, p, t));
        });
      }), d.push(() => r.emit("afterTransaction", [t, r])), Tm(d, []), t._needFormattingCleanup && hL(t);
    } finally {
      r.gc && qU(a, o, r.gcFilter), VU(a, o), t.afterState.forEach((m, y) => {
        const v = t.beforeState.get(y) || 0;
        if (v !== m) {
          const k = (
            /** @type {Array<GC|Item>} */
            o.clients.get(y)
          ), A = Qn(Zn(k, v), 1);
          for (let S = k.length - 1; S >= A; )
            S -= 1 + yu(k, S);
        }
      });
      for (let m = l.length - 1; m >= 0; m--) {
        const { client: y, clock: v } = l[m].id, k = (
          /** @type {Array<GC|Item>} */
          o.clients.get(y)
        ), A = Zn(k, v);
        A + 1 < k.length && yu(k, A + 1) > 1 || A > 0 && yu(k, A);
      }
      if (!t.local && t.afterState.get(r.clientID) !== t.beforeState.get(r.clientID) && (vU(Bm, SA, "[yjs] ", EA, TA, "Changed the client-id because another client seems to be using it."), r.clientID = RA()), r.emit("afterTransactionCleanup", [t, r]), r._observers.has("update")) {
        const m = new Hl();
        Qv(m, t) && r.emit("update", [m.toUint8Array(), t.origin, r, t]);
      }
      if (r._observers.has("updateV2")) {
        const m = new Do();
        Qv(m, t) && r.emit("updateV2", [m.toUint8Array(), t.origin, r, t]);
      }
      const { subdocsAdded: d, subdocsLoaded: p, subdocsRemoved: f } = t;
      (d.size > 0 || f.size > 0 || p.size > 0) && (d.forEach((m) => {
        m.clientID = r.clientID, m.collectionid == null && (m.collectionid = r.collectionid), r.subdocs.add(m);
      }), f.forEach((m) => r.subdocs.delete(m)), r.emit("subdocs", [{ loaded: p, added: d, removed: f }, r, t]), f.forEach((m) => m.destroy())), n.length <= e + 1 ? (r._transactionCleanups = [], r.emit("afterAllTransactions", [r, n])) : VA(n, e + 1);
    }
  }
}, et = (n, e, t = null, r = !0) => {
  const o = n._transactionCleanups;
  let a = !1, l = null;
  n._transaction === null && (a = !0, n._transaction = new zU(n, t, r), o.push(n._transaction), o.length === 1 && n.emit("beforeAllTransactions", [n]), n.emit("beforeTransaction", [n._transaction, n]));
  try {
    l = e(n._transaction);
  } finally {
    if (a) {
      const d = n._transaction === o[0];
      n._transaction = null, d && VA(o, 0);
    }
  }
  return l;
};
class XU {
  /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */
  constructor(e, t) {
    this.insertions = t, this.deletions = e, this.meta = /* @__PURE__ */ new Map();
  }
}
const ex = (n, e, t) => {
  $i(n, t.deletions, (r) => {
    r instanceof Ke && e.scope.some((o) => o === n.doc || Cl(
      /** @type {AbstractType<any>} */
      o,
      r
    )) && Gm(r, !1);
  });
}, tx = (n, e, t) => {
  let r = null;
  const o = n.doc, a = n.scope;
  et(o, (d) => {
    for (; e.length > 0 && n.currStackItem === null; ) {
      const p = o.store, f = (
        /** @type {StackItem} */
        e.pop()
      ), m = /* @__PURE__ */ new Set(), y = [];
      let v = !1;
      $i(d, f.insertions, (k) => {
        if (k instanceof Ke) {
          if (k.redone !== null) {
            let { item: A, diff: S } = xf(p, k.id);
            S > 0 && (A = mn(d, Te(A.id.client, A.id.clock + S))), k = A;
          }
          !k.deleted && a.some((A) => A === d.doc || Cl(
            /** @type {AbstractType<any>} */
            A,
            /** @type {Item} */
            k
          )) && y.push(k);
        }
      }), $i(d, f.deletions, (k) => {
        k instanceof Ke && a.some((A) => A === d.doc || Cl(
          /** @type {AbstractType<any>} */
          A,
          k
        )) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
        !da(f.insertions, k.id) && m.add(k);
      }), m.forEach((k) => {
        v = pC(d, k, m, f.insertions, n.ignoreRemoteMapChanges, n) !== null || v;
      });
      for (let k = y.length - 1; k >= 0; k--) {
        const A = y[k];
        n.deleteFilter(A) && (A.delete(d), v = !0);
      }
      n.currStackItem = v ? f : null;
    }
    d.changed.forEach((p, f) => {
      p.has(null) && f._searchMarker && (f._searchMarker.length = 0);
    }), r = d;
  }, n);
  const l = n.currStackItem;
  if (l != null) {
    const d = r.changedParentTypes;
    n.emit("stack-item-popped", [{ stackItem: l, type: t, changedParentTypes: d, origin: n }, n]), n.currStackItem = null;
  }
  return l;
};
class XA extends hA {
  /**
   * @param {Doc|AbstractType<any>|Array<AbstractType<any>>} typeScope Limits the scope of the UndoManager. If this is set to a ydoc instance, all changes on that ydoc will be undone. If set to a specific type, only changes on that type or its children will be undone. Also accepts an array of types.
   * @param {UndoManagerOptions} options
   */
  constructor(e, {
    captureTimeout: t = 500,
    captureTransaction: r = (p) => !0,
    deleteFilter: o = () => !0,
    trackedOrigins: a = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges: l = !1,
    doc: d = (
      /** @type {Doc} */
      pf(e) ? e[0].doc : e instanceof ni ? e : e.doc
    )
  } = {}) {
    super(), this.scope = [], this.doc = d, this.addToScope(e), this.deleteFilter = o, a.add(this), this.trackedOrigins = a, this.captureTransaction = r, this.undoStack = [], this.redoStack = [], this.undoing = !1, this.redoing = !1, this.currStackItem = null, this.lastChange = 0, this.ignoreRemoteMapChanges = l, this.captureTimeout = t, this.afterTransactionHandler = (p) => {
      if (!this.captureTransaction(p) || !this.scope.some((B) => p.changedParentTypes.has(
        /** @type {AbstractType<any>} */
        B
      ) || B === this.doc) || !this.trackedOrigins.has(p.origin) && (!p.origin || !this.trackedOrigins.has(p.origin.constructor)))
        return;
      const f = this.undoing, m = this.redoing, y = f ? this.redoStack : this.undoStack;
      f ? this.stopCapturing() : m || this.clear(!1, !0);
      const v = new ua();
      p.afterState.forEach((B, O) => {
        const L = p.beforeState.get(O) || 0, G = B - L;
        G > 0 && kl(v, O, L, G);
      });
      const k = Lj();
      let A = !1;
      if (this.lastChange > 0 && k - this.lastChange < this.captureTimeout && y.length > 0 && !f && !m) {
        const B = y[y.length - 1];
        B.deletions = yf([B.deletions, p.deleteSet]), B.insertions = yf([B.insertions, v]);
      } else
        y.push(new XU(p.deleteSet, v)), A = !0;
      !f && !m && (this.lastChange = k), $i(
        p,
        p.deleteSet,
        /** @param {Item|GC} item */
        (B) => {
          B instanceof Ke && this.scope.some((O) => O === p.doc || Cl(
            /** @type {AbstractType<any>} */
            O,
            B
          )) && Gm(B, !0);
        }
      );
      const S = [{ stackItem: y[y.length - 1], origin: p.origin, type: f ? "redo" : "undo", changedParentTypes: p.changedParentTypes }, this];
      A ? this.emit("stack-item-added", S) : this.emit("stack-item-updated", S);
    }, this.doc.on("afterTransaction", this.afterTransactionHandler), this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  /**
   * Extend the scope.
   *
   * @param {Array<AbstractType<any> | Doc> | AbstractType<any> | Doc} ytypes
   */
  addToScope(e) {
    const t = new Set(this.scope);
    e = pf(e) ? e : [e], e.forEach((r) => {
      t.has(r) || (t.add(r), (r instanceof Dt ? r.doc !== this.doc : r !== this.doc) && BA("[yjs#509] Not same Y.Doc"), this.scope.push(r));
    });
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(e) {
    this.trackedOrigins.add(e);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(e) {
    this.trackedOrigins.delete(e);
  }
  clear(e = !0, t = !0) {
    (e && this.canUndo() || t && this.canRedo()) && this.doc.transact((r) => {
      e && (this.undoStack.forEach((o) => ex(r, this, o)), this.undoStack = []), t && (this.redoStack.forEach((o) => ex(r, this, o)), this.redoStack = []), this.emit("stack-cleared", [{ undoStackCleared: e, redoStackCleared: t }]);
    });
  }
  /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */
  stopCapturing() {
    this.lastChange = 0;
  }
  /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  undo() {
    this.undoing = !0;
    let e;
    try {
      e = tx(this, this.undoStack, "undo");
    } finally {
      this.undoing = !1;
    }
    return e;
  }
  /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  redo() {
    this.redoing = !0;
    let e;
    try {
      e = tx(this, this.redoStack, "redo");
    } finally {
      this.redoing = !1;
    }
    return e;
  }
  /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this), this.doc.off("afterTransaction", this.afterTransactionHandler), super.destroy();
  }
}
function* JU(n) {
  const e = Re(n.restDecoder);
  for (let t = 0; t < e; t++) {
    const r = Re(n.restDecoder), o = n.readClient();
    let a = Re(n.restDecoder);
    for (let l = 0; l < r; l++) {
      const d = n.readInfo();
      if (d === 10) {
        const p = Re(n.restDecoder);
        yield new Dn(Te(o, a), p), a += p;
      } else if (hd & d) {
        const p = (d & (Kr | sn)) === 0, f = new Ke(
          Te(o, a),
          null,
          // left
          (d & sn) === sn ? n.readLeftID() : null,
          // origin
          null,
          // right
          (d & Kr) === Kr ? n.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          p ? n.readParentInfo() ? n.readString() : n.readLeftID() : null,
          // parent
          p && (d & bl) === bl ? n.readString() : null,
          // parentSub
          hC(n, d)
          // item content
        );
        yield f, a += f.length;
      } else {
        const p = n.readLen();
        yield new On(Te(o, a), p), a += p;
      }
    }
  }
}
class Fm {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(e, t) {
    this.gen = JU(e), this.curr = null, this.done = !1, this.filterSkips = t, this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do
      this.curr = this.gen.next().value || null;
    while (this.filterSkips && this.curr !== null && this.curr.constructor === Dn);
    return this.curr;
  }
}
class Pm {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(e) {
    this.currClient = 0, this.startClock = 0, this.written = 0, this.encoder = e, this.clientStructs = [];
  }
}
const KU = (n) => Uu(n, PA, Hl), WU = (n, e) => {
  if (n.constructor === On) {
    const { client: t, clock: r } = n.id;
    return new On(Te(t, r + e), n.length - e);
  } else if (n.constructor === Dn) {
    const { client: t, clock: r } = n.id;
    return new Dn(Te(t, r + e), n.length - e);
  } else {
    const t = (
      /** @type {Item} */
      n
    ), { client: r, clock: o } = t.id;
    return new Ke(
      Te(r, o + e),
      null,
      Te(r, o + e - 1),
      null,
      t.rightOrigin,
      t.parent,
      t.parentSub,
      t.content.splice(e)
    );
  }
}, Uu = (n, e = Zs, t = Do) => {
  if (n.length === 1)
    return n[0];
  const r = n.map((m) => new e(ca(m)));
  let o = r.map((m) => new Fm(m, !0)), a = null;
  const l = new t(), d = new Pm(l);
  for (; o = o.filter((v) => v.curr !== null), o.sort(
    /** @type {function(any,any):number} */
    (v, k) => {
      if (v.curr.id.client === k.curr.id.client) {
        const A = v.curr.id.clock - k.curr.id.clock;
        return A === 0 ? v.curr.constructor === k.curr.constructor ? 0 : v.curr.constructor === Dn ? 1 : -1 : A;
      } else
        return k.curr.id.client - v.curr.id.client;
    }
  ), o.length !== 0; ) {
    const m = o[0], y = (
      /** @type {Item | GC} */
      m.curr.id.client
    );
    if (a !== null) {
      let v = (
        /** @type {Item | GC | null} */
        m.curr
      ), k = !1;
      for (; v !== null && v.id.clock + v.length <= a.struct.id.clock + a.struct.length && v.id.client >= a.struct.id.client; )
        v = m.next(), k = !0;
      if (v === null || // current decoder is empty
      v.id.client !== y || // check whether there is another decoder that has has updates from `firstClient`
      k && v.id.clock > a.struct.id.clock + a.struct.length)
        continue;
      if (y !== a.struct.id.client)
        Ci(d, a.struct, a.offset), a = { struct: v, offset: 0 }, m.next();
      else if (a.struct.id.clock + a.struct.length < v.id.clock)
        if (a.struct.constructor === Dn)
          a.struct.length = v.id.clock + v.length - a.struct.id.clock;
        else {
          Ci(d, a.struct, a.offset);
          const A = v.id.clock - a.struct.id.clock - a.struct.length;
          a = { struct: new Dn(Te(y, a.struct.id.clock + a.struct.length), A), offset: 0 };
        }
      else {
        const A = a.struct.id.clock + a.struct.length - v.id.clock;
        A > 0 && (a.struct.constructor === Dn ? a.struct.length -= A : v = WU(v, A)), a.struct.mergeWith(
          /** @type {any} */
          v
        ) || (Ci(d, a.struct, a.offset), a = { struct: v, offset: 0 }, m.next());
      }
    } else
      a = { struct: (
        /** @type {Item | GC} */
        m.curr
      ), offset: 0 }, m.next();
    for (let v = m.curr; v !== null && v.id.client === y && v.id.clock === a.struct.id.clock + a.struct.length && v.constructor !== Dn; v = m.next())
      Ci(d, a.struct, a.offset), a = { struct: v, offset: 0 };
  }
  a !== null && (Ci(d, a.struct, a.offset), a = null), $m(d);
  const p = r.map((m) => Om(m)), f = yf(p);
  return pa(l, f), l.toUint8Array();
}, YU = (n, e, t = Zs, r = Do) => {
  const o = UA(e), a = new r(), l = new Pm(a), d = new t(ca(n)), p = new Fm(d, !1);
  for (; p.curr; ) {
    const m = p.curr, y = m.id.client, v = o.get(y) || 0;
    if (p.curr.constructor === Dn) {
      p.next();
      continue;
    }
    if (m.id.clock + m.length > v)
      for (Ci(l, m, Qn(v - m.id.clock, 0)), p.next(); p.curr && p.curr.id.client === y; )
        Ci(l, p.curr, 0), p.next();
    else
      for (; p.curr && p.curr.id.client === y && p.curr.id.clock + p.curr.length <= v; )
        p.next();
  }
  $m(l);
  const f = Om(d);
  return pa(a, f), a.toUint8Array();
}, JA = (n) => {
  n.written > 0 && (n.clientStructs.push({ written: n.written, restEncoder: Kn(n.encoder.restEncoder) }), n.encoder.restEncoder = Ll(), n.written = 0);
}, Ci = (n, e, t) => {
  n.written > 0 && n.currClient !== e.id.client && JA(n), n.written === 0 && (n.currClient = e.id.client, n.encoder.writeClient(e.id.client), Ue(n.encoder.restEncoder, e.id.clock + t)), e.write(n.encoder, t), n.written++;
}, $m = (n) => {
  JA(n);
  const e = n.encoder.restEncoder;
  Ue(e, n.clientStructs.length);
  for (let t = 0; t < n.clientStructs.length; t++) {
    const r = n.clientStructs[t];
    Ue(e, r.written), fd(e, r.restEncoder);
  }
}, QU = (n, e, t, r) => {
  const o = new t(ca(n)), a = new Fm(o, !1), l = new r(), d = new Pm(l);
  for (let f = a.curr; f !== null; f = a.next())
    Ci(d, e(f), 0);
  $m(d);
  const p = Om(o);
  return pa(l, p), l.toUint8Array();
}, ZU = (n) => QU(n, Wj, Zs, Hl), nx = "You must not compute changes after the event-handler fired.";
class gd {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(e, t) {
    this.target = e, this.currentTarget = e, this.transaction = t, this._changes = null, this._keys = null, this._delta = null, this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = eL(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(e) {
    return da(this.transaction.deleteSet, e.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw Pi(nx);
      const e = /* @__PURE__ */ new Map(), t = this.target;
      /** @type Set<string|null> */
      this.transaction.changed.get(t).forEach((o) => {
        if (o !== null) {
          const a = (
            /** @type {Item} */
            t._map.get(o)
          );
          let l, d;
          if (this.adds(a)) {
            let p = a.left;
            for (; p !== null && this.adds(p); )
              p = p.left;
            if (this.deletes(a))
              if (p !== null && this.deletes(p))
                l = "delete", d = Eh(p.content.getContent());
              else
                return;
            else
              p !== null && this.deletes(p) ? (l = "update", d = Eh(p.content.getContent())) : (l = "add", d = void 0);
          } else if (this.deletes(a))
            l = "delete", d = Eh(
              /** @type {Item} */
              a.content.getContent()
            );
          else
            return;
          e.set(o, { action: l, oldValue: d });
        }
      }), this._keys = e;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(e) {
    return e.id.clock >= (this.transaction.beforeState.get(e.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let e = this._changes;
    if (e === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw Pi(nx);
      const t = this.target, r = Oo(), o = Oo(), a = [];
      if (e = {
        added: r,
        deleted: o,
        delta: a,
        keys: this.keys
      }, /** @type Set<string|null> */
      this.transaction.changed.get(t).has(null)) {
        let d = null;
        const p = () => {
          d && a.push(d);
        };
        for (let f = t._start; f !== null; f = f.right)
          f.deleted ? this.deletes(f) && !this.adds(f) && ((d === null || d.delete === void 0) && (p(), d = { delete: 0 }), d.delete += f.length, o.add(f)) : this.adds(f) ? ((d === null || d.insert === void 0) && (p(), d = { insert: [] }), d.insert = d.insert.concat(f.content.getContent()), r.add(f)) : ((d === null || d.retain === void 0) && (p(), d = { retain: 0 }), d.retain += f.length);
        d !== null && d.retain === void 0 && p();
      }
      this._changes = e;
    }
    return (
      /** @type {any} */
      e
    );
  }
}
const eL = (n, e) => {
  const t = [];
  for (; e._item !== null && e !== n; ) {
    if (e._item.parentSub !== null)
      t.unshift(e._item.parentSub);
    else {
      let r = 0, o = (
        /** @type {AbstractType<any>} */
        e._item.parent._start
      );
      for (; o !== e._item && o !== null; )
        !o.deleted && o.countable && (r += o.length), o = o.right;
      t.unshift(r);
    }
    e = /** @type {AbstractType<any>} */
    e._item.parent;
  }
  return t;
}, Kt = () => {
  BA("Invalid access: Add Yjs type to a document before reading data.");
}, KA = 80;
let jm = 0;
class tL {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(e, t) {
    e.marker = !0, this.p = e, this.index = t, this.timestamp = jm++;
  }
}
const nL = (n) => {
  n.timestamp = jm++;
}, WA = (n, e, t) => {
  n.p.marker = !1, n.p = e, e.marker = !0, n.index = t, n.timestamp = jm++;
}, rL = (n, e, t) => {
  if (n.length >= KA) {
    const r = n.reduce((o, a) => o.timestamp < a.timestamp ? o : a);
    return WA(r, e, t), r;
  } else {
    const r = new tL(e, t);
    return n.push(r), r;
  }
}, yd = (n, e) => {
  if (n._start === null || e === 0 || n._searchMarker === null)
    return null;
  const t = n._searchMarker.length === 0 ? null : n._searchMarker.reduce((a, l) => fu(e - a.index) < fu(e - l.index) ? a : l);
  let r = n._start, o = 0;
  for (t !== null && (r = t.p, o = t.index, nL(t)); r.right !== null && o < e; ) {
    if (!r.deleted && r.countable) {
      if (e < o + r.length)
        break;
      o += r.length;
    }
    r = r.right;
  }
  for (; r.left !== null && o > e; )
    r = r.left, !r.deleted && r.countable && (o -= r.length);
  for (; r.left !== null && r.left.id.client === r.id.client && r.left.id.clock + r.left.length === r.id.clock; )
    r = r.left, !r.deleted && r.countable && (o -= r.length);
  return t !== null && fu(t.index - o) < /** @type {YText|YArray<any>} */
  r.parent.length / KA ? (WA(t, r, o), t) : rL(n._searchMarker, r, o);
}, El = (n, e, t) => {
  for (let r = n.length - 1; r >= 0; r--) {
    const o = n[r];
    if (t > 0) {
      let a = o.p;
      for (a.marker = !1; a && (a.deleted || !a.countable); )
        a = a.left, a && !a.deleted && a.countable && (o.index -= a.length);
      if (a === null || a.marker === !0) {
        n.splice(r, 1);
        continue;
      }
      o.p = a, a.marker = !0;
    }
    (e < o.index || t > 0 && e === o.index) && (o.index = Qn(e, o.index + t));
  }
}, wd = (n, e, t) => {
  const r = n, o = e.changedParentTypes;
  for (; Br(o, n, () => []).push(t), n._item !== null; )
    n = /** @type {AbstractType<any>} */
    n._item.parent;
  HA(r._eH, t, e);
};
class Dt {
  constructor() {
    this._item = null, this._map = /* @__PURE__ */ new Map(), this._start = null, this.doc = null, this._length = 0, this._eH = Xv(), this._dEH = Xv(), this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(e, t) {
    this.doc = e, this._item = t;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw Wn();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw Wn();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(e) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let e = this._start;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, t) {
    !e.local && this._searchMarker && (this._searchMarker.length = 0);
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(e) {
    Jv(this._eH, e);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(e) {
    Jv(this._dEH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(e) {
    Kv(this._eH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(e) {
    Kv(this._dEH, e);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
}
const YA = (n, e, t) => {
  n.doc ?? Kt(), e < 0 && (e = n._length + e), t < 0 && (t = n._length + t);
  let r = t - e;
  const o = [];
  let a = n._start;
  for (; a !== null && r > 0; ) {
    if (a.countable && !a.deleted) {
      const l = a.content.getContent();
      if (l.length <= e)
        e -= l.length;
      else {
        for (let d = e; d < l.length && r > 0; d++)
          o.push(l[d]), r--;
        e = 0;
      }
    }
    a = a.right;
  }
  return o;
}, QA = (n) => {
  n.doc ?? Kt();
  const e = [];
  let t = n._start;
  for (; t !== null; ) {
    if (t.countable && !t.deleted) {
      const r = t.content.getContent();
      for (let o = 0; o < r.length; o++)
        e.push(r[o]);
    }
    t = t.right;
  }
  return e;
}, ZA = (n, e) => {
  const t = [];
  let r = n._start;
  for (; r !== null; ) {
    if (r.countable && mo(r, e)) {
      const o = r.content.getContent();
      for (let a = 0; a < o.length; a++)
        t.push(o[a]);
    }
    r = r.right;
  }
  return t;
}, Tl = (n, e) => {
  let t = 0, r = n._start;
  for (n.doc ?? Kt(); r !== null; ) {
    if (r.countable && !r.deleted) {
      const o = r.content.getContent();
      for (let a = 0; a < o.length; a++)
        e(o[a], t++, n);
    }
    r = r.right;
  }
}, eC = (n, e) => {
  const t = [];
  return Tl(n, (r, o) => {
    t.push(e(r, o, n));
  }), t;
}, iL = (n) => {
  let e = n._start, t = null, r = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (t === null) {
        for (; e !== null && e.deleted; )
          e = e.right;
        if (e === null)
          return {
            done: !0,
            value: void 0
          };
        t = e.content.getContent(), r = 0, e = e.right;
      }
      const o = t[r++];
      return t.length <= r && (t = null), {
        done: !1,
        value: o
      };
    }
  };
}, tC = (n, e) => {
  n.doc ?? Kt();
  const t = yd(n, e);
  let r = n._start;
  for (t !== null && (r = t.p, e -= t.index); r !== null; r = r.right)
    if (!r.deleted && r.countable) {
      if (e < r.length)
        return r.content.getContent()[e];
      e -= r.length;
    }
}, Lu = (n, e, t, r) => {
  let o = t;
  const a = n.doc, l = a.clientID, d = a.store, p = t === null ? e._start : t.right;
  let f = [];
  const m = () => {
    f.length > 0 && (o = new Ke(Te(l, xt(d, l)), o, o && o.lastId, p, p && p.id, e, null, new Fo(f)), o.integrate(n, 0), f = []);
  };
  r.forEach((y) => {
    if (y === null)
      f.push(y);
    else
      switch (y.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          f.push(y);
          break;
        default:
          switch (m(), y.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              o = new Ke(Te(l, xt(d, l)), o, o && o.lastId, p, p && p.id, e, null, new _l(new Uint8Array(
                /** @type {Uint8Array} */
                y
              ))), o.integrate(n, 0);
              break;
            case ni:
              o = new Ke(Te(l, xt(d, l)), o, o && o.lastId, p, p && p.id, e, null, new zl(
                /** @type {Doc} */
                y
              )), o.integrate(n, 0);
              break;
            default:
              if (y instanceof Dt)
                o = new Ke(Te(l, xt(d, l)), o, o && o.lastId, p, p && p.id, e, null, new rr(y)), o.integrate(n, 0);
              else
                throw new Error("Unexpected content type in insert operation");
          }
      }
  }), m();
}, nC = () => Pi("Length exceeded!"), rC = (n, e, t, r) => {
  if (t > e._length)
    throw nC();
  if (t === 0)
    return e._searchMarker && El(e._searchMarker, t, r.length), Lu(n, e, null, r);
  const o = t, a = yd(e, t);
  let l = e._start;
  for (a !== null && (l = a.p, t -= a.index, t === 0 && (l = l.prev, t += l && l.countable && !l.deleted ? l.length : 0)); l !== null; l = l.right)
    if (!l.deleted && l.countable) {
      if (t <= l.length) {
        t < l.length && mn(n, Te(l.id.client, l.id.clock + t));
        break;
      }
      t -= l.length;
    }
  return e._searchMarker && El(e._searchMarker, o, r.length), Lu(n, e, l, r);
}, oL = (n, e, t) => {
  let o = (e._searchMarker || []).reduce((a, l) => l.index > a.index ? l : a, { index: 0, p: e._start }).p;
  if (o)
    for (; o.right; )
      o = o.right;
  return Lu(n, e, o, t);
}, iC = (n, e, t, r) => {
  if (r === 0)
    return;
  const o = t, a = r, l = yd(e, t);
  let d = e._start;
  for (l !== null && (d = l.p, t -= l.index); d !== null && t > 0; d = d.right)
    !d.deleted && d.countable && (t < d.length && mn(n, Te(d.id.client, d.id.clock + t)), t -= d.length);
  for (; r > 0 && d !== null; )
    d.deleted || (r < d.length && mn(n, Te(d.id.client, d.id.clock + r)), d.delete(n), r -= d.length), d = d.right;
  if (r > 0)
    throw nC();
  e._searchMarker && El(
    e._searchMarker,
    o,
    -a + r
    /* in case we remove the above exception */
  );
}, Hu = (n, e, t) => {
  const r = e._map.get(t);
  r !== void 0 && r.delete(n);
}, Um = (n, e, t, r) => {
  const o = e._map.get(t) || null, a = n.doc, l = a.clientID;
  let d;
  if (r == null)
    d = new Fo([r]);
  else
    switch (r.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
      case Date:
      case BigInt:
        d = new Fo([r]);
        break;
      case Uint8Array:
        d = new _l(
          /** @type {Uint8Array} */
          r
        );
        break;
      case ni:
        d = new zl(
          /** @type {Doc} */
          r
        );
        break;
      default:
        if (r instanceof Dt)
          d = new rr(r);
        else
          throw new Error("Unexpected content type");
    }
  new Ke(Te(l, xt(a.store, l)), o, o && o.lastId, null, null, e, t, d).integrate(n, 0);
}, Lm = (n, e) => {
  n.doc ?? Kt();
  const t = n._map.get(e);
  return t !== void 0 && !t.deleted ? t.content.getContent()[t.length - 1] : void 0;
}, oC = (n) => {
  const e = {};
  return n.doc ?? Kt(), n._map.forEach((t, r) => {
    t.deleted || (e[r] = t.content.getContent()[t.length - 1]);
  }), e;
}, sC = (n, e) => {
  n.doc ?? Kt();
  const t = n._map.get(e);
  return t !== void 0 && !t.deleted;
}, sL = (n, e) => {
  const t = {};
  return n._map.forEach((r, o) => {
    let a = r;
    for (; a !== null && (!e.sv.has(a.id.client) || a.id.clock >= (e.sv.get(a.id.client) || 0)); )
      a = a.left;
    a !== null && mo(a, e) && (t[o] = a.content.getContent()[a.length - 1]);
  }), t;
}, Yc = (n) => (n.doc ?? Kt(), xU(
  n._map.entries(),
  /** @param {any} entry */
  (e) => !e[1].deleted
));
class aL extends gd {
}
class _s extends Dt {
  constructor() {
    super(), this._prelimContent = [], this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(e) {
    const t = new _s();
    return t.push(e), t;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, t) {
    super._integrate(e, t), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new _s();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const e = new _s();
    return e.insert(0, this.toArray().map(
      (t) => t instanceof Dt ? (
        /** @type {typeof el} */
        t.clone()
      ) : t
    )), e;
  }
  get length() {
    return this.doc ?? Kt(), this._length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, t) {
    super._callObserver(e, t), wd(this, e, new aL(this, e));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(e, t) {
    this.doc !== null ? et(this.doc, (r) => {
      rC(
        r,
        this,
        e,
        /** @type {any} */
        t
      );
    }) : this._prelimContent.splice(e, 0, ...t);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(e) {
    this.doc !== null ? et(this.doc, (t) => {
      oL(
        t,
        this,
        /** @type {any} */
        e
      );
    }) : this._prelimContent.push(...e);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(e, t = 1) {
    this.doc !== null ? et(this.doc, (r) => {
      iC(r, this, e, t);
    }) : this._prelimContent.splice(e, t);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(e) {
    return tC(this, e);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return QA(this);
  }
  /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(e = 0, t = this.length) {
    return YA(this, e, t);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((e) => e instanceof Dt ? e.toJSON() : e);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(e) {
    return eC(
      this,
      /** @type {any} */
      e
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    Tl(this, e);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return iL(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(OL);
  }
}
const lL = (n) => new _s();
class cL extends gd {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(e, t, r) {
    super(e, t), this.keysChanged = r;
  }
}
class ea extends Dt {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(e) {
    super(), this._prelimContent = null, e === void 0 ? this._prelimContent = /* @__PURE__ */ new Map() : this._prelimContent = new Map(e);
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, t) {
    super._integrate(e, t), this._prelimContent.forEach((r, o) => {
      this.set(o, r);
    }), this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new ea();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const e = new ea();
    return this.forEach((t, r) => {
      e.set(r, t instanceof Dt ? (
        /** @type {typeof value} */
        t.clone()
      ) : t);
    }), e;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, t) {
    wd(this, e, new cL(this, e, t));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    this.doc ?? Kt();
    const e = {};
    return this._map.forEach((t, r) => {
      if (!t.deleted) {
        const o = t.content.getContent()[t.length - 1];
        e[r] = o instanceof Dt ? o.toJSON() : o;
      }
    }), e;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...Yc(this)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return Mh(
      Yc(this),
      /** @param {any} v */
      (e) => e[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return Mh(
      Yc(this),
      /** @param {any} v */
      (e) => e[1].content.getContent()[e[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return Mh(
      Yc(this),
      /** @param {any} v */
      (e) => (
        /** @type {any} */
        [e[0], e[1].content.getContent()[e[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    this.doc ?? Kt(), this._map.forEach((t, r) => {
      t.deleted || e(t.content.getContent()[t.length - 1], r, this);
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(e) {
    this.doc !== null ? et(this.doc, (t) => {
      Hu(t, this, e);
    }) : this._prelimContent.delete(e);
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(e, t) {
    return this.doc !== null ? et(this.doc, (r) => {
      Um(
        r,
        this,
        e,
        /** @type {any} */
        t
      );
    }) : this._prelimContent.set(e, t), t;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(e) {
    return (
      /** @type {any} */
      Lm(this, e)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(e) {
    return sC(this, e);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    this.doc !== null ? et(this.doc, (e) => {
      this.forEach(function(t, r, o) {
        Hu(e, o, r);
      });
    }) : this._prelimContent.clear();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(DL);
  }
}
const uL = (n) => new ea(), Bi = (n, e) => n === e || typeof n == "object" && typeof e == "object" && n && e && Jj(n, e);
class vf {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(e, t, r, o) {
    this.left = e, this.right = t, this.index = r, this.currentAttributes = o;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    switch (this.right === null && bn(), this.right.content.constructor) {
      case St:
        this.right.deleted || ha(
          this.currentAttributes,
          /** @type {ContentFormat} */
          this.right.content
        );
        break;
      default:
        this.right.deleted || (this.index += this.right.length);
        break;
    }
    this.left = this.right, this.right = this.right.right;
  }
}
const rx = (n, e, t) => {
  for (; e.right !== null && t > 0; ) {
    switch (e.right.content.constructor) {
      case St:
        e.right.deleted || ha(
          e.currentAttributes,
          /** @type {ContentFormat} */
          e.right.content
        );
        break;
      default:
        e.right.deleted || (t < e.right.length && mn(n, Te(e.right.id.client, e.right.id.clock + t)), e.index += e.right.length, t -= e.right.length);
        break;
    }
    e.left = e.right, e.right = e.right.right;
  }
  return e;
}, Qc = (n, e, t, r) => {
  const o = /* @__PURE__ */ new Map(), a = r ? yd(e, t) : null;
  if (a) {
    const l = new vf(a.p.left, a.p, a.index, o);
    return rx(n, l, t - a.index);
  } else {
    const l = new vf(null, e._start, 0, o);
    return rx(n, l, t);
  }
}, aC = (n, e, t, r) => {
  for (; t.right !== null && (t.right.deleted === !0 || t.right.content.constructor === St && Bi(
    r.get(
      /** @type {ContentFormat} */
      t.right.content.key
    ),
    /** @type {ContentFormat} */
    t.right.content.value
  )); )
    t.right.deleted || r.delete(
      /** @type {ContentFormat} */
      t.right.content.key
    ), t.forward();
  const o = n.doc, a = o.clientID;
  r.forEach((l, d) => {
    const p = t.left, f = t.right, m = new Ke(Te(a, xt(o.store, a)), p, p && p.lastId, f, f && f.id, e, null, new St(d, l));
    m.integrate(n, 0), t.right = m, t.forward();
  });
}, ha = (n, e) => {
  const { key: t, value: r } = e;
  r === null ? n.delete(t) : n.set(t, r);
}, lC = (n, e) => {
  for (; n.right !== null; ) {
    if (!(n.right.deleted || n.right.content.constructor === St && Bi(
      e[
        /** @type {ContentFormat} */
        n.right.content.key
      ] ?? null,
      /** @type {ContentFormat} */
      n.right.content.value
    ))) break;
    n.forward();
  }
}, cC = (n, e, t, r) => {
  const o = n.doc, a = o.clientID, l = /* @__PURE__ */ new Map();
  for (const d in r) {
    const p = r[d], f = t.currentAttributes.get(d) ?? null;
    if (!Bi(f, p)) {
      l.set(d, f);
      const { left: m, right: y } = t;
      t.right = new Ke(Te(a, xt(o.store, a)), m, m && m.lastId, y, y && y.id, e, null, new St(d, p)), t.right.integrate(n, 0), t.forward();
    }
  }
  return l;
}, Rh = (n, e, t, r, o) => {
  t.currentAttributes.forEach((v, k) => {
    o[k] === void 0 && (o[k] = null);
  });
  const a = n.doc, l = a.clientID;
  lC(t, o);
  const d = cC(n, e, t, o), p = r.constructor === String ? new er(
    /** @type {string} */
    r
  ) : r instanceof Dt ? new rr(r) : new Lo(r);
  let { left: f, right: m, index: y } = t;
  e._searchMarker && El(e._searchMarker, t.index, p.getLength()), m = new Ke(Te(l, xt(a.store, l)), f, f && f.lastId, m, m && m.id, e, null, p), m.integrate(n, 0), t.right = m, t.index = y, t.forward(), aC(n, e, t, d);
}, ix = (n, e, t, r, o) => {
  const a = n.doc, l = a.clientID;
  lC(t, o);
  const d = cC(n, e, t, o);
  e: for (; t.right !== null && (r > 0 || d.size > 0 && (t.right.deleted || t.right.content.constructor === St)); ) {
    if (!t.right.deleted)
      switch (t.right.content.constructor) {
        case St: {
          const { key: p, value: f } = (
            /** @type {ContentFormat} */
            t.right.content
          ), m = o[p];
          if (m !== void 0) {
            if (Bi(m, f))
              d.delete(p);
            else {
              if (r === 0)
                break e;
              d.set(p, f);
            }
            t.right.delete(n);
          } else
            t.currentAttributes.set(p, f);
          break;
        }
        default:
          r < t.right.length && mn(n, Te(t.right.id.client, t.right.id.clock + r)), r -= t.right.length;
          break;
      }
    t.forward();
  }
  if (r > 0) {
    let p = "";
    for (; r > 0; r--)
      p += `
`;
    t.right = new Ke(Te(l, xt(a.store, l)), t.left, t.left && t.left.lastId, t.right, t.right && t.right.id, e, null, new er(p)), t.right.integrate(n, 0), t.forward();
  }
  aC(n, e, t, d);
}, uC = (n, e, t, r, o) => {
  let a = e;
  const l = Pn();
  for (; a && (!a.countable || a.deleted); ) {
    if (!a.deleted && a.content.constructor === St) {
      const f = (
        /** @type {ContentFormat} */
        a.content
      );
      l.set(f.key, f);
    }
    a = a.right;
  }
  let d = 0, p = !1;
  for (; e !== a; ) {
    if (t === e && (p = !0), !e.deleted) {
      const f = e.content;
      switch (f.constructor) {
        case St: {
          const { key: m, value: y } = (
            /** @type {ContentFormat} */
            f
          ), v = r.get(m) ?? null;
          (l.get(m) !== f || v === y) && (e.delete(n), d++, !p && (o.get(m) ?? null) === y && v !== y && (v === null ? o.delete(m) : o.set(m, v))), !p && !e.deleted && ha(
            o,
            /** @type {ContentFormat} */
            f
          );
          break;
        }
      }
    }
    e = /** @type {Item} */
    e.right;
  }
  return d;
}, dL = (n, e) => {
  for (; e && e.right && (e.right.deleted || !e.right.countable); )
    e = e.right;
  const t = /* @__PURE__ */ new Set();
  for (; e && (e.deleted || !e.countable); ) {
    if (!e.deleted && e.content.constructor === St) {
      const r = (
        /** @type {ContentFormat} */
        e.content.key
      );
      t.has(r) ? e.delete(n) : t.add(r);
    }
    e = e.left;
  }
}, pL = (n) => {
  let e = 0;
  return et(
    /** @type {Doc} */
    n.doc,
    (t) => {
      let r = (
        /** @type {Item} */
        n._start
      ), o = n._start, a = Pn();
      const l = df(a);
      for (; o; ) {
        if (o.deleted === !1)
          switch (o.content.constructor) {
            case St:
              ha(
                l,
                /** @type {ContentFormat} */
                o.content
              );
              break;
            default:
              e += uC(t, r, o, a, l), a = df(l), r = o;
              break;
          }
        o = o.right;
      }
    }
  ), e;
}, hL = (n) => {
  const e = /* @__PURE__ */ new Set(), t = n.doc;
  for (const [r, o] of n.afterState.entries()) {
    const a = n.beforeState.get(r) || 0;
    o !== a && qA(
      n,
      /** @type {Array<Item|GC>} */
      t.store.clients.get(r),
      a,
      o,
      (l) => {
        !l.deleted && /** @type {Item} */
        l.content.constructor === St && l.constructor !== On && e.add(
          /** @type {any} */
          l.parent
        );
      }
    );
  }
  et(t, (r) => {
    $i(n, n.deleteSet, (o) => {
      if (o instanceof On || !/** @type {YText} */
      o.parent._hasFormatting || e.has(
        /** @type {YText} */
        o.parent
      ))
        return;
      const a = (
        /** @type {YText} */
        o.parent
      );
      o.content.constructor === St ? e.add(a) : dL(r, o);
    });
    for (const o of e)
      pL(o);
  });
}, ox = (n, e, t) => {
  const r = t, o = df(e.currentAttributes), a = e.right;
  for (; t > 0 && e.right !== null; ) {
    if (e.right.deleted === !1)
      switch (e.right.content.constructor) {
        case rr:
        case Lo:
        case er:
          t < e.right.length && mn(n, Te(e.right.id.client, e.right.id.clock + t)), t -= e.right.length, e.right.delete(n);
          break;
      }
    e.forward();
  }
  a && uC(n, a, e.right, o, e.currentAttributes);
  const l = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (e.left || e.right).parent
  );
  return l._searchMarker && El(l._searchMarker, e.index, -r + t), e;
};
class fL extends gd {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(e, t, r) {
    super(e, t), this.childListChanged = !1, this.keysChanged = /* @__PURE__ */ new Set(), r.forEach((o) => {
      o === null ? this.childListChanged = !0 : this.keysChanged.add(o);
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const e = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = e;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const e = (
        /** @type {Doc} */
        this.target.doc
      ), t = [];
      et(e, (r) => {
        const o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
        let l = this.target._start, d = null;
        const p = {};
        let f = "", m = 0, y = 0;
        const v = () => {
          if (d !== null) {
            let k = null;
            switch (d) {
              case "delete":
                y > 0 && (k = { delete: y }), y = 0;
                break;
              case "insert":
                (typeof f == "object" || f.length > 0) && (k = { insert: f }, o.size > 0 && (k.attributes = {}, o.forEach((A, S) => {
                  A !== null && (k.attributes[S] = A);
                }))), f = "";
                break;
              case "retain":
                m > 0 && (k = { retain: m }, Vj(p) || (k.attributes = zj({}, p))), m = 0;
                break;
            }
            k && t.push(k), d = null;
          }
        };
        for (; l !== null; ) {
          switch (l.content.constructor) {
            case rr:
            case Lo:
              this.adds(l) ? this.deletes(l) || (v(), d = "insert", f = l.content.getContent()[0], v()) : this.deletes(l) ? (d !== "delete" && (v(), d = "delete"), y += 1) : l.deleted || (d !== "retain" && (v(), d = "retain"), m += 1);
              break;
            case er:
              this.adds(l) ? this.deletes(l) || (d !== "insert" && (v(), d = "insert"), f += /** @type {ContentString} */
              l.content.str) : this.deletes(l) ? (d !== "delete" && (v(), d = "delete"), y += l.length) : l.deleted || (d !== "retain" && (v(), d = "retain"), m += l.length);
              break;
            case St: {
              const { key: k, value: A } = (
                /** @type {ContentFormat} */
                l.content
              );
              if (this.adds(l)) {
                if (!this.deletes(l)) {
                  const S = o.get(k) ?? null;
                  Bi(S, A) ? A !== null && l.delete(r) : (d === "retain" && v(), Bi(A, a.get(k) ?? null) ? delete p[k] : p[k] = A);
                }
              } else if (this.deletes(l)) {
                a.set(k, A);
                const S = o.get(k) ?? null;
                Bi(S, A) || (d === "retain" && v(), p[k] = S);
              } else if (!l.deleted) {
                a.set(k, A);
                const S = p[k];
                S !== void 0 && (Bi(S, A) ? S !== null && l.delete(r) : (d === "retain" && v(), A === null ? delete p[k] : p[k] = A));
              }
              l.deleted || (d === "insert" && v(), ha(
                o,
                /** @type {ContentFormat} */
                l.content
              ));
              break;
            }
          }
          l = l.right;
        }
        for (v(); t.length > 0; ) {
          const k = t[t.length - 1];
          if (k.retain !== void 0 && k.attributes === void 0)
            t.pop();
          else
            break;
        }
      }), this._delta = t;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
}
class ji extends Dt {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(e) {
    super(), this._pending = e !== void 0 ? [() => this.insert(0, e)] : [], this._searchMarker = [], this._hasFormatting = !1;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this.doc ?? Kt(), this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(e, t) {
    super._integrate(e, t);
    try {
      this._pending.forEach((r) => r());
    } catch (r) {
      console.error(r);
    }
    this._pending = null;
  }
  _copy() {
    return new ji();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const e = new ji();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, t) {
    super._callObserver(e, t);
    const r = new fL(this, e, t);
    wd(this, e, r), !e.local && this._hasFormatting && (e._needFormattingCleanup = !0);
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    this.doc ?? Kt();
    let e = "", t = this._start;
    for (; t !== null; )
      !t.deleted && t.countable && t.content.constructor === er && (e += /** @type {ContentString} */
      t.content.str), t = t.right;
    return e;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {Array<any>} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(e, { sanitize: t = !0 } = {}) {
    this.doc !== null ? et(this.doc, (r) => {
      const o = new vf(null, this._start, 0, /* @__PURE__ */ new Map());
      for (let a = 0; a < e.length; a++) {
        const l = e[a];
        if (l.insert !== void 0) {
          const d = !t && typeof l.insert == "string" && a === e.length - 1 && o.right === null && l.insert.slice(-1) === `
` ? l.insert.slice(0, -1) : l.insert;
          (typeof d != "string" || d.length > 0) && Rh(r, this, o, d, l.attributes || {});
        } else l.retain !== void 0 ? ix(r, this, o, l.retain, l.attributes || {}) : l.delete !== void 0 && ox(r, o, l.delete);
      }
    }) : this._pending.push(() => this.applyDelta(e));
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(e, t, r) {
    this.doc ?? Kt();
    const o = [], a = /* @__PURE__ */ new Map(), l = (
      /** @type {Doc} */
      this.doc
    );
    let d = "", p = this._start;
    function f() {
      if (d.length > 0) {
        const y = {};
        let v = !1;
        a.forEach((A, S) => {
          v = !0, y[S] = A;
        });
        const k = { insert: d };
        v && (k.attributes = y), o.push(k), d = "";
      }
    }
    const m = () => {
      for (; p !== null; ) {
        if (mo(p, e) || t !== void 0 && mo(p, t))
          switch (p.content.constructor) {
            case er: {
              const y = a.get("ychange");
              e !== void 0 && !mo(p, e) ? (y === void 0 || y.user !== p.id.client || y.type !== "removed") && (f(), a.set("ychange", r ? r("removed", p.id) : { type: "removed" })) : t !== void 0 && !mo(p, t) ? (y === void 0 || y.user !== p.id.client || y.type !== "added") && (f(), a.set("ychange", r ? r("added", p.id) : { type: "added" })) : y !== void 0 && (f(), a.delete("ychange")), d += /** @type {ContentString} */
              p.content.str;
              break;
            }
            case rr:
            case Lo: {
              f();
              const y = {
                insert: p.content.getContent()[0]
              };
              if (a.size > 0) {
                const v = (
                  /** @type {Object<string,any>} */
                  {}
                );
                y.attributes = v, a.forEach((k, A) => {
                  v[A] = k;
                });
              }
              o.push(y);
              break;
            }
            case St:
              mo(p, e) && (f(), ha(
                a,
                /** @type {ContentFormat} */
                p.content
              ));
              break;
          }
        p = p.right;
      }
      f();
    };
    return e || t ? et(l, (y) => {
      e && wf(y, e), t && wf(y, t), m();
    }, "cleanup") : m(), o;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(e, t, r) {
    if (t.length <= 0)
      return;
    const o = this.doc;
    o !== null ? et(o, (a) => {
      const l = Qc(a, this, e, !r);
      r || (r = {}, l.currentAttributes.forEach((d, p) => {
        r[p] = d;
      })), Rh(a, this, l, t, r);
    }) : this._pending.push(() => this.insert(e, t, r));
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(e, t, r) {
    const o = this.doc;
    o !== null ? et(o, (a) => {
      const l = Qc(a, this, e, !r);
      Rh(a, this, l, t, r || {});
    }) : this._pending.push(() => this.insertEmbed(e, t, r || {}));
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(e, t) {
    if (t === 0)
      return;
    const r = this.doc;
    r !== null ? et(r, (o) => {
      ox(o, Qc(o, this, e, !0), t);
    }) : this._pending.push(() => this.delete(e, t));
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(e, t, r) {
    if (t === 0)
      return;
    const o = this.doc;
    o !== null ? et(o, (a) => {
      const l = Qc(a, this, e, !1);
      l.right !== null && ix(a, this, l, t, r);
    }) : this._pending.push(() => this.format(e, t, r));
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? et(this.doc, (t) => {
      Hu(t, this, e);
    }) : this._pending.push(() => this.removeAttribute(e));
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, t) {
    this.doc !== null ? et(this.doc, (r) => {
      Um(r, this, e, t);
    }) : this._pending.push(() => this.setAttribute(e, t));
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      Lm(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return oC(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(RL);
  }
}
const mL = (n) => new ji();
class Fh {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(e, t = () => !0) {
    this._filter = t, this._root = e, this._currentNode = /** @type {Item} */
    e._start, this._firstCall = !0, e.doc ?? Kt();
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let e = this._currentNode, t = e && e.content && /** @type {any} */
    e.content.type;
    if (e !== null && (!this._firstCall || e.deleted || !this._filter(t)))
      do
        if (t = /** @type {any} */
        e.content.type, !e.deleted && (t.constructor === Jt || t.constructor === Ro) && t._start !== null)
          e = t._start;
        else
          for (; e !== null; ) {
            const r = e.next;
            if (r !== null) {
              e = r;
              break;
            } else e.parent === this._root ? e = null : e = /** @type {AbstractType<any>} */
            e.parent._item;
          }
      while (e !== null && (e.deleted || !this._filter(
        /** @type {ContentType} */
        e.content.type
      )));
    return this._firstCall = !1, e === null ? { value: void 0, done: !0 } : (this._currentNode = e, { value: (
      /** @type {any} */
      e.content.type
    ), done: !1 });
  }
}
class Ro extends Dt {
  constructor() {
    super(), this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const e = this._first;
    return e ? e.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, t) {
    super._integrate(e, t), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  _copy() {
    return new Ro();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const e = new Ro();
    return e.insert(0, this.toArray().map((t) => t instanceof Dt ? t.clone() : t)), e;
  }
  get length() {
    return this.doc ?? Kt(), this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(e) {
    return new Fh(this, e);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(e) {
    e = e.toUpperCase();
    const r = new Fh(this, (o) => o.nodeName && o.nodeName.toUpperCase() === e).next();
    return r.done ? null : r.value;
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(e) {
    return e = e.toUpperCase(), Fi(new Fh(this, (t) => t.nodeName && t.nodeName.toUpperCase() === e));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, t) {
    wd(this, e, new wL(this, t, e));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return eC(this, (e) => e.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, t = {}, r) {
    const o = e.createDocumentFragment();
    return r !== void 0 && r._createAssociation(o, this), Tl(this, (a) => {
      o.insertBefore(a.toDOM(e, t, r), null);
    }), o;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(e, t) {
    this.doc !== null ? et(this.doc, (r) => {
      rC(r, this, e, t);
    }) : this._prelimContent.splice(e, 0, ...t);
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(e, t) {
    if (this.doc !== null)
      et(this.doc, (r) => {
        const o = e && e instanceof Dt ? e._item : e;
        Lu(r, this, o, t);
      });
    else {
      const r = (
        /** @type {Array<any>} */
        this._prelimContent
      ), o = e === null ? 0 : r.findIndex((a) => a === e) + 1;
      if (o === 0 && e !== null)
        throw Pi("Reference item not found");
      r.splice(o, 0, ...t);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(e, t = 1) {
    this.doc !== null ? et(this.doc, (r) => {
      iC(r, this, e, t);
    }) : this._prelimContent.splice(e, t);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return QA(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(e) {
    this.insert(this.length, e);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(e) {
    return tC(this, e);
  }
  /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(e = 0, t = this.length) {
    return YA(this, e, t);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    Tl(this, e);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(PL);
  }
}
const gL = (n) => new Ro();
class Jt extends Ro {
  constructor(e = "UNDEFINED") {
    super(), this.nodeName = e, this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, t) {
    super._integrate(e, t), /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((r, o) => {
      this.setAttribute(o, r);
    }), this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new Jt(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const e = new Jt(this.nodeName), t = this.getAttributes();
    return qj(t, (r, o) => {
      typeof r == "string" && e.setAttribute(o, r);
    }), e.insert(0, this.toArray().map((r) => r instanceof Dt ? r.clone() : r)), e;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const e = this.getAttributes(), t = [], r = [];
    for (const d in e)
      r.push(d);
    r.sort();
    const o = r.length;
    for (let d = 0; d < o; d++) {
      const p = r[d];
      t.push(p + '="' + e[p] + '"');
    }
    const a = this.nodeName.toLocaleLowerCase(), l = t.length > 0 ? " " + t.join(" ") : "";
    return `<${a}${l}>${super.toString()}</${a}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? et(this.doc, (t) => {
      Hu(t, this, e);
    }) : this._prelimAttrs.delete(e);
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, t) {
    this.doc !== null ? et(this.doc, (r) => {
      Um(r, this, e, t);
    }) : this._prelimAttrs.set(e, t);
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      Lm(this, e)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(e) {
    return (
      /** @type {any} */
      sC(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(e) {
    return (
      /** @type {any} */
      e ? sL(this, e) : oC(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, t = {}, r) {
    const o = e.createElement(this.nodeName), a = this.getAttributes();
    for (const l in a) {
      const d = a[l];
      typeof d == "string" && o.setAttribute(l, d);
    }
    return Tl(this, (l) => {
      o.appendChild(l.toDOM(e, t, r));
    }), r !== void 0 && r._createAssociation(o, this), o;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(FL), e.writeKey(this.nodeName);
  }
}
const yL = (n) => new Jt(n.readKey());
class wL extends gd {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with which the
   *                                  change was created.
   */
  constructor(e, t, r) {
    super(e, r), this.childListChanged = !1, this.attributesChanged = /* @__PURE__ */ new Set(), t.forEach((o) => {
      o === null ? this.childListChanged = !0 : this.attributesChanged.add(o);
    });
  }
}
class Gu extends ea {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(e) {
    super(), this.hookName = e;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new Gu(this.hookName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlHook}
   */
  clone() {
    const e = new Gu(this.hookName);
    return this.forEach((t, r) => {
      e.set(r, t);
    }), e;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, t = {}, r) {
    const o = t[this.hookName];
    let a;
    return o !== void 0 ? a = o.createDom(this) : a = document.createElement(this.hookName), a.setAttribute("data-yjs-hook", this.hookName), r !== void 0 && r._createAssociation(a, this), a;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef($L), e.writeKey(this.hookName);
  }
}
const bL = (n) => new Gu(n.readKey());
class wn extends ji {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  _copy() {
    return new wn();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlText}
   */
  clone() {
    const e = new wn();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, t, r) {
    const o = e.createTextNode(this.toString());
    return r !== void 0 && r._createAssociation(o, this), o;
  }
  toString() {
    return this.toDelta().map((e) => {
      const t = [];
      for (const o in e.attributes) {
        const a = [];
        for (const l in e.attributes[o])
          a.push({ key: l, value: e.attributes[o][l] });
        a.sort((l, d) => l.key < d.key ? -1 : 1), t.push({ nodeName: o, attrs: a });
      }
      t.sort((o, a) => o.nodeName < a.nodeName ? -1 : 1);
      let r = "";
      for (let o = 0; o < t.length; o++) {
        const a = t[o];
        r += `<${a.nodeName}`;
        for (let l = 0; l < a.attrs.length; l++) {
          const d = a.attrs[l];
          r += ` ${d.key}="${d.value}"`;
        }
        r += ">";
      }
      r += e.insert;
      for (let o = t.length - 1; o >= 0; o--)
        r += `</${t[o].nodeName}>`;
      return r;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(jL);
  }
}
const vL = (n) => new wn();
class Hm {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(e, t) {
    this.id = e, this.length = t;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw Wn();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} whether this merged with right
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(e, t, r) {
    throw Wn();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, t) {
    throw Wn();
  }
}
const xL = 0;
class On extends Hm {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, t) {
    t > 0 && (this.id.clock += t, this.length -= t), zA(e.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeInfo(xL), e.writeLen(this.length - t);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, t) {
    return null;
  }
}
class _l {
  /**
   * @param {Uint8Array} content
   */
  constructor(e) {
    this.content = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new _l(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(e) {
    throw Wn();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
}
const kL = (n) => new _l(n.readBuf());
class Nl {
  /**
   * @param {number} len
   */
  constructor(e) {
    this.len = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new Nl(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(e) {
    const t = new Nl(this.len - e);
    return this.len = e, t;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.len += e.len, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
    kl(e.deleteSet, t.id.client, t.id.clock, this.len), t.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeLen(this.len - t);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
}
const AL = (n) => new Nl(n.readLen()), dC = (n, e) => new ni({ guid: n, ...e, shouldLoad: e.shouldLoad || e.autoLoad || !1 });
class zl {
  /**
   * @param {Doc} doc
   */
  constructor(e) {
    e._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."), this.doc = e;
    const t = {};
    this.opts = t, e.gc || (t.gc = !1), e.autoLoad && (t.autoLoad = !0), e.meta !== null && (t.meta = e.meta);
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new zl(dC(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(e) {
    throw Wn();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
    this.doc._item = t, e.subdocsAdded.add(this.doc), this.doc.shouldLoad && e.subdocsLoaded.add(this.doc);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    e.subdocsAdded.has(this.doc) ? e.subdocsAdded.delete(this.doc) : e.subdocsRemoved.add(this.doc);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeString(this.doc.guid), e.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
}
const CL = (n) => new zl(dC(n.readString(), n.readAny()));
class Lo {
  /**
   * @param {Object} embed
   */
  constructor(e) {
    this.embed = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new Lo(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(e) {
    throw Wn();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
}
const SL = (n) => new Lo(n.readJSON());
class St {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(e, t) {
    this.key = e, this.value = t;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new St(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(e) {
    throw Wn();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(e, t) {
    const r = (
      /** @type {YText} */
      t.parent
    );
    r._searchMarker = null, r._hasFormatting = !0;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeKey(this.key), e.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
}
const EL = (n) => new St(n.readKey(), n.readJSON());
class _u {
  /**
   * @param {Array<any>} arr
   */
  constructor(e) {
    this.arr = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new _u(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(e) {
    const t = new _u(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), t;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    const r = this.arr.length;
    e.writeLen(r - t);
    for (let o = t; o < r; o++) {
      const a = this.arr[o];
      e.writeString(a === void 0 ? "undefined" : JSON.stringify(a));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
}
const TL = (n) => {
  const e = n.readLen(), t = [];
  for (let r = 0; r < e; r++) {
    const o = n.readString();
    o === "undefined" ? t.push(void 0) : t.push(JSON.parse(o));
  }
  return new _u(t);
}, NL = $u("node_env") === "development";
class Fo {
  /**
   * @param {Array<any>} arr
   */
  constructor(e) {
    this.arr = e, NL && kA(e);
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new Fo(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(e) {
    const t = new Fo(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), t;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    const r = this.arr.length;
    e.writeLen(r - t);
    for (let o = t; o < r; o++) {
      const a = this.arr[o];
      e.writeAny(a);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
}
const BL = (n) => {
  const e = n.readLen(), t = [];
  for (let r = 0; r < e; r++)
    t.push(n.readAny());
  return new Fo(t);
};
class er {
  /**
   * @param {string} str
   */
  constructor(e) {
    this.str = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new er(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(e) {
    const t = new er(this.str.slice(e));
    this.str = this.str.slice(0, e);
    const r = this.str.charCodeAt(e - 1);
    return r >= 55296 && r <= 56319 && (this.str = this.str.slice(0, e - 1) + "�", t.str = "�" + t.str.slice(1)), t;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.str += e.str, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeString(t === 0 ? this.str : this.str.slice(t));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
}
const IL = (n) => new er(n.readString()), ML = [
  lL,
  uL,
  mL,
  yL,
  gL,
  bL,
  vL
], OL = 0, DL = 1, RL = 2, FL = 3, PL = 4, $L = 5, jL = 6;
class rr {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(e) {
    this.type = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new rr(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(e) {
    throw Wn();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
    this.type._integrate(e.doc, t);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    let t = this.type._start;
    for (; t !== null; )
      t.deleted ? t.id.clock < (e.beforeState.get(t.id.client) || 0) && e._mergeStructs.push(t) : t.delete(e), t = t.right;
    this.type._map.forEach((r) => {
      r.deleted ? r.id.clock < (e.beforeState.get(r.id.client) || 0) && e._mergeStructs.push(r) : r.delete(e);
    }), e.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
    let t = this.type._start;
    for (; t !== null; )
      t.gc(e, !0), t = t.right;
    this.type._start = null, this.type._map.forEach(
      /** @param {Item | null} item */
      (r) => {
        for (; r !== null; )
          r.gc(e, !0), r = r.left;
      }
    ), this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    this.type._write(e);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
}
const UL = (n) => new rr(ML[n.readTypeRef()](n)), xf = (n, e) => {
  let t = e, r = 0, o;
  do
    r > 0 && (t = Te(t.client, t.clock + r)), o = Gs(n, t), r = t.clock - o.id.clock, t = o.redone;
  while (t !== null && o instanceof Ke);
  return {
    item: o,
    diff: r
  };
}, Gm = (n, e) => {
  for (; n !== null && n.keep !== e; )
    n.keep = e, n = /** @type {AbstractType<any>} */
    n.parent._item;
}, zu = (n, e, t) => {
  const { client: r, clock: o } = e.id, a = new Ke(
    Te(r, o + t),
    e,
    Te(r, o + t - 1),
    e.right,
    e.rightOrigin,
    e.parent,
    e.parentSub,
    e.content.splice(t)
  );
  return e.deleted && a.markDeleted(), e.keep && (a.keep = !0), e.redone !== null && (a.redone = Te(e.redone.client, e.redone.clock + t)), e.right = a, a.right !== null && (a.right.left = a), n._mergeStructs.push(a), a.parentSub !== null && a.right === null && a.parent._map.set(a.parentSub, a), e.length = t, a;
}, sx = (n, e) => rj(
  n,
  /** @param {StackItem} s */
  (t) => da(t.deletions, e)
), pC = (n, e, t, r, o, a) => {
  const l = n.doc, d = l.store, p = l.clientID, f = e.redone;
  if (f !== null)
    return mn(n, f);
  let m = (
    /** @type {AbstractType<any>} */
    e.parent._item
  ), y = null, v;
  if (m !== null && m.deleted === !0) {
    if (m.redone === null && (!t.has(m) || pC(n, m, t, r, o, a) === null))
      return null;
    for (; m.redone !== null; )
      m = mn(n, m.redone);
  }
  const k = m === null ? (
    /** @type {AbstractType<any>} */
    e.parent
  ) : (
    /** @type {ContentType} */
    m.content.type
  );
  if (e.parentSub === null) {
    for (y = e.left, v = e; y !== null; ) {
      let O = y;
      for (; O !== null && /** @type {AbstractType<any>} */
      O.parent._item !== m; )
        O = O.redone === null ? null : mn(n, O.redone);
      if (O !== null && /** @type {AbstractType<any>} */
      O.parent._item === m) {
        y = O;
        break;
      }
      y = y.left;
    }
    for (; v !== null; ) {
      let O = v;
      for (; O !== null && /** @type {AbstractType<any>} */
      O.parent._item !== m; )
        O = O.redone === null ? null : mn(n, O.redone);
      if (O !== null && /** @type {AbstractType<any>} */
      O.parent._item === m) {
        v = O;
        break;
      }
      v = v.right;
    }
  } else if (v = null, e.right && !o) {
    for (y = e; y !== null && y.right !== null && (y.right.redone || da(r, y.right.id) || sx(a.undoStack, y.right.id) || sx(a.redoStack, y.right.id)); )
      for (y = y.right; y.redone; ) y = mn(n, y.redone);
    if (y && y.right !== null)
      return null;
  } else
    y = k._map.get(e.parentSub) || null;
  const A = xt(d, p), S = Te(p, A), B = new Ke(
    S,
    y,
    y && y.lastId,
    v,
    v && v.id,
    k,
    e.parentSub,
    e.content.copy()
  );
  return e.redone = S, Gm(B, !0), B.integrate(n, 0), B;
};
class Ke extends Hm {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(e, t, r, o, a, l, d, p) {
    super(e, p.getLength()), this.origin = r, this.left = t, this.right = o, this.rightOrigin = a, this.parent = l, this.parentSub = d, this.redone = null, this.content = p, this.info = this.content.isCountable() ? Pv : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(e) {
    (this.info & Nh) > 0 !== e && (this.info ^= Nh);
  }
  get marker() {
    return (this.info & Nh) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & Fv) > 0;
  }
  set keep(e) {
    this.keep !== e && (this.info ^= Fv);
  }
  get countable() {
    return (this.info & Pv) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & Th) > 0;
  }
  set deleted(e) {
    this.deleted !== e && (this.info ^= Th);
  }
  markDeleted() {
    this.info |= Th;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, t) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= xt(t, this.origin.client))
      return this.origin.client;
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= xt(t, this.rightOrigin.client))
      return this.rightOrigin.client;
    if (this.parent && this.parent.constructor === Hs && this.id.client !== this.parent.client && this.parent.clock >= xt(t, this.parent.client))
      return this.parent.client;
    if (this.origin && (this.left = Yv(e, t, this.origin), this.origin = this.left.lastId), this.rightOrigin && (this.right = mn(e, this.rightOrigin), this.rightOrigin = this.right.id), this.left && this.left.constructor === On || this.right && this.right.constructor === On)
      this.parent = null;
    else if (!this.parent)
      this.left && this.left.constructor === Ke ? (this.parent = this.left.parent, this.parentSub = this.left.parentSub) : this.right && this.right.constructor === Ke && (this.parent = this.right.parent, this.parentSub = this.right.parentSub);
    else if (this.parent.constructor === Hs) {
      const r = Gs(t, this.parent);
      r.constructor === On ? this.parent = null : this.parent = /** @type {ContentType} */
      r.content.type;
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, t) {
    if (t > 0 && (this.id.clock += t, this.left = Yv(e, e.doc.store, Te(this.id.client, this.id.clock - 1)), this.origin = this.left.lastId, this.content = this.content.splice(t), this.length -= t), this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let r = this.left, o;
        if (r !== null)
          o = r.right;
        else if (this.parentSub !== null)
          for (o = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; o !== null && o.left !== null; )
            o = o.left;
        else
          o = /** @type {AbstractType<any>} */
          this.parent._start;
        const a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
        for (; o !== null && o !== this.right; ) {
          if (l.add(o), a.add(o), Fs(this.origin, o.origin)) {
            if (o.id.client < this.id.client)
              r = o, a.clear();
            else if (Fs(this.rightOrigin, o.rightOrigin))
              break;
          } else if (o.origin !== null && l.has(Gs(e.doc.store, o.origin)))
            a.has(Gs(e.doc.store, o.origin)) || (r = o, a.clear());
          else
            break;
          o = o.right;
        }
        this.left = r;
      }
      if (this.left !== null) {
        const r = this.left.right;
        this.right = r, this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null)
          for (r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; r !== null && r.left !== null; )
            r = r.left;
        else
          r = /** @type {AbstractType<any>} */
          this.parent._start, this.parent._start = this;
        this.right = r;
      }
      this.right !== null ? this.right.left = this : this.parentSub !== null && (this.parent._map.set(this.parentSub, this), this.left !== null && this.left.delete(e)), this.parentSub === null && this.countable && !this.deleted && (this.parent._length += this.length), zA(e.doc.store, this), this.content.integrate(e, this), Zv(
        e,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      ), /** @type {AbstractType<any>} */
      (this.parent._item !== null && /** @type {AbstractType<any>} */
      this.parent._item.deleted || this.parentSub !== null && this.right !== null) && this.delete(e);
    } else
      new On(this.id, this.length).integrate(e, 0);
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let e = this.right;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let e = this.left;
    for (; e !== null && e.deleted; )
      e = e.left;
    return e;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : Te(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(e) {
    if (this.constructor === e.constructor && Fs(e.origin, this.lastId) && this.right === e && Fs(this.rightOrigin, e.rightOrigin) && this.id.client === e.id.client && this.id.clock + this.length === e.id.clock && this.deleted === e.deleted && this.redone === null && e.redone === null && this.content.constructor === e.content.constructor && this.content.mergeWith(e.content)) {
      const t = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      return t && t.forEach((r) => {
        r.p === e && (r.p = this, !this.deleted && this.countable && (r.index -= this.length));
      }), e.keep && (this.keep = !0), this.right = e.right, this.right !== null && (this.right.left = this), this.length += e.length, !0;
    }
    return !1;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(e) {
    if (!this.deleted) {
      const t = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      this.countable && this.parentSub === null && (t._length -= this.length), this.markDeleted(), kl(e.deleteSet, this.id.client, this.id.clock, this.length), Zv(e, t, this.parentSub), this.content.delete(e);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(e, t) {
    if (!this.deleted)
      throw bn();
    this.content.gc(e), t ? _U(e, this, new On(this.id, this.length)) : this.content = new Nl(this.length);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(e, t) {
    const r = t > 0 ? Te(this.id.client, this.id.clock + t - 1) : this.origin, o = this.rightOrigin, a = this.parentSub, l = this.content.getRef() & hd | (r === null ? 0 : sn) | // origin is defined
    (o === null ? 0 : Kr) | // right origin is defined
    (a === null ? 0 : bl);
    if (e.writeInfo(l), r !== null && e.writeLeftID(r), o !== null && e.writeRightID(o), r === null && o === null) {
      const d = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (d._item !== void 0) {
        const p = d._item;
        if (p === null) {
          const f = Al(d);
          e.writeParentInfo(!0), e.writeString(f);
        } else
          e.writeParentInfo(!1), e.writeLeftID(p.id);
      } else d.constructor === String ? (e.writeParentInfo(!0), e.writeString(d)) : d.constructor === Hs ? (e.writeParentInfo(!1), e.writeLeftID(d)) : bn();
      a !== null && e.writeString(a);
    }
    this.content.write(e, t);
  }
}
const hC = (n, e) => LL[e & hd](n), LL = [
  () => {
    bn();
  },
  // GC is not ItemContent
  AL,
  // 1
  TL,
  // 2
  kL,
  // 3
  IL,
  // 4
  SL,
  // 5
  EL,
  // 6
  UL,
  // 7
  BL,
  // 8
  CL,
  // 9
  () => {
    bn();
  }
  // 10 - Skip is not ItemContent
], HL = 10;
class Dn extends Hm {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, t) {
    bn();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeInfo(HL), Ue(e.restEncoder, this.length - t);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, t) {
    return null;
  }
}
const fC = (
  /** @type {any} */
  typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {}
), mC = "__ $YJS$ __";
fC[mC] === !0 && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
fC[mC] = !0;
const GL = () => {
  let n = !0;
  return (e, t) => {
    if (n) {
      n = !1;
      try {
        e();
      } finally {
        n = !0;
      }
    } else t !== void 0 && t();
  };
}, _L = /[\uD800-\uDBFF]/, zL = /[\uDC00-\uDFFF]/, qL = (n, e) => {
  let t = 0, r = 0;
  for (; t < n.length && t < e.length && n[t] === e[t]; )
    t++;
  for (t > 0 && _L.test(n[t - 1]) && t--; r + t < n.length && r + t < e.length && n[n.length - r - 1] === e[e.length - r - 1]; )
    r++;
  return r > 0 && zL.test(n[n.length - r]) && r--, {
    index: t,
    remove: n.length - t - r,
    insert: e.slice(t, e.length - r)
  };
}, VL = qL, Ar = (n, e) => n >>> e | n << 32 - e, XL = (n) => Ar(n, 2) ^ Ar(n, 13) ^ Ar(n, 22), JL = (n) => Ar(n, 6) ^ Ar(n, 11) ^ Ar(n, 25), KL = (n) => Ar(n, 7) ^ Ar(n, 18) ^ n >>> 3, WL = (n) => Ar(n, 17) ^ Ar(n, 19) ^ n >>> 10, YL = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), QL = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
class ZL {
  constructor() {
    const e = new ArrayBuffer(320);
    this._H = new Uint32Array(e, 0, 8), this._H.set(QL), this._W = new Uint32Array(e, 64, 64);
  }
  _updateHash() {
    const e = this._H, t = this._W;
    for (let y = 16; y < 64; y++)
      t[y] = WL(t[y - 2]) + t[y - 7] + KL(t[y - 15]) + t[y - 16];
    let r = e[0], o = e[1], a = e[2], l = e[3], d = e[4], p = e[5], f = e[6], m = e[7];
    for (let y = 0, v, k; y < 64; y++)
      v = m + JL(d) + (d & p ^ ~d & f) + YL[y] + t[y] >>> 0, k = XL(r) + (r & o ^ r & a ^ o & a) >>> 0, m = f, f = p, p = d, d = l + v >>> 0, l = a, a = o, o = r, r = v + k >>> 0;
    e[0] += r, e[1] += o, e[2] += a, e[3] += l, e[4] += d, e[5] += p, e[6] += f, e[7] += m;
  }
  /**
   * Returns a 32-byte hash.
   *
   * @param {Uint8Array} data
   */
  digest(e) {
    let t = 0;
    for (; t + 56 <= e.length; ) {
      let l = 0;
      for (; l < 16 && t + 3 < e.length; l++)
        this._W[l] = e[t++] << 24 | e[t++] << 16 | e[t++] << 8 | e[t++];
      if (t % 64 !== 0) {
        for (this._W.fill(0, l, 16); t < e.length; )
          this._W[l] |= e[t] << (3 - t % 4) * 8, t++;
        this._W[l] |= sn << (3 - t % 4) * 8;
      }
      this._updateHash();
    }
    const r = t % 64 !== 0;
    this._W.fill(0, 0, 16);
    let o = 0;
    for (; t < e.length; o++)
      for (let l = 3; l >= 0 && t < e.length; l--)
        this._W[o] |= e[t++] << l * 8;
    r || (this._W[o - (t % 4 === 0 ? 0 : 1)] |= sn << (3 - t % 4) * 8), this._W[14] = e.byteLength / ij, this._W[15] = e.byteLength * 8, this._updateHash();
    const a = new Uint8Array(32);
    for (let l = 0; l < this._H.length; l++)
      for (let d = 0; d < 4; d++)
        a[l * 4 + d] = this._H[l] >>> (3 - d) * 8;
    return a;
  }
}
const e6 = (n) => new ZL().digest(n), gt = new pt("y-sync"), Wr = new pt("y-undo"), Zc = new pt("yjs-cursor"), t6 = (n) => {
  for (let t = 6; t < n.length; t++)
    n[t % 6] = n[t % 6] ^ n[t];
  return n.slice(0, 6);
}, n6 = (n) => iU(t6(e6(sU(n)))), qu = (n, e) => e === void 0 ? !n.deleted : e.sv.has(n.id.client) && /** @type {number} */
e.sv.get(n.id.client) > n.id.clock && !da(e.ds, n.id), r6 = [{ light: "#ecd44433", dark: "#ecd444" }], i6 = (n, e, t) => {
  if (!n.has(t)) {
    if (n.size < e.length) {
      const r = Oo();
      n.forEach((o) => r.add(o)), e = e.filter((o) => !r.has(o));
    }
    n.set(t, $j(e));
  }
  return (
    /** @type {ColorDef} */
    n.get(t)
  );
}, o6 = (n, {
  colors: e = r6,
  colorMapping: t = /* @__PURE__ */ new Map(),
  permanentUserData: r = null,
  onFirstRender: o = () => {
  },
  mapping: a
} = {}) => {
  let l = !1;
  const d = new a6(n, a), p = new ot({
    props: {
      editable: (f) => {
        const m = gt.getState(f);
        return m.snapshot == null && m.prevSnapshot == null;
      }
    },
    key: gt,
    state: {
      /**
       * @returns {any}
       */
      init: (f, m) => ({
        type: n,
        doc: n.doc,
        binding: d,
        snapshot: null,
        prevSnapshot: null,
        isChangeOrigin: !1,
        isUndoRedoOperation: !1,
        addToHistory: !0,
        colors: e,
        colorMapping: t,
        permanentUserData: r
      }),
      apply: (f, m) => {
        const y = f.getMeta(gt);
        if (y !== void 0) {
          m = Object.assign({}, m);
          for (const v in y)
            m[v] = y[v];
        }
        return m.addToHistory = f.getMeta("addToHistory") !== !1, m.isChangeOrigin = y !== void 0 && !!y.isChangeOrigin, m.isUndoRedoOperation = y !== void 0 && !!y.isChangeOrigin && !!y.isUndoRedoOperation, d.prosemirrorView !== null && y !== void 0 && (y.snapshot != null || y.prevSnapshot != null) && Nm(0, () => {
          d.prosemirrorView != null && (y.restore == null ? d._renderSnapshot(
            y.snapshot,
            y.prevSnapshot,
            m
          ) : (d._renderSnapshot(
            y.snapshot,
            y.snapshot,
            m
          ), delete m.restore, delete m.snapshot, delete m.prevSnapshot, d.mux(() => {
            d._prosemirrorChanged(
              d.prosemirrorView.state.doc
            );
          })));
        }), m;
      }
    },
    view: (f) => (d.initView(f), a == null && d._forceRerender(), o(), {
      update: () => {
        const m = p.getState(f.state);
        if (m.snapshot == null && m.prevSnapshot == null && // If the content doesn't change initially, we don't render anything to Yjs
        // If the content was cleared by a user action, we want to catch the change and
        // represent it in Yjs
        (l || f.state.doc.content.findDiffStart(
          f.state.doc.type.createAndFill().content
        ) !== null)) {
          if (l = !0, m.addToHistory === !1 && !m.isChangeOrigin) {
            const y = Wr.getState(f.state), v = y && y.undoManager;
            v && v.stopCapturing();
          }
          d.mux(() => {
            m.doc.transact((y) => {
              y.meta.set("addToHistory", m.addToHistory), d._prosemirrorChanged(f.state.doc);
            }, gt);
          });
        }
      },
      destroy: () => {
        d.destroy();
      }
    })
  });
  return p;
}, s6 = (n, e, t) => {
  if (e !== null && e.anchor !== null && e.head !== null)
    if (e.type === "all")
      n.setSelection(new gn(n.doc));
    else if (e.type === "node") {
      const r = zs(
        t.doc,
        t.type,
        e.anchor,
        t.mapping
      );
      n.setSelection(fe.create(n.doc, r));
    } else {
      const r = zs(
        t.doc,
        t.type,
        e.anchor,
        t.mapping
      ), o = zs(
        t.doc,
        t.type,
        e.head,
        t.mapping
      );
      r !== null && o !== null && n.setSelection(ge.between(n.doc.resolve(r), n.doc.resolve(o)));
    }
}, kf = (n, e) => ({
  type: (
    /** @type {any} */
    e.selection.jsonID
  ),
  anchor: Xu(
    e.selection.anchor,
    n.type,
    n.mapping
  ),
  head: Xu(
    e.selection.head,
    n.type,
    n.mapping
  )
});
class a6 {
  /**
   * @param {Y.XmlFragment} yXmlFragment The bind source
   * @param {ProsemirrorMapping} mapping
   */
  constructor(e, t = /* @__PURE__ */ new Map()) {
    this.type = e, this.prosemirrorView = null, this.mux = GL(), this.mapping = t, this.isOMark = /* @__PURE__ */ new Map(), this._observeFunction = this._typeChanged.bind(this), this.doc = e.doc, this.beforeTransactionSelection = null, this.beforeAllTransactions = () => {
      this.beforeTransactionSelection === null && this.prosemirrorView != null && (this.beforeTransactionSelection = kf(
        this,
        this.prosemirrorView.state
      ));
    }, this.afterAllTransactions = () => {
      this.beforeTransactionSelection = null;
    }, this._domSelectionInView = null;
  }
  /**
   * Create a transaction for changing the prosemirror state.
   *
   * @returns
   */
  get _tr() {
    return this.prosemirrorView.state.tr.setMeta("addToHistory", !1);
  }
  _isLocalCursorInView() {
    return this.prosemirrorView.hasFocus() ? (AA && this._domSelectionInView === null && (Nm(0, () => {
      this._domSelectionInView = null;
    }), this._domSelectionInView = this._isDomSelectionInView()), this._domSelectionInView) : !1;
  }
  _isDomSelectionInView() {
    const e = this.prosemirrorView._root.getSelection();
    if (e == null || e.anchorNode == null) return !1;
    const t = this.prosemirrorView._root.createRange();
    t.setStart(e.anchorNode, e.anchorOffset), t.setEnd(e.focusNode, e.focusOffset), t.getClientRects().length === 0 && t.startContainer && t.collapsed && t.selectNodeContents(t.startContainer);
    const o = t.getBoundingClientRect(), a = lU.documentElement;
    return o.bottom >= 0 && o.right >= 0 && o.left <= (window.innerWidth || a.clientWidth || 0) && o.top <= (window.innerHeight || a.clientHeight || 0);
  }
  /**
   * @param {Y.Snapshot} snapshot
   * @param {Y.Snapshot} prevSnapshot
   */
  renderSnapshot(e, t) {
    t || (t = GA(OA(), /* @__PURE__ */ new Map())), this.prosemirrorView.dispatch(
      this._tr.setMeta(gt, { snapshot: e, prevSnapshot: t })
    );
  }
  unrenderSnapshot() {
    this.mapping.clear(), this.mux(() => {
      const e = this.type.toArray().map(
        (r) => wu(
          /** @type {Y.XmlElement} */
          r,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((r) => r !== null), t = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new ne(X.from(e), 0, 0)
      );
      t.setMeta(gt, { snapshot: null, prevSnapshot: null }), this.prosemirrorView.dispatch(t);
    });
  }
  _forceRerender() {
    this.mapping.clear(), this.mux(() => {
      const e = this.beforeTransactionSelection !== null ? null : this.prosemirrorView.state.selection, t = this.type.toArray().map(
        (o) => wu(
          /** @type {Y.XmlElement} */
          o,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((o) => o !== null), r = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new ne(X.from(t), 0, 0)
      );
      if (e) {
        const o = Jr(Qn(e.anchor, 0), r.doc.content.size), a = Jr(Qn(e.head, 0), r.doc.content.size);
        r.setSelection(ge.create(r.doc, o, a));
      }
      this.prosemirrorView.dispatch(
        r.setMeta(gt, { isChangeOrigin: !0, binding: this })
      );
    });
  }
  /**
   * @param {Y.Snapshot|Uint8Array} snapshot
   * @param {Y.Snapshot|Uint8Array} prevSnapshot
   * @param {Object} pluginState
   */
  _renderSnapshot(e, t, r) {
    let o = this.doc, a = this.type;
    if (e || (e = Dh(this.doc)), e instanceof Uint8Array || t instanceof Uint8Array)
      if ((!(e instanceof Uint8Array) || !(t instanceof Uint8Array)) && bn(), o = new ni({ gc: !1 }), ju(o, t), t = Dh(o), ju(o, e), e = Dh(o), a._item === null) {
        const l = Array.from(this.doc.share.keys()).find(
          (d) => this.doc.share.get(d) === this.type
        );
        a = o.getXmlFragment(l);
      } else {
        const l = o.store.clients.get(a._item.id.client) ?? [], d = Zn(
          l,
          a._item.id.clock
        );
        a = /** @type {Y.XmlFragment} */
        /** @type {Y.ContentType} */
        /** @type {Y.Item} */
        l[d].content.type;
      }
    this.mapping.clear(), this.mux(() => {
      o.transact((l) => {
        const d = r.permanentUserData;
        d && d.dss.forEach((y) => {
          $i(l, y, (v) => {
          });
        });
        const p = (y, v) => {
          const k = y === "added" ? d.getUserByClientId(v.client) : d.getUserByDeletedId(v);
          return {
            user: k,
            type: y,
            color: i6(
              r.colorMapping,
              r.colors,
              k
            )
          };
        }, f = ZA(
          a,
          new Rm(t.ds, e.sv)
        ).map((y) => !y._item.deleted || qu(y._item, e) || qu(y._item, t) ? wu(
          y,
          this.prosemirrorView.state.schema,
          { mapping: /* @__PURE__ */ new Map(), isOMark: /* @__PURE__ */ new Map() },
          e,
          t,
          p
        ) : null).filter((y) => y !== null), m = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new ne(X.from(f), 0, 0)
        );
        this.prosemirrorView.dispatch(
          m.setMeta(gt, { isChangeOrigin: !0 })
        );
      }, gt);
    });
  }
  /**
   * @param {Array<Y.YEvent<any>>} events
   * @param {Y.Transaction} transaction
   */
  _typeChanged(e, t) {
    if (this.prosemirrorView == null) return;
    const r = gt.getState(this.prosemirrorView.state);
    if (e.length === 0 || r.snapshot != null || r.prevSnapshot != null) {
      this.renderSnapshot(r.snapshot, r.prevSnapshot);
      return;
    }
    this.mux(() => {
      const o = (d, p) => this.mapping.delete(p);
      $i(
        t,
        t.deleteSet,
        (d) => {
          if (d.constructor === Ke) {
            const p = (
              /** @type {Y.ContentType} */
              /** @type {Y.Item} */
              d.content.type
            );
            p && this.mapping.delete(p);
          }
        }
      ), t.changed.forEach(o), t.changedParentTypes.forEach(o);
      const a = this.type.toArray().map(
        (d) => gC(
          /** @type {Y.XmlElement | Y.XmlHook} */
          d,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((d) => d !== null);
      let l = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new ne(X.from(a), 0, 0)
      );
      s6(l, this.beforeTransactionSelection, this), l = l.setMeta(gt, { isChangeOrigin: !0, isUndoRedoOperation: t.origin instanceof XA }), this.beforeTransactionSelection !== null && this._isLocalCursorInView() && l.scrollIntoView(), this.prosemirrorView.dispatch(l);
    });
  }
  /**
   * @param {import('prosemirror-model').Node} doc
   */
  _prosemirrorChanged(e) {
    this.doc.transact(() => {
      Cf(this.doc, this.type, e, this), this.beforeTransactionSelection = kf(
        this,
        this.prosemirrorView.state
      );
    }, gt);
  }
  /**
   * View is ready to listen to changes. Register observers.
   * @param {any} prosemirrorView
   */
  initView(e) {
    this.prosemirrorView != null && this.destroy(), this.prosemirrorView = e, this.doc.on("beforeAllTransactions", this.beforeAllTransactions), this.doc.on("afterAllTransactions", this.afterAllTransactions), this.type.observeDeep(this._observeFunction);
  }
  destroy() {
    this.prosemirrorView != null && (this.prosemirrorView = null, this.type.unobserveDeep(this._observeFunction), this.doc.off("beforeAllTransactions", this.beforeAllTransactions), this.doc.off("afterAllTransactions", this.afterAllTransactions));
  }
}
const gC = (n, e, t, r, o, a) => {
  const l = (
    /** @type {PModel.Node} */
    t.mapping.get(n)
  );
  if (l === void 0) {
    if (n instanceof Jt)
      return wu(
        n,
        e,
        t,
        r,
        o,
        a
      );
    throw Wn();
  }
  return l;
}, wu = (n, e, t, r, o, a) => {
  const l = [], d = (p) => {
    var f, m;
    if (p instanceof Jt) {
      const y = gC(
        p,
        e,
        t,
        r,
        o,
        a
      );
      y !== null && l.push(y);
    } else {
      const y = (
        /** @type {Y.ContentType} */
        (m = (f = p._item.right) == null ? void 0 : f.content) == null ? void 0 : m.type
      );
      y instanceof ji && !y._item.deleted && y._item.id.client === y.doc.clientID && (p.applyDelta([
        { retain: p.length },
        ...y.toDelta()
      ]), y.doc.transact((k) => {
        y._item.delete(k);
      }));
      const v = l6(
        p,
        e,
        t,
        r,
        o,
        a
      );
      v !== null && v.forEach((k) => {
        k !== null && l.push(k);
      });
    }
  };
  r === void 0 || o === void 0 ? n.toArray().forEach(d) : ZA(n, new Rm(o.ds, r.sv)).forEach(d);
  try {
    const p = n.getAttributes(r);
    r !== void 0 && (qu(
      /** @type {Y.Item} */
      n._item,
      r
    ) ? qu(
      /** @type {Y.Item} */
      n._item,
      o
    ) || (p.ychange = a ? a(
      "added",
      /** @type {Y.Item} */
      n._item.id
    ) : { type: "added" }) : p.ychange = a ? a(
      "removed",
      /** @type {Y.Item} */
      n._item.id
    ) : { type: "removed" });
    const f = e.node(n.nodeName, p, l);
    return t.mapping.set(n, f), f;
  } catch {
    return n.doc.transact((f) => {
      n._item.delete(f);
    }, gt), t.mapping.delete(n), null;
  }
}, l6 = (n, e, t, r, o, a) => {
  const l = [], d = n.toDelta(r, o, a);
  try {
    for (let p = 0; p < d.length; p++) {
      const f = d[p];
      l.push(e.text(f.insert, f6(f.attributes, e)));
    }
  } catch {
    return n.doc.transact((f) => {
      n._item.delete(f);
    }, gt), null;
  }
  return l;
}, c6 = (n, e) => {
  const t = new wn(), r = n.map((o) => ({
    // @ts-ignore
    insert: o.text,
    attributes: wC(o.marks, e)
  }));
  return t.applyDelta(r), e.mapping.set(t, n), t;
}, u6 = (n, e) => {
  const t = new Jt(n.type.name);
  for (const r in n.attrs) {
    const o = n.attrs[r];
    o !== null && r !== "ychange" && t.setAttribute(r, o);
  }
  return t.insert(
    0,
    bd(n).map(
      (r) => Af(r, e)
    )
  ), e.mapping.set(t, n), t;
}, Af = (n, e) => n instanceof Array ? c6(n, e) : u6(n, e), ax = (n) => typeof n == "object" && n !== null, _m = (n, e) => {
  const t = Object.keys(n).filter((o) => n[o] !== null);
  let r = t.length === Object.keys(e).filter((o) => e[o] !== null).length;
  for (let o = 0; o < t.length && r; o++) {
    const a = t[o], l = n[a], d = e[a];
    r = a === "ychange" || l === d || ax(l) && ax(d) && _m(l, d);
  }
  return r;
}, bd = (n) => {
  const e = n.content.content, t = [];
  for (let r = 0; r < e.length; r++) {
    const o = e[r];
    if (o.isText) {
      const a = [];
      for (let l = e[r]; r < e.length && l.isText; l = e[++r])
        a.push(l);
      r--, t.push(a);
    } else
      t.push(o);
  }
  return t;
}, yC = (n, e) => {
  const t = n.toDelta();
  return t.length === e.length && t.every(
    /** @type {(d:any,i:number) => boolean} */
    (r, o) => r.insert === /** @type {any} */
    e[o].text && vA(r.attributes || {}).length === e[o].marks.length && xA(r.attributes, (a, l) => {
      var f;
      const d = zm(l), p = e[o].marks;
      return _m(a, (f = p.find(
        /** @param {any} mark */
        (m) => m.type.name === d
      )) == null ? void 0 : f.attrs);
    })
  );
}, Bl = (n, e) => {
  if (n instanceof Jt && !(e instanceof Array) && Sf(n, e)) {
    const t = bd(e);
    return n._length === t.length && _m(n.getAttributes(), e.attrs) && n.toArray().every(
      (r, o) => Bl(r, t[o])
    );
  }
  return n instanceof wn && e instanceof Array && yC(n, e);
}, Vu = (n, e) => n === e || n instanceof Array && e instanceof Array && n.length === e.length && n.every(
  (t, r) => e[r] === t
), lx = (n, e, t) => {
  const r = n.toArray(), o = bd(e), a = o.length, l = r.length, d = Jr(l, a);
  let p = 0, f = 0, m = !1;
  for (; p < d; p++) {
    const y = r[p], v = o[p];
    if (Vu(t.mapping.get(y), v))
      m = !0;
    else if (!Bl(y, v))
      break;
  }
  for (; p + f < d; f++) {
    const y = r[l - f - 1], v = o[a - f - 1];
    if (Vu(t.mapping.get(y), v))
      m = !0;
    else if (!Bl(y, v))
      break;
  }
  return {
    equalityFactor: p + f,
    foundMappedChild: m
  };
}, d6 = (n) => {
  let e = "", t = n._start;
  const r = {};
  for (; t !== null; )
    t.deleted || (t.countable && t.content instanceof er ? e += t.content.str : t.content instanceof St && (r[t.content.key] = null)), t = t.right;
  return {
    str: e,
    nAttrs: r
  };
}, p6 = (n, e, t) => {
  t.mapping.set(n, e);
  const { nAttrs: r, str: o } = d6(n), a = e.map((f) => ({
    insert: (
      /** @type {any} */
      f.text
    ),
    attributes: Object.assign({}, r, wC(f.marks, t))
  })), { insert: l, remove: d, index: p } = VL(
    o,
    a.map((f) => f.insert).join("")
  );
  n.delete(p, d), n.insert(p, l), n.applyDelta(
    a.map((f) => ({ retain: f.insert.length, attributes: f.attributes }))
  );
}, h6 = /(.*)(--[a-zA-Z0-9+/=]{8})$/, zm = (n) => {
  var e;
  return ((e = h6.exec(n)) == null ? void 0 : e[1]) ?? n;
}, f6 = (n, e) => {
  const t = [];
  for (const r in n)
    t.push(e.mark(zm(r), n[r]));
  return t;
}, wC = (n, e) => {
  const t = {};
  return n.forEach((r) => {
    if (r.type.name !== "ychange") {
      const o = Br(e.isOMark, r.type, () => !r.type.excludes(r.type));
      t[o ? `${r.type.name}--${n6(r.toJSON())}` : r.type.name] = r.attrs;
    }
  }), t;
}, Cf = (n, e, t, r) => {
  if (e instanceof Jt && e.nodeName !== t.type.name)
    throw new Error("node name mismatch!");
  if (r.mapping.set(e, t), e instanceof Jt) {
    const y = e.getAttributes(), v = t.attrs;
    for (const k in v)
      v[k] !== null ? y[k] !== v[k] && k !== "ychange" && e.setAttribute(k, v[k]) : e.removeAttribute(k);
    for (const k in y)
      v[k] === void 0 && e.removeAttribute(k);
  }
  const o = bd(t), a = o.length, l = e.toArray(), d = l.length, p = Jr(a, d);
  let f = 0, m = 0;
  for (; f < p; f++) {
    const y = l[f], v = o[f];
    if (!Vu(r.mapping.get(y), v))
      if (Bl(y, v))
        r.mapping.set(y, v);
      else
        break;
  }
  for (; m + f + 1 < p; m++) {
    const y = l[d - m - 1], v = o[a - m - 1];
    if (!Vu(r.mapping.get(y), v))
      if (Bl(y, v))
        r.mapping.set(y, v);
      else
        break;
  }
  n.transact(() => {
    for (; d - f - m > 0 && a - f - m > 0; ) {
      const v = l[f], k = o[f], A = l[d - m - 1], S = o[a - m - 1];
      if (v instanceof wn && k instanceof Array)
        yC(v, k) || p6(v, k, r), f += 1;
      else {
        let B = v instanceof Jt && Sf(v, k), O = A instanceof Jt && Sf(A, S);
        if (B && O) {
          const L = lx(
            /** @type {Y.XmlElement} */
            v,
            /** @type {PModel.Node} */
            k,
            r
          ), G = lx(
            /** @type {Y.XmlElement} */
            A,
            /** @type {PModel.Node} */
            S,
            r
          );
          L.foundMappedChild && !G.foundMappedChild ? O = !1 : !L.foundMappedChild && G.foundMappedChild || L.equalityFactor < G.equalityFactor ? B = !1 : O = !1;
        }
        B ? (Cf(
          n,
          /** @type {Y.XmlFragment} */
          v,
          /** @type {PModel.Node} */
          k,
          r
        ), f += 1) : O ? (Cf(
          n,
          /** @type {Y.XmlFragment} */
          A,
          /** @type {PModel.Node} */
          S,
          r
        ), m += 1) : (r.mapping.delete(e.get(f)), e.delete(f, 1), e.insert(f, [
          Af(k, r)
        ]), f += 1);
      }
    }
    const y = d - f - m;
    if (d === 1 && a === 0 && l[0] instanceof wn ? (r.mapping.delete(l[0]), l[0].delete(0, l[0].length)) : y > 0 && (e.slice(f, f + y).forEach((v) => r.mapping.delete(v)), e.delete(f, y)), f + m < a) {
      const v = [];
      for (let k = f; k < a - m; k++)
        v.push(Af(o[k], r));
      e.insert(f, v);
    }
  }, gt);
}, Sf = (n, e) => !(e instanceof Array) && n.nodeName === e.type.name;
let il = null;
const m6 = () => {
  const n = (
    /** @type {Map<EditorView, Map<any, any>>} */
    il
  );
  il = null, n.forEach((e, t) => {
    const r = t.state.tr, o = gt.getState(t.state);
    o && o.binding && !o.binding.isDestroyed && (e.forEach((a, l) => {
      r.setMeta(l, a);
    }), t.dispatch(r));
  });
}, g6 = (n, e, t) => {
  il || (il = /* @__PURE__ */ new Map(), Nm(0, m6)), Br(il, n, Pn).set(e, t);
}, Xu = (n, e, t) => {
  if (n === 0)
    return Oh(e, 0, -1);
  let r = e._first === null ? null : (
    /** @type {Y.ContentType} */
    e._first.content.type
  );
  for (; r !== null && e !== r; ) {
    if (r instanceof wn) {
      if (r._length >= n)
        return Oh(r, n, -1);
      if (n -= r._length, r._item !== null && r._item.next !== null)
        r = /** @type {Y.ContentType} */
        r._item.next.content.type;
      else {
        do
          r = r._item === null ? null : r._item.parent, n--;
        while (r !== e && r !== null && r._item !== null && r._item.next === null);
        r !== null && r !== e && (r = r._item === null ? null : (
          /** @type {Y.ContentType} */
          /** @type Y.Item */
          r._item.next.content.type
        ));
      }
    } else {
      const o = (
        /** @type {any} */
        (t.get(r) || { nodeSize: 0 }).nodeSize
      );
      if (r._first !== null && n < o)
        r = /** @type {Y.ContentType} */
        r._first.content.type, n--;
      else {
        if (n === 1 && r._length === 0 && o > 1)
          return new Sl(r._item === null ? null : r._item.id, r._item === null ? Al(r) : null, null);
        if (n -= o, r._item !== null && r._item.next !== null)
          r = /** @type {Y.ContentType} */
          r._item.next.content.type;
        else {
          if (n === 0)
            return r = r._item === null ? r : r._item.parent, new Sl(r._item === null ? null : r._item.id, r._item === null ? Al(r) : null, null);
          do
            r = /** @type {Y.Item} */
            r._item.parent, n--;
          while (r !== e && /** @type {Y.Item} */
          r._item.next === null);
          r !== e && (r = /** @type {Y.ContentType} */
          /** @type {Y.Item} */
          /** @type {Y.Item} */
          r._item.next.content.type);
        }
      }
    }
    if (r === null)
      throw bn();
    if (n === 0 && r.constructor !== wn && r !== e)
      return y6(r._item.parent, r._item);
  }
  return Oh(e, e._length, -1);
}, y6 = (n, e) => {
  let t = null, r = null;
  return n._item === null ? r = Al(n) : t = Te(n._item.id.client, n._item.id.clock), new Sl(t, r, e.id);
}, zs = (n, e, t, r) => {
  const o = HU(t, n);
  if (o === null || o.type !== e && !Cl(e, o.type._item))
    return null;
  let a = o.type, l = 0;
  if (a.constructor === wn)
    l = o.index;
  else if (a._item === null || !a._item.deleted) {
    let d = a._first, p = 0;
    for (; p < a._length && p < o.index && d !== null; ) {
      if (!d.deleted) {
        const f = (
          /** @type {Y.ContentType} */
          d.content.type
        );
        p++, f instanceof wn ? l += f._length : l += /** @type {any} */
        r.get(f).nodeSize;
      }
      d = /** @type {Y.Item} */
      d.right;
    }
    l += 1;
  }
  for (; a !== e && a._item !== null; ) {
    const d = a._item.parent;
    if (d._item === null || !d._item.deleted) {
      l += 1;
      let p = (
        /** @type {Y.AbstractType} */
        d._first
      );
      for (; p !== null; ) {
        const f = (
          /** @type {Y.ContentType} */
          p.content.type
        );
        if (f === a)
          break;
        p.deleted || (f instanceof wn ? l += f._length : l += /** @type {any} */
        r.get(f).nodeSize), p = p.right;
      }
    }
    a = /** @type {Y.AbstractType} */
    d;
  }
  return l - 1;
};
function w6(n) {
  const e = n.toArray(), t = (r) => {
    let o;
    if (r instanceof wn)
      o = r.toDelta().map(
        /** @param {any} d */
        (l) => {
          const d = {
            type: "text",
            text: l.insert
          };
          return l.attributes && (d.marks = Object.keys(l.attributes).map((p) => {
            const f = l.attributes[p], y = {
              type: zm(p)
            };
            return Object.keys(f) && (y.attrs = f), y;
          })), d;
        }
      );
    else if (r instanceof Jt) {
      o = {
        type: r.nodeName
      };
      const a = r.getAttributes();
      Object.keys(a).length && (o.attrs = a);
      const l = r.toArray();
      l.length && (o.content = l.map(t).flat());
    } else
      bn();
    return o;
  };
  return {
    type: "doc",
    content: e.map(t)
  };
}
const b6 = (n, e, t) => n !== e, v6 = (n) => {
  const e = document.createElement("span");
  e.classList.add("ProseMirror-yjs-cursor"), e.setAttribute("style", `border-color: ${n.color}`);
  const t = document.createElement("div");
  t.setAttribute("style", `background-color: ${n.color}`), t.insertBefore(document.createTextNode(n.name), null);
  const r = document.createTextNode("⁠"), o = document.createTextNode("⁠");
  return e.insertBefore(r, null), e.insertBefore(t, null), e.insertBefore(o, null), e;
}, bC = (n) => ({
  style: `background-color: ${n.color}70`,
  class: "ProseMirror-yjs-selection"
}), x6 = /^#[0-9a-fA-F]{6}$/, cx = (n, e, t, r, o) => {
  const a = gt.getState(n), l = a.doc, d = [];
  return a.snapshot != null || a.prevSnapshot != null || a.binding.mapping.size === 0 ? rt.create(n.doc, []) : (e.getStates().forEach((p, f) => {
    if (t(l.clientID, f, p) && p.cursor != null) {
      const m = p.user || {};
      m.color == null ? m.color = "#ffa500" : x6.test(m.color) || console.warn("A user uses an unsupported color format", m), m.name == null && (m.name = `User: ${f}`);
      let y = zs(
        l,
        a.type,
        rl(p.cursor.anchor),
        a.binding.mapping
      ), v = zs(
        l,
        a.type,
        rl(p.cursor.head),
        a.binding.mapping
      );
      if (y !== null && v !== null) {
        const k = Qn(n.doc.content.size - 1, 0);
        y = Jr(y, k), v = Jr(v, k), d.push(
          It.widget(v, () => r(m, f), {
            key: f + "",
            side: 10
          })
        );
        const A = Jr(y, v), S = Qn(y, v);
        d.push(
          It.inline(A, S, o(m, f), {
            inclusiveEnd: !0,
            inclusiveStart: !1
          })
        );
      }
    }
  }), rt.create(n.doc, d));
}, k6 = (n, {
  awarenessStateFilter: e = b6,
  cursorBuilder: t = v6,
  selectionBuilder: r = bC,
  getSelection: o = (l) => l.selection
} = {}, a = "cursor") => new ot({
  key: Zc,
  state: {
    init(l, d) {
      return cx(
        d,
        n,
        e,
        t,
        r
      );
    },
    apply(l, d, p, f) {
      const m = gt.getState(f), y = l.getMeta(Zc);
      return m && m.isChangeOrigin || y && y.awarenessUpdated ? cx(
        f,
        n,
        e,
        t,
        r
      ) : d.map(l.mapping, l.doc);
    }
  },
  props: {
    decorations: (l) => Zc.getState(l)
  },
  view: (l) => {
    const d = () => {
      l.docView && g6(l, Zc, { awarenessUpdated: !0 });
    }, p = () => {
      const f = gt.getState(l.state), m = n.getLocalState() || {};
      if (l.hasFocus()) {
        const y = o(l.state), v = Xu(
          y.anchor,
          f.type,
          f.binding.mapping
        ), k = Xu(
          y.head,
          f.type,
          f.binding.mapping
        );
        (m.cursor == null || !Wv(
          rl(m.cursor.anchor),
          v
        ) || !Wv(
          rl(m.cursor.head),
          k
        )) && n.setLocalStateField(a, {
          anchor: v,
          head: k
        });
      } else m.cursor != null && zs(
        f.doc,
        f.type,
        rl(m.cursor.anchor),
        f.binding.mapping
      ) !== null && n.setLocalStateField(a, null);
    };
    return n.on("change", d), l.dom.addEventListener("focusin", p), l.dom.addEventListener("focusout", p), {
      update: p,
      destroy: () => {
        l.dom.removeEventListener("focusin", p), l.dom.removeEventListener("focusout", p), n.off("change", d), n.setLocalStateField(a, null);
      }
    };
  }
}), A6 = (n) => {
  const e = Wr.getState(n).undoManager;
  if (e != null)
    return e.undo(), !0;
}, C6 = (n) => {
  const e = Wr.getState(n).undoManager;
  if (e != null)
    return e.redo(), !0;
}, S6 = /* @__PURE__ */ new Set(["paragraph"]), E6 = (n, e) => !(n instanceof Ke) || !(n.content instanceof rr) || !(n.content.type instanceof ji || n.content.type instanceof Jt && e.has(n.content.type.nodeName)) || n.content.type._length === 0, T6 = ({ protectedNodes: n = S6, trackedOrigins: e = [], undoManager: t = null } = {}) => new ot({
  key: Wr,
  state: {
    init: (r, o) => {
      const a = gt.getState(o), l = t || new XA(a.type, {
        trackedOrigins: new Set([gt].concat(e)),
        deleteFilter: (d) => E6(d, n),
        captureTransaction: (d) => d.meta.get("addToHistory") !== !1
      });
      return {
        undoManager: l,
        prevSel: null,
        hasUndoOps: l.undoStack.length > 0,
        hasRedoOps: l.redoStack.length > 0
      };
    },
    /**
     * @returns {any}
     */
    apply: (r, o, a, l) => {
      const d = gt.getState(l).binding, p = o.undoManager, f = p.undoStack.length > 0, m = p.redoStack.length > 0;
      return d ? {
        undoManager: p,
        prevSel: kf(d, a),
        hasUndoOps: f,
        hasRedoOps: m
      } : f !== o.hasUndoOps || m !== o.hasRedoOps ? Object.assign({}, o, {
        hasUndoOps: p.undoStack.length > 0,
        hasRedoOps: p.redoStack.length > 0
      }) : o;
    }
  },
  view: (r) => {
    const o = gt.getState(r.state), a = Wr.getState(r.state).undoManager;
    return a.on("stack-item-added", ({ stackItem: l }) => {
      const d = o.binding;
      d && l.meta.set(d, Wr.getState(r.state).prevSel);
    }), a.on("stack-item-popped", ({ stackItem: l }) => {
      const d = o.binding;
      d && (d.beforeTransactionSelection = l.meta.get(d) || d.beforeTransactionSelection);
    }), {
      destroy: () => {
        a.destroy();
      }
    };
  }
});
var N6 = yt.create({
  name: "collaboration",
  priority: 1e3,
  addOptions() {
    return {
      document: null,
      field: "default",
      fragment: null,
      provider: null
    };
  },
  addStorage() {
    return {
      isDisabled: !1
    };
  },
  onCreate() {
    this.editor.extensionManager.extensions.find((n) => n.name === "undoRedo") && console.warn(
      '[tiptap warn]: "@tiptap/extension-collaboration" comes with its own history support and is not compatible with "@tiptap/extension-undo-redo".'
    );
  },
  addCommands() {
    return {
      undo: () => ({ tr: n, state: e, dispatch: t }) => (n.setMeta("preventDispatch", !0), Wr.getState(e).undoManager.undoStack.length === 0 ? !1 : t ? A6(e) : !0),
      redo: () => ({ tr: n, state: e, dispatch: t }) => (n.setMeta("preventDispatch", !0), Wr.getState(e).undoManager.redoStack.length === 0 ? !1 : t ? C6(e) : !0)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Mod-y": () => this.editor.commands.redo(),
      "Shift-Mod-z": () => this.editor.commands.redo()
    };
  },
  addProseMirrorPlugins() {
    var n;
    const e = this.options.fragment ? this.options.fragment : this.options.document.getXmlFragment(this.options.field), t = T6(this.options.yUndoOptions), r = t.spec.view;
    t.spec.view = (l) => {
      const { undoManager: d } = Wr.getState(l.state);
      d.restore && (d.restore(), d.restore = () => {
      });
      const p = r ? r(l) : void 0;
      return {
        destroy: () => {
          const f = d.trackedOrigins.has(d), m = d._observers;
          d.restore = () => {
            f && d.trackedOrigins.add(d), d.doc.on("afterTransaction", d.afterTransactionHandler), d._observers = m;
          }, p != null && p.destroy && p.destroy();
        }
      };
    };
    const o = {
      ...this.options.ySyncOptions,
      onFirstRender: this.options.onFirstRender
    }, a = o6(e, o);
    return this.editor.options.enableContentCheck && ((n = e.doc) == null || n.on("beforeTransaction", () => {
      try {
        const l = w6(e);
        if (l.content.length === 0)
          return;
        this.editor.schema.nodeFromJSON(l).check();
      } catch (l) {
        return this.editor.emit("contentError", {
          error: l,
          editor: this.editor,
          disableCollaboration: () => {
            var d;
            (d = e.doc) == null || d.destroy(), this.storage.isDisabled = !0;
          }
        }), !1;
      }
    })), [
      a,
      t,
      // Only add the filterInvalidContent plugin if content checking is enabled
      this.editor.options.enableContentCheck && new ot({
        key: new pt("filterInvalidContent"),
        filterTransaction: () => {
          var l;
          return this.storage.isDisabled !== !1 && ((l = e.doc) == null || l.destroy()), !0;
        }
      })
    ].filter(Boolean);
  }
}), ux = (n) => Array.from(n.entries()).map(([e, t]) => ({
  clientId: e,
  ...t.user
})), dx = () => null, B6 = yt.create({
  name: "collaborationCaret",
  priority: 999,
  addOptions() {
    return {
      provider: null,
      user: {
        name: null,
        color: null
      },
      render: (n) => {
        const e = document.createElement("span");
        e.classList.add("collaboration-carets__caret"), e.setAttribute("style", `border-color: ${n.color}`);
        const t = document.createElement("div");
        return t.classList.add("collaboration-carets__label"), t.setAttribute("style", `background-color: ${n.color}`), t.insertBefore(document.createTextNode(n.name), null), e.insertBefore(t, null), e;
      },
      selectionRender: bC,
      onUpdate: dx
    };
  },
  onCreate() {
    if (this.options.onUpdate !== dx && console.warn(
      '[tiptap warn]: DEPRECATED: The "onUpdate" option is deprecated. Please use `editor.storage.collaborationCaret.users` instead. Read more: https://tiptap.dev/api/extensions/collaboration-caret'
    ), !this.options.provider)
      throw new Error('The "provider" option is required for the CollaborationCaret extension');
  },
  addStorage() {
    return {
      users: []
    };
  },
  addCommands() {
    return {
      updateUser: (n) => () => (this.options.user = n, this.options.provider.awareness.setLocalStateField("user", this.options.user), !0),
      user: (n) => ({ editor: e }) => (console.warn(
        '[tiptap warn]: DEPRECATED: The "user" command is deprecated. Please use "updateUser" instead. Read more: https://tiptap.dev/api/extensions/collaboration-caret'
      ), e.commands.updateUser(n))
    };
  },
  addProseMirrorPlugins() {
    return [
      k6(
        (this.options.provider.awareness.setLocalStateField("user", this.options.user), this.storage.users = ux(this.options.provider.awareness.states), this.options.provider.awareness.on("update", () => {
          this.storage.users = ux(this.options.provider.awareness.states);
        }), this.options.provider.awareness),
        {
          cursorBuilder: this.options.render,
          selectionBuilder: this.options.selectionRender
        }
      )
    ];
  }
}), I6 = B6;
const M6 = Math.floor, O6 = (n, e) => n < e ? n : e, D6 = (n, e) => n > e ? n : e, vC = 128, bu = 127, R6 = Number.MAX_SAFE_INTEGER, F6 = (n) => {
  const e = unescape(encodeURIComponent(n)), t = e.length, r = new Uint8Array(t);
  for (let o = 0; o < t; o++)
    r[o] = /** @type {number} */
    e.codePointAt(o);
  return r;
}, Il = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), P6 = (n) => Il.encode(n), $6 = Il ? P6 : F6;
let ol = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
ol && ol.decode(new Uint8Array()).length === 1 && (ol = null);
const Ju = (n, e) => {
  const t = n.cbuf.length;
  n.cpos === t && (n.bufs.push(n.cbuf), n.cbuf = new Uint8Array(t * 2), n.cpos = 0), n.cbuf[n.cpos++] = e;
}, vd = (n, e) => {
  for (; e > bu; )
    Ju(n, vC | bu & e), e = M6(e / 128);
  Ju(n, bu & e);
}, Ef = new Uint8Array(3e4), j6 = Ef.length / 3, U6 = (n, e) => {
  if (e.length < j6) {
    const t = Il.encodeInto(e, Ef).written || 0;
    vd(n, t);
    for (let r = 0; r < t; r++)
      Ju(n, Ef[r]);
  } else
    _6(n, $6(e));
}, L6 = (n, e) => {
  const t = unescape(encodeURIComponent(e)), r = t.length;
  vd(n, r);
  for (let o = 0; o < r; o++)
    Ju(
      n,
      /** @type {number} */
      t.codePointAt(o)
    );
}, H6 = Il && /** @type {any} */
Il.encodeInto ? U6 : L6, G6 = (n, e) => {
  const t = n.cbuf.length, r = n.cpos, o = O6(t - r, e.length), a = e.length - o;
  n.cbuf.set(e.subarray(0, o), r), n.cpos += o, a > 0 && (n.bufs.push(n.cbuf), n.cbuf = new Uint8Array(D6(t * 2, a)), n.cbuf.set(e.subarray(o)), n.cpos = a);
}, _6 = (n, e) => {
  vd(n, e.byteLength), G6(n, e);
}, xC = (n) => new Error(n), z6 = xC("Unexpected end of array"), q6 = xC("Integer out of Range"), V6 = (n, e) => {
  const t = new Uint8Array(n.arr.buffer, n.pos + n.arr.byteOffset, e);
  return n.pos += e, t;
}, X6 = (n) => V6(n, qm(n)), px = (n) => n.arr[n.pos++], qm = (n) => {
  let e = 0, t = 1;
  const r = n.arr.length;
  for (; n.pos < r; ) {
    const o = n.arr[n.pos++];
    if (e = e + (o & bu) * t, t *= 128, o < vC)
      return e;
    if (e > R6)
      throw q6;
  }
  throw z6;
}, J6 = (n) => {
  let e = qm(n);
  if (e === 0)
    return "";
  {
    let t = String.fromCodePoint(px(n));
    if (--e < 100)
      for (; e--; )
        t += String.fromCodePoint(px(n));
    else
      for (; e > 0; ) {
        const r = e < 1e4 ? e : 1e4, o = n.arr.subarray(n.pos, n.pos + r);
        n.pos += r, t += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          o
        ), e -= r;
      }
    return decodeURIComponent(escape(t));
  }
}, K6 = (n) => (
  /** @type any */
  ol.decode(X6(n))
), hx = ol ? K6 : J6;
var Ml;
(function(n) {
  n[n.Token = 0] = "Token", n[n.PermissionDenied = 1] = "PermissionDenied", n[n.Authenticated = 2] = "Authenticated";
})(Ml || (Ml = {}));
const W6 = (n, e) => {
  vd(n, Ml.Token), H6(n, e);
}, Y6 = (n, e, t) => {
  switch (qm(n)) {
    case Ml.PermissionDenied: {
      e(hx(n));
      break;
    }
    case Ml.Authenticated: {
      t(hx(n));
      break;
    }
  }
}, fx = (n) => Array.from(n.entries()).map(([e, t]) => ({
  clientId: e,
  ...t
}));
var Tf;
(function(n) {
  n[n.Connecting = 0] = "Connecting", n[n.Open = 1] = "Open", n[n.Closing = 2] = "Closing", n[n.Closed = 3] = "Closed";
})(Tf || (Tf = {}));
function Q6(n) {
  return n || (n = {}), {
    delay: n.delay === void 0 ? 200 : n.delay,
    initialDelay: n.initialDelay === void 0 ? 0 : n.initialDelay,
    minDelay: n.minDelay === void 0 ? 0 : n.minDelay,
    maxDelay: n.maxDelay === void 0 ? 0 : n.maxDelay,
    factor: n.factor === void 0 ? 0 : n.factor,
    maxAttempts: n.maxAttempts === void 0 ? 3 : n.maxAttempts,
    timeout: n.timeout === void 0 ? 0 : n.timeout,
    jitter: n.jitter === !0,
    initialJitter: n.initialJitter === !0,
    handleError: n.handleError === void 0 ? null : n.handleError,
    handleTimeout: n.handleTimeout === void 0 ? null : n.handleTimeout,
    beforeAttempt: n.beforeAttempt === void 0 ? null : n.beforeAttempt,
    calculateDelay: n.calculateDelay === void 0 ? null : n.calculateDelay
  };
}
async function Ph(n) {
  return new Promise((e) => setTimeout(e, n));
}
function Z6(n, e) {
  let t = e.delay;
  if (t === 0)
    return 0;
  if (e.factor && (t *= Math.pow(e.factor, n.attemptNum - 1), e.maxDelay !== 0 && (t = Math.min(t, e.maxDelay))), e.jitter) {
    const r = Math.ceil(e.minDelay), o = Math.floor(t);
    t = Math.floor(Math.random() * (o - r + 1)) + r;
  }
  return Math.round(t);
}
async function eH(n, e) {
  const t = Q6(e);
  for (const d of [
    "delay",
    "initialDelay",
    "minDelay",
    "maxDelay",
    "maxAttempts",
    "timeout"
  ]) {
    const p = t[d];
    if (!Number.isInteger(p) || p < 0)
      throw new Error(`Value for ${d} must be an integer greater than or equal to 0`);
  }
  if (t.factor.constructor !== Number || t.factor < 0)
    throw new Error("Value for factor must be a number greater than or equal to 0");
  if (t.delay < t.minDelay)
    throw new Error(`delay cannot be less than minDelay (delay: ${t.delay}, minDelay: ${t.minDelay}`);
  const r = {
    attemptNum: 0,
    attemptsRemaining: t.maxAttempts ? t.maxAttempts : -1,
    aborted: !1,
    abort() {
      r.aborted = !0;
    }
  }, o = t.calculateDelay || Z6;
  async function a() {
    if (t.beforeAttempt && t.beforeAttempt(r, t), r.aborted) {
      const p = new Error("Attempt aborted");
      throw p.code = "ATTEMPT_ABORTED", p;
    }
    const d = async (p) => {
      if (t.handleError && await t.handleError(p, r, t), r.aborted || r.attemptsRemaining === 0)
        throw p;
      r.attemptNum++;
      const f = o(r, t);
      return f && await Ph(f), a();
    };
    return r.attemptsRemaining > 0 && r.attemptsRemaining--, t.timeout ? new Promise((p, f) => {
      const m = setTimeout(() => {
        if (t.handleTimeout)
          try {
            p(t.handleTimeout(r, t));
          } catch (y) {
            f(y);
          }
        else {
          const y = new Error(`Retry timeout (attemptNum: ${r.attemptNum}, timeout: ${t.timeout})`);
          y.code = "ATTEMPT_TIMEOUT", f(y);
        }
      }, t.timeout);
      n(r, t).then((y) => {
        clearTimeout(m), p(y);
      }).catch((y) => {
        clearTimeout(m), d(y).then(p).catch(f);
      });
    }) : n(r, t).catch(d);
  }
  const l = t.calculateDelay ? t.calculateDelay(r, t) : t.initialDelay;
  if (l && await Ph(l), r.attemptNum < 1 && t.initialJitter) {
    const d = o(r, t);
    d && await Ph(d);
  }
  return a();
}
const kC = Math.floor, tH = (n, e) => n < e ? n : e, nH = (n, e) => n > e ? n : e, rH = 64, Ku = 128, iH = 63, sl = 127, AC = Number.MAX_SAFE_INTEGER, oH = () => /* @__PURE__ */ new Set(), sH = Array.from, aH = (n) => {
  const e = unescape(encodeURIComponent(n)), t = e.length, r = new Uint8Array(t);
  for (let o = 0; o < t; o++)
    r[o] = /** @type {number} */
    e.codePointAt(o);
  return r;
}, Ol = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), lH = (n) => Ol.encode(n), cH = Ol ? lH : aH;
let al = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
al && al.decode(new Uint8Array()).length === 1 && (al = null);
class uH {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
}
const Vm = () => new uH(), CC = (n) => {
  let e = n.cpos;
  for (let t = 0; t < n.bufs.length; t++)
    e += n.bufs[t].length;
  return e;
}, Xm = (n) => {
  const e = new Uint8Array(CC(n));
  let t = 0;
  for (let r = 0; r < n.bufs.length; r++) {
    const o = n.bufs[r];
    e.set(o, t), t += o.length;
  }
  return e.set(new Uint8Array(n.cbuf.buffer, 0, n.cpos), t), e;
}, Wu = (n, e) => {
  const t = n.cbuf.length;
  n.cpos === t && (n.bufs.push(n.cbuf), n.cbuf = new Uint8Array(t * 2), n.cpos = 0), n.cbuf[n.cpos++] = e;
}, Wt = (n, e) => {
  for (; e > sl; )
    Wu(n, Ku | sl & e), e = kC(e / 128);
  Wu(n, sl & e);
}, Nf = new Uint8Array(3e4), dH = Nf.length / 3, pH = (n, e) => {
  if (e.length < dH) {
    const t = Ol.encodeInto(e, Nf).written || 0;
    Wt(n, t);
    for (let r = 0; r < t; r++)
      Wu(n, Nf[r]);
  } else
    fa(n, cH(e));
}, hH = (n, e) => {
  const t = unescape(encodeURIComponent(e)), r = t.length;
  Wt(n, r);
  for (let o = 0; o < r; o++)
    Wu(
      n,
      /** @type {number} */
      t.codePointAt(o)
    );
}, Zr = Ol && /** @type {any} */
Ol.encodeInto ? pH : hH, fH = (n, e) => {
  const t = n.cbuf.length, r = n.cpos, o = tH(t - r, e.length), a = e.length - o;
  n.cbuf.set(e.subarray(0, o), r), n.cpos += o, a > 0 && (n.bufs.push(n.cbuf), n.cbuf = new Uint8Array(nH(t * 2, a)), n.cbuf.set(e.subarray(o)), n.cpos = a);
}, fa = (n, e) => {
  Wt(n, e.byteLength), fH(n, e);
}, SC = (n) => new Error(n), EC = SC("Unexpected end of array"), TC = SC("Integer out of Range");
class mH {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(e) {
    this.arr = e, this.pos = 0;
  }
}
const NC = (n) => new mH(n), gH = (n, e) => {
  const t = new Uint8Array(n.arr.buffer, n.pos + n.arr.byteOffset, e);
  return n.pos += e, t;
}, xd = (n) => gH(n, So(n)), mx = (n) => n.arr[n.pos++], So = (n) => {
  let e = 0, t = 1;
  const r = n.arr.length;
  for (; n.pos < r; ) {
    const o = n.arr[n.pos++];
    if (e = e + (o & sl) * t, t *= 128, o < Ku)
      return e;
    if (e > AC)
      throw TC;
  }
  throw EC;
}, yH = (n) => {
  let e = n.arr[n.pos++], t = e & iH, r = 64;
  const o = (e & rH) > 0 ? -1 : 1;
  if (!(e & Ku))
    return o * t;
  const a = n.arr.length;
  for (; n.pos < a; ) {
    if (e = n.arr[n.pos++], t = t + (e & sl) * r, r *= 128, e < Ku)
      return o * t;
    if (t > AC)
      throw TC;
  }
  throw EC;
}, wH = (n) => {
  let e = So(n);
  if (e === 0)
    return "";
  {
    let t = String.fromCodePoint(mx(n));
    if (--e < 100)
      for (; e--; )
        t += String.fromCodePoint(mx(n));
    else
      for (; e > 0; ) {
        const r = e < 1e4 ? e : 1e4, o = n.arr.subarray(n.pos, n.pos + r);
        n.pos += r, t += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          o
        ), e -= r;
      }
    return decodeURIComponent(escape(t));
  }
}, bH = (n) => (
  /** @type any */
  al.decode(xd(n))
), Dl = al ? bH : wH, vH = (n) => {
  const e = n.pos, t = Dl(n);
  return n.pos = e, t;
}, ta = Date.now, $h = () => /* @__PURE__ */ new Map(), xH = (n, e, t) => {
  let r = n.get(e);
  return r === void 0 && n.set(e, r = t()), r;
};
class kH {
  constructor() {
    this._observers = $h();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(e, t) {
    xH(this._observers, e, oH).add(t);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(e, t) {
    const r = (...o) => {
      this.off(e, r), t(...o);
    };
    this.on(e, r);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(e, t) {
    const r = this._observers.get(e);
    r !== void 0 && (r.delete(t), r.size === 0 && this._observers.delete(e));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(e, t) {
    return sH((this._observers.get(e) || $h()).values()).forEach((r) => r(...t));
  }
  destroy() {
    this._observers = $h();
  }
}
const AH = Object.keys, gx = (n) => AH(n).length, CH = (n, e) => Object.prototype.hasOwnProperty.call(n, e), SH = (n, e) => n === e, ll = (n, e) => {
  if (n == null || e == null)
    return SH(n, e);
  if (n.constructor !== e.constructor)
    return !1;
  if (n === e)
    return !0;
  switch (n.constructor) {
    case ArrayBuffer:
      n = new Uint8Array(n), e = new Uint8Array(e);
    case Uint8Array: {
      if (n.byteLength !== e.byteLength)
        return !1;
      for (let t = 0; t < n.length; t++)
        if (n[t] !== e[t])
          return !1;
      break;
    }
    case Set: {
      if (n.size !== e.size)
        return !1;
      for (const t of n)
        if (!e.has(t))
          return !1;
      break;
    }
    case Map: {
      if (n.size !== e.size)
        return !1;
      for (const t of n.keys())
        if (!e.has(t) || !ll(n.get(t), e.get(t)))
          return !1;
      break;
    }
    case Object:
      if (gx(n) !== gx(e))
        return !1;
      for (const t in n)
        if (!CH(n, t) || !ll(n[t], e[t]))
          return !1;
      break;
    case Array:
      if (n.length !== e.length)
        return !1;
      for (let t = 0; t < n.length; t++)
        if (!ll(n[t], e[t]))
          return !1;
      break;
    default:
      return !1;
  }
  return !0;
}, jh = 3e4;
class EH extends kH {
  /**
   * @param {Y.Doc} doc
   */
  constructor(e) {
    super(), this.doc = e, this.clientID = e.clientID, this.states = /* @__PURE__ */ new Map(), this.meta = /* @__PURE__ */ new Map(), this._checkInterval = /** @type {any} */
    setInterval(() => {
      const t = ta();
      this.getLocalState() !== null && jh / 2 <= t - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated && this.setLocalState(this.getLocalState());
      const r = [];
      this.meta.forEach((o, a) => {
        a !== this.clientID && jh <= t - o.lastUpdated && this.states.has(a) && r.push(a);
      }), r.length > 0 && vu(this, r, "timeout");
    }, kC(jh / 10)), e.on("destroy", () => {
      this.destroy();
    }), this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]), this.setLocalState(null), super.destroy(), clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(e) {
    const t = this.clientID, r = this.meta.get(t), o = r === void 0 ? 0 : r.clock + 1, a = this.states.get(t);
    e === null ? this.states.delete(t) : this.states.set(t, e), this.meta.set(t, {
      clock: o,
      lastUpdated: ta()
    });
    const l = [], d = [], p = [], f = [];
    e === null ? f.push(t) : a == null ? e != null && l.push(t) : (d.push(t), ll(a, e) || p.push(t)), (l.length > 0 || p.length > 0 || f.length > 0) && this.emit("change", [{ added: l, updated: p, removed: f }, "local"]), this.emit("update", [{ added: l, updated: d, removed: f }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(e, t) {
    const r = this.getLocalState();
    r !== null && this.setLocalState({
      ...r,
      [e]: t
    });
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
}
const vu = (n, e, t) => {
  const r = [];
  for (let o = 0; o < e.length; o++) {
    const a = e[o];
    if (n.states.has(a)) {
      if (n.states.delete(a), a === n.clientID) {
        const l = (
          /** @type {MetaClientState} */
          n.meta.get(a)
        );
        n.meta.set(a, {
          clock: l.clock + 1,
          lastUpdated: ta()
        });
      }
      r.push(a);
    }
  }
  r.length > 0 && (n.emit("change", [{ added: [], updated: [], removed: r }, t]), n.emit("update", [{ added: [], updated: [], removed: r }, t]));
}, Bf = (n, e, t = n.states) => {
  const r = e.length, o = Vm();
  Wt(o, r);
  for (let a = 0; a < r; a++) {
    const l = e[a], d = t.get(l) || null, p = (
      /** @type {MetaClientState} */
      n.meta.get(l).clock
    );
    Wt(o, l), Wt(o, p), Zr(o, JSON.stringify(d));
  }
  return Xm(o);
}, TH = (n, e, t) => {
  const r = NC(e), o = ta(), a = [], l = [], d = [], p = [], f = So(r);
  for (let m = 0; m < f; m++) {
    const y = So(r);
    let v = So(r);
    const k = JSON.parse(Dl(r)), A = n.meta.get(y), S = n.states.get(y), B = A === void 0 ? 0 : A.clock;
    (B < v || B === v && k === null && n.states.has(y)) && (k === null ? y === n.clientID && n.getLocalState() != null ? v++ : n.states.delete(y) : n.states.set(y, k), n.meta.set(y, {
      clock: v,
      lastUpdated: o
    }), A === void 0 && k !== null ? a.push(y) : A !== void 0 && k === null ? p.push(y) : k !== null && (ll(k, S) || d.push(y), l.push(y)));
  }
  (a.length > 0 || d.length > 0 || p.length > 0) && n.emit("change", [{
    added: a,
    updated: d,
    removed: p
  }, t]), (a.length > 0 || l.length > 0 || p.length > 0) && n.emit("update", [{
    added: a,
    updated: l,
    removed: p
  }, t]);
};
class BC {
  constructor() {
    this.callbacks = {};
  }
  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
  on(e, t) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this;
  }
  emit(e, ...t) {
    const r = this.callbacks[e];
    return r && r.forEach((o) => o.apply(this, t)), this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
  off(e, t) {
    const r = this.callbacks[e];
    return r && (t ? this.callbacks[e] = r.filter((o) => o !== t) : delete this.callbacks[e]), this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
class If {
  constructor(e) {
    this.data = e, this.encoder = Vm(), this.decoder = NC(new Uint8Array(this.data));
  }
  peekVarString() {
    return vH(this.decoder);
  }
  readVarUint() {
    return So(this.decoder);
  }
  readVarString() {
    return Dl(this.decoder);
  }
  readVarUint8Array() {
    return xd(this.decoder);
  }
  writeVarUint(e) {
    return Wt(this.encoder, e);
  }
  writeVarString(e) {
    return Zr(this.encoder, e);
  }
  writeVarUint8Array(e) {
    return fa(this.encoder, e);
  }
  length() {
    return CC(this.encoder);
  }
}
var Ut;
(function(n) {
  n[n.Sync = 0] = "Sync", n[n.Awareness = 1] = "Awareness", n[n.Auth = 2] = "Auth", n[n.QueryAwareness = 3] = "QueryAwareness", n[n.Stateless = 5] = "Stateless", n[n.CLOSE = 7] = "CLOSE", n[n.SyncStatus = 8] = "SyncStatus";
})(Ut || (Ut = {}));
var hn;
(function(n) {
  n.Connecting = "connecting", n.Connected = "connected", n.Disconnected = "disconnected";
})(hn || (hn = {}));
class Ho {
  constructor() {
    this.encoder = Vm();
  }
  get(e) {
    return e.encoder;
  }
  toUint8Array() {
    return Xm(this.encoder);
  }
}
class NH extends Ho {
  constructor() {
    super(...arguments), this.type = Ut.CLOSE, this.description = "Ask the server to close the connection";
  }
  get(e) {
    return Zr(this.encoder, e.documentName), Wt(this.encoder, this.type), this.encoder;
  }
}
class BH extends BC {
  constructor(e) {
    super(), this.messageQueue = [], this.configuration = {
      url: "",
      autoConnect: !0,
      // @ts-ignore
      document: void 0,
      WebSocketPolyfill: void 0,
      // TODO: this should depend on awareness.outdatedTime
      messageReconnectTimeout: 3e4,
      // 1 second
      delay: 1e3,
      // instant
      initialDelay: 0,
      // double the delay each time
      factor: 2,
      // unlimited retries
      maxAttempts: 0,
      // wait at least 1 second
      minDelay: 1e3,
      // at least every 30 seconds
      maxDelay: 3e4,
      // randomize
      jitter: !0,
      // retry forever
      timeout: 0,
      onOpen: () => null,
      onConnect: () => null,
      onMessage: () => null,
      onOutgoingMessage: () => null,
      onStatus: () => null,
      onDisconnect: () => null,
      onClose: () => null,
      onDestroy: () => null,
      onAwarenessUpdate: () => null,
      onAwarenessChange: () => null,
      handleTimeout: null,
      providerMap: /* @__PURE__ */ new Map()
    }, this.webSocket = null, this.webSocketHandlers = {}, this.shouldConnect = !0, this.status = hn.Disconnected, this.lastMessageReceived = 0, this.identifier = 0, this.intervals = {
      connectionChecker: null
    }, this.connectionAttempt = null, this.receivedOnOpenPayload = void 0, this.closeTries = 0, this.setConfiguration(e), this.configuration.WebSocketPolyfill = e.WebSocketPolyfill ? e.WebSocketPolyfill : WebSocket, this.on("open", this.configuration.onOpen), this.on("open", this.onOpen.bind(this)), this.on("connect", this.configuration.onConnect), this.on("message", this.configuration.onMessage), this.on("outgoingMessage", this.configuration.onOutgoingMessage), this.on("status", this.configuration.onStatus), this.on("disconnect", this.configuration.onDisconnect), this.on("close", this.configuration.onClose), this.on("destroy", this.configuration.onDestroy), this.on("awarenessUpdate", this.configuration.onAwarenessUpdate), this.on("awarenessChange", this.configuration.onAwarenessChange), this.on("close", this.onClose.bind(this)), this.on("message", this.onMessage.bind(this)), this.intervals.connectionChecker = setInterval(this.checkConnection.bind(this), this.configuration.messageReconnectTimeout / 10), this.shouldConnect && this.connect();
  }
  async onOpen(e) {
    this.status = hn.Connected, this.cancelWebsocketRetry = void 0, this.receivedOnOpenPayload = e;
  }
  attach(e) {
    this.configuration.providerMap.set(e.configuration.name, e), this.status === hn.Disconnected && this.shouldConnect && this.connect(), this.receivedOnOpenPayload && this.status === hn.Connected && e.onOpen(this.receivedOnOpenPayload);
  }
  detach(e) {
    this.configuration.providerMap.has(e.configuration.name) && (e.send(NH, {
      documentName: e.configuration.name
    }), this.configuration.providerMap.delete(e.configuration.name));
  }
  setConfiguration(e = {}) {
    this.configuration = { ...this.configuration, ...e }, this.configuration.autoConnect || (this.shouldConnect = !1);
  }
  async connect() {
    if (this.status === hn.Connected)
      return;
    this.cancelWebsocketRetry && (this.cancelWebsocketRetry(), this.cancelWebsocketRetry = void 0), this.receivedOnOpenPayload = void 0, this.shouldConnect = !0;
    const e = () => {
      let o = !1;
      return {
        retryPromise: eH(this.createWebSocketConnection.bind(this), {
          delay: this.configuration.delay,
          initialDelay: this.configuration.initialDelay,
          factor: this.configuration.factor,
          maxAttempts: this.configuration.maxAttempts,
          minDelay: this.configuration.minDelay,
          maxDelay: this.configuration.maxDelay,
          jitter: this.configuration.jitter,
          timeout: this.configuration.timeout,
          handleTimeout: this.configuration.handleTimeout,
          beforeAttempt: (l) => {
            (!this.shouldConnect || o) && l.abort();
          }
        }).catch((l) => {
          if (l && l.code !== "ATTEMPT_ABORTED")
            throw l;
        }),
        cancelFunc: () => {
          o = !0;
        }
      };
    }, { retryPromise: t, cancelFunc: r } = e();
    return this.cancelWebsocketRetry = r, t;
  }
  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
  attachWebSocketListeners(e, t) {
    const { identifier: r } = e, o = (f) => this.emit("message", f), a = (f) => this.emit("close", { event: f }), l = (f) => this.emit("open", f), d = (f) => {
      t(f);
    };
    this.webSocketHandlers[r] = {
      message: o,
      close: a,
      open: l,
      error: d
    };
    const p = this.webSocketHandlers[e.identifier];
    Object.keys(p).forEach((f) => {
      e.addEventListener(f, p[f]);
    });
  }
  cleanupWebSocket() {
    if (!this.webSocket)
      return;
    const { identifier: e } = this.webSocket, t = this.webSocketHandlers[e];
    Object.keys(t).forEach((r) => {
      var o;
      (o = this.webSocket) === null || o === void 0 || o.removeEventListener(r, t[r]), delete this.webSocketHandlers[e];
    }), this.webSocket.close(), this.webSocket = null;
  }
  createWebSocketConnection() {
    return new Promise((e, t) => {
      this.webSocket && (this.messageQueue = [], this.cleanupWebSocket()), this.lastMessageReceived = 0, this.identifier += 1;
      const r = new this.configuration.WebSocketPolyfill(this.url);
      r.binaryType = "arraybuffer", r.identifier = this.identifier, this.attachWebSocketListeners(r, t), this.webSocket = r, this.status = hn.Connecting, this.emit("status", { status: hn.Connecting }), this.connectionAttempt = {
        resolve: e,
        reject: t
      };
    });
  }
  onMessage(e) {
    var t;
    this.resolveConnectionAttempt(), this.lastMessageReceived = ta();
    const o = new If(e.data).peekVarString();
    (t = this.configuration.providerMap.get(o)) === null || t === void 0 || t.onMessage(e);
  }
  resolveConnectionAttempt() {
    this.connectionAttempt && (this.connectionAttempt.resolve(), this.connectionAttempt = null, this.status = hn.Connected, this.emit("status", { status: hn.Connected }), this.emit("connect"), this.messageQueue.forEach((e) => this.send(e)), this.messageQueue = []);
  }
  stopConnectionAttempt() {
    this.connectionAttempt = null;
  }
  rejectConnectionAttempt() {
    var e;
    (e = this.connectionAttempt) === null || e === void 0 || e.reject(), this.connectionAttempt = null;
  }
  checkConnection() {
    var e;
    this.status === hn.Connected && this.lastMessageReceived && (this.configuration.messageReconnectTimeout >= ta() - this.lastMessageReceived || (this.closeTries += 1, this.closeTries > 2 ? (this.onClose({
      event: {
        code: 4408,
        reason: "forced"
      }
    }), this.closeTries = 0) : ((e = this.webSocket) === null || e === void 0 || e.close(), this.messageQueue = [])));
  }
  // Ensure that the URL never ends with /
  get serverUrl() {
    for (; this.configuration.url[this.configuration.url.length - 1] === "/"; )
      return this.configuration.url.slice(0, this.configuration.url.length - 1);
    return this.configuration.url;
  }
  get url() {
    return this.serverUrl;
  }
  disconnect() {
    if (this.shouldConnect = !1, this.webSocket !== null)
      try {
        this.webSocket.close(), this.messageQueue = [];
      } catch (e) {
        console.error(e);
      }
  }
  send(e) {
    var t;
    ((t = this.webSocket) === null || t === void 0 ? void 0 : t.readyState) === Tf.Open ? this.webSocket.send(e) : this.messageQueue.push(e);
  }
  onClose({ event: e }) {
    this.closeTries = 0, this.cleanupWebSocket(), this.connectionAttempt && this.rejectConnectionAttempt(), this.status = hn.Disconnected, this.emit("status", { status: hn.Disconnected }), this.emit("disconnect", { event: e }), !this.cancelWebsocketRetry && this.shouldConnect && setTimeout(() => {
      this.connect();
    }, this.configuration.delay);
  }
  destroy() {
    this.emit("destroy"), clearInterval(this.intervals.connectionChecker), this.stopConnectionAttempt(), this.disconnect(), this.removeAllListeners(), this.cleanupWebSocket();
  }
}
const IC = 0, Jm = 1, MC = 2, IH = (n, e) => {
  Wt(n, IC);
  const t = PU(e);
  fa(n, t);
}, MH = (n, e, t) => {
  Wt(n, Jm), fa(n, OU(e, t));
}, OH = (n, e, t) => MH(e, t, xd(n)), OC = (n, e, t) => {
  try {
    BU(e, xd(n), t);
  } catch (r) {
    console.error("Caught error while handling a Yjs update", r);
  }
}, DH = (n, e) => {
  Wt(n, MC), fa(n, e);
}, RH = OC, FH = (n, e, t, r) => {
  const o = So(n);
  switch (o) {
    case IC:
      OH(n, e, t);
      break;
    case Jm:
      OC(n, t, r);
      break;
    case MC:
      RH(n, t, r);
      break;
    default:
      throw new Error("Unknown message type");
  }
  return o;
};
class PH {
  constructor(e) {
    this.message = e;
  }
  apply(e, t) {
    const { message: r } = this, o = r.readVarUint(), a = r.length();
    switch (o) {
      case Ut.Sync:
        this.applySyncMessage(e, t);
        break;
      case Ut.Awareness:
        this.applyAwarenessMessage(e);
        break;
      case Ut.Auth:
        this.applyAuthMessage(e);
        break;
      case Ut.QueryAwareness:
        this.applyQueryAwarenessMessage(e);
        break;
      case Ut.Stateless:
        e.receiveStateless(Dl(r.decoder));
        break;
      case Ut.SyncStatus:
        this.applySyncStatusMessage(e, yH(r.decoder) === 1);
        break;
      case Ut.CLOSE:
        const l = {
          code: 1e3,
          reason: Dl(r.decoder),
          // @ts-ignore
          target: e.configuration.websocketProvider.webSocket,
          type: "close"
        };
        e.onClose(), e.configuration.onClose({ event: l }), e.forwardClose(l);
        break;
      default:
        throw new Error(`Can’t apply message of unknown type: ${o}`);
    }
    r.length() > a + 1 && e.send(Ho, { encoder: r.encoder });
  }
  applySyncMessage(e, t) {
    const { message: r } = this;
    r.writeVarUint(Ut.Sync);
    const o = FH(r.decoder, r.encoder, e.document, e);
    t && o === Jm && (e.synced = !0);
  }
  applySyncStatusMessage(e, t) {
    t && e.decrementUnsyncedChanges();
  }
  applyAwarenessMessage(e) {
    if (!e.awareness)
      return;
    const { message: t } = this;
    TH(e.awareness, t.readVarUint8Array(), e);
  }
  applyAuthMessage(e) {
    const { message: t } = this;
    Y6(t.decoder, e.permissionDeniedHandler.bind(e), e.authenticatedHandler.bind(e));
  }
  applyQueryAwarenessMessage(e) {
    if (!e.awareness)
      return;
    const { message: t } = this;
    t.writeVarUint(Ut.Awareness), t.writeVarUint8Array(Bf(e.awareness, Array.from(e.awareness.getStates().keys())));
  }
}
class $H {
  constructor(e, t = {}) {
    this.message = new e(), this.encoder = this.message.get(t);
  }
  create() {
    return Xm(this.encoder);
  }
  send(e) {
    e == null || e.send(this.create());
  }
}
class jH extends Ho {
  constructor() {
    super(...arguments), this.type = Ut.Auth, this.description = "Authentication";
  }
  get(e) {
    if (typeof e.token > "u")
      throw new Error("The authentication message requires `token` as an argument.");
    return Zr(this.encoder, e.documentName), Wt(this.encoder, this.type), W6(this.encoder, e.token), this.encoder;
  }
}
class yx extends Ho {
  constructor() {
    super(...arguments), this.type = Ut.Awareness, this.description = "Awareness states update";
  }
  get(e) {
    if (typeof e.awareness > "u")
      throw new Error("The awareness message requires awareness as an argument");
    if (typeof e.clients > "u")
      throw new Error("The awareness message requires clients as an argument");
    Zr(this.encoder, e.documentName), Wt(this.encoder, this.type);
    let t;
    return e.states === void 0 ? t = Bf(e.awareness, e.clients) : t = Bf(e.awareness, e.clients, e.states), fa(this.encoder, t), this.encoder;
  }
}
class UH extends Ho {
  constructor() {
    super(...arguments), this.type = Ut.Stateless, this.description = "A stateless message";
  }
  get(e) {
    var t;
    return Zr(this.encoder, e.documentName), Wt(this.encoder, this.type), Zr(this.encoder, (t = e.payload) !== null && t !== void 0 ? t : ""), this.encoder;
  }
}
class wx extends Ho {
  constructor() {
    super(...arguments), this.type = Ut.Sync, this.description = "First sync step";
  }
  get(e) {
    if (typeof e.document > "u")
      throw new Error("The sync step one message requires document as an argument");
    return Zr(this.encoder, e.documentName), Wt(this.encoder, this.type), IH(this.encoder, e.document), this.encoder;
  }
}
class LH extends Ho {
  constructor() {
    super(...arguments), this.type = Ut.Sync, this.description = "A document update";
  }
  get(e) {
    return Zr(this.encoder, e.documentName), Wt(this.encoder, this.type), DH(this.encoder, e.update), this.encoder;
  }
}
class HH extends Error {
  constructor() {
    super(...arguments), this.code = 1001;
  }
}
class GH extends BC {
  constructor(e) {
    var t, r, o;
    super(), this.configuration = {
      name: "",
      // @ts-ignore
      document: void 0,
      // @ts-ignore
      awareness: void 0,
      token: null,
      forceSyncInterval: !1,
      onAuthenticated: () => null,
      onAuthenticationFailed: () => null,
      onOpen: () => null,
      onConnect: () => null,
      onMessage: () => null,
      onOutgoingMessage: () => null,
      onSynced: () => null,
      onDisconnect: () => null,
      onClose: () => null,
      onDestroy: () => null,
      onAwarenessUpdate: () => null,
      onAwarenessChange: () => null,
      onStateless: () => null,
      onUnsyncedChanges: () => null
    }, this.isSynced = !1, this.unsyncedChanges = 0, this.isAuthenticated = !1, this.authorizedScope = void 0, this.manageSocket = !1, this._isAttached = !1, this.intervals = {
      forceSync: null
    }, this.boundDocumentUpdateHandler = this.documentUpdateHandler.bind(this), this.boundAwarenessUpdateHandler = this.awarenessUpdateHandler.bind(this), this.boundPageHide = this.pageHide.bind(this), this.boundOnOpen = this.onOpen.bind(this), this.boundOnClose = this.onClose.bind(this), this.forwardConnect = (a) => this.emit("connect", a), this.forwardClose = (a) => this.emit("close", a), this.forwardDisconnect = (a) => this.emit("disconnect", a), this.forwardDestroy = (a) => this.emit("destroy", a), this.setConfiguration(e), this.configuration.document = e.document ? e.document : new ni(), this.configuration.awareness = e.awareness !== void 0 ? e.awareness : new EH(this.document), this.on("open", this.configuration.onOpen), this.on("message", this.configuration.onMessage), this.on("outgoingMessage", this.configuration.onOutgoingMessage), this.on("synced", this.configuration.onSynced), this.on("destroy", this.configuration.onDestroy), this.on("awarenessUpdate", this.configuration.onAwarenessUpdate), this.on("awarenessChange", this.configuration.onAwarenessChange), this.on("stateless", this.configuration.onStateless), this.on("unsyncedChanges", this.configuration.onUnsyncedChanges), this.on("authenticated", this.configuration.onAuthenticated), this.on("authenticationFailed", this.configuration.onAuthenticationFailed), (t = this.awareness) === null || t === void 0 || t.on("update", () => {
      this.emit("awarenessUpdate", {
        states: fx(this.awareness.getStates())
      });
    }), (r = this.awareness) === null || r === void 0 || r.on("change", () => {
      this.emit("awarenessChange", {
        states: fx(this.awareness.getStates())
      });
    }), this.document.on("update", this.boundDocumentUpdateHandler), (o = this.awareness) === null || o === void 0 || o.on("update", this.boundAwarenessUpdateHandler), this.registerEventListeners(), this.configuration.forceSyncInterval && typeof this.configuration.forceSyncInterval == "number" && (this.intervals.forceSync = setInterval(this.forceSync.bind(this), this.configuration.forceSyncInterval)), this.manageSocket && this.attach();
  }
  setConfiguration(e = {}) {
    if (!e.websocketProvider) {
      const t = e;
      this.manageSocket = !0, this.configuration.websocketProvider = new BH({
        url: t.url
      });
    }
    this.configuration = { ...this.configuration, ...e };
  }
  get document() {
    return this.configuration.document;
  }
  get isAttached() {
    return this._isAttached;
  }
  get awareness() {
    return this.configuration.awareness;
  }
  get hasUnsyncedChanges() {
    return this.unsyncedChanges > 0;
  }
  resetUnsyncedChanges() {
    this.unsyncedChanges = 1, this.emit("unsyncedChanges", { number: this.unsyncedChanges });
  }
  incrementUnsyncedChanges() {
    this.unsyncedChanges += 1, this.emit("unsyncedChanges", { number: this.unsyncedChanges });
  }
  decrementUnsyncedChanges() {
    this.unsyncedChanges > 0 && (this.unsyncedChanges -= 1), this.unsyncedChanges === 0 && (this.synced = !0), this.emit("unsyncedChanges", { number: this.unsyncedChanges });
  }
  forceSync() {
    this.resetUnsyncedChanges(), this.send(wx, {
      document: this.document,
      documentName: this.configuration.name
    });
  }
  pageHide() {
    this.awareness && vu(this.awareness, [this.document.clientID], "page hide");
  }
  registerEventListeners() {
    typeof window > "u" || !("addEventListener" in window) || window.addEventListener("pagehide", this.boundPageHide);
  }
  sendStateless(e) {
    this.send(UH, {
      documentName: this.configuration.name,
      payload: e
    });
  }
  documentUpdateHandler(e, t) {
    t !== this && (this.incrementUnsyncedChanges(), this.send(LH, { update: e, documentName: this.configuration.name }));
  }
  awarenessUpdateHandler({ added: e, updated: t, removed: r }, o) {
    const a = e.concat(t).concat(r);
    this.send(yx, {
      awareness: this.awareness,
      clients: a,
      documentName: this.configuration.name
    });
  }
  /**
   * Indicates whether a first handshake with the server has been established
   *
   * Note: this does not mean all updates from the client have been persisted to the backend. For this,
   * use `hasUnsyncedChanges`.
   */
  get synced() {
    return this.isSynced;
  }
  set synced(e) {
    this.isSynced !== e && (this.isSynced = e, e && this.emit("synced", { state: e }));
  }
  receiveStateless(e) {
    this.emit("stateless", { payload: e });
  }
  // not needed, but provides backward compatibility with e.g. lexical/yjs
  async connect() {
    if (this.manageSocket)
      return this.configuration.websocketProvider.connect();
    console.warn("HocuspocusProvider::connect() is deprecated and does not do anything. Please connect/disconnect on the websocketProvider, or attach/deattach providers.");
  }
  disconnect() {
    if (this.manageSocket)
      return this.configuration.websocketProvider.disconnect();
    console.warn("HocuspocusProvider::disconnect() is deprecated and does not do anything. Please connect/disconnect on the websocketProvider, or attach/deattach providers.");
  }
  async onOpen(e) {
    this.isAuthenticated = !1, this.emit("open", { event: e });
    let t;
    try {
      t = await this.getToken();
    } catch (r) {
      this.permissionDeniedHandler(`Failed to get token: ${r}`);
      return;
    }
    this.send(jH, {
      token: t ?? "",
      documentName: this.configuration.name
    }), this.startSync();
  }
  async getToken() {
    return typeof this.configuration.token == "function" ? await this.configuration.token() : this.configuration.token;
  }
  startSync() {
    this.resetUnsyncedChanges(), this.send(wx, {
      document: this.document,
      documentName: this.configuration.name
    }), this.awareness && this.awareness.getLocalState() !== null && this.send(yx, {
      awareness: this.awareness,
      clients: [this.document.clientID],
      documentName: this.configuration.name
    });
  }
  send(e, t) {
    if (!this._isAttached)
      return;
    const r = new $H(e, t);
    this.emit("outgoingMessage", { message: r.message }), r.send(this.configuration.websocketProvider);
  }
  onMessage(e) {
    const t = new If(e.data), r = t.readVarString();
    t.writeVarString(r), this.emit("message", { event: e, message: new If(e.data) }), new PH(t).apply(this, !0);
  }
  onClose() {
    this.isAuthenticated = !1, this.synced = !1, this.awareness && vu(this.awareness, Array.from(this.awareness.getStates().keys()).filter((e) => e !== this.document.clientID), this);
  }
  destroy() {
    this.emit("destroy"), this.intervals.forceSync && clearInterval(this.intervals.forceSync), this.awareness && (vu(this.awareness, [this.document.clientID], "provider destroy"), this.awareness.off("update", this.boundAwarenessUpdateHandler), this.awareness.destroy()), this.document.off("update", this.boundDocumentUpdateHandler), this.removeAllListeners(), this.detach(), this.manageSocket && this.configuration.websocketProvider.destroy(), !(typeof window > "u" || !("removeEventListener" in window)) && window.removeEventListener("pagehide", this.boundPageHide);
  }
  detach() {
    this.configuration.websocketProvider.off("connect", this.configuration.onConnect), this.configuration.websocketProvider.off("connect", this.forwardConnect), this.configuration.websocketProvider.off("open", this.boundOnOpen), this.configuration.websocketProvider.off("close", this.boundOnClose), this.configuration.websocketProvider.off("close", this.configuration.onClose), this.configuration.websocketProvider.off("close", this.forwardClose), this.configuration.websocketProvider.off("disconnect", this.configuration.onDisconnect), this.configuration.websocketProvider.off("disconnect", this.forwardDisconnect), this.configuration.websocketProvider.off("destroy", this.configuration.onDestroy), this.configuration.websocketProvider.off("destroy", this.forwardDestroy), this.configuration.websocketProvider.detach(this), this._isAttached = !1;
  }
  attach() {
    this._isAttached || (this.configuration.websocketProvider.on("connect", this.configuration.onConnect), this.configuration.websocketProvider.on("connect", this.forwardConnect), this.configuration.websocketProvider.on("open", this.boundOnOpen), this.configuration.websocketProvider.on("close", this.boundOnClose), this.configuration.websocketProvider.on("close", this.configuration.onClose), this.configuration.websocketProvider.on("close", this.forwardClose), this.configuration.websocketProvider.on("disconnect", this.configuration.onDisconnect), this.configuration.websocketProvider.on("disconnect", this.forwardDisconnect), this.configuration.websocketProvider.on("destroy", this.configuration.onDestroy), this.configuration.websocketProvider.on("destroy", this.forwardDestroy), this.configuration.websocketProvider.attach(this), this._isAttached = !0);
  }
  permissionDeniedHandler(e) {
    this.emit("authenticationFailed", { reason: e }), this.isAuthenticated = !1;
  }
  authenticatedHandler(e) {
    this.isAuthenticated = !0, this.authorizedScope = e, this.emit("authenticated", { scope: e });
  }
  setAwarenessField(e, t) {
    if (!this.awareness)
      throw new HH(`Cannot set awareness field "${e}" to ${JSON.stringify(t)}. You have disabled Awareness for this provider by explicitly passing awareness: null in the provider configuration.`);
    this.awareness.setLocalStateField(e, t);
  }
}
function bx(n, e) {
  const r = n.state.doc.toJSON(), o = new _H(n, e);
  let a = [];
  return r.content.forEach((l) => {
    a.push(o.serialize(l));
  }), a.join(`
`);
}
function co(n, e) {
  return n.type === e.type && JSON.stringify(n.attrs) === JSON.stringify(e.attrs);
}
class _H {
  constructor(e, t) {
    this.editor = e, this.openMarks = [], this.schemaDef = t;
  }
  serialize(e, t, r) {
    if (e.type === "text") {
      const d = e.text, p = document.createTextNode(d), f = new XMLSerializer().serializeToString(p);
      let m = "";
      if (e.marks && e.marks.length > 0) {
        t != null && t.marks && t.marks.forEach((v) => {
          if (!e.marks.some((A) => co(A, v))) {
            const A = this.openMarks.pop();
            co(A, v) || console.error("Serialization mismatch"), m += `</${v.type}>`;
          }
        });
        let y = [];
        e.marks.forEach((v) => {
          var A;
          ((A = t == null ? void 0 : t.marks) == null ? void 0 : A.some((S) => co(S, v))) || y.push(v);
        }), y.sort((v, k) => {
          var B, O;
          const A = (B = r == null ? void 0 : r.marks) != null && B.some((L) => co(L, v)) ? 1 : 0;
          return ((O = r == null ? void 0 : r.marks) != null && O.some((L) => co(L, k)) ? 1 : 0) - A;
        }), y.forEach((v) => {
          this.openMarks.push(v);
          const k = this.schemaDef.schema[v.type], A = v.type, S = v.attrs ? Object.entries(v.attrs).filter(([B, O]) => O !== null).map(([B, O]) => `${B}="${O}"`) : [];
          k.preserveSpace && S.push('xml:space="preserve"'), m += `<${A}${S.length > 0 ? " " + S.join(" ") : ""}>`;
        }), m += f, r || (this.openMarks.reverse().forEach((v) => {
          m += `</${v.type}>`;
        }), this.openMarks = []);
      } else
        this.openMarks.reverse().forEach((y) => {
          m += `</${y.type}>`;
        }), this.openMarks = [], m += f;
      return m;
    }
    const o = e.type, a = e.attrs ? Object.entries(e.attrs).filter(([d, p]) => p !== null && !d.startsWith("_")).map(([d, p]) => d === "id" ? `xml:id="${p}"` : `${d}="${p}"`).join(" ") : "";
    let l = "";
    if (e.content)
      for (let d = 0; d < e.content.length; d++) {
        const p = e.content[d], f = d > 0 ? e.content[d - 1] : null, m = d < e.content.length - 1 ? e.content[d + 1] : null;
        l += this.serialize(p, f, m);
      }
    return l ? `${this.closeMarks(r)}<${o}${a ? " " + a : ""}>${l}</${o}>` : `${this.closeMarks(r)}<${o}${a ? " " + a : ""}/>`;
  }
  closeMarks(e) {
    let t = "";
    return this.openMarks.forEach((r) => {
      if (e != null && e.isText && e.marks.some((a) => co(a, r)))
        return "";
      const o = r.type;
      this.openMarks = this.openMarks.filter((a) => !co(a, r)), t += `</${o}>`;
    }), t;
  }
}
var zH = la.create({
  name: "doc",
  topNode: !0,
  content: "block+"
}), qH = zH, VH = la.create({
  name: "text",
  group: "inline"
}), XH = VH;
const DC = q1.create({
  name: "inline",
  addOptions() {
    return {
      tag: `tei-${this.name}`,
      shortcuts: {},
      attributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.tag
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return [this.options.tag, n, 0];
  },
  addAttributes() {
    const n = {};
    return this.options.attributes && Object.entries(this.options.attributes).forEach(([e, t]) => {
      n[e] = {
        default: t.default || null,
        parseHTML: (r) => r.getAttribute(e),
        renderHTML: (r) => r[e] ? {
          [e]: r[e]
        } : {}
      };
    }), n;
  },
  addKeyboardShortcuts() {
    const n = {};
    return this.options.shortcuts && Object.entries(this.options.shortcuts).forEach(([e, t]) => {
      n[e] = () => this.editor.commands.toggleMark(this.name, t.attributes);
    }), n;
  },
  addCommands() {
    return {
      [`toggle${this.name.charAt(0).toUpperCase() + this.name.slice(1)}`]: () => ({ commands: n, attributes: e }) => n.toggleMark(this.name, e)
    };
  }
}), ql = la.create({
  name: "block",
  group: "block",
  content: "inline*",
  addOptions() {
    return {
      tag: `tei-${this.name}`,
      shortcuts: {},
      attributes: {},
      inputRules: []
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.tag
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return [this.options.tag, n, 0];
  },
  addAttributes() {
    const n = {};
    return this.options.attributes && Object.entries(this.options.attributes).forEach(([e, t]) => {
      n[e] = {
        default: t.default || null,
        parseHTML: (r) => r.getAttribute(e),
        renderHTML: (r) => r[e] ? {
          [e]: r[e]
        } : {}
      };
    }), n;
  },
  addKeyboardShortcuts() {
    const n = {};
    return this.options.shortcuts && Object.entries(this.options.shortcuts).forEach(([e, t]) => {
      t.command ? n[e] = () => this.editor.commands[t.command](this.name, t.attributes) : n[e] = () => this.editor.commands.setNode(this.name, t.attributes);
    }), n;
  },
  addCommands() {
    return {
      [`wrap${this.name.charAt(0).toUpperCase() + this.name.slice(1)}`]: () => ({ commands: e, attributes: t }) => e.wrapIn(this.name, t)
    };
  },
  addInputRules() {
    return !this.options.inputRules || this.options.inputRules.length === 0 ? [] : this.options.inputRules.map((n) => {
      if (n.type === "textblock")
        return M5({
          find: new RegExp(n.find),
          type: this.type,
          getAttributes: () => n.attributes || {}
        });
      if (n.type === "wrapping")
        return O5({
          find: new RegExp(n.find),
          type: this.type,
          keepMarks: !0,
          keepAttributes: !1,
          getAttributes: () => n.attributes || {},
          editor: this.editor
        });
    });
  }
}), JH = ql.extend({
  name: "list",
  content: "head? item+",
  group: "block",
  defining: !0,
  inline: !1,
  addCommands() {
    return {
      [`toggle${this.name.charAt(0).toUpperCase() + this.name.slice(1)}`]: (e) => ({ commands: t, editor: r }) => {
        const { state: o } = r, { selection: a } = o, { $from: l } = a;
        return ko(l, (p) => p.type.name === this.name) ? t.liftListItem(this.name) : t.wrapInList(this.name, e);
      },
      transformToHead: () => ({ commands: e, state: t, tr: r }) => {
        const { selection: o } = t, { $from: a } = o, l = ko(a, (y) => y.type.name === "item");
        if (!l) return !1;
        const d = ko(a, (y) => y.type.name === "list");
        if (!d || !(d.node.firstChild === l.node)) return !1;
        const f = l.node.firstChild;
        if (!f) return !1;
        const m = t.schema.nodes.head.create({}, f.content);
        return r.replaceWith(l.pos, l.pos + l.node.nodeSize, m), !0;
      }
    };
  },
  addKeyboardShortcuts() {
    const n = {};
    return this.options.shortcuts && Object.entries(this.options.shortcuts).forEach(([e, t]) => {
      const r = this.name.charAt(0).toUpperCase() + this.name.slice(1);
      n[e] = () => this.editor.commands[`toggle${r}`](this.name);
    }), n;
  }
}), KH = ql.extend({
  name: "item",
  content: "p block*",
  group: "item",
  defining: !1,
  addKeyboardShortcuts() {
    return {
      Enter: () => {
        const { state: n } = this.editor, { selection: e } = n, { $from: t } = e, r = t.node();
        return t.parentOffset === 0 && r.content.size === 0 ? this.editor.commands.liftListItem(this.name) : this.editor.commands.splitListItem(this.name);
      },
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name),
      "Mod-Alt-1": () => this.editor.commands.transformToHead()
    };
  }
});
function WH(n) {
  return Object.entries(n || {}).map(([e, t]) => t !== null ? `${e}="${t}"` : "").join(" ");
}
const RC = ql.extend({
  name: "emptyElement",
  group: "inline",
  content: "",
  inline: !0,
  addOptions() {
    return {
      tag: `tei-${this.name}`,
      shortcuts: {},
      attributes: {},
      label: "Empty Element"
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.tag
      }
    ];
  },
  addNodeView() {
    return ({ node: n }) => {
      const e = document.createElement(`tei-${this.name}`);
      return e.classList.add("empty-element"), e.innerHTML = this.options.label, Object.entries(n.attrs).forEach(([t, r]) => {
        r && e.setAttribute(t, r);
      }), e.addEventListener("click", () => {
        const t = this.editor.view.posAtDOM(e);
        this.editor.options.element.dispatchEvent(
          new CustomEvent("empty-element-clicked", { detail: { node: n, pos: t } })
        );
      }), {
        dom: e,
        update: (t) => {
          if (t.type !== n.type)
            return !1;
          n.attrs = t.attrs;
          const r = WH(t.attrs);
          return r && e.setAttribute("data-tooltip", r), Object.entries(n.attrs).forEach(([o, a]) => {
            a ? e.setAttribute(o, a) : e.removeAttribute(o);
          }), !0;
        }
      };
    };
  },
  addKeyboardShortcuts() {
    const n = {};
    return this.options.shortcuts && Object.entries(this.options.shortcuts).forEach(([e, t]) => {
      n[e] = () => this.editor.commands.insertContent({
        type: this.name,
        attrs: t.attributes
      });
    }), n;
  }
}), Mf = /* @__PURE__ */ new Map();
function vx(n) {
  const e = [], t = /* @__PURE__ */ new Map();
  n.nodesBetween(0, n.content.size, (o, a) => {
    o.type.name === "anchor" ? e.push({ node: o, pos: a }) : o.type.name === "note" && o.attrs.n && t.set(o.attrs.target, o.attrs.n);
  }), Mf.clear();
  let r = 0;
  return e.forEach((o) => {
    let a;
    const l = `#${o.node.attrs.id}`;
    t.has(l) ? a = t.get(l) : a = ++r, Mf.set(o.node.attrs.id, a.toString());
  }), e;
}
function kd(n) {
  return Mf.get(n);
}
function xx(n, e) {
  return e.nodesBetween(0, e.content.size, (t, r) => {
    if (t.type.name === "note") {
      const o = t.attrs.target;
      if (o && o.startsWith("#")) {
        const a = o.substring(1), l = kd(a);
        if (l)
          n = n.setNodeMarkup(r, null, {
            ...t.attrs,
            _reference: l.toString(),
            _timestamp: Date.now()
          });
        else {
          const { target: d, _reference: p, ...f } = t.attrs;
          n = n.setNodeMarkup(r, null, {
            ...f,
            _timestamp: Date.now()
          });
        }
      }
    }
  }), n;
}
function kx(n, e, t, r = null) {
  let o = null;
  if (e.descendants((m, y) => {
    if (m.type.name === t)
      return o = y, !1;
  }), o === null) return n;
  const a = e.nodeAt(o);
  if (!a) return n;
  const l = [];
  let d = -1;
  a.content.forEach((m, y) => {
    if (m.type.name === "note") {
      const v = m.attrs.target;
      let k;
      if (v && v.startsWith("#")) {
        const A = v.substring(1);
        k = kd(A);
      }
      l.push({ node: m, reference: k, originalIndex: l.length }), r && v === `#${r}` && (d = l.length - 1);
    }
  }), l.sort((m, y) => !m.reference && !y.reference ? 0 : m.reference ? y.reference ? m.reference.localeCompare(y.reference) : -1 : 1);
  let p = -1;
  d !== -1 && (p = l.findIndex((m) => m.originalIndex === d));
  const f = a.type.create(
    a.attrs,
    l.map((m) => m.node)
  );
  if (n = n.replaceWith(o, o + a.nodeSize, f), p !== -1) {
    let y = o + 1;
    for (let v = 0; v < p; v++) {
      const k = n.doc.nodeAt(y);
      k && (y += k.nodeSize);
    }
    n = n.setSelection(ge.create(n.doc, y + 1));
  }
  return n;
}
function Ax(n, e) {
  const t = Date.now();
  return e.nodesBetween(0, e.content.size, (r, o) => {
    if (r.type.name === "anchor") {
      const a = kd(r.attrs.id), l = `${t}-${o}`;
      n = n.setNodeMarkup(o, null, {
        ...r.attrs,
        _timestamp: l,
        _reference: a.toString()
        // Ensure reference is stored as string
      });
    }
  }), n;
}
const YH = yt.create({
  name: "footnoteRules",
  priority: 1e3,
  addOptions() {
    return {
      notesWrapper: "listAnnotation",
      notesWithoutAnchor: !1
    };
  },
  addCommands() {
    return {
      addNote: () => ({ commands: n, state: e }) => n.insertContent({
        type: "note",
        attrs: {
          _timestamp: Date.now()
        },
        content: [
          {
            type: "p"
          }
        ]
      }),
      updateNotes: () => ({ commands: n, state: e }) => {
        let t = e.tr;
        return vx(t.doc), t = Ax(t, t.doc), t = xx(t, t.doc), t = kx(t, t.doc, this.options.notesWrapper), !0;
      }
    };
  },
  addProseMirrorPlugins() {
    const n = this.options;
    return [
      new ot({
        key: new pt("footnoteRules"),
        appendTransaction(e, t, r) {
          if (e.every((m) => m.meta["y-sync$"] !== void 0))
            return null;
          let a = r.tr, l = null, d = !1, p = /* @__PURE__ */ new Set();
          if (e.some((m) => m.steps.some((y) => y instanceof At ? y.from === 0 && y.to === t.doc.content.size : !1)))
            d = !0;
          else
            for (let m of e)
              if (m.docChanged)
                for (let y of m.steps) {
                  if (!(y instanceof At)) continue;
                  y.slice.size > 0 && y.slice.content.descendants((O, L) => {
                    if ((O == null ? void 0 : O.type.name) == "anchor")
                      return l = O.attrs.id, d = !0, !1;
                  });
                  const k = m.docs[0], A = m.doc, S = /* @__PURE__ */ new Map(), B = /* @__PURE__ */ new Map();
                  k.descendants((O, L) => {
                    O.type.name === "anchor" && S.set(O.attrs.id, L);
                  }), A.descendants((O, L) => {
                    O.type.name === "anchor" && B.set(O.attrs.id, L);
                  });
                  for (const [O, L] of S)
                    B.has(O) || (p.add(O), d = !0);
                  (S.size !== B.size || Array.from(S.entries()).some(([O, L]) => B.get(O) !== L)) && (d = !0);
                }
          if (p.size > 0 && r.doc.descendants((m, y) => {
            if (m.type.name === "note") {
              const v = m.attrs.target;
              if (v && v.startsWith("#")) {
                const k = v.substring(1);
                if (p.has(k))
                  if (!n.notesWithoutAnchor)
                    a = a.delete(y, y + m.nodeSize);
                  else {
                    const { target: A, _reference: S, ...B } = m.attrs;
                    a = a.setNodeMarkup(y, null, {
                      ...B,
                      _timestamp: Date.now()
                    });
                  }
              }
            }
          }), l) {
            if (n.notesWithoutAnchor) {
              let O = !1;
              if (r.doc.descendants((L, G) => {
                if (L.type.name === "note" && !L.attrs.target)
                  return O = !0, !1;
              }), O)
                return null;
            }
            let m = !1;
            if (r.doc.descendants((O, L) => {
              if (O.type.name === "note" && O.attrs.target === `#${l}`)
                return m = !0, !1;
            }), m)
              return null;
            let y = null;
            r.doc.descendants((O, L) => {
              if (O.type.name === n.notesWrapper)
                return y = L, !1;
            }), y === null && (y = r.doc.content.size, a = a.insert(y, r.schema.nodes.listAnnotation.create()));
            const v = a.doc.nodeAt(y);
            if (!v)
              return null;
            const k = r.schema.nodes.note.create(
              {
                target: `#${l}`,
                _reference: "1",
                // Will be updated later
                _timestamp: Date.now()
              },
              [r.schema.nodes.p.create({}, [])]
            ), A = y + v.nodeSize - 1;
            a = a.insert(A, k);
            const S = A;
            a.doc.nodeAt(S) && (a = a.setSelection(ge.create(a.doc, S + 1)), a.scrollIntoView());
          }
          return d && (vx(a.doc), a = Ax(a, a.doc), a = xx(a, a.doc), a = kx(a, a.doc, n.notesWrapper, l)), a;
        }
      })
    ];
  }
});
function Cx() {
  const n = Date.now().toString(36), e = Math.random().toString(36).substring(2, 8);
  return `fn-${n}-${e}`;
}
const QH = RC.extend({
  name: "anchor",
  group: "inline",
  content: "",
  // Atomic nodes should not have content
  inline: !0,
  atom: !0,
  addAttributes() {
    const n = {
      id: {
        isRequired: !0,
        type: "string",
        renderHTML(e) {
          return { id: e.id };
        },
        parseHTML(e) {
          return e.getAttribute("id") || Cx();
        }
      },
      _timestamp: {
        default: null,
        renderHTML: () => ({})
      },
      _reference: {
        default: null,
        renderHTML: () => ({})
      }
    };
    return this.options.attributes && Object.entries(this.options.attributes).forEach(([e, t]) => {
      n[e] = {
        default: t.default || null,
        parseHTML: (r) => r.getAttribute(e),
        renderHTML: (r) => r[e] ? {
          [e]: r[e]
        } : {}
      };
    }), n;
  },
  addCommands() {
    return {
      addAnchor: (n) => ({ commands: e }) => {
        const t = n.id || Cx();
        if (e.insertContent({
          type: this.name,
          attrs: {
            ...n,
            id: t
          }
        }), !n.id) {
          navigator.clipboard.writeText(`#${t}`).then(() => {
            document.dispatchEvent(
              new CustomEvent("jinn-toast", {
                detail: {
                  message: "Anchor ID copied to clipboard",
                  type: "info"
                }
              })
            );
          }).catch((a) => {
            document.dispatchEvent(
              new CustomEvent("jinn-toast", {
                detail: {
                  message: "Failed to copy ID to clipboard",
                  type: "error"
                }
              })
            );
          });
          const { view: r } = this.editor;
          let o = !1;
          r.state.doc.descendants((a, l) => {
            if (a.type.name === "note" && !a.attrs.target) {
              const d = r.domAtPos(l).node;
              return d && (d.scrollIntoView({ behavior: "smooth", block: "center" }), e.setNodeSelection(l + 1), this.editor.options.element.dispatchEvent(
                new CustomEvent("empty-element-clicked", { detail: { node: a, pos: l } })
              ), o = !0), o;
            }
          });
        }
      },
      gotoNote: (n) => ({ commands: e, editor: t }) => {
        const r = `#${n}`;
        t.view.state.doc.descendants((o, a) => {
          if (o.type.name === "note" && o.attrs.target === r)
            return t.view.domAtPos(a).node.scrollIntoView({ behavior: "smooth", block: "center" }), e.setNodeSelection(a + 1), !0;
        });
      }
    };
  },
  addNodeView() {
    return ({ node: n, editor: e }) => {
      const t = document.createElement(`tei-${this.name}`);
      return Object.entries(n.attrs).forEach(([r, o]) => {
        o && t.setAttribute(r, o);
      }), {
        dom: t,
        update: (r) => r.type !== n.type ? !1 : (Object.entries(r.attrs).forEach(([o, a]) => {
          a ? t.setAttribute(o, a) : t.removeAttribute(o);
        }), !0)
      };
    };
  },
  addProseMirrorPlugins() {
    const { editor: n } = this;
    return [
      new ot({
        key: new pt("footnoteRefClick"),
        props: {
          handleClickOn(e, t, r, o, a) {
            if (r.type.name === "anchor")
              return a.ctrlKey || a.metaKey ? kd(r.attrs.id) && n.commands.gotoNote(r.attrs.id) : n.options.element.dispatchEvent(
                new CustomEvent("empty-element-clicked", { detail: { node: r, pos: t } })
              ), !0;
          }
        }
      })
    ];
  }
}), ZH = ql.extend({
  name: "graphic",
  content: "",
  selectable: !0,
  addNodeView() {
    return ({ node: n }) => {
      const e = document.createElement("img");
      return e.src = n.attrs.url, e.addEventListener("click", () => {
        const t = this.editor.view.posAtDOM(e);
        this.editor.options.element.dispatchEvent(
          new CustomEvent("empty-element-clicked", { detail: { node: n, pos: t } })
        );
      }), {
        dom: e
      };
    };
  }
}), FC = ["top", "right", "bottom", "left"], Sx = ["start", "end"], Ex = /* @__PURE__ */ FC.reduce((n, e) => n.concat(e, e + "-" + Sx[0], e + "-" + Sx[1]), []), Tr = Math.min, on = Math.max, Yu = Math.round, Cr = (n) => ({
  x: n,
  y: n
}), e4 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, t4 = {
  start: "end",
  end: "start"
};
function Of(n, e, t) {
  return on(n, Tr(e, t));
}
function ri(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function $n(n) {
  return n.split("-")[0];
}
function Yn(n) {
  return n.split("-")[1];
}
function PC(n) {
  return n === "x" ? "y" : "x";
}
function Km(n) {
  return n === "y" ? "height" : "width";
}
const n4 = /* @__PURE__ */ new Set(["top", "bottom"]);
function kr(n) {
  return n4.has($n(n)) ? "y" : "x";
}
function Wm(n) {
  return PC(kr(n));
}
function $C(n, e, t) {
  t === void 0 && (t = !1);
  const r = Yn(n), o = Wm(n), a = Km(o);
  let l = o === "x" ? r === (t ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[a] > e.floating[a] && (l = Zu(l)), [l, Zu(l)];
}
function r4(n) {
  const e = Zu(n);
  return [Qu(n), e, Qu(e)];
}
function Qu(n) {
  return n.replace(/start|end/g, (e) => t4[e]);
}
const Tx = ["left", "right"], Nx = ["right", "left"], i4 = ["top", "bottom"], o4 = ["bottom", "top"];
function s4(n, e, t) {
  switch (n) {
    case "top":
    case "bottom":
      return t ? e ? Nx : Tx : e ? Tx : Nx;
    case "left":
    case "right":
      return e ? i4 : o4;
    default:
      return [];
  }
}
function a4(n, e, t, r) {
  const o = Yn(n);
  let a = s4($n(n), t === "start", r);
  return o && (a = a.map((l) => l + "-" + o), e && (a = a.concat(a.map(Qu)))), a;
}
function Zu(n) {
  return n.replace(/left|right|bottom|top/g, (e) => e4[e]);
}
function l4(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
function Ym(n) {
  return typeof n != "number" ? l4(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
function na(n) {
  const {
    x: e,
    y: t,
    width: r,
    height: o
  } = n;
  return {
    width: r,
    height: o,
    top: t,
    left: e,
    right: e + r,
    bottom: t + o,
    x: e,
    y: t
  };
}
function Bx(n, e, t) {
  let {
    reference: r,
    floating: o
  } = n;
  const a = kr(e), l = Wm(e), d = Km(l), p = $n(e), f = a === "y", m = r.x + r.width / 2 - o.width / 2, y = r.y + r.height / 2 - o.height / 2, v = r[d] / 2 - o[d] / 2;
  let k;
  switch (p) {
    case "top":
      k = {
        x: m,
        y: r.y - o.height
      };
      break;
    case "bottom":
      k = {
        x: m,
        y: r.y + r.height
      };
      break;
    case "right":
      k = {
        x: r.x + r.width,
        y
      };
      break;
    case "left":
      k = {
        x: r.x - o.width,
        y
      };
      break;
    default:
      k = {
        x: r.x,
        y: r.y
      };
  }
  switch (Yn(e)) {
    case "start":
      k[l] -= v * (t && f ? -1 : 1);
      break;
    case "end":
      k[l] += v * (t && f ? -1 : 1);
      break;
  }
  return k;
}
const c4 = async (n, e, t) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: a = [],
    platform: l
  } = t, d = a.filter(Boolean), p = await (l.isRTL == null ? void 0 : l.isRTL(e));
  let f = await l.getElementRects({
    reference: n,
    floating: e,
    strategy: o
  }), {
    x: m,
    y
  } = Bx(f, r, p), v = r, k = {}, A = 0;
  for (let S = 0; S < d.length; S++) {
    const {
      name: B,
      fn: O
    } = d[S], {
      x: L,
      y: G,
      data: Y,
      reset: z
    } = await O({
      x: m,
      y,
      initialPlacement: r,
      placement: v,
      strategy: o,
      middlewareData: k,
      rects: f,
      platform: l,
      elements: {
        reference: n,
        floating: e
      }
    });
    m = L ?? m, y = G ?? y, k = {
      ...k,
      [B]: {
        ...k[B],
        ...Y
      }
    }, z && A <= 50 && (A++, typeof z == "object" && (z.placement && (v = z.placement), z.rects && (f = z.rects === !0 ? await l.getElementRects({
      reference: n,
      floating: e,
      strategy: o
    }) : z.rects), {
      x: m,
      y
    } = Bx(f, v, p)), S = -1);
  }
  return {
    x: m,
    y,
    placement: v,
    strategy: o,
    middlewareData: k
  };
};
async function ra(n, e) {
  var t;
  e === void 0 && (e = {});
  const {
    x: r,
    y: o,
    platform: a,
    rects: l,
    elements: d,
    strategy: p
  } = n, {
    boundary: f = "clippingAncestors",
    rootBoundary: m = "viewport",
    elementContext: y = "floating",
    altBoundary: v = !1,
    padding: k = 0
  } = ri(e, n), A = Ym(k), B = d[v ? y === "floating" ? "reference" : "floating" : y], O = na(await a.getClippingRect({
    element: (t = await (a.isElement == null ? void 0 : a.isElement(B))) == null || t ? B : B.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(d.floating)),
    boundary: f,
    rootBoundary: m,
    strategy: p
  })), L = y === "floating" ? {
    x: r,
    y: o,
    width: l.floating.width,
    height: l.floating.height
  } : l.reference, G = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(d.floating)), Y = await (a.isElement == null ? void 0 : a.isElement(G)) ? await (a.getScale == null ? void 0 : a.getScale(G)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, z = na(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: d,
    rect: L,
    offsetParent: G,
    strategy: p
  }) : L);
  return {
    top: (O.top - z.top + A.top) / Y.y,
    bottom: (z.bottom - O.bottom + A.bottom) / Y.y,
    left: (O.left - z.left + A.left) / Y.x,
    right: (z.right - O.right + A.right) / Y.x
  };
}
const u4 = (n) => ({
  name: "arrow",
  options: n,
  async fn(e) {
    const {
      x: t,
      y: r,
      placement: o,
      rects: a,
      platform: l,
      elements: d,
      middlewareData: p
    } = e, {
      element: f,
      padding: m = 0
    } = ri(n, e) || {};
    if (f == null)
      return {};
    const y = Ym(m), v = {
      x: t,
      y: r
    }, k = Wm(o), A = Km(k), S = await l.getDimensions(f), B = k === "y", O = B ? "top" : "left", L = B ? "bottom" : "right", G = B ? "clientHeight" : "clientWidth", Y = a.reference[A] + a.reference[k] - v[k] - a.floating[A], z = v[k] - a.reference[k], M = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(f));
    let ee = M ? M[G] : 0;
    (!ee || !await (l.isElement == null ? void 0 : l.isElement(M))) && (ee = d.floating[G] || a.floating[A]);
    const U = Y / 2 - z / 2, K = ee / 2 - S[A] / 2 - 1, Q = Tr(y[O], K), H = Tr(y[L], K), j = Q, ce = ee - S[A] - H, I = ee / 2 - S[A] / 2 + U, Le = Of(j, I, ce), Be = !p.arrow && Yn(o) != null && I !== Le && a.reference[A] / 2 - (I < j ? Q : H) - S[A] / 2 < 0, Ge = Be ? I < j ? I - j : I - ce : 0;
    return {
      [k]: v[k] + Ge,
      data: {
        [k]: Le,
        centerOffset: I - Le - Ge,
        ...Be && {
          alignmentOffset: Ge
        }
      },
      reset: Be
    };
  }
});
function d4(n, e, t) {
  return (n ? [...t.filter((o) => Yn(o) === n), ...t.filter((o) => Yn(o) !== n)] : t.filter((o) => $n(o) === o)).filter((o) => n ? Yn(o) === n || (e ? Qu(o) !== o : !1) : !0);
}
const p4 = function(n) {
  return n === void 0 && (n = {}), {
    name: "autoPlacement",
    options: n,
    async fn(e) {
      var t, r, o;
      const {
        rects: a,
        middlewareData: l,
        placement: d,
        platform: p,
        elements: f
      } = e, {
        crossAxis: m = !1,
        alignment: y,
        allowedPlacements: v = Ex,
        autoAlignment: k = !0,
        ...A
      } = ri(n, e), S = y !== void 0 || v === Ex ? d4(y || null, k, v) : v, B = await ra(e, A), O = ((t = l.autoPlacement) == null ? void 0 : t.index) || 0, L = S[O];
      if (L == null)
        return {};
      const G = $C(L, a, await (p.isRTL == null ? void 0 : p.isRTL(f.floating)));
      if (d !== L)
        return {
          reset: {
            placement: S[0]
          }
        };
      const Y = [B[$n(L)], B[G[0]], B[G[1]]], z = [...((r = l.autoPlacement) == null ? void 0 : r.overflows) || [], {
        placement: L,
        overflows: Y
      }], M = S[O + 1];
      if (M)
        return {
          data: {
            index: O + 1,
            overflows: z
          },
          reset: {
            placement: M
          }
        };
      const ee = z.map((Q) => {
        const H = Yn(Q.placement);
        return [Q.placement, H && m ? (
          // Check along the mainAxis and main crossAxis side.
          Q.overflows.slice(0, 2).reduce((j, ce) => j + ce, 0)
        ) : (
          // Check only the mainAxis.
          Q.overflows[0]
        ), Q.overflows];
      }).sort((Q, H) => Q[1] - H[1]), K = ((o = ee.filter((Q) => Q[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        Yn(Q[0]) ? 2 : 3
      ).every((H) => H <= 0))[0]) == null ? void 0 : o[0]) || ee[0][0];
      return K !== d ? {
        data: {
          index: O + 1,
          overflows: z
        },
        reset: {
          placement: K
        }
      } : {};
    }
  };
}, h4 = function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(e) {
      var t, r;
      const {
        placement: o,
        middlewareData: a,
        rects: l,
        initialPlacement: d,
        platform: p,
        elements: f
      } = e, {
        mainAxis: m = !0,
        crossAxis: y = !0,
        fallbackPlacements: v,
        fallbackStrategy: k = "bestFit",
        fallbackAxisSideDirection: A = "none",
        flipAlignment: S = !0,
        ...B
      } = ri(n, e);
      if ((t = a.arrow) != null && t.alignmentOffset)
        return {};
      const O = $n(o), L = kr(d), G = $n(d) === d, Y = await (p.isRTL == null ? void 0 : p.isRTL(f.floating)), z = v || (G || !S ? [Zu(d)] : r4(d)), M = A !== "none";
      !v && M && z.push(...a4(d, S, A, Y));
      const ee = [d, ...z], U = await ra(e, B), K = [];
      let Q = ((r = a.flip) == null ? void 0 : r.overflows) || [];
      if (m && K.push(U[O]), y) {
        const I = $C(o, l, Y);
        K.push(U[I[0]], U[I[1]]);
      }
      if (Q = [...Q, {
        placement: o,
        overflows: K
      }], !K.every((I) => I <= 0)) {
        var H, j;
        const I = (((H = a.flip) == null ? void 0 : H.index) || 0) + 1, Le = ee[I];
        if (Le && (!(y === "alignment" ? L !== kr(Le) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        Q.every((se) => kr(se.placement) === L ? se.overflows[0] > 0 : !0)))
          return {
            data: {
              index: I,
              overflows: Q
            },
            reset: {
              placement: Le
            }
          };
        let Be = (j = Q.filter((Ge) => Ge.overflows[0] <= 0).sort((Ge, se) => Ge.overflows[1] - se.overflows[1])[0]) == null ? void 0 : j.placement;
        if (!Be)
          switch (k) {
            case "bestFit": {
              var ce;
              const Ge = (ce = Q.filter((se) => {
                if (M) {
                  const ht = kr(se.placement);
                  return ht === L || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  ht === "y";
                }
                return !0;
              }).map((se) => [se.placement, se.overflows.filter((ht) => ht > 0).reduce((ht, kt) => ht + kt, 0)]).sort((se, ht) => se[1] - ht[1])[0]) == null ? void 0 : ce[0];
              Ge && (Be = Ge);
              break;
            }
            case "initialPlacement":
              Be = d;
              break;
          }
        if (o !== Be)
          return {
            reset: {
              placement: Be
            }
          };
      }
      return {};
    }
  };
};
function Ix(n, e) {
  return {
    top: n.top - e.height,
    right: n.right - e.width,
    bottom: n.bottom - e.height,
    left: n.left - e.width
  };
}
function Mx(n) {
  return FC.some((e) => n[e] >= 0);
}
const f4 = function(n) {
  return n === void 0 && (n = {}), {
    name: "hide",
    options: n,
    async fn(e) {
      const {
        rects: t
      } = e, {
        strategy: r = "referenceHidden",
        ...o
      } = ri(n, e);
      switch (r) {
        case "referenceHidden": {
          const a = await ra(e, {
            ...o,
            elementContext: "reference"
          }), l = Ix(a, t.reference);
          return {
            data: {
              referenceHiddenOffsets: l,
              referenceHidden: Mx(l)
            }
          };
        }
        case "escaped": {
          const a = await ra(e, {
            ...o,
            altBoundary: !0
          }), l = Ix(a, t.floating);
          return {
            data: {
              escapedOffsets: l,
              escaped: Mx(l)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
function jC(n) {
  const e = Tr(...n.map((a) => a.left)), t = Tr(...n.map((a) => a.top)), r = on(...n.map((a) => a.right)), o = on(...n.map((a) => a.bottom));
  return {
    x: e,
    y: t,
    width: r - e,
    height: o - t
  };
}
function m4(n) {
  const e = n.slice().sort((o, a) => o.y - a.y), t = [];
  let r = null;
  for (let o = 0; o < e.length; o++) {
    const a = e[o];
    !r || a.y - r.y > r.height / 2 ? t.push([a]) : t[t.length - 1].push(a), r = a;
  }
  return t.map((o) => na(jC(o)));
}
const g4 = function(n) {
  return n === void 0 && (n = {}), {
    name: "inline",
    options: n,
    async fn(e) {
      const {
        placement: t,
        elements: r,
        rects: o,
        platform: a,
        strategy: l
      } = e, {
        padding: d = 2,
        x: p,
        y: f
      } = ri(n, e), m = Array.from(await (a.getClientRects == null ? void 0 : a.getClientRects(r.reference)) || []), y = m4(m), v = na(jC(m)), k = Ym(d);
      function A() {
        if (y.length === 2 && y[0].left > y[1].right && p != null && f != null)
          return y.find((B) => p > B.left - k.left && p < B.right + k.right && f > B.top - k.top && f < B.bottom + k.bottom) || v;
        if (y.length >= 2) {
          if (kr(t) === "y") {
            const Q = y[0], H = y[y.length - 1], j = $n(t) === "top", ce = Q.top, I = H.bottom, Le = j ? Q.left : H.left, Be = j ? Q.right : H.right, Ge = Be - Le, se = I - ce;
            return {
              top: ce,
              bottom: I,
              left: Le,
              right: Be,
              width: Ge,
              height: se,
              x: Le,
              y: ce
            };
          }
          const B = $n(t) === "left", O = on(...y.map((Q) => Q.right)), L = Tr(...y.map((Q) => Q.left)), G = y.filter((Q) => B ? Q.left === L : Q.right === O), Y = G[0].top, z = G[G.length - 1].bottom, M = L, ee = O, U = ee - M, K = z - Y;
          return {
            top: Y,
            bottom: z,
            left: M,
            right: ee,
            width: U,
            height: K,
            x: M,
            y: Y
          };
        }
        return v;
      }
      const S = await a.getElementRects({
        reference: {
          getBoundingClientRect: A
        },
        floating: r.floating,
        strategy: l
      });
      return o.reference.x !== S.reference.x || o.reference.y !== S.reference.y || o.reference.width !== S.reference.width || o.reference.height !== S.reference.height ? {
        reset: {
          rects: S
        }
      } : {};
    }
  };
}, y4 = /* @__PURE__ */ new Set(["left", "top"]);
async function w4(n, e) {
  const {
    placement: t,
    platform: r,
    elements: o
  } = n, a = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), l = $n(t), d = Yn(t), p = kr(t) === "y", f = y4.has(l) ? -1 : 1, m = a && p ? -1 : 1, y = ri(e, n);
  let {
    mainAxis: v,
    crossAxis: k,
    alignmentAxis: A
  } = typeof y == "number" ? {
    mainAxis: y,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: y.mainAxis || 0,
    crossAxis: y.crossAxis || 0,
    alignmentAxis: y.alignmentAxis
  };
  return d && typeof A == "number" && (k = d === "end" ? A * -1 : A), p ? {
    x: k * m,
    y: v * f
  } : {
    x: v * f,
    y: k * m
  };
}
const b4 = function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(e) {
      var t, r;
      const {
        x: o,
        y: a,
        placement: l,
        middlewareData: d
      } = e, p = await w4(e, n);
      return l === ((t = d.offset) == null ? void 0 : t.placement) && (r = d.arrow) != null && r.alignmentOffset ? {} : {
        x: o + p.x,
        y: a + p.y,
        data: {
          ...p,
          placement: l
        }
      };
    }
  };
}, v4 = function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(e) {
      const {
        x: t,
        y: r,
        placement: o
      } = e, {
        mainAxis: a = !0,
        crossAxis: l = !1,
        limiter: d = {
          fn: (B) => {
            let {
              x: O,
              y: L
            } = B;
            return {
              x: O,
              y: L
            };
          }
        },
        ...p
      } = ri(n, e), f = {
        x: t,
        y: r
      }, m = await ra(e, p), y = kr($n(o)), v = PC(y);
      let k = f[v], A = f[y];
      if (a) {
        const B = v === "y" ? "top" : "left", O = v === "y" ? "bottom" : "right", L = k + m[B], G = k - m[O];
        k = Of(L, k, G);
      }
      if (l) {
        const B = y === "y" ? "top" : "left", O = y === "y" ? "bottom" : "right", L = A + m[B], G = A - m[O];
        A = Of(L, A, G);
      }
      const S = d.fn({
        ...e,
        [v]: k,
        [y]: A
      });
      return {
        ...S,
        data: {
          x: S.x - t,
          y: S.y - r,
          enabled: {
            [v]: a,
            [y]: l
          }
        }
      };
    }
  };
}, x4 = function(n) {
  return n === void 0 && (n = {}), {
    name: "size",
    options: n,
    async fn(e) {
      var t, r;
      const {
        placement: o,
        rects: a,
        platform: l,
        elements: d
      } = e, {
        apply: p = () => {
        },
        ...f
      } = ri(n, e), m = await ra(e, f), y = $n(o), v = Yn(o), k = kr(o) === "y", {
        width: A,
        height: S
      } = a.floating;
      let B, O;
      y === "top" || y === "bottom" ? (B = y, O = v === (await (l.isRTL == null ? void 0 : l.isRTL(d.floating)) ? "start" : "end") ? "left" : "right") : (O = y, B = v === "end" ? "top" : "bottom");
      const L = S - m.top - m.bottom, G = A - m.left - m.right, Y = Tr(S - m[B], L), z = Tr(A - m[O], G), M = !e.middlewareData.shift;
      let ee = Y, U = z;
      if ((t = e.middlewareData.shift) != null && t.enabled.x && (U = G), (r = e.middlewareData.shift) != null && r.enabled.y && (ee = L), M && !v) {
        const Q = on(m.left, 0), H = on(m.right, 0), j = on(m.top, 0), ce = on(m.bottom, 0);
        k ? U = A - 2 * (Q !== 0 || H !== 0 ? Q + H : on(m.left, m.right)) : ee = S - 2 * (j !== 0 || ce !== 0 ? j + ce : on(m.top, m.bottom));
      }
      await p({
        ...e,
        availableWidth: U,
        availableHeight: ee
      });
      const K = await l.getDimensions(d.floating);
      return A !== K.width || S !== K.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Ad() {
  return typeof window < "u";
}
function ma(n) {
  return UC(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function Sn(n) {
  var e;
  return (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function ii(n) {
  var e;
  return (e = (UC(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : e.documentElement;
}
function UC(n) {
  return Ad() ? n instanceof Node || n instanceof Sn(n).Node : !1;
}
function tr(n) {
  return Ad() ? n instanceof Element || n instanceof Sn(n).Element : !1;
}
function Nr(n) {
  return Ad() ? n instanceof HTMLElement || n instanceof Sn(n).HTMLElement : !1;
}
function Ox(n) {
  return !Ad() || typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof Sn(n).ShadowRoot;
}
const k4 = /* @__PURE__ */ new Set(["inline", "contents"]);
function Vl(n) {
  const {
    overflow: e,
    overflowX: t,
    overflowY: r,
    display: o
  } = nr(n);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + t) && !k4.has(o);
}
const A4 = /* @__PURE__ */ new Set(["table", "td", "th"]);
function C4(n) {
  return A4.has(ma(n));
}
const S4 = [":popover-open", ":modal"];
function Cd(n) {
  return S4.some((e) => {
    try {
      return n.matches(e);
    } catch {
      return !1;
    }
  });
}
const E4 = ["transform", "translate", "scale", "rotate", "perspective"], T4 = ["transform", "translate", "scale", "rotate", "perspective", "filter"], N4 = ["paint", "layout", "strict", "content"];
function Qm(n) {
  const e = Zm(), t = tr(n) ? nr(n) : n;
  return E4.some((r) => t[r] ? t[r] !== "none" : !1) || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || T4.some((r) => (t.willChange || "").includes(r)) || N4.some((r) => (t.contain || "").includes(r));
}
function B4(n) {
  let e = Ui(n);
  for (; Nr(e) && !ia(e); ) {
    if (Qm(e))
      return e;
    if (Cd(e))
      return null;
    e = Ui(e);
  }
  return null;
}
function Zm() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const I4 = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function ia(n) {
  return I4.has(ma(n));
}
function nr(n) {
  return Sn(n).getComputedStyle(n);
}
function Sd(n) {
  return tr(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.scrollX,
    scrollTop: n.scrollY
  };
}
function Ui(n) {
  if (ma(n) === "html")
    return n;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    Ox(n) && n.host || // Fallback.
    ii(n)
  );
  return Ox(e) ? e.host : e;
}
function LC(n) {
  const e = Ui(n);
  return ia(e) ? n.ownerDocument ? n.ownerDocument.body : n.body : Nr(e) && Vl(e) ? e : LC(e);
}
function HC(n, e, t) {
  var r;
  e === void 0 && (e = []);
  const o = LC(n), a = o === ((r = n.ownerDocument) == null ? void 0 : r.body), l = Sn(o);
  return a ? (Df(l), e.concat(l, l.visualViewport || [], Vl(o) ? o : [], [])) : e.concat(o, HC(o, []));
}
function Df(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
function GC(n) {
  const e = nr(n);
  let t = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const o = Nr(n), a = o ? n.offsetWidth : t, l = o ? n.offsetHeight : r, d = Yu(t) !== a || Yu(r) !== l;
  return d && (t = a, r = l), {
    width: t,
    height: r,
    $: d
  };
}
function _C(n) {
  return tr(n) ? n : n.contextElement;
}
function qs(n) {
  const e = _C(n);
  if (!Nr(e))
    return Cr(1);
  const t = e.getBoundingClientRect(), {
    width: r,
    height: o,
    $: a
  } = GC(e);
  let l = (a ? Yu(t.width) : t.width) / r, d = (a ? Yu(t.height) : t.height) / o;
  return (!l || !Number.isFinite(l)) && (l = 1), (!d || !Number.isFinite(d)) && (d = 1), {
    x: l,
    y: d
  };
}
const M4 = /* @__PURE__ */ Cr(0);
function zC(n) {
  const e = Sn(n);
  return !Zm() || !e.visualViewport ? M4 : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function O4(n, e, t) {
  return e === void 0 && (e = !1), !t || e && t !== Sn(n) ? !1 : e;
}
function Rl(n, e, t, r) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const o = n.getBoundingClientRect(), a = _C(n);
  let l = Cr(1);
  e && (r ? tr(r) && (l = qs(r)) : l = qs(n));
  const d = O4(a, t, r) ? zC(a) : Cr(0);
  let p = (o.left + d.x) / l.x, f = (o.top + d.y) / l.y, m = o.width / l.x, y = o.height / l.y;
  if (a) {
    const v = Sn(a), k = r && tr(r) ? Sn(r) : r;
    let A = v, S = Df(A);
    for (; S && r && k !== A; ) {
      const B = qs(S), O = S.getBoundingClientRect(), L = nr(S), G = O.left + (S.clientLeft + parseFloat(L.paddingLeft)) * B.x, Y = O.top + (S.clientTop + parseFloat(L.paddingTop)) * B.y;
      p *= B.x, f *= B.y, m *= B.x, y *= B.y, p += G, f += Y, A = Sn(S), S = Df(A);
    }
  }
  return na({
    width: m,
    height: y,
    x: p,
    y: f
  });
}
function Ed(n, e) {
  const t = Sd(n).scrollLeft;
  return e ? e.left + t : Rl(ii(n)).left + t;
}
function qC(n, e) {
  const t = n.getBoundingClientRect(), r = t.left + e.scrollLeft - Ed(n, t), o = t.top + e.scrollTop;
  return {
    x: r,
    y: o
  };
}
function D4(n) {
  let {
    elements: e,
    rect: t,
    offsetParent: r,
    strategy: o
  } = n;
  const a = o === "fixed", l = ii(r), d = e ? Cd(e.floating) : !1;
  if (r === l || d && a)
    return t;
  let p = {
    scrollLeft: 0,
    scrollTop: 0
  }, f = Cr(1);
  const m = Cr(0), y = Nr(r);
  if ((y || !y && !a) && ((ma(r) !== "body" || Vl(l)) && (p = Sd(r)), Nr(r))) {
    const k = Rl(r);
    f = qs(r), m.x = k.x + r.clientLeft, m.y = k.y + r.clientTop;
  }
  const v = l && !y && !a ? qC(l, p) : Cr(0);
  return {
    width: t.width * f.x,
    height: t.height * f.y,
    x: t.x * f.x - p.scrollLeft * f.x + m.x + v.x,
    y: t.y * f.y - p.scrollTop * f.y + m.y + v.y
  };
}
function R4(n) {
  return Array.from(n.getClientRects());
}
function F4(n) {
  const e = ii(n), t = Sd(n), r = n.ownerDocument.body, o = on(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), a = on(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let l = -t.scrollLeft + Ed(n);
  const d = -t.scrollTop;
  return nr(r).direction === "rtl" && (l += on(e.clientWidth, r.clientWidth) - o), {
    width: o,
    height: a,
    x: l,
    y: d
  };
}
const Dx = 25;
function P4(n, e) {
  const t = Sn(n), r = ii(n), o = t.visualViewport;
  let a = r.clientWidth, l = r.clientHeight, d = 0, p = 0;
  if (o) {
    a = o.width, l = o.height;
    const m = Zm();
    (!m || m && e === "fixed") && (d = o.offsetLeft, p = o.offsetTop);
  }
  const f = Ed(r);
  if (f <= 0) {
    const m = r.ownerDocument, y = m.body, v = getComputedStyle(y), k = m.compatMode === "CSS1Compat" && parseFloat(v.marginLeft) + parseFloat(v.marginRight) || 0, A = Math.abs(r.clientWidth - y.clientWidth - k);
    A <= Dx && (a -= A);
  } else f <= Dx && (a += f);
  return {
    width: a,
    height: l,
    x: d,
    y: p
  };
}
const $4 = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function j4(n, e) {
  const t = Rl(n, !0, e === "fixed"), r = t.top + n.clientTop, o = t.left + n.clientLeft, a = Nr(n) ? qs(n) : Cr(1), l = n.clientWidth * a.x, d = n.clientHeight * a.y, p = o * a.x, f = r * a.y;
  return {
    width: l,
    height: d,
    x: p,
    y: f
  };
}
function Rx(n, e, t) {
  let r;
  if (e === "viewport")
    r = P4(n, t);
  else if (e === "document")
    r = F4(ii(n));
  else if (tr(e))
    r = j4(e, t);
  else {
    const o = zC(n);
    r = {
      x: e.x - o.x,
      y: e.y - o.y,
      width: e.width,
      height: e.height
    };
  }
  return na(r);
}
function VC(n, e) {
  const t = Ui(n);
  return t === e || !tr(t) || ia(t) ? !1 : nr(t).position === "fixed" || VC(t, e);
}
function U4(n, e) {
  const t = e.get(n);
  if (t)
    return t;
  let r = HC(n, []).filter((d) => tr(d) && ma(d) !== "body"), o = null;
  const a = nr(n).position === "fixed";
  let l = a ? Ui(n) : n;
  for (; tr(l) && !ia(l); ) {
    const d = nr(l), p = Qm(l);
    !p && d.position === "fixed" && (o = null), (a ? !p && !o : !p && d.position === "static" && !!o && $4.has(o.position) || Vl(l) && !p && VC(n, l)) ? r = r.filter((m) => m !== l) : o = d, l = Ui(l);
  }
  return e.set(n, r), r;
}
function L4(n) {
  let {
    element: e,
    boundary: t,
    rootBoundary: r,
    strategy: o
  } = n;
  const l = [...t === "clippingAncestors" ? Cd(e) ? [] : U4(e, this._c) : [].concat(t), r], d = l[0], p = l.reduce((f, m) => {
    const y = Rx(e, m, o);
    return f.top = on(y.top, f.top), f.right = Tr(y.right, f.right), f.bottom = Tr(y.bottom, f.bottom), f.left = on(y.left, f.left), f;
  }, Rx(e, d, o));
  return {
    width: p.right - p.left,
    height: p.bottom - p.top,
    x: p.left,
    y: p.top
  };
}
function H4(n) {
  const {
    width: e,
    height: t
  } = GC(n);
  return {
    width: e,
    height: t
  };
}
function G4(n, e, t) {
  const r = Nr(e), o = ii(e), a = t === "fixed", l = Rl(n, !0, a, e);
  let d = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const p = Cr(0);
  function f() {
    p.x = Ed(o);
  }
  if (r || !r && !a)
    if ((ma(e) !== "body" || Vl(o)) && (d = Sd(e)), r) {
      const k = Rl(e, !0, a, e);
      p.x = k.x + e.clientLeft, p.y = k.y + e.clientTop;
    } else o && f();
  a && !r && o && f();
  const m = o && !r && !a ? qC(o, d) : Cr(0), y = l.left + d.scrollLeft - p.x - m.x, v = l.top + d.scrollTop - p.y - m.y;
  return {
    x: y,
    y: v,
    width: l.width,
    height: l.height
  };
}
function Uh(n) {
  return nr(n).position === "static";
}
function Fx(n, e) {
  if (!Nr(n) || nr(n).position === "fixed")
    return null;
  if (e)
    return e(n);
  let t = n.offsetParent;
  return ii(n) === t && (t = t.ownerDocument.body), t;
}
function XC(n, e) {
  const t = Sn(n);
  if (Cd(n))
    return t;
  if (!Nr(n)) {
    let o = Ui(n);
    for (; o && !ia(o); ) {
      if (tr(o) && !Uh(o))
        return o;
      o = Ui(o);
    }
    return t;
  }
  let r = Fx(n, e);
  for (; r && C4(r) && Uh(r); )
    r = Fx(r, e);
  return r && ia(r) && Uh(r) && !Qm(r) ? t : r || B4(n) || t;
}
const _4 = async function(n) {
  const e = this.getOffsetParent || XC, t = this.getDimensions, r = await t(n.floating);
  return {
    reference: G4(n.reference, await e(n.floating), n.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function z4(n) {
  return nr(n).direction === "rtl";
}
const q4 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: D4,
  getDocumentElement: ii,
  getClippingRect: L4,
  getOffsetParent: XC,
  getElementRects: _4,
  getClientRects: R4,
  getDimensions: H4,
  getScale: qs,
  isElement: tr,
  isRTL: z4
}, V4 = b4, X4 = p4, J4 = v4, K4 = h4, W4 = x4, Y4 = f4, Q4 = u4, Z4 = g4, eG = (n, e, t) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: q4,
    ...t
  }, a = {
    ...o.platform,
    _c: r
  };
  return c4(n, e, {
    ...o,
    platform: a
  });
};
var Rf, Ff;
if (typeof WeakMap < "u") {
  let n = /* @__PURE__ */ new WeakMap();
  Rf = (e) => n.get(e), Ff = (e, t) => (n.set(e, t), t);
} else {
  const n = [];
  let t = 0;
  Rf = (r) => {
    for (let o = 0; o < n.length; o += 2)
      if (n[o] == r) return n[o + 1];
  }, Ff = (r, o) => (t == 10 && (t = 0), n[t++] = r, n[t++] = o);
}
var Gt = class {
  constructor(n, e, t, r) {
    this.width = n, this.height = e, this.map = t, this.problems = r;
  }
  // Find the dimensions of the cell at the given position.
  findCell(n) {
    for (let e = 0; e < this.map.length; e++) {
      const t = this.map[e];
      if (t != n) continue;
      const r = e % this.width, o = e / this.width | 0;
      let a = r + 1, l = o + 1;
      for (let d = 1; a < this.width && this.map[e + d] == t; d++)
        a++;
      for (let d = 1; l < this.height && this.map[e + this.width * d] == t; d++)
        l++;
      return { left: r, top: o, right: a, bottom: l };
    }
    throw new RangeError(`No cell with offset ${n} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(n) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == n)
        return e % this.width;
    throw new RangeError(`No cell with offset ${n} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(n, e, t) {
    const { left: r, right: o, top: a, bottom: l } = this.findCell(n);
    return e == "horiz" ? (t < 0 ? r == 0 : o == this.width) ? null : this.map[a * this.width + (t < 0 ? r - 1 : o)] : (t < 0 ? a == 0 : l == this.height) ? null : this.map[r + this.width * (t < 0 ? a - 1 : l)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(n, e) {
    const {
      left: t,
      right: r,
      top: o,
      bottom: a
    } = this.findCell(n), {
      left: l,
      right: d,
      top: p,
      bottom: f
    } = this.findCell(e);
    return {
      left: Math.min(t, l),
      top: Math.min(o, p),
      right: Math.max(r, d),
      bottom: Math.max(a, f)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(n) {
    const e = [], t = {};
    for (let r = n.top; r < n.bottom; r++)
      for (let o = n.left; o < n.right; o++) {
        const a = r * this.width + o, l = this.map[a];
        t[l] || (t[l] = !0, !(o == n.left && o && this.map[a - 1] == l || r == n.top && r && this.map[a - this.width] == l) && e.push(l));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(n, e, t) {
    for (let r = 0, o = 0; ; r++) {
      const a = o + t.child(r).nodeSize;
      if (r == n) {
        let l = e + n * this.width;
        const d = (n + 1) * this.width;
        for (; l < d && this.map[l] < o; ) l++;
        return l == d ? a - 1 : this.map[l];
      }
      o = a;
    }
  }
  // Find the table map for the given table node.
  static get(n) {
    return Rf(n) || Ff(n, tG(n));
  }
};
function tG(n) {
  if (n.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + n.type.name);
  const e = nG(n), t = n.childCount, r = [];
  let o = 0, a = null;
  const l = [];
  for (let f = 0, m = e * t; f < m; f++) r[f] = 0;
  for (let f = 0, m = 0; f < t; f++) {
    const y = n.child(f);
    m++;
    for (let A = 0; ; A++) {
      for (; o < r.length && r[o] != 0; ) o++;
      if (A == y.childCount) break;
      const S = y.child(A), { colspan: B, rowspan: O, colwidth: L } = S.attrs;
      for (let G = 0; G < O; G++) {
        if (G + f >= t) {
          (a || (a = [])).push({
            type: "overlong_rowspan",
            pos: m,
            n: O - G
          });
          break;
        }
        const Y = o + G * e;
        for (let z = 0; z < B; z++) {
          r[Y + z] == 0 ? r[Y + z] = m : (a || (a = [])).push({
            type: "collision",
            row: f,
            pos: m,
            n: B - z
          });
          const M = L && L[z];
          if (M) {
            const ee = (Y + z) % e * 2, U = l[ee];
            U == null || U != M && l[ee + 1] == 1 ? (l[ee] = M, l[ee + 1] = 1) : U == M && l[ee + 1]++;
          }
        }
      }
      o += B, m += S.nodeSize;
    }
    const v = (f + 1) * e;
    let k = 0;
    for (; o < v; ) r[o++] == 0 && k++;
    k && (a || (a = [])).push({ type: "missing", row: f, n: k }), m++;
  }
  (e === 0 || t === 0) && (a || (a = [])).push({ type: "zero_sized" });
  const d = new Gt(e, t, r, a);
  let p = !1;
  for (let f = 0; !p && f < l.length; f += 2)
    l[f] != null && l[f + 1] < t && (p = !0);
  return p && rG(d, l, n), d;
}
function nG(n) {
  let e = -1, t = !1;
  for (let r = 0; r < n.childCount; r++) {
    const o = n.child(r);
    let a = 0;
    if (t)
      for (let l = 0; l < r; l++) {
        const d = n.child(l);
        for (let p = 0; p < d.childCount; p++) {
          const f = d.child(p);
          l + f.attrs.rowspan > r && (a += f.attrs.colspan);
        }
      }
    for (let l = 0; l < o.childCount; l++) {
      const d = o.child(l);
      a += d.attrs.colspan, d.attrs.rowspan > 1 && (t = !0);
    }
    e == -1 ? e = a : e != a && (e = Math.max(e, a));
  }
  return e;
}
function rG(n, e, t) {
  n.problems || (n.problems = []);
  const r = {};
  for (let o = 0; o < n.map.length; o++) {
    const a = n.map[o];
    if (r[a]) continue;
    r[a] = !0;
    const l = t.nodeAt(a);
    if (!l)
      throw new RangeError(`No cell with offset ${a} found`);
    let d = null;
    const p = l.attrs;
    for (let f = 0; f < p.colspan; f++) {
      const m = (o + f) % n.width, y = e[m * 2];
      y != null && (!p.colwidth || p.colwidth[f] != y) && ((d || (d = iG(p)))[f] = y);
    }
    d && n.problems.unshift({
      type: "colwidth mismatch",
      pos: a,
      colwidth: d
    });
  }
}
function iG(n) {
  if (n.colwidth) return n.colwidth.slice();
  const e = [];
  for (let t = 0; t < n.colspan; t++) e.push(0);
  return e;
}
function un(n) {
  let e = n.cached.tableNodeTypes;
  if (!e) {
    e = n.cached.tableNodeTypes = {};
    for (const t in n.nodes) {
      const r = n.nodes[t], o = r.spec.tableRole;
      o && (e[o] = r);
    }
  }
  return e;
}
var Si = new pt("selectingCells");
function Xl(n) {
  for (let e = n.depth - 1; e > 0; e--)
    if (n.node(e).type.spec.tableRole == "row")
      return n.node(0).resolve(n.before(e + 1));
  return null;
}
function oG(n) {
  for (let e = n.depth; e > 0; e--) {
    const t = n.node(e).type.spec.tableRole;
    if (t === "cell" || t === "header_cell") return n.node(e);
  }
  return null;
}
function ir(n) {
  const e = n.selection.$head;
  for (let t = e.depth; t > 0; t--)
    if (e.node(t).type.spec.tableRole == "row") return !0;
  return !1;
}
function Td(n) {
  const e = n.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const t = Xl(e.$head) || sG(e.$head);
  if (t)
    return t;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function sG(n) {
  for (let e = n.nodeAfter, t = n.pos; e; e = e.firstChild, t++) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell") return n.doc.resolve(t);
  }
  for (let e = n.nodeBefore, t = n.pos; e; e = e.lastChild, t--) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return n.doc.resolve(t - e.nodeSize);
  }
}
function Px(n) {
  return n.parent.type.spec.tableRole == "row" && !!n.nodeAfter;
}
function aG(n) {
  return n.node(0).resolve(n.pos + n.nodeAfter.nodeSize);
}
function eg(n, e) {
  return n.depth == e.depth && n.pos >= e.start(-1) && n.pos <= e.end(-1);
}
function JC(n, e, t) {
  const r = n.node(-1), o = Gt.get(r), a = n.start(-1), l = o.nextCell(n.pos - a, e, t);
  return l == null ? null : n.node(0).resolve(a + l);
}
function Po(n, e, t = 1) {
  const r = { ...n, colspan: n.colspan - t };
  return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, t), r.colwidth.some((o) => o > 0) || (r.colwidth = null)), r;
}
function KC(n, e, t = 1) {
  const r = { ...n, colspan: n.colspan + t };
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice();
    for (let o = 0; o < t; o++) r.colwidth.splice(e, 0, 0);
  }
  return r;
}
function lG(n, e, t) {
  const r = un(e.type.schema).header_cell;
  for (let o = 0; o < n.height; o++)
    if (e.nodeAt(n.map[t + o * n.width]).type != r)
      return !1;
  return !0;
}
var it = class Gr extends ve {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, t = e) {
    const r = e.node(-1), o = Gt.get(r), a = e.start(-1), l = o.rectBetween(
      e.pos - a,
      t.pos - a
    ), d = e.node(0), p = o.cellsInRect(l).filter((m) => m != t.pos - a);
    p.unshift(t.pos - a);
    const f = p.map((m) => {
      const y = r.nodeAt(m);
      if (!y)
        throw RangeError(`No cell with offset ${m} found`);
      const v = a + m + 1;
      return new Uk(
        d.resolve(v),
        d.resolve(v + y.content.size)
      );
    });
    super(f[0].$from, f[0].$to, f), this.$anchorCell = e, this.$headCell = t;
  }
  map(e, t) {
    const r = e.resolve(t.map(this.$anchorCell.pos)), o = e.resolve(t.map(this.$headCell.pos));
    if (Px(r) && Px(o) && eg(r, o)) {
      const a = this.$anchorCell.node(-1) != r.node(-1);
      return a && this.isRowSelection() ? Gr.rowSelection(r, o) : a && this.isColSelection() ? Gr.colSelection(r, o) : new Gr(r, o);
    }
    return ge.between(r, o);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), t = Gt.get(e), r = this.$anchorCell.start(-1), o = t.rectBetween(
      this.$anchorCell.pos - r,
      this.$headCell.pos - r
    ), a = {}, l = [];
    for (let p = o.top; p < o.bottom; p++) {
      const f = [];
      for (let m = p * t.width + o.left, y = o.left; y < o.right; y++, m++) {
        const v = t.map[m];
        if (a[v]) continue;
        a[v] = !0;
        const k = t.findCell(v);
        let A = e.nodeAt(v);
        if (!A)
          throw RangeError(`No cell with offset ${v} found`);
        const S = o.left - k.left, B = k.right - o.right;
        if (S > 0 || B > 0) {
          let O = A.attrs;
          if (S > 0 && (O = Po(O, 0, S)), B > 0 && (O = Po(
            O,
            O.colspan - B,
            B
          )), k.left < o.left) {
            if (A = A.type.createAndFill(O), !A)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(O)}`
              );
          } else
            A = A.type.create(O, A.content);
        }
        if (k.top < o.top || k.bottom > o.bottom) {
          const O = {
            ...A.attrs,
            rowspan: Math.min(k.bottom, o.bottom) - Math.max(k.top, o.top)
          };
          k.top < o.top ? A = A.type.createAndFill(O) : A = A.type.create(O, A.content);
        }
        f.push(A);
      }
      l.push(e.child(p).copy(X.from(f)));
    }
    const d = this.isColSelection() && this.isRowSelection() ? e : l;
    return new ne(X.from(d), 1, 1);
  }
  replace(e, t = ne.empty) {
    const r = e.steps.length, o = this.ranges;
    for (let l = 0; l < o.length; l++) {
      const { $from: d, $to: p } = o[l], f = e.mapping.slice(r);
      e.replace(
        f.map(d.pos),
        f.map(p.pos),
        l ? ne.empty : t
      );
    }
    const a = ve.findFrom(
      e.doc.resolve(e.mapping.slice(r).map(this.to)),
      -1
    );
    a && e.setSelection(a);
  }
  replaceWith(e, t) {
    this.replace(e, new ne(X.from(t), 0, 0));
  }
  forEachCell(e) {
    const t = this.$anchorCell.node(-1), r = Gt.get(t), o = this.$anchorCell.start(-1), a = r.cellsInRect(
      r.rectBetween(
        this.$anchorCell.pos - o,
        this.$headCell.pos - o
      )
    );
    for (let l = 0; l < a.length; l++)
      e(t.nodeAt(a[l]), o + a[l]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), t = this.$headCell.index(-1);
    if (Math.min(e, t) > 0) return !1;
    const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, o = t + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(r, o) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, t = e) {
    const r = e.node(-1), o = Gt.get(r), a = e.start(-1), l = o.findCell(e.pos - a), d = o.findCell(t.pos - a), p = e.node(0);
    return l.top <= d.top ? (l.top > 0 && (e = p.resolve(a + o.map[l.left])), d.bottom < o.height && (t = p.resolve(
      a + o.map[o.width * (o.height - 1) + d.right - 1]
    ))) : (d.top > 0 && (t = p.resolve(a + o.map[d.left])), l.bottom < o.height && (e = p.resolve(
      a + o.map[o.width * (o.height - 1) + l.right - 1]
    ))), new Gr(e, t);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), t = Gt.get(e), r = this.$anchorCell.start(-1), o = t.colCount(this.$anchorCell.pos - r), a = t.colCount(this.$headCell.pos - r);
    if (Math.min(o, a) > 0) return !1;
    const l = o + this.$anchorCell.nodeAfter.attrs.colspan, d = a + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(l, d) == t.width;
  }
  eq(e) {
    return e instanceof Gr && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, t = e) {
    const r = e.node(-1), o = Gt.get(r), a = e.start(-1), l = o.findCell(e.pos - a), d = o.findCell(t.pos - a), p = e.node(0);
    return l.left <= d.left ? (l.left > 0 && (e = p.resolve(
      a + o.map[l.top * o.width]
    )), d.right < o.width && (t = p.resolve(
      a + o.map[o.width * (d.top + 1) - 1]
    ))) : (d.left > 0 && (t = p.resolve(a + o.map[d.top * o.width])), l.right < o.width && (e = p.resolve(
      a + o.map[o.width * (l.top + 1) - 1]
    ))), new Gr(e, t);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, t) {
    return new Gr(e.resolve(t.anchor), e.resolve(t.head));
  }
  static create(e, t, r = t) {
    return new Gr(e.resolve(t), e.resolve(r));
  }
  getBookmark() {
    return new cG(this.$anchorCell.pos, this.$headCell.pos);
  }
};
it.prototype.visible = !1;
ve.jsonID("cell", it);
var cG = class WC {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new WC(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const t = e.resolve(this.anchor), r = e.resolve(this.head);
    return t.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && t.index() < t.parent.childCount && r.index() < r.parent.childCount && eg(t, r) ? new it(t, r) : ve.near(r, 1);
  }
};
function uG(n) {
  if (!(n.selection instanceof it)) return null;
  const e = [];
  return n.selection.forEachCell((t, r) => {
    e.push(
      It.node(r, r + t.nodeSize, { class: "selectedCell" })
    );
  }), rt.create(n.doc, e);
}
function dG({ $from: n, $to: e }) {
  if (n.pos == e.pos || n.pos < e.pos - 6) return !1;
  let t = n.pos, r = e.pos, o = n.depth;
  for (; o >= 0 && !(n.after(o + 1) < n.end(o)); o--, t++)
    ;
  for (let a = e.depth; a >= 0 && !(e.before(a + 1) > e.start(a)); a--, r--)
    ;
  return t == r && /row|table/.test(n.node(o).type.spec.tableRole);
}
function pG({ $from: n, $to: e }) {
  let t, r;
  for (let o = n.depth; o > 0; o--) {
    const a = n.node(o);
    if (a.type.spec.tableRole === "cell" || a.type.spec.tableRole === "header_cell") {
      t = a;
      break;
    }
  }
  for (let o = e.depth; o > 0; o--) {
    const a = e.node(o);
    if (a.type.spec.tableRole === "cell" || a.type.spec.tableRole === "header_cell") {
      r = a;
      break;
    }
  }
  return t !== r && e.parentOffset === 0;
}
function hG(n, e, t) {
  const r = (e || n).selection, o = (e || n).doc;
  let a, l;
  if (r instanceof fe && (l = r.node.type.spec.tableRole)) {
    if (l == "cell" || l == "header_cell")
      a = it.create(o, r.from);
    else if (l == "row") {
      const d = o.resolve(r.from + 1);
      a = it.rowSelection(d, d);
    } else if (!t) {
      const d = Gt.get(r.node), p = r.from + 1, f = p + d.map[d.width * d.height - 1];
      a = it.create(o, p + 1, f);
    }
  } else r instanceof ge && dG(r) ? a = ge.create(o, r.from) : r instanceof ge && pG(r) && (a = ge.create(o, r.$from.start(), r.$from.end()));
  return a && (e || (e = n.tr)).setSelection(a), e;
}
var fG = new pt("fix-tables");
function YC(n, e, t, r) {
  const o = n.childCount, a = e.childCount;
  e: for (let l = 0, d = 0; l < a; l++) {
    const p = e.child(l);
    for (let f = d, m = Math.min(o, l + 3); f < m; f++)
      if (n.child(f) == p) {
        d = f + 1, t += p.nodeSize;
        continue e;
      }
    r(p, t), d < o && n.child(d).sameMarkup(p) ? YC(n.child(d), p, t + 1, r) : p.nodesBetween(0, p.content.size, r, t + 1), t += p.nodeSize;
  }
}
function QC(n, e) {
  let t;
  const r = (o, a) => {
    o.type.spec.tableRole == "table" && (t = mG(n, o, a, t));
  };
  return e ? e.doc != n.doc && YC(e.doc, n.doc, 0, r) : n.doc.descendants(r), t;
}
function mG(n, e, t, r) {
  const o = Gt.get(e);
  if (!o.problems) return r;
  r || (r = n.tr);
  const a = [];
  for (let p = 0; p < o.height; p++) a.push(0);
  for (let p = 0; p < o.problems.length; p++) {
    const f = o.problems[p];
    if (f.type == "collision") {
      const m = e.nodeAt(f.pos);
      if (!m) continue;
      const y = m.attrs;
      for (let v = 0; v < y.rowspan; v++) a[f.row + v] += f.n;
      r.setNodeMarkup(
        r.mapping.map(t + 1 + f.pos),
        null,
        Po(y, y.colspan - f.n, f.n)
      );
    } else if (f.type == "missing")
      a[f.row] += f.n;
    else if (f.type == "overlong_rowspan") {
      const m = e.nodeAt(f.pos);
      if (!m) continue;
      r.setNodeMarkup(r.mapping.map(t + 1 + f.pos), null, {
        ...m.attrs,
        rowspan: m.attrs.rowspan - f.n
      });
    } else if (f.type == "colwidth mismatch") {
      const m = e.nodeAt(f.pos);
      if (!m) continue;
      r.setNodeMarkup(r.mapping.map(t + 1 + f.pos), null, {
        ...m.attrs,
        colwidth: f.colwidth
      });
    } else if (f.type == "zero_sized") {
      const m = r.mapping.map(t);
      r.delete(m, m + e.nodeSize);
    }
  }
  let l, d;
  for (let p = 0; p < a.length; p++)
    a[p] && (l == null && (l = p), d = p);
  for (let p = 0, f = t + 1; p < o.height; p++) {
    const m = e.child(p), y = f + m.nodeSize, v = a[p];
    if (v > 0) {
      let k = "cell";
      m.firstChild && (k = m.firstChild.type.spec.tableRole);
      const A = [];
      for (let B = 0; B < v; B++) {
        const O = un(n.schema)[k].createAndFill();
        O && A.push(O);
      }
      const S = (p == 0 || l == p - 1) && d == p ? f + 1 : y - 1;
      r.insert(r.mapping.map(S), A);
    }
    f = y;
  }
  return r.setMeta(fG, { fixTables: !0 });
}
function Ir(n) {
  const e = n.selection, t = Td(n), r = t.node(-1), o = t.start(-1), a = Gt.get(r);
  return { ...e instanceof it ? a.rectBetween(
    e.$anchorCell.pos - o,
    e.$headCell.pos - o
  ) : a.findCell(t.pos - o), tableStart: o, map: a, table: r };
}
function ZC(n, { map: e, tableStart: t, table: r }, o) {
  let a = o > 0 ? -1 : 0;
  lG(e, r, o + a) && (a = o == 0 || o == e.width ? null : 0);
  for (let l = 0; l < e.height; l++) {
    const d = l * e.width + o;
    if (o > 0 && o < e.width && e.map[d - 1] == e.map[d]) {
      const p = e.map[d], f = r.nodeAt(p);
      n.setNodeMarkup(
        n.mapping.map(t + p),
        null,
        KC(f.attrs, o - e.colCount(p))
      ), l += f.attrs.rowspan - 1;
    } else {
      const p = a == null ? un(r.type.schema).cell : r.nodeAt(e.map[d + a]).type, f = e.positionAt(l, o, r);
      n.insert(n.mapping.map(t + f), p.createAndFill());
    }
  }
  return n;
}
function gG(n, e) {
  if (!ir(n)) return !1;
  if (e) {
    const t = Ir(n);
    e(ZC(n.tr, t, t.left));
  }
  return !0;
}
function yG(n, e) {
  if (!ir(n)) return !1;
  if (e) {
    const t = Ir(n);
    e(ZC(n.tr, t, t.right));
  }
  return !0;
}
function wG(n, { map: e, table: t, tableStart: r }, o) {
  const a = n.mapping.maps.length;
  for (let l = 0; l < e.height; ) {
    const d = l * e.width + o, p = e.map[d], f = t.nodeAt(p), m = f.attrs;
    if (o > 0 && e.map[d - 1] == p || o < e.width - 1 && e.map[d + 1] == p)
      n.setNodeMarkup(
        n.mapping.slice(a).map(r + p),
        null,
        Po(m, o - e.colCount(p))
      );
    else {
      const y = n.mapping.slice(a).map(r + p);
      n.delete(y, y + f.nodeSize);
    }
    l += m.rowspan;
  }
}
function bG(n, e) {
  if (!ir(n)) return !1;
  if (e) {
    const t = Ir(n), r = n.tr;
    if (t.left == 0 && t.right == t.map.width) return !1;
    for (let o = t.right - 1; wG(r, t, o), o != t.left; o--) {
      const a = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
      if (!a)
        throw RangeError("No table found");
      t.table = a, t.map = Gt.get(a);
    }
    e(r);
  }
  return !0;
}
function vG(n, e, t) {
  var r;
  const o = un(e.type.schema).header_cell;
  for (let a = 0; a < n.width; a++)
    if (((r = e.nodeAt(n.map[a + t * n.width])) == null ? void 0 : r.type) != o)
      return !1;
  return !0;
}
function eS(n, { map: e, tableStart: t, table: r }, o) {
  var a;
  let l = t;
  for (let f = 0; f < o; f++) l += r.child(f).nodeSize;
  const d = [];
  let p = o > 0 ? -1 : 0;
  vG(e, r, o + p) && (p = o == 0 || o == e.height ? null : 0);
  for (let f = 0, m = e.width * o; f < e.width; f++, m++)
    if (o > 0 && o < e.height && e.map[m] == e.map[m - e.width]) {
      const y = e.map[m], v = r.nodeAt(y).attrs;
      n.setNodeMarkup(t + y, null, {
        ...v,
        rowspan: v.rowspan + 1
      }), f += v.colspan - 1;
    } else {
      const y = p == null ? un(r.type.schema).cell : (a = r.nodeAt(e.map[m + p * e.width])) == null ? void 0 : a.type, v = y == null ? void 0 : y.createAndFill();
      v && d.push(v);
    }
  return n.insert(l, un(r.type.schema).row.create(null, d)), n;
}
function xG(n, e) {
  if (!ir(n)) return !1;
  if (e) {
    const t = Ir(n);
    e(eS(n.tr, t, t.top));
  }
  return !0;
}
function kG(n, e) {
  if (!ir(n)) return !1;
  if (e) {
    const t = Ir(n);
    e(eS(n.tr, t, t.bottom));
  }
  return !0;
}
function AG(n, { map: e, table: t, tableStart: r }, o) {
  let a = 0;
  for (let f = 0; f < o; f++) a += t.child(f).nodeSize;
  const l = a + t.child(o).nodeSize, d = n.mapping.maps.length;
  n.delete(a + r, l + r);
  const p = /* @__PURE__ */ new Set();
  for (let f = 0, m = o * e.width; f < e.width; f++, m++) {
    const y = e.map[m];
    if (!p.has(y)) {
      if (p.add(y), o > 0 && y == e.map[m - e.width]) {
        const v = t.nodeAt(y).attrs;
        n.setNodeMarkup(n.mapping.slice(d).map(y + r), null, {
          ...v,
          rowspan: v.rowspan - 1
        }), f += v.colspan - 1;
      } else if (o < e.height && y == e.map[m + e.width]) {
        const v = t.nodeAt(y), k = v.attrs, A = v.type.create(
          { ...k, rowspan: v.attrs.rowspan - 1 },
          v.content
        ), S = e.positionAt(o + 1, f, t);
        n.insert(n.mapping.slice(d).map(r + S), A), f += k.colspan - 1;
      }
    }
  }
}
function CG(n, e) {
  if (!ir(n)) return !1;
  if (e) {
    const t = Ir(n), r = n.tr;
    if (t.top == 0 && t.bottom == t.map.height) return !1;
    for (let o = t.bottom - 1; AG(r, t, o), o != t.top; o--) {
      const a = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
      if (!a)
        throw RangeError("No table found");
      t.table = a, t.map = Gt.get(t.table);
    }
    e(r);
  }
  return !0;
}
function $x(n) {
  const e = n.content;
  return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
}
function SG({ width: n, height: e, map: t }, r) {
  let o = r.top * n + r.left, a = o, l = (r.bottom - 1) * n + r.left, d = o + (r.right - r.left - 1);
  for (let p = r.top; p < r.bottom; p++) {
    if (r.left > 0 && t[a] == t[a - 1] || r.right < n && t[d] == t[d + 1])
      return !0;
    a += n, d += n;
  }
  for (let p = r.left; p < r.right; p++) {
    if (r.top > 0 && t[o] == t[o - n] || r.bottom < e && t[l] == t[l + n])
      return !0;
    o++, l++;
  }
  return !1;
}
function jx(n, e) {
  const t = n.selection;
  if (!(t instanceof it) || t.$anchorCell.pos == t.$headCell.pos)
    return !1;
  const r = Ir(n), { map: o } = r;
  if (SG(o, r)) return !1;
  if (e) {
    const a = n.tr, l = {};
    let d = X.empty, p, f;
    for (let m = r.top; m < r.bottom; m++)
      for (let y = r.left; y < r.right; y++) {
        const v = o.map[m * o.width + y], k = r.table.nodeAt(v);
        if (!(l[v] || !k))
          if (l[v] = !0, p == null)
            p = v, f = k;
          else {
            $x(k) || (d = d.append(k.content));
            const A = a.mapping.map(v + r.tableStart);
            a.delete(A, A + k.nodeSize);
          }
      }
    if (p == null || f == null)
      return !0;
    if (a.setNodeMarkup(p + r.tableStart, null, {
      ...KC(
        f.attrs,
        f.attrs.colspan,
        r.right - r.left - f.attrs.colspan
      ),
      rowspan: r.bottom - r.top
    }), d.size) {
      const m = p + 1 + f.content.size, y = $x(f) ? p + 1 : m;
      a.replaceWith(y + r.tableStart, m + r.tableStart, d);
    }
    a.setSelection(
      new it(a.doc.resolve(p + r.tableStart))
    ), e(a);
  }
  return !0;
}
function Ux(n, e) {
  const t = un(n.schema);
  return EG(({ node: r }) => t[r.type.spec.tableRole])(n, e);
}
function EG(n) {
  return (e, t) => {
    var r;
    const o = e.selection;
    let a, l;
    if (o instanceof it) {
      if (o.$anchorCell.pos != o.$headCell.pos) return !1;
      a = o.$anchorCell.nodeAfter, l = o.$anchorCell.pos;
    } else {
      if (a = oG(o.$from), !a) return !1;
      l = (r = Xl(o.$from)) == null ? void 0 : r.pos;
    }
    if (a == null || l == null || a.attrs.colspan == 1 && a.attrs.rowspan == 1)
      return !1;
    if (t) {
      let d = a.attrs;
      const p = [], f = d.colwidth;
      d.rowspan > 1 && (d = { ...d, rowspan: 1 }), d.colspan > 1 && (d = { ...d, colspan: 1 });
      const m = Ir(e), y = e.tr;
      for (let k = 0; k < m.right - m.left; k++)
        p.push(
          f ? {
            ...d,
            colwidth: f && f[k] ? [f[k]] : null
          } : d
        );
      let v;
      for (let k = m.top; k < m.bottom; k++) {
        let A = m.map.positionAt(k, m.left, m.table);
        k == m.top && (A += a.nodeSize);
        for (let S = m.left, B = 0; S < m.right; S++, B++)
          S == m.left && k == m.top || y.insert(
            v = y.mapping.map(A + m.tableStart, 1),
            n({ node: a, row: k, col: S }).createAndFill(p[B])
          );
      }
      y.setNodeMarkup(
        l,
        n({ node: a, row: m.top, col: m.left }),
        p[0]
      ), o instanceof it && y.setSelection(
        new it(
          y.doc.resolve(o.$anchorCell.pos),
          v ? y.doc.resolve(v) : void 0
        )
      ), t(y);
    }
    return !0;
  };
}
function TG(n, e) {
  return function(t, r) {
    if (!ir(t)) return !1;
    const o = Td(t);
    if (o.nodeAfter.attrs[n] === e) return !1;
    if (r) {
      const a = t.tr;
      t.selection instanceof it ? t.selection.forEachCell((l, d) => {
        l.attrs[n] !== e && a.setNodeMarkup(d, null, {
          ...l.attrs,
          [n]: e
        });
      }) : a.setNodeMarkup(o.pos, null, {
        ...o.nodeAfter.attrs,
        [n]: e
      }), r(a);
    }
    return !0;
  };
}
function NG(n) {
  return function(e, t) {
    if (!ir(e)) return !1;
    if (t) {
      const r = un(e.schema), o = Ir(e), a = e.tr, l = o.map.cellsInRect(
        n == "column" ? {
          left: o.left,
          top: 0,
          right: o.right,
          bottom: o.map.height
        } : n == "row" ? {
          left: 0,
          top: o.top,
          right: o.map.width,
          bottom: o.bottom
        } : o
      ), d = l.map((p) => o.table.nodeAt(p));
      for (let p = 0; p < l.length; p++)
        d[p].type == r.header_cell && a.setNodeMarkup(
          o.tableStart + l[p],
          r.cell,
          d[p].attrs
        );
      if (a.steps.length == 0)
        for (let p = 0; p < l.length; p++)
          a.setNodeMarkup(
            o.tableStart + l[p],
            r.header_cell,
            d[p].attrs
          );
      t(a);
    }
    return !0;
  };
}
function Lx(n, e, t) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: n == "row" ? e.map.width : 1,
    bottom: n == "column" ? e.map.height : 1
  });
  for (let o = 0; o < r.length; o++) {
    const a = e.table.nodeAt(r[o]);
    if (a && a.type !== t.header_cell)
      return !1;
  }
  return !0;
}
function Fl(n, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? NG(n) : function(t, r) {
    if (!ir(t)) return !1;
    if (r) {
      const o = un(t.schema), a = Ir(t), l = t.tr, d = Lx("row", a, o), p = Lx(
        "column",
        a,
        o
      ), m = (n === "column" ? d : n === "row" ? p : !1) ? 1 : 0, y = n == "column" ? {
        left: 0,
        top: m,
        right: 1,
        bottom: a.map.height
      } : n == "row" ? {
        left: m,
        top: 0,
        right: a.map.width,
        bottom: 1
      } : a, v = n == "column" ? p ? o.cell : o.header_cell : n == "row" ? d ? o.cell : o.header_cell : o.cell;
      a.map.cellsInRect(y).forEach((k) => {
        const A = k + a.tableStart, S = l.doc.nodeAt(A);
        S && l.setNodeMarkup(A, v, S.attrs);
      }), r(l);
    }
    return !0;
  };
}
Fl("row", {
  useDeprecatedLogic: !0
});
Fl("column", {
  useDeprecatedLogic: !0
});
var BG = Fl("cell", {
  useDeprecatedLogic: !0
});
function IG(n, e) {
  if (e < 0) {
    const t = n.nodeBefore;
    if (t) return n.pos - t.nodeSize;
    for (let r = n.index(-1) - 1, o = n.before(); r >= 0; r--) {
      const a = n.node(-1).child(r), l = a.lastChild;
      if (l)
        return o - 1 - l.nodeSize;
      o -= a.nodeSize;
    }
  } else {
    if (n.index() < n.parent.childCount - 1)
      return n.pos + n.nodeAfter.nodeSize;
    const t = n.node(-1);
    for (let r = n.indexAfter(-1), o = n.after(); r < t.childCount; r++) {
      const a = t.child(r);
      if (a.childCount) return o + 1;
      o += a.nodeSize;
    }
  }
  return null;
}
function Hx(n) {
  return function(e, t) {
    if (!ir(e)) return !1;
    const r = IG(Td(e), n);
    if (r == null) return !1;
    if (t) {
      const o = e.doc.resolve(r);
      t(
        e.tr.setSelection(ge.between(o, aG(o))).scrollIntoView()
      );
    }
    return !0;
  };
}
function MG(n, e) {
  const t = n.selection.$anchor;
  for (let r = t.depth; r > 0; r--)
    if (t.node(r).type.spec.tableRole == "table")
      return e && e(
        n.tr.delete(t.before(r), t.after(r)).scrollIntoView()
      ), !0;
  return !1;
}
function eu(n, e) {
  const t = n.selection;
  if (!(t instanceof it)) return !1;
  if (e) {
    const r = n.tr, o = un(n.schema).cell.createAndFill().content;
    t.forEachCell((a, l) => {
      a.content.eq(o) || r.replace(
        r.mapping.map(l + 1),
        r.mapping.map(l + a.nodeSize - 1),
        new ne(o, 0, 0)
      );
    }), r.docChanged && e(r);
  }
  return !0;
}
function OG(n) {
  if (!n.size) return null;
  let { content: e, openStart: t, openEnd: r } = n;
  for (; e.childCount == 1 && (t > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
    t--, r--, e = e.child(0).content;
  const o = e.child(0), a = o.type.spec.tableRole, l = o.type.schema, d = [];
  if (a == "row")
    for (let p = 0; p < e.childCount; p++) {
      let f = e.child(p).content;
      const m = p ? 0 : Math.max(0, t - 1), y = p < e.childCount - 1 ? 0 : Math.max(0, r - 1);
      (m || y) && (f = Pf(
        un(l).row,
        new ne(f, m, y)
      ).content), d.push(f);
    }
  else if (a == "cell" || a == "header_cell")
    d.push(
      t || r ? Pf(
        un(l).row,
        new ne(e, t, r)
      ).content : e
    );
  else
    return null;
  return DG(l, d);
}
function DG(n, e) {
  const t = [];
  for (let o = 0; o < e.length; o++) {
    const a = e[o];
    for (let l = a.childCount - 1; l >= 0; l--) {
      const { rowspan: d, colspan: p } = a.child(l).attrs;
      for (let f = o; f < o + d; f++)
        t[f] = (t[f] || 0) + p;
    }
  }
  let r = 0;
  for (let o = 0; o < t.length; o++) r = Math.max(r, t[o]);
  for (let o = 0; o < t.length; o++)
    if (o >= e.length && e.push(X.empty), t[o] < r) {
      const a = un(n).cell.createAndFill(), l = [];
      for (let d = t[o]; d < r; d++)
        l.push(a);
      e[o] = e[o].append(X.from(l));
    }
  return { height: e.length, width: r, rows: e };
}
function Pf(n, e) {
  const t = n.createAndFill();
  return new Jf(t).replace(0, t.content.size, e).doc;
}
function RG({ width: n, height: e, rows: t }, r, o) {
  if (n != r) {
    const a = [], l = [];
    for (let d = 0; d < t.length; d++) {
      const p = t[d], f = [];
      for (let m = a[d] || 0, y = 0; m < r; y++) {
        let v = p.child(y % p.childCount);
        m + v.attrs.colspan > r && (v = v.type.createChecked(
          Po(
            v.attrs,
            v.attrs.colspan,
            m + v.attrs.colspan - r
          ),
          v.content
        )), f.push(v), m += v.attrs.colspan;
        for (let k = 1; k < v.attrs.rowspan; k++)
          a[d + k] = (a[d + k] || 0) + v.attrs.colspan;
      }
      l.push(X.from(f));
    }
    t = l, n = r;
  }
  if (e != o) {
    const a = [];
    for (let l = 0, d = 0; l < o; l++, d++) {
      const p = [], f = t[d % e];
      for (let m = 0; m < f.childCount; m++) {
        let y = f.child(m);
        l + y.attrs.rowspan > o && (y = y.type.create(
          {
            ...y.attrs,
            rowspan: Math.max(1, o - y.attrs.rowspan)
          },
          y.content
        )), p.push(y);
      }
      a.push(X.from(p));
    }
    t = a, e = o;
  }
  return { width: n, height: e, rows: t };
}
function FG(n, e, t, r, o, a, l) {
  const d = n.doc.type.schema, p = un(d);
  let f, m;
  if (o > e.width)
    for (let y = 0, v = 0; y < e.height; y++) {
      const k = t.child(y);
      v += k.nodeSize;
      const A = [];
      let S;
      k.lastChild == null || k.lastChild.type == p.cell ? S = f || (f = p.cell.createAndFill()) : S = m || (m = p.header_cell.createAndFill());
      for (let B = e.width; B < o; B++) A.push(S);
      n.insert(n.mapping.slice(l).map(v - 1 + r), A);
    }
  if (a > e.height) {
    const y = [];
    for (let A = 0, S = (e.height - 1) * e.width; A < Math.max(e.width, o); A++) {
      const B = A >= e.width ? !1 : t.nodeAt(e.map[S + A]).type == p.header_cell;
      y.push(
        B ? m || (m = p.header_cell.createAndFill()) : f || (f = p.cell.createAndFill())
      );
    }
    const v = p.row.create(null, X.from(y)), k = [];
    for (let A = e.height; A < a; A++) k.push(v);
    n.insert(n.mapping.slice(l).map(r + t.nodeSize - 2), k);
  }
  return !!(f || m);
}
function Gx(n, e, t, r, o, a, l, d) {
  if (l == 0 || l == e.height) return !1;
  let p = !1;
  for (let f = o; f < a; f++) {
    const m = l * e.width + f, y = e.map[m];
    if (e.map[m - e.width] == y) {
      p = !0;
      const v = t.nodeAt(y), { top: k, left: A } = e.findCell(y);
      n.setNodeMarkup(n.mapping.slice(d).map(y + r), null, {
        ...v.attrs,
        rowspan: l - k
      }), n.insert(
        n.mapping.slice(d).map(e.positionAt(l, A, t)),
        v.type.createAndFill({
          ...v.attrs,
          rowspan: k + v.attrs.rowspan - l
        })
      ), f += v.attrs.colspan - 1;
    }
  }
  return p;
}
function _x(n, e, t, r, o, a, l, d) {
  if (l == 0 || l == e.width) return !1;
  let p = !1;
  for (let f = o; f < a; f++) {
    const m = f * e.width + l, y = e.map[m];
    if (e.map[m - 1] == y) {
      p = !0;
      const v = t.nodeAt(y), k = e.colCount(y), A = n.mapping.slice(d).map(y + r);
      n.setNodeMarkup(
        A,
        null,
        Po(
          v.attrs,
          l - k,
          v.attrs.colspan - (l - k)
        )
      ), n.insert(
        A + v.nodeSize,
        v.type.createAndFill(
          Po(v.attrs, 0, l - k)
        )
      ), f += v.attrs.rowspan - 1;
    }
  }
  return p;
}
function zx(n, e, t, r, o) {
  let a = t ? n.doc.nodeAt(t - 1) : n.doc;
  if (!a)
    throw new Error("No table found");
  let l = Gt.get(a);
  const { top: d, left: p } = r, f = p + o.width, m = d + o.height, y = n.tr;
  let v = 0;
  function k() {
    if (a = t ? y.doc.nodeAt(t - 1) : y.doc, !a)
      throw new Error("No table found");
    l = Gt.get(a), v = y.mapping.maps.length;
  }
  FG(y, l, a, t, f, m, v) && k(), Gx(y, l, a, t, p, f, d, v) && k(), Gx(y, l, a, t, p, f, m, v) && k(), _x(y, l, a, t, d, m, p, v) && k(), _x(y, l, a, t, d, m, f, v) && k();
  for (let A = d; A < m; A++) {
    const S = l.positionAt(A, p, a), B = l.positionAt(A, f, a);
    y.replace(
      y.mapping.slice(v).map(S + t),
      y.mapping.slice(v).map(B + t),
      new ne(o.rows[A - d], 0, 0)
    );
  }
  k(), y.setSelection(
    new it(
      y.doc.resolve(t + l.positionAt(d, p, a)),
      y.doc.resolve(t + l.positionAt(m - 1, f - 1, a))
    )
  ), e(y);
}
var PG = om({
  ArrowLeft: tu("horiz", -1),
  ArrowRight: tu("horiz", 1),
  ArrowUp: tu("vert", -1),
  ArrowDown: tu("vert", 1),
  "Shift-ArrowLeft": nu("horiz", -1),
  "Shift-ArrowRight": nu("horiz", 1),
  "Shift-ArrowUp": nu("vert", -1),
  "Shift-ArrowDown": nu("vert", 1),
  Backspace: eu,
  "Mod-Backspace": eu,
  Delete: eu,
  "Mod-Delete": eu
});
function xu(n, e, t) {
  return t.eq(n.selection) ? !1 : (e && e(n.tr.setSelection(t).scrollIntoView()), !0);
}
function tu(n, e) {
  return (t, r, o) => {
    if (!o) return !1;
    const a = t.selection;
    if (a instanceof it)
      return xu(
        t,
        r,
        ve.near(a.$headCell, e)
      );
    if (n != "horiz" && !a.empty) return !1;
    const l = tS(o, n, e);
    if (l == null) return !1;
    if (n == "horiz")
      return xu(
        t,
        r,
        ve.near(t.doc.resolve(a.head + e), e)
      );
    {
      const d = t.doc.resolve(l), p = JC(d, n, e);
      let f;
      return p ? f = ve.near(p, 1) : e < 0 ? f = ve.near(t.doc.resolve(d.before(-1)), -1) : f = ve.near(t.doc.resolve(d.after(-1)), 1), xu(t, r, f);
    }
  };
}
function nu(n, e) {
  return (t, r, o) => {
    if (!o) return !1;
    const a = t.selection;
    let l;
    if (a instanceof it)
      l = a;
    else {
      const p = tS(o, n, e);
      if (p == null) return !1;
      l = new it(t.doc.resolve(p));
    }
    const d = JC(l.$headCell, n, e);
    return d ? xu(
      t,
      r,
      new it(l.$anchorCell, d)
    ) : !1;
  };
}
function $G(n, e) {
  const t = n.state.doc, r = Xl(t.resolve(e));
  return r ? (n.dispatch(n.state.tr.setSelection(new it(r))), !0) : !1;
}
function jG(n, e, t) {
  if (!ir(n.state)) return !1;
  let r = OG(t);
  const o = n.state.selection;
  if (o instanceof it) {
    r || (r = {
      width: 1,
      height: 1,
      rows: [
        X.from(
          Pf(un(n.state.schema).cell, t)
        )
      ]
    });
    const a = o.$anchorCell.node(-1), l = o.$anchorCell.start(-1), d = Gt.get(a).rectBetween(
      o.$anchorCell.pos - l,
      o.$headCell.pos - l
    );
    return r = RG(r, d.right - d.left, d.bottom - d.top), zx(n.state, n.dispatch, l, d, r), !0;
  } else if (r) {
    const a = Td(n.state), l = a.start(-1);
    return zx(
      n.state,
      n.dispatch,
      l,
      Gt.get(a.node(-1)).findCell(a.pos - l),
      r
    ), !0;
  } else
    return !1;
}
function UG(n, e) {
  var t;
  if (e.ctrlKey || e.metaKey) return;
  const r = qx(n, e.target);
  let o;
  if (e.shiftKey && n.state.selection instanceof it)
    a(n.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && r && (o = Xl(n.state.selection.$anchor)) != null && ((t = Lh(n, e)) == null ? void 0 : t.pos) != o.pos)
    a(o, e), e.preventDefault();
  else if (!r)
    return;
  function a(p, f) {
    let m = Lh(n, f);
    const y = Si.getState(n.state) == null;
    if (!m || !eg(p, m))
      if (y) m = p;
      else return;
    const v = new it(p, m);
    if (y || !n.state.selection.eq(v)) {
      const k = n.state.tr.setSelection(v);
      y && k.setMeta(Si, p.pos), n.dispatch(k);
    }
  }
  function l() {
    n.root.removeEventListener("mouseup", l), n.root.removeEventListener("dragstart", l), n.root.removeEventListener("mousemove", d), Si.getState(n.state) != null && n.dispatch(n.state.tr.setMeta(Si, -1));
  }
  function d(p) {
    const f = p, m = Si.getState(n.state);
    let y;
    if (m != null)
      y = n.state.doc.resolve(m);
    else if (qx(n, f.target) != r && (y = Lh(n, e), !y))
      return l();
    y && a(y, f);
  }
  n.root.addEventListener("mouseup", l), n.root.addEventListener("dragstart", l), n.root.addEventListener("mousemove", d);
}
function tS(n, e, t) {
  if (!(n.state.selection instanceof ge)) return null;
  const { $head: r } = n.state.selection;
  for (let o = r.depth - 1; o >= 0; o--) {
    const a = r.node(o);
    if ((t < 0 ? r.index(o) : r.indexAfter(o)) != (t < 0 ? 0 : a.childCount)) return null;
    if (a.type.spec.tableRole == "cell" || a.type.spec.tableRole == "header_cell") {
      const d = r.before(o), p = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
      return n.endOfTextblock(p) ? d : null;
    }
  }
  return null;
}
function qx(n, e) {
  for (; e && e != n.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function Lh(n, e) {
  const t = n.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return t && t ? Xl(n.state.doc.resolve(t.pos)) : null;
}
new pt(
  "tableColumnResizing"
);
function LG({
  allowTableNodeSelection: n = !1
} = {}) {
  return new ot({
    key: Si,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, t) {
        const r = e.getMeta(Si);
        if (r != null) return r == -1 ? null : r;
        if (t == null || !e.docChanged) return t;
        const { deleted: o, pos: a } = e.mapping.mapResult(t);
        return o ? null : a;
      }
    },
    props: {
      decorations: uG,
      handleDOMEvents: {
        mousedown: UG
      },
      createSelectionBetween(e) {
        return Si.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: $G,
      handleKeyDown: PG,
      handlePaste: jG
    },
    appendTransaction(e, t, r) {
      return hG(
        r,
        QC(r, t),
        n
      );
    }
  });
}
function HG(n, e) {
  const t = Math.min(n.top, e.top), r = Math.max(n.bottom, e.bottom), o = Math.min(n.left, e.left), l = Math.max(n.right, e.right) - o, d = r - t, p = o, f = t;
  return new DOMRect(p, f, l, d);
}
var GG = class {
  constructor({
    editor: n,
    element: e,
    view: t,
    updateDelay: r = 250,
    resizeDelay: o = 60,
    shouldShow: a,
    appendTo: l,
    getReferencedVirtualElement: d,
    options: p
  }) {
    this.preventHide = !1, this.isVisible = !1, this.scrollTarget = window, this.floatingUIOptions = {
      strategy: "absolute",
      placement: "top",
      offset: 8,
      flip: {},
      shift: {},
      arrow: !1,
      size: !1,
      autoPlacement: !1,
      hide: !1,
      inline: !1,
      onShow: void 0,
      onHide: void 0,
      onUpdate: void 0,
      onDestroy: void 0
    }, this.shouldShow = ({ view: m, state: y, from: v, to: k }) => {
      const { doc: A, selection: S } = y, { empty: B } = S, O = !A.textBetween(v, k).length && wm(y.selection), L = this.element.contains(document.activeElement);
      return !(!(m.hasFocus() || L) || B || O || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.dragstartHandler = () => {
      this.hide();
    }, this.resizeHandler = () => {
      this.resizeDebounceTimer && clearTimeout(this.resizeDebounceTimer), this.resizeDebounceTimer = window.setTimeout(() => {
        this.updatePosition();
      }, this.resizeDelay);
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: m }) => {
      var y;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      m != null && m.relatedTarget && ((y = this.element.parentNode) != null && y.contains(m.relatedTarget)) || (m == null ? void 0 : m.relatedTarget) !== this.editor.view.dom && this.hide();
    }, this.handleDebouncedUpdate = (m, y) => {
      const v = !(y != null && y.selection.eq(m.state.selection)), k = !(y != null && y.doc.eq(m.state.doc));
      !v && !k || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(m, v, k, y);
      }, this.updateDelay));
    }, this.updateHandler = (m, y, v, k) => {
      const { composing: A } = m;
      if (A || !y && !v)
        return;
      if (!this.getShouldShow(k)) {
        this.hide();
        return;
      }
      this.updatePosition(), this.show();
    };
    var f;
    this.editor = n, this.element = e, this.view = t, this.updateDelay = r, this.resizeDelay = o, this.appendTo = l, this.scrollTarget = (f = p == null ? void 0 : p.scrollTarget) != null ? f : window, this.getReferencedVirtualElement = d, this.floatingUIOptions = {
      ...this.floatingUIOptions,
      ...p
    }, this.element.tabIndex = 0, a && (this.shouldShow = a), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), window.addEventListener("resize", this.resizeHandler), this.scrollTarget.addEventListener("scroll", this.resizeHandler), this.update(t, t.state), this.getShouldShow() && this.show();
  }
  get middlewares() {
    const n = [];
    return this.floatingUIOptions.flip && n.push(K4(typeof this.floatingUIOptions.flip != "boolean" ? this.floatingUIOptions.flip : void 0)), this.floatingUIOptions.shift && n.push(
      J4(typeof this.floatingUIOptions.shift != "boolean" ? this.floatingUIOptions.shift : void 0)
    ), this.floatingUIOptions.offset && n.push(
      V4(typeof this.floatingUIOptions.offset != "boolean" ? this.floatingUIOptions.offset : void 0)
    ), this.floatingUIOptions.arrow && n.push(Q4(this.floatingUIOptions.arrow)), this.floatingUIOptions.size && n.push(W4(typeof this.floatingUIOptions.size != "boolean" ? this.floatingUIOptions.size : void 0)), this.floatingUIOptions.autoPlacement && n.push(
      X4(
        typeof this.floatingUIOptions.autoPlacement != "boolean" ? this.floatingUIOptions.autoPlacement : void 0
      )
    ), this.floatingUIOptions.hide && n.push(Y4(typeof this.floatingUIOptions.hide != "boolean" ? this.floatingUIOptions.hide : void 0)), this.floatingUIOptions.inline && n.push(
      Z4(typeof this.floatingUIOptions.inline != "boolean" ? this.floatingUIOptions.inline : void 0)
    ), n;
  }
  get virtualElement() {
    var n;
    const { selection: e } = this.editor.state, t = (n = this.getReferencedVirtualElement) == null ? void 0 : n.call(this);
    if (t)
      return t;
    const r = l$(this.view, e.from, e.to);
    let o = {
      getBoundingClientRect: () => r,
      getClientRects: () => [r]
    };
    if (e instanceof fe) {
      let a = this.view.nodeDOM(e.from);
      const l = a.dataset.nodeViewWrapper ? a : a.querySelector("[data-node-view-wrapper]");
      l && (a = l), a && (o = {
        getBoundingClientRect: () => a.getBoundingClientRect(),
        getClientRects: () => [a.getBoundingClientRect()]
      });
    }
    if (e instanceof it) {
      const { $anchorCell: a, $headCell: l } = e, d = a ? a.pos : l.pos, p = l ? l.pos : a.pos, f = this.view.nodeDOM(d), m = this.view.nodeDOM(p);
      if (!f || !m)
        return;
      const y = f === m ? f.getBoundingClientRect() : HG(
        f.getBoundingClientRect(),
        m.getBoundingClientRect()
      );
      o = {
        getBoundingClientRect: () => y,
        getClientRects: () => [y]
      };
    }
    return o;
  }
  updatePosition() {
    const n = this.virtualElement;
    n && eG(n, this.element, {
      placement: this.floatingUIOptions.placement,
      strategy: this.floatingUIOptions.strategy,
      middleware: this.middlewares
    }).then(({ x: e, y: t, strategy: r }) => {
      this.element.style.width = "max-content", this.element.style.position = r, this.element.style.left = `${e}px`, this.element.style.top = `${t}px`, this.isVisible && this.floatingUIOptions.onUpdate && this.floatingUIOptions.onUpdate();
    });
  }
  update(n, e) {
    const { state: t } = n, r = t.selection.from !== t.selection.to;
    if (this.updateDelay > 0 && r) {
      this.handleDebouncedUpdate(n, e);
      return;
    }
    const o = !(e != null && e.selection.eq(n.state.selection)), a = !(e != null && e.doc.eq(n.state.doc));
    this.updateHandler(n, o, a, e);
  }
  getShouldShow(n) {
    var e;
    const { state: t } = this.view, { selection: r } = t, { ranges: o } = r, a = Math.min(...o.map((p) => p.$from.pos)), l = Math.max(...o.map((p) => p.$to.pos));
    return (e = this.shouldShow) == null ? void 0 : e.call(this, {
      editor: this.editor,
      element: this.element,
      view: this.view,
      state: t,
      oldState: n,
      from: a,
      to: l
    });
  }
  show() {
    var n, e;
    this.isVisible || (this.element.style.visibility = "visible", this.element.style.opacity = "1", (e = (n = this.appendTo) != null ? n : this.view.dom.parentElement) == null || e.appendChild(this.element), this.floatingUIOptions.onShow && this.floatingUIOptions.onShow(), this.isVisible = !0);
  }
  hide() {
    this.isVisible && (this.element.style.visibility = "hidden", this.element.style.opacity = "0", this.element.remove(), this.floatingUIOptions.onHide && this.floatingUIOptions.onHide(), this.isVisible = !1);
  }
  destroy() {
    this.hide(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), window.removeEventListener("resize", this.resizeHandler), this.scrollTarget.removeEventListener("scroll", this.resizeHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler), this.floatingUIOptions.onDestroy && this.floatingUIOptions.onDestroy();
  }
}, _G = (n) => new ot({
  key: typeof n.pluginKey == "string" ? new pt(n.pluginKey) : n.pluginKey,
  view: (e) => new GG({ view: e, ...n })
}), zG = yt.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      appendTo: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      _G({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        updateDelay: this.options.updateDelay,
        options: this.options.options,
        appendTo: this.options.appendTo,
        getReferencedVirtualElement: this.options.getReferencedVirtualElement,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
const qG = (n) => {
  const e = n.$head;
  for (let t = e.depth; t > 0; t--)
    if (e.node(t).type.spec.tableRole == "table")
      return { node: e.node(t), pos: e.before(t) };
  return null;
}, bi = ({ state: n, tr: e }, { cols: t = 0, rows: r = 0 } = {}) => {
  const o = qG(n.selection);
  if (!o)
    return;
  const { node: a, pos: l } = o, d = a.children.filter((v) => v.type.spec.tableRole === "row"), p = d.length, y = [...d[0].children].filter((v) => v.type.spec.tableRole === "cell").reduce((v, k) => v + parseInt(k.attrs.colspan), 0);
  return t !== 0 && (e = e.setNodeAttribute(l, "cols", y + t)), r !== 0 && (e = e.setNodeAttribute(l, "rows", p + r)), e;
}, VG = la.create({
  name: "table",
  content: "row*",
  group: "block",
  isolating: !0,
  tableRole: "table",
  addOptions() {
    return {
      tag: "tei-table",
      shortcuts: {},
      attributes: {},
      inputRules: []
      //            View: TableView,
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.tag
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["table", n, 0];
  },
  addAttributes() {
    const n = {};
    return n.rows = {
      default: null,
      parseHTML: (e) => Array.from(e.children).filter((t) => t.localName === "tei-row").length,
      renderHTML: (e) => e.rows
    }, n.cols = {
      default: null,
      parseHTML: (e) => {
        const t = [...e.children].find((o) => o.localName === "tei-row");
        return t ? [...t.children].filter((o) => o.localName === "tei-cell").reduce(
          (o, a) => o + parseInt(a.getAttribute("cols") || "1", 10),
          0
        ) : null;
      },
      renderHTML: (e) => e.cols
    }, n;
  },
  addCommands() {
    return {
      addColumnBefore: () => ({ state: e, dispatch: t, editor: r }) => gG(
        e,
        (o) => bi({ state: e, tr: o }, { cols: 1 })
      ),
      addColumnAfter: () => ({ state: e, dispatch: t, editor: r }) => yG(
        e,
        (o) => bi({ state: e, tr: o }, { cols: 1 })
      ),
      deleteColumn: () => ({ state: e, dispatch: t, editor: r }) => bG(
        e,
        (o) => bi({ state: e, tr: o }, { cols: -1 })
      ),
      addRowBefore: () => ({ state: e, dispatch: t, editor: r }) => xG(e, (o) => bi({ state: e, tr: o }, { rows: 1 })),
      addRowAfter: () => ({ state: e, dispatch: t, editor: r }) => kG(e, (o) => bi({ state: e, tr: o }, { rows: 1 })),
      deleteRow: () => ({ state: e, dispatch: t, editor: r }) => CG(e, (o) => bi({ state: e, tr: o }, { rows: -1 })),
      deleteTable: () => ({ state: e, dispatch: t }) => MG(e, t),
      mergeCells: () => ({ state: e, dispatch: t }) => jx(e, t),
      splitCell: () => ({ state: e, dispatch: t }) => Ux(e, t),
      toggleHeaderColumn: () => ({ state: e, dispatch: t }) => Fl("column")(e, t),
      toggleHeaderRow: () => ({ state: e, dispatch: t }) => Fl("row")(e, t),
      toggleHeaderCell: () => ({ state: e, dispatch: t }) => BG(e, t),
      mergeOrSplit: () => ({ state: e, dispatch: t, editor: r }) => jx(e, t) ? bi({ state: e }) : Ux(e, t) && bi({ state: e }),
      setCellAttribute: (e, t) => ({ state: r, dispatch: o }) => TG(e, t)(r, o),
      goToNextCell: () => ({ state: e, dispatch: t }) => Hx(1)(e, t),
      goToPreviousCell: () => ({ state: e, dispatch: t }) => Hx(-1)(e, t),
      fixTables: () => ({ state: e, dispatch: t }) => (t && QC(e), !0),
      setCellSelection: (e) => ({ tr: t, dispatch: r }) => {
        if (r) {
          const o = it.create(t.doc, e.anchorCell, e.headCell);
          t.setSelection(o);
        }
        return !0;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1,
      "Shift-Tab": () => this.editor.commands.goToPreviousCell()
    };
  },
  addExtensions() {
    return [
      zG.configure({
        element: document.querySelector(".table-menu"),
        options: {
          offset: 50,
          // Place at the bottom to prevent it from overlapping with the toolbar
          // TODO: redo the HTML structure there to prevent this from happening at all
          placement: "bottom",
          shift: !0
        },
        shouldShow: ({ editor: n }) => n.isActive("table")
      })
    ];
  },
  extendNodeSchema(n) {
    const e = {
      name: n.name,
      options: n.options,
      storage: n.storage
    };
    return {
      tableRole: Ze(pe(n, "tableRole", e))
    };
  },
  addProseMirrorPlugins() {
    return [
      LG({
        allowTableNodeSelection: !0
      })
    ];
  }
}), XG = la.create({
  name: "row",
  group: "row",
  content: "cell+",
  tableRole: "row",
  addOptions() {
    return {
      tag: "tei-row",
      shortcuts: {},
      attributes: {
        role: {
          default: null
        },
        "data-preceding-pb": {
          default: null
        }
      },
      inputRules: []
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.tag
      }
    ];
  },
  renderHTML({ node: n, HTMLAttributes: e }) {
    return [n.attrs.role === "label" ? "thead" : "tr", fm(this.options.HTMLAttributes, e), 0];
  },
  addAttributes() {
    const n = {};
    return this.options.attributes && Object.entries(this.options.attributes).forEach(([e, t]) => {
      n[e] = {
        default: t.default || null,
        parseHTML: (r) => r.getAttribute(e),
        renderHTML: (r) => r[e] ? {
          [e]: r[e]
        } : {}
      };
    }), n;
  }
}), JG = la.create({
  name: "cell",
  group: "cell",
  content: "inline*",
  // Technically header cell OR normal cell, but that depends on attributes of the ancestry
  tableRole: "cell",
  isolating: !0,
  addOptions() {
    return {
      tag: "tei-cell",
      attributes: {
        ana: {
          default: null
        },
        role: {
          default: null
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.tag
      }
    ];
  },
  renderHTML({ HTMLAttributes: n }) {
    return ["td", fm(this.options.HTMLAttributes, n), 0];
  },
  addAttributes() {
    const n = {};
    return n.rowspan = {
      default: 1,
      parseHTML: (e) => e.hasAttribute("rows") ? parseInt(e.getAttribute("rows"), 10) : 1,
      renderHTML: (e) => (e.rows = e.rowspan === 1 ? null : e.rowspan, {
        rowspan: e.rowspan
      })
    }, n.colspan = {
      default: 1,
      parseHTML: (e) => e.hasAttribute("cols") ? parseInt(e.getAttribute("cols"), 10) : 1,
      renderHTML: (e) => (e.cols = e.colspan === 1 ? null : e.colspan, {
        colspan: e.colspan
      })
    }, this.options.attributes && Object.entries(this.options.attributes).forEach(([e, t]) => {
      n[e] = {
        default: t.default || null,
        parseHTML: (r) => r.getAttribute(e),
        renderHTML: (r) => r[e] ? {
          [e]: r[e]
        } : {}
      };
    }), n;
  }
}), KG = DC.extend({
  name: "ref",
  addMarkView() {
    return ({ mark: n, HTMLAttributes: e }) => {
      const t = document.createElement("a"), r = document.createElement(this.options.tag), o = n.attrs.target || "#";
      return t.href = o, t.title = o, t.target = "_blank", t.classList.add("reference"), t.addEventListener("click", (a) => {
        const l = t.getBoundingClientRect(), d = a.clientX - l.left, p = r.getBoundingClientRect().width;
        if (d <= p)
          a.preventDefault();
        else if (a.preventDefault(), a.stopPropagation(), t.href && t.href !== "#")
          try {
            window.open(t.href, "_blank", "noopener,noreferrer");
          } catch {
            window.location.href = t.href;
          }
      }), t.appendChild(r), {
        dom: t,
        contentDOM: r
      };
    };
  }
});
function WG(n) {
  const e = [YG, XH];
  return Object.entries(n.schema).forEach(([t, r]) => {
    let o;
    switch (r.type) {
      case "inline":
        o = DC.extend({
          name: t
        });
        break;
      case "anchor":
        o = QH.extend({
          name: t
        });
        break;
      case "ref":
        o = KG.extend({
          name: t
        });
        break;
      case "empty":
        o = RC.extend({
          name: t
        });
        break;
      case "list":
        o = JH.extend({
          name: t,
          content: r.content || "item+"
        });
        break;
      case "listItem":
        o = KH.extend({
          name: t,
          content: r.content || "p block*"
        });
        break;
      case "block":
        o = ql.extend({
          name: t,
          group: r.group || "block",
          defining: r.defining,
          isolating: r.isolating,
          priority: r.priority,
          inline: r.inline,
          content: r.content,
          selectable: r.selectable
        });
        break;
      case "graphic":
        o = ZH.extend({
          name: t
        });
        break;
      case "table":
        o = VG.extend({});
        break;
      case "row":
        o = XG.extend({});
        break;
      case "cell":
        o = JG.extend({});
        break;
    }
    const a = { ...n.attributes, ...r.attributes }, l = {
      shortcuts: r.keyboard,
      attributes: a,
      label: r.label
    };
    r.inputRules && (l.inputRules = r.inputRules), e.push(o.configure(l));
  }), e;
}
const YG = qH.extend({
  content: "heading* block+ listAnnotation?"
}), QG = sA({
  find: /---|–-/,
  replace: "—"
}), ZG = sA({
  find: /--(?!-)/,
  replace: "–"
}), e_ = yt.create({
  name: "inputRules",
  addInputRules() {
    return [QG, ZG];
  }
}), t_ = yt.create({
  name: "jinnTapCommands",
  addCommands() {
    return {
      moveUp: () => ({ commands: n, state: e }) => {
        const { from: t } = e.selection, o = e.doc.resolve(t).node();
        n.lift(o.type, o.attrs);
      },
      insertSnippet: (n) => ({ state: e, dispatch: t }) => {
        const { from: r, to: o } = e.selection, a = e.doc.textBetween(r, o);
        let l = n, d = 0;
        if (n.includes("{")) {
          const y = /\{([^}]*)\}/g;
          let v, k = 0, A = "";
          for (; (v = y.exec(n)) !== null; ) {
            A += n.slice(k, v.index);
            const S = d === 0 && a || v[1];
            A += S, k = v.index + v[0].length, d++;
          }
          A += n.slice(k), l = A;
        }
        const p = Mo(l, e.schema), f = e.tr;
        f.replaceWith(r, o, p);
        const m = f.mapping.map(o);
        return f.doc.nodesBetween(r, m, (y, v) => {
          y.type.name === "text" && y.text !== a && f.setSelection(ge.create(f.doc, v, v + y.nodeSize));
        }), t && t(f), !0;
      },
      insertFigure: (n) => ({ state: e, commands: t }) => (t.insertContent({
        type: "figure",
        attrs: {},
        content: [
          { type: "graphic", attrs: { url: "https://placehold.co/320x200" } },
          { type: "head", content: [{ type: "text", text: "Description" }] }
        ]
      }), !0)
    };
  }
});
function nS(n, e, t) {
  let r = null;
  return n.state.doc.nodesBetween(e, t, (o, a, l, d) => {
    o.isText && (r == null ? r = o.marks.map((p) => ({ mark: p, pos: a })) : r = r.filter(
      (p) => o.marks.find((f) => f.type.name === p.mark.type.name)
    ));
  }), r && (r = r.map((o) => {
    const a = n.state.doc.resolve(o.pos), l = ym(a, o.mark.type, o.mark.attrs);
    return o.text = n.state.doc.textBetween(l.from, l.to, "", " "), o;
  }), r.sort((o, a) => {
    var l, d;
    return (((l = a.text) == null ? void 0 : l.length) || 0) - (((d = o.text) == null ? void 0 : d.length) || 0);
  })), r;
}
function n_(n, e = []) {
  const t = {}, r = [];
  return n.state.doc.nodesBetween(0, n.state.doc.content.size, (o, a) => {
    o.isText && e.forEach((l) => {
      const d = o.text.indexOf(l);
      if (d !== -1) {
        const p = { pos: a, index: d, length: l.length };
        r.some(
          (m) => m.pos <= p.pos && m.pos + m.index + m.length >= p.pos + p.index + p.length
        ) || (t[l] = [...t[l] || [], p], r.push(p));
      }
    });
  }), t;
}
function rS(n) {
  const t = new DOMParser().parseFromString(n, "application/xml"), r = t.querySelector("parsererror");
  return r ? (console.error("XML Parsing Error:", r.textContent), null) : t;
}
function r_(n, e, t, r = 3) {
  let o = e - 1, a = 0;
  for (; o >= 0; ) {
    if (/[\p{P}\s]/.test(n.charAt(o))) {
      for (; o > 1 && /[\p{P}\s]/.test(n.charAt(o - 1)); )
        o -= 1;
      if (a += 1, a === r)
        break;
    }
    o -= 1;
  }
  let l = t + 1;
  for (a = 0; l < n.length; ) {
    if (/[\p{P}\s]/.test(n.charAt(l))) {
      for (; l < n.length - 1 && /[\p{P}\s]/.test(n.charAt(l + 1)); )
        l += 1;
      if (a += 1, a === r)
        break;
    }
    l += 1;
  }
  return `&#8230; ${n.substring(o, e)}<mark>${n.substring(e, t)}</mark>${n.substring(t, l + 1)} &#8230;`;
}
class i_ {
  constructor(e, t) {
    this.editor = e.tiptap, this.schemaDef = t, this.panel = e.sidebarContainer.querySelector(".attribute-panel"), this.currentElement = null, this.currentMark = null, this.setupEventListeners(e), this.overlay = document.createElement("div"), this.overlay.className = "jinn-tap overlay", this.overlay.style.display = "block", this.overlay.style.position = "fixed", this.overlay.style.pointerEvents = "none", this.overlay.style.zIndex = "1000", this.overlay.style.display = "none";
  }
  setupEventListeners(e) {
    this.editor.on("selectionUpdate", (t) => {
      this.updatePanelForCurrentPosition(t.editor);
    }), this.editor.on("transaction", ({ editor: t, transaction: r }) => {
      const o = r.meta["y-sync$"] !== void 0;
      r.docChanged && !o && this.updatePanelForCurrentPosition(t);
    }), this.editor.options.element.addEventListener("empty-element-clicked", ({ detail: t }) => {
      const { node: r, pos: o } = t;
      this.editor.chain().focus().setNodeSelection(o).run(), this.updatePanel(r, o);
    });
  }
  updatePanelForCurrentPosition(e) {
    var d;
    const { from: t, to: r } = e.state.selection, o = nS(e, t, r);
    if (o && o.length > 0) {
      this.currentElement = null;
      const p = o[o.length - 1];
      ((d = this.currentMark) == null ? void 0 : d.mark) != p.mark && this.updatePanel(p.mark, t, p.text), this.currentMark = p;
      return;
    }
    const a = e.state.doc.resolve(t), l = a.node();
    if (this.currentMark = null, l && Object.keys(this.schemaDef.schema).includes(l.type.name)) {
      if (this.currentElement == l)
        return;
      this.currentElement = l, this.currentAttributes = { ...l.attrs };
      const p = a.before();
      this.updatePanel(l, p);
    } else
      this.currentElement = null, this.currentAttributes = {}, this.hidePanel();
  }
  hidePanel() {
    this.updatePanel();
  }
  createAttributeInput(e, t, r, o, a = "") {
    const l = document.createElement("label");
    l.textContent = t, e.appendChild(l);
    let d;
    if (r.enum)
      if (r.open) {
        d = document.createElement("input"), d.type = "text", d.setAttribute("list", `${t}-list`);
        const p = document.createElement("datalist");
        p.id = `${t}-list`, r.enum.forEach((f) => {
          const m = document.createElement("option");
          m.value = f, p.appendChild(m);
        }), e.appendChild(p);
      } else
        d = document.createElement("select"), r.enum.forEach((p) => {
          const f = document.createElement("option");
          f.value = p, f.textContent = p, d.appendChild(f);
        });
    else
      d = document.createElement("input"), d.type = "text";
    return d.placeholder = a, d.value = o || r.default || "", d.name = t, e.appendChild(d), d;
  }
  updatePanel(e, t, r) {
    if (!this.panel || (this.panel.innerHTML = "", !e))
      return;
    const o = this.schemaDef.schema[e.type.name];
    if (!o) {
      this.panel.innerHTML = "";
      return;
    }
    const a = document.createElement("h4");
    a.textContent = e.type.name, this.panel.appendChild(a);
    const l = document.createElement("div");
    this.panel.appendChild(l);
    const d = document.createElement("form");
    this.panel.appendChild(d);
    const p = document.createElement("fieldset");
    d.appendChild(p);
    const f = { ...this.schemaDef.attributes, ...o.attributes };
    if (Object.entries(f).forEach(([m, y]) => {
      if (!m.startsWith("_"))
        if (y.connector) {
          const v = document.createElement("label");
          v.textContent = m;
          const k = document.createElement("input");
          k.type = "text", k.value = e.attrs[m], k.readOnly = !0, k.name = m, k.placeholder = "No reference assigned", p.appendChild(v), p.appendChild(k);
          const A = document.createElement("details");
          A.open = !e.attrs[m];
          const S = document.createElement("summary");
          S.textContent = "Lookup", A.appendChild(S);
          const B = document.createElement("pb-authority-lookup"), O = e.attrs[m] || e.attrs[m] === "";
          B.setAttribute("type", y.connector.type), B.setAttribute("query", r), B.setAttribute("auto", O), B.setAttribute("no-occurrences", !0);
          const L = document.createElement("pb-authority");
          if (L.setAttribute("connector", y.connector.name), L.setAttribute("name", y.connector.type), y.connector.user && L.setAttribute("user", y.connector.user), B.appendChild(L), document.addEventListener("pb-authority-select", (G) => {
            const Y = `${y.connector.prefix}-${G.detail.properties.ref}`;
            k.value = Y, A.open = !1, this.handleAttributeUpdate(e, t, { [m]: Y });
          }), A.appendChild(B), d.appendChild(A), e.attrs[m]) {
            const G = e.attrs[m].substring(e.attrs[m].indexOf("-") + 1);
            B.lookup(y.connector.type, G, l).then((Y) => {
              const z = Y.strings;
              z.sort((M, ee) => ee.length - M.length), z.unshift(r), this.updateOccurrences(this.editor, e, z);
            });
          }
        } else
          this.createAttributeInput(p, m, y, e.attrs[m]);
    }), Object.keys(f).length > 0 && !(Object.keys(f).length === 1 && f[Object.keys(f)[0]].connector)) {
      const m = document.createElement("footer"), y = document.createElement("button");
      y.dataset.tooltip = "Apply Changes", y.type = "submit", y.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="bi bi-check2-circle" viewBox="0 0 16 16">
                    <path d="M2.5 8a5.5 5.5 0 0 1 8.25-4.764.5.5 0 0 0 .5-.866A6.5 6.5 0 1 0 14.5 8a.5.5 0 0 0-1 0 5.5 5.5 0 1 1-11 0"/>
                    <path d="M15.354 3.354a.5.5 0 0 0-.708-.708L8 9.293 5.354 6.646a.5.5 0 1 0-.708.708l3 3a.5.5 0 0 0 .708 0z"/>
                </svg>
                <span>Apply</span>`, y.addEventListener("click", (v) => {
        v.preventDefault(), this.handleAttributeUpdate(e, t);
      }), m.appendChild(y), this.panel.appendChild(m);
    }
  }
  handleAttributeUpdate(e, t, r = {}) {
    const o = new FormData(this.panel.querySelector("form")), a = [];
    for (const [p, f] of o.entries())
      f !== "" ? r[p] = f : a.push(p);
    console.log("<jinn-tap> pendingChanges: %o, cleared: %o", r, a);
    const { from: l, to: d } = this.editor.state.selection;
    if (e instanceof Je && this.editor.chain().focus().extendMarkRange(e.type).run(), Object.keys(r).length > 0 || a.length > 0)
      if (e instanceof Je)
        a.length > 0 && this.editor.commands.resetAttributes(e.type, a), this.editor.chain().focus().updateAttributes(e.type, r).setTextSelection({ from: l, to: d }).run();
      else {
        if (t !== null) {
          const p = this.editor.state.tr, f = { ...e.attrs, ...r };
          a.forEach((m) => delete f[m]), console.log("<jinn-tap> newAttrs: %o", f), p.setNodeMarkup(t, e.type, f), this.editor.view.dispatch(p);
        } else
          console.log("<jinn-tap> updating attributes: %o", r), this.editor.chain().focus().resetAttributes(e.type, a).updateAttributes(e.type, r).setTextSelection({ from: l, to: d }).run();
        e.type.name === "note" && this.editor.commands.updateNotes();
      }
  }
  updateOccurrences(e, t, r) {
    const o = n_(e, r), a = document.createElement("div");
    a.classList.add("occurrences"), a.innerHTML = `
            <h5>Other Occurrences
                <div role="group">
                    <button class="apply-all" data-tooltip="Apply to All">
                        <i class="bi bi-check-all"></i>
                    </button>
                </div>
            </h5>
            <ul></ul>`;
    const l = a.querySelector("ul");
    this.panel.appendChild(a);
    const d = [];
    for (const [f, m] of Object.entries(o))
      for (const y of m) {
        const v = e.state.doc.resolve(y.pos);
        let k = v.node(), A = null;
        k.isText || e.state.doc.nodesBetween(y.pos, y.pos + y.length, (M, ee) => {
          if (M.isText)
            return A = M, !1;
        });
        const S = A && A.marks.find((M) => t.eq(M)), B = document.createElement("li"), O = document.createElement("label"), L = document.createElement("input");
        L.type = "checkbox", L.checked = S, O.appendChild(L), d.push({
          checkbox: L,
          from: y.pos + y.index,
          to: y.pos + y.index + y.length,
          hasMark: S
        });
        const G = e.state.doc.textBetween(y.pos, v.end()), Y = r_(G, y.index, y.index + y.length), z = document.createElement("span");
        z.innerHTML = Y, O.appendChild(z), B.appendChild(O), l.appendChild(B), O.addEventListener("mouseenter", (M) => {
          M.preventDefault(), M.stopPropagation();
          const ee = e.view.nodeDOM(y.pos);
          if (ee) {
            (ee.nodeType === window.Node.TEXT_NODE ? ee.parentNode : ee).scrollIntoView({ behavior: "instant", block: "center" });
            let K;
            if (ee.nodeType === window.Node.TEXT_NODE) {
              const Q = document.createRange();
              Q.setStart(ee, y.index), Q.setEnd(ee, y.index + y.length), K = Q.getBoundingClientRect();
            } else
              K = ee.getBoundingClientRect();
            this.overlay.style.display = "block", this.overlay.style.top = K.top - 4 + "px", this.overlay.style.left = K.left - 4 + "px", this.overlay.style.width = K.width + 4 + "px", this.overlay.style.height = K.height + 4 + "px", document.body.appendChild(this.overlay);
          }
        }), O.addEventListener("mouseleave", (M) => {
          M.preventDefault(), M.stopPropagation(), this.overlay.style.display = "none";
        }), L.addEventListener("change", (M) => {
          M.preventDefault(), M.stopPropagation(), this.editor.chain().focus().setTextSelection({ from: y.pos + y.index, to: y.pos + y.index + y.length }).toggleMark(t.type, t.attrs).run();
        });
      }
    a.querySelector(".apply-all").addEventListener("click", (f) => {
      f.preventDefault(), f.stopPropagation();
      const m = d.filter((y) => !y.checkbox.checked);
      if (m.length > 0) {
        let y = this.editor.chain().focus();
        m.forEach((v) => {
          y = y.setTextSelection({ from: v.from, to: v.to }).toggleMark(t.type, t.attrs), v.checkbox.checked = !0;
        }), y.run();
      }
    });
  }
}
class o_ {
  constructor(e, t) {
    this.editor = e.tiptap, this.attributePanel = t, this.panel = e.sidebarContainer.querySelector(".navigation-panel"), this.setupEventListeners();
  }
  setupEventListeners() {
    this.editor.on("transaction", ({ editor: e, transaction: t }) => {
      const r = t.meta["y-sync$"] !== void 0;
      t.docChanged && !r && this.updatePanelForCurrentPosition(e);
    }), this.editor.on("selectionUpdate", ({ editor: e }) => {
      this.updatePanelForCurrentPosition(e);
    });
  }
  updatePanelForCurrentPosition(e) {
    this.panel.innerHTML = "";
    const { from: t, to: r } = e.state.selection, o = e.state.doc.resolve(t), a = o.node(), l = [];
    let d;
    if (a) {
      d = nS(e, t, r);
      let f = o.depth;
      for (; f > 0; ) {
        const m = o.node(f);
        if (m) {
          const y = {
            type: m.type.name,
            node: m,
            pos: { from: o.start(f), to: o.end(f) }
          };
          l.push(y);
        }
        f--;
      }
    }
    let p = document.createElement("ul");
    l.reverse().forEach((f, m) => {
      const y = document.createElement("li"), v = document.createElement("a");
      v.setAttribute("href", "#"), v.textContent = f.type, v.addEventListener("click", (k) => {
        k.preventDefault(), this.editor.chain().focus().setNodeSelection(f.pos.from - 1).run(), this.attributePanel.updatePanel(f.node, f.pos.from - 1);
      }), y.appendChild(v), p.appendChild(y);
    }), d && d.forEach((f) => {
      const m = document.createElement("li"), y = document.createElement("a");
      y.setAttribute("href", "#"), y.textContent = f.mark.type.name, y.addEventListener("click", (v) => {
        v.preventDefault(), this.editor.chain().focus().extendMarkRange(f.mark.type).run(), this.attributePanel.updatePanel(f.mark, t, f.text);
      }), m.appendChild(y), p.appendChild(m);
    }), this.panel.appendChild(p);
  }
}
class s_ {
  /**
   * Create a new Toolbar instance.
   *
   * @param {import('./jinn-tap').JinnTap} editor - The editor instance.
   * @param {Object} schemaDef - The schema definition.
   */
  constructor(e, t) {
    this.editor = e.tiptap, this.toolbar = e.toolbarContainer, this.schemaDef = t, this.selectElements = /* @__PURE__ */ new Map();
    const r = [], o = /* @__PURE__ */ new Map();
    t.toolbar && Object.entries(t.toolbar).forEach(([l, d]) => {
      var p;
      d.select ? (o.has(d.select) || o.set(d.select, []), o.get(d.select).push({ name: l, def: d, isGlobal: !0 }), r.some((f) => f.type === "select" && f.name === d.select) || r.push({
        type: "select",
        name: d.select,
        order: ((p = this.schemaDef.selects[d.select]) == null ? void 0 : p.order) ?? 0
      })) : r.push({
        type: "button",
        name: l,
        def: d,
        isGlobal: !0,
        order: d.order ?? 0
      });
    }), Object.entries(t.schema).forEach(([l, d]) => {
      d.toolbar && Object.entries(d.toolbar).forEach(([p, f]) => {
        var m;
        f.select ? (o.has(f.select) || o.set(f.select, []), o.get(f.select).push({ name: l, def: d, label: p, toolbarDef: f, isGlobal: !1 }), r.some((y) => y.type === "select" && y.name === f.select) || r.push({
          type: "select",
          name: f.select,
          order: ((m = this.schemaDef.selects[f.select]) == null ? void 0 : m.order) ?? 0
        })) : r.push({
          type: "button",
          name: l,
          def: d,
          label: p,
          toolbarDef: f,
          isGlobal: !1,
          order: f.order ?? 0
        });
      });
    }), r.sort((l, d) => l.order - d.order).forEach((l) => {
      if (l.type === "select") {
        const d = this.schemaDef.selects[l.name], p = this.createSelect((d == null ? void 0 : d.label) || l.name);
        this.selectElements.set(l.name, p);
        const f = document.createElement("li");
        f.appendChild(p), this.toolbar.appendChild(f), o.get(l.name).forEach((m) => {
          m.isGlobal ? this.addOptionToSelect(
            p,
            m.name,
            m.def,
            m.name,
            m.def
          ) : this.addOptionToSelect(
            p,
            m.name,
            m.def,
            m.label,
            m.toolbarDef
          );
        });
      } else {
        const d = this.createButton(
          l.name,
          l.isGlobal ? l.name : l.label,
          l.isGlobal ? l.def : l.toolbarDef || l.def
        );
        d.addEventListener("click", (f) => {
          f.preventDefault(), this.nodeAction(l.name, l.def, l.toolbarDef || l.def);
        });
        const p = document.createElement("li");
        p.appendChild(d), this.toolbar.appendChild(p);
      }
    }), this.editor.on("selectionUpdate", this.updateButtonStates.bind(this));
  }
  /**
   * Perform action for a node in the toolbar.
   *
   * @param {string} name - The name of the node.
   * @param {Object} def - The definition of the node.
   * @param {Object} toolbarDef - The definition of the toolbar item.
   * @param {boolean} checkOnly - Whether to only check if the action can be performed.
   */
  nodeAction(e, t, r, o = !1) {
    if (e === "head") {
      const { state: d } = this.editor, { selection: p } = d, { $from: f } = p;
      if (ko(f, (y) => y.type.name === "item")) {
        if (o)
          return this.editor.can().transformToHead();
        this.editor.chain().focus().transformToHead().run();
        return;
      }
    }
    if (e === "pb") {
      const { state: d } = this.editor, { selection: p } = d, { $from: f, $to: m } = p, y = ko(f, (k) => k.type.name === "row"), v = ko(m, (k) => k.type.name === "row");
      if (y) {
        if (v.pos !== y.pos)
          return !1;
        const [k] = Cv(y.node, (O) => O.type.name === "cell"), A = y.start + k.pos + 1, S = o ? this.editor.can().chain() : this.editor.chain(), [B] = Cv(k.node, (O) => O.type.name === "pb");
        return B ? (console.log(f, m), S.focus().deleteRange({
          from: A + B.pos,
          to: A + B.pos + 1
        }).run()) : S.focus().insertContentAt(A, Mo("<tei-pb/>", this.editor.schema)).run();
      }
    }
    let a;
    o ? a = this.editor.can() : a = this.editor.chain().focus();
    const l = (r == null ? void 0 : r.attributes) ?? {};
    if (r != null && r.command) {
      switch (r.command) {
        case "toggleSource":
          return o ? !0 : this.toggleSource();
        case "toggleDebug":
          return o ? !0 : this.toggleDebug();
      }
      r.args ? a = a[r.command](...r.args) : a = a[r.command](e, l);
    } else if (t.type === "inline" || t.type === "ref")
      a = a.toggleMark(e, l);
    else if (t.type === "list")
      a = a.toggleList(l);
    else if (t.type === "anchor")
      a = o ? !0 : a.addAnchor(l);
    else if (t.type === "empty" || t.type === "graphic")
      a = a.insertContent({
        type: e,
        attrs: l
      });
    else {
      const d = this.editor.schema.nodes[e];
      d && d.isTextblock ? a = a.setNode(e, l) : a = a.wrapIn(e, l);
    }
    if (o)
      return a;
    a.run();
  }
  createButton(e, t, r) {
    const o = document.createElement("a");
    return o.href = "#", o.className = "outline toolbar-button", r.label && (o.innerHTML = r.label), o.dataset.tooltip = t, o.dataset.placement = "bottom", o.dataset.name = e, o.addEventListener("mousedown", (a) => {
      a.preventDefault();
    }), o;
  }
  /**
   * Update the state of buttons based on the current selection.
   */
  updateButtonStates() {
    this.toolbar.querySelectorAll("a[data-name]").forEach((t) => {
      const r = t.dataset.name, o = this.schemaDef.schema[r];
      if (!o) return;
      const a = this.schemaDef.toolbar[r], l = this.nodeAction(r, o, a, !0);
      t.disabled = !l, l ? t.classList.remove("disabled") : t.classList.add("disabled"), t.classList.toggle("active", this.editor.isActive(r));
    });
  }
  createSelect(e) {
    const t = document.createElement("details");
    t.className = "dropdown";
    const r = document.createElement("summary");
    r.innerHTML = e, t.appendChild(r);
    const o = document.createElement("ul");
    return t.appendChild(o), t;
  }
  addOptionToSelect(e, t, r, o, a) {
    const l = document.createElement("li"), d = document.createElement("a");
    d.innerHTML = a.label, d.dataset.name = t, d.appendChild(document.createTextNode(" " + o)), d.href = "#", l.appendChild(d), d.addEventListener("click", (p) => {
      p.preventDefault(), e.open = !1, this.nodeAction(t, r, a);
    }), e.querySelector("ul").appendChild(l);
  }
  toggleSource() {
    const e = this.toolbar.closest("jinn-tap"), t = e.querySelector(".editor-area"), r = e.querySelector(".code-area");
    return r.style.display === "none" ? (r.style.display = "block", t.style.display = "none") : (r.style.display = "none", t.style.display = "block"), !0;
  }
  toggleDebug() {
    const e = this.toolbar.closest("jinn-tap");
    return e.hasAttribute("debug") ? e.removeAttribute("debug") : e.setAttribute("debug", ""), !0;
  }
}
function Hh(n, e) {
  const t = n.querySelectorAll("slot");
  for (const r of t) {
    const o = r.name, a = e.querySelectorAll(`[slot="${o}"]`);
    if (a.length > 0) {
      const l = r.parentNode;
      a.forEach((d) => {
        const p = document.createElement("div");
        p.innerHTML = d.outerHTML, Array.from(p.children).forEach((m) => l.insertBefore(m, r)), d.remove();
      });
    }
  }
  return t.forEach((r) => r.remove()), e;
}
const iS = (n) => {
  let e = parseInt(n.substring(1, 3), 16) / 255, t = parseInt(n.substring(3, 5), 16) / 255, r = parseInt(n.substring(5, 7), 16) / 255, o = Math.max(e, t, r), a = Math.min(e, t, r), l, d, p = (o + a) / 2;
  if (o === a)
    l = d = 0;
  else {
    let f = o - a;
    switch (d = p > 0.5 ? f / (2 - o - a) : f / (o + a), o) {
      case e:
        l = (t - r) / f + (t < r ? 6 : 0);
        break;
      case t:
        l = (r - e) / f + 2;
        break;
      case r:
        l = (e - t) / f + 4;
        break;
    }
    l /= 6;
  }
  return [l * 360, d * 100, p * 100];
}, $f = (n, e, t) => {
  t /= 100;
  const r = e * Math.min(t, 1 - t) / 100, o = (a) => {
    const l = (a + n / 30) % 12, d = t - r * Math.max(Math.min(l - 3, 9 - l, 1), -1);
    return Math.round(255 * d).toString(16).padStart(2, "0");
  };
  return `#${o(0)}${o(8)}${o(4)}`;
};
function a_(n) {
  const e = "#E48500", t = {}, r = [], [o, a, l] = iS(e);
  for (let p = 0; p < 5; p++) {
    const f = (o + p * 40) % 360, m = $f(f, a, l);
    t[`--tei-div-color-${p}`] = m;
  }
  let d = 5;
  return Object.entries(n.schema).forEach(([p, f]) => {
    const m = (o + d * 60) % 360, y = $f(m, a, l);
    t[`--tei-${p}-color`] = `${y}`, (f.type === "inline" || f.type === "empty") && r.push(`
                .debug tei-${p}::after { 
                    background-color: var(--tei-${p}-color);
                    content: "${p}";
                }
            `), d++;
  }), `
        :root {
            ${Object.entries(t).map(([p, f]) => `${p}: ${f};`).join(`
`)}
        }
        
        ${r.join(`
`)}
    `;
}
function Vx() {
  const n = "#E48500", [e, t, r] = iS(n), o = (e + Math.random() * 360) % 360;
  return $f(o, t, r);
}
function Ts(n, e, t, r) {
  const o = { op: e, func: t, data: r };
  return n.push(o), o;
}
function l_(n, e) {
  return n;
}
let c_ = class {
  constructor() {
    this.program = [];
  }
  test(e, t) {
    return Ts(this.program, 5, e, t === void 0 ? null : t);
  }
  jump(e) {
    return Ts(this.program, 3, null, e);
  }
  record(e, t) {
    return Ts(this.program, 4, t === void 0 ? l_ : t, e);
  }
  bad(e = 1) {
    return Ts(this.program, 1, null, e);
  }
  accept() {
    return Ts(this.program, 0, null, null);
  }
  fail(e) {
    return Ts(this.program, 2, e || null, null);
  }
}, u_ = class jf {
  constructor(e, t, r) {
    this.programLength = e, this.maxFromByPc = t, this.maxSurvivorFromByPc = r;
  }
  static fromProgram(e) {
    const t = e.length, r = [], o = [];
    return e.forEach((a) => {
      r.push(0), o.push(0);
    }), e.forEach((a, l) => {
      switch (a.op) {
        case 2:
          if (a.func === null) return;
          if (l + 1 >= t) throw new Error("Invalid program: program could run past end");
          r[l + 1] += 1;
          break;
        case 1:
        case 4:
          if (l + 1 >= t) throw new Error("Invalid program: program could run past end");
          r[l + 1] += 1;
          break;
        case 3:
          a.data.forEach((d) => {
            if (d < 0 || d >= t) throw new Error("Invalid program: program could run past end");
            r[d] += 1;
          });
          break;
        case 5:
          if (l + 1 >= t) throw new Error("Invalid program: program could run past end");
          o[l + 1] += 1;
          break;
        case 0:
          o[l] += 1;
      }
    }), new jf(t, r, o);
  }
  static createStub(e) {
    const t = [], r = [];
    for (let o = 0; o < e; ++o) t.push(e), r.push(e);
    return new jf(e, t, r);
  }
}, d_ = class {
  constructor(e) {
    this.acceptingTraces = e, this.success = e.length > 0;
  }
}, Xx = class {
  constructor(e) {
    this.t = 0, this.i = 0, this.h = new Uint16Array(e), this.l = new Uint8Array(e);
  }
  getBadness(e) {
    return this.l[e];
  }
  add(e, t) {
    this.l[e] = t > 255 ? 255 : t;
    const r = function(o, a, l, d, p) {
      let f = d, m = p;
      for (; f < m; ) {
        const y = f + m >>> 1;
        l < a[o[y]] ? m = y : f = y + 1;
      }
      return f;
    }(this.h, this.l, t, this.i, this.t);
    this.h.copyWithin(r + 1, r, this.t), this.h[r] = e, this.t += 1;
  }
  reschedule(e, t) {
    const r = Math.max(this.l[e], t > 255 ? 255 : t);
    if (this.l[e] !== r) {
      const o = this.h.indexOf(e, this.i);
      if (o < 0 || o >= this.t) return void (this.l[e] = r);
      this.h.copyWithin(o, o + 1, this.t), this.t -= 1, this.add(e, r);
    }
  }
  getNextPc() {
    return this.i >= this.t ? null : this.h[this.i++];
  }
  reset() {
    this.t = 0, this.i = 0, this.l.fill(0);
  }
}, Jx = class {
  constructor(e) {
    this.o = [];
    let t = e.length;
    e.forEach((r) => {
      this.o.push(r > 0 ? t : -1), t += r;
    }), this.u = new Uint16Array(t);
  }
  clear() {
    this.u.fill(0, 0, this.o.length);
  }
  add(e, t) {
    const r = this.u[t], o = this.o[t];
    this.u[t] += 1, this.u[o + r] = e;
  }
  has(e) {
    return this.u[e] > 0;
  }
  forEach(e, t) {
    const r = this.u[e], o = this.o[e];
    for (let a = o; a < o + r; ++a) t(this.u[a]);
  }
};
function Uf(n, e, t = !1) {
  return n === null ? e : Array.isArray(n) ? (n.indexOf(e) === -1 && (t && (n = n.slice()), n.push(e)), n) : n === e ? n : [n, e];
}
let oa = class {
  constructor(e, t) {
    this.prefixes = e, this.record = t;
  }
};
function Kx(n, e) {
  let t;
  if (e === null) {
    if (!Array.isArray(n)) return n;
    t = n;
  } else t = n === oa.EMPTY ? [] : Array.isArray(n) ? n : [n];
  return new oa(t, e);
}
oa.EMPTY = new oa([], null);
let p_ = class {
  constructor(e) {
    this.p = [], this.v = [];
    for (let t = 0; t < e; ++t) this.p.push(0), this.v.push(null);
  }
  mergeTraces(e, t, r, o, a, l) {
    let d = !1;
    return r.forEach(t, (p) => {
      const f = this.trace(p, o, a, l);
      var m, y, v;
      y = f, v = d, e = (m = e) === null ? y : y === null ? m : Array.isArray(y) ? y.reduce((k, A) => Uf(k, A, k === y), m) : Uf(m, y, v), d = e === f;
    }), e;
  }
  trace(e, t, r, o) {
    switch (this.p[e]) {
      case 2:
        return this.v[e];
      case 1:
        return null;
    }
    this.p[e] = 1;
    let a = null;
    const l = t[e];
    if (l !== null) a = l;
    else if (!r.has(e)) throw new Error("Trace without source at pc " + e);
    if (a = this.mergeTraces(a, e, r, t, r, o), a !== null) {
      const d = o[e];
      d !== null && (a = Kx(a, d));
    }
    return this.v[e] = a, this.p[e] = 2, a;
  }
  buildSurvivorTraces(e, t, r, o, a) {
    for (let l = 0, d = e.length; l < d; ++l) {
      if (!r.has(l)) {
        t[l] = null;
        continue;
      }
      this.v.fill(null), this.p.fill(0);
      const p = this.mergeTraces(null, l, r, e, o, a);
      if (p === null) throw new Error("No non-cyclic paths found to survivor " + l);
      t[l] = Kx(p, null);
    }
    this.v.fill(null);
  }
}, h_ = class {
  constructor(e) {
    this.g = [], this.k = [], this.m = [], this.A = new Jx(e.maxFromByPc), this.T = new Jx(e.maxSurvivorFromByPc), this.S = new p_(e.programLength);
    for (let t = 0; t < e.programLength; ++t) this.g.push(null), this.k.push(null), this.m.push(null);
    this.k[0] = oa.EMPTY;
  }
  reset(e) {
    this.A.clear(), this.T.clear(), this.g.fill(null), e && (this.k.fill(null), this.m.fill(null), this.k[0] = oa.EMPTY);
  }
  record(e, t) {
    this.g[e] = t;
  }
  has(e) {
    return this.A.has(e) || this.k[e] !== null;
  }
  add(e, t) {
    this.A.add(e, t);
  }
  hasSurvivor(e) {
    return this.T.has(e);
  }
  addSurvivor(e, t) {
    this.T.add(e, t);
  }
  buildSurvivorTraces() {
    const e = this.k;
    this.S.buildSurvivorTraces(e, this.m, this.T, this.A, this.g), this.k = this.m, this.m = e;
  }
  getTraces(e) {
    const t = e.reduce((r, o) => Uf(r, this.k[o]), null);
    return t === null ? [] : Array.isArray(t) ? t : [t];
  }
}, Wx = class {
  constructor(e) {
    this.I = [], this.N = new Xx(e.programLength), this.M = new Xx(e.programLength), this.P = new h_(e);
  }
  reset() {
    this.N.reset(), this.N.add(0, 0), this.I.length = 0, this.P.reset(!0);
  }
  getNextThreadPc() {
    return this.N.getNextPc();
  }
  step(e, t, r) {
    const o = this.P.has(t);
    this.P.add(e, t);
    const a = this.N.getBadness(e) + r;
    o ? this.N.reschedule(t, a) : this.N.add(t, a);
  }
  stepToNextGeneration(e, t) {
    const r = this.P.hasSurvivor(t);
    this.P.addSurvivor(e, t);
    const o = this.N.getBadness(e);
    r ? this.M.reschedule(t, o) : this.M.add(t, o);
  }
  accept(e) {
    this.I.push(e), this.P.addSurvivor(e, e);
  }
  fail(e) {
  }
  record(e, t) {
    this.P.record(e, t);
  }
  nextGeneration() {
    this.P.buildSurvivorTraces(), this.P.reset(!1);
    const e = this.N;
    e.reset(), this.N = this.M, this.M = e;
  }
  getAcceptingTraces() {
    return this.P.getTraces(this.I);
  }
}, f_ = class {
  constructor(e) {
    this.U = [], this.G = e, this.V = u_.fromProgram(e), this.U.push(new Wx(this.V));
  }
  execute(e, t) {
    const r = this.U.pop() || new Wx(this.V);
    r.reset();
    const o = e.length;
    let a, l = -1;
    do {
      let p = r.getNextThreadPc();
      if (p === null) break;
      for (++l, a = l >= o ? null : e[l]; p !== null; ) {
        const f = this.G[p];
        switch (f.op) {
          case 0:
            a === null ? r.accept(p) : r.fail(p);
            break;
          case 2: {
            const m = f.func;
            if (m === null || m(t)) {
              r.fail(p);
              break;
            }
            r.step(p, p + 1, 0);
            break;
          }
          case 1:
            r.step(p, p + 1, f.data);
            break;
          case 5:
            if (a === null) {
              r.fail(p);
              break;
            }
            if (!(0, f.func)(a, f.data, t)) {
              r.fail(p);
              break;
            }
            r.stepToNextGeneration(p, p + 1);
            break;
          case 3: {
            const m = f.data, y = m.length;
            if (y === 0) {
              r.fail(p);
              break;
            }
            for (let v = 0; v < y; ++v) r.step(p, m[v], 0);
            break;
          }
          case 4: {
            const m = (0, f.func)(f.data, l, t);
            m != null && r.record(p, m), r.step(p, p + 1, 0);
            break;
          }
        }
        p = r.getNextThreadPc();
      }
      r.nextGeneration();
    } while (a !== null);
    const d = new d_(r.getAcceptingTraces());
    return r.reset(), this.U.push(r), d;
  }
};
function m_(n) {
  const e = new c_();
  return n(e), new f_(e.program);
}
function fn(n) {
  return (e) => e === n;
}
function Ve(n, e) {
  if (n === null || e === null) throw new Error("unescaped hyphen may not be used as a range endpoint");
  if (e < n) throw new Error("character range is in the wrong order");
  return (t) => n <= t && t <= e;
}
function g_(n) {
  return !0;
}
function Yx() {
  return !1;
}
function Li(n, e) {
  return (t) => n(t) || e(t);
}
function _a(n, e) {
  switch (e.kind) {
    case "predicate":
      return void n.test(e.value);
    case "regexp":
      return void oS(n, e.value, !1);
  }
}
function y_(n, e) {
  e.forEach((t) => {
    (function(r, o) {
      const [a, { min: l, max: d }] = o;
      if (d !== null) {
        for (let p = 0; p < l; ++p) _a(r, a);
        for (let p = l; p < d; ++p) {
          const f = r.jump([]);
          f.data.push(r.program.length), _a(r, a), f.data.push(r.program.length);
        }
      } else if (l > 0) {
        for (let f = 0; f < l - 1; ++f) _a(r, a);
        const p = r.program.length;
        _a(r, a), r.jump([p]).data.push(r.program.length);
      } else {
        const p = r.program.length, f = r.jump([]);
        f.data.push(r.program.length), _a(r, a), r.jump([p]), f.data.push(r.program.length);
      }
    })(n, t);
  });
}
function oS(n, e, t) {
  const r = n.program.length, o = n.jump([]);
  t && (o.data.push(n.program.length), n.test(() => !0), n.jump([r]));
  const a = [];
  if (e.forEach((l) => {
    o.data.push(n.program.length), y_(n, l), a.push(n.jump([]));
  }), a.forEach((l) => {
    l.data.push(n.program.length);
  }), t) {
    const l = n.program.length, d = n.jump([]);
    d.data.push(n.program.length), n.test(() => !0), n.jump([l]), d.data.push(n.program.length);
  }
}
function Yr(n, e) {
  return { success: !0, offset: n, value: e };
}
function sS(n) {
  return Yr(n, void 0);
}
function Go(n, e, t = !1) {
  return { success: !1, offset: n, expected: e, fatal: t };
}
function Xe(n) {
  return (e, t) => {
    const r = t + n.length;
    return e.slice(t, r) === n ? Yr(r, n) : Go(t, [n]);
  };
}
function Ne(n, e) {
  return (t, r) => {
    const o = n(t, r);
    return o.success ? Yr(o.offset, e(o.value)) : o;
  };
}
function uo(n, e, t, r) {
  return (o, a) => {
    const l = n(o, a);
    return l.success ? e(l.value) ? l : Go(a, t, r) : l;
  };
}
function Qe(n, e) {
  return (t, r) => {
    let o = null;
    for (const a of n) {
      const l = a(t, r);
      if (l.success || (o === null || l.offset > o.offset ? o = l : l.offset === o.offset && e === void 0 && (o.expected = o.expected.concat(l.expected)), l.fatal)) return l;
    }
    return e = e || (o == null ? void 0 : o.expected) || [], o && (o.expected = e), o || Go(r, e);
  };
}
function za(n) {
  return (e, t) => {
    const r = n(e, t);
    return r.success || r.fatal ? r : Yr(t, null);
  };
}
function ku(n) {
  return (e, t) => {
    let r = [], o = t;
    for (; ; ) {
      const a = n(e, o);
      if (!a.success) {
        if (a.fatal) return a;
        break;
      }
      if (r.push(a.value), a.offset === o) break;
      o = a.offset;
    }
    return Yr(o, r);
  };
}
function $t(n, e, t) {
  return (r, o) => {
    const a = n(r, o);
    if (!a.success) return a;
    const l = e(r, a.offset);
    return l.success ? Yr(l.offset, t(a.value, l.value)) : l;
  };
}
function Qx(n) {
  return $t(n, ku(n), (e, t) => [e].concat(t));
}
function aS(n, e) {
  return n;
}
function w_(n, e) {
  return e;
}
function pn(n, e) {
  return $t(n, e, w_);
}
function ed(n, e) {
  return $t(n, e, aS);
}
function po(n, e, t, r = !1) {
  return pn(n, r ? lS(ed(e, t)) : ed(e, t));
}
function Gh(n, e) {
  return (t, r) => n(t, r).success ? Go(r, e) : sS(r);
}
function lS(n) {
  return (e, t) => {
    const r = n(e, t);
    return r.success ? r : Go(r.offset, r.expected, !0);
  };
}
const b_ = (n, e) => n.length === e ? sS(e) : Go(e, ["end of input"]), Zx = ["Lu", "Ll", "Lt", "Lm", "Lo", "Mn", "Mc", "Me", "Nd", "Nl", "No", "Pc", "Pd", "Ps", "Pe", "Pi", "Pf", "Po", "Zs", "Zl", "Zp", "Sm", "Sc", "Sk", "So", "Cc", "Cf", "Co", "Cn"], Ds = {};
function dt(n) {
  return n.codePointAt(0);
}
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("").forEach((n, e) => {
  Ds[n] = e;
});
const cS = (n) => n === -1 || n === -2;
function Eo(n) {
  return (e) => !cS(e) && !n(e);
}
function uS(n, e) {
  return e === null ? n : (t) => n(t) && !e(t);
}
const v_ = function(n, e) {
  const t = /* @__PURE__ */ new Map();
  let r = 0;
  return n.forEach((o, a) => {
    const l = e[a];
    o !== null && o.split("|").forEach((d) => {
      const p = t.get(d), f = Ve(r, r + l - 1);
      t.set(d, p ? Li(p, f) : f);
    }), r += l;
  }), t;
}(["BasicLatin", "Latin-1Supplement", "LatinExtended-A", "LatinExtended-B", "IPAExtensions", "SpacingModifierLetters", "CombiningDiacriticalMarks", "GreekandCoptic|Greek", "Cyrillic", "CyrillicSupplement", "Armenian", "Hebrew", "Arabic", "Syriac", "ArabicSupplement", "Thaana", "NKo", "Samaritan", "Mandaic", "SyriacSupplement", "ArabicExtended-B", "ArabicExtended-A", "Devanagari", "Bengali", "Gurmukhi", "Gujarati", "Oriya", "Tamil", "Telugu", "Kannada", "Malayalam", "Sinhala", "Thai", "Lao", "Tibetan", "Myanmar", "Georgian", "HangulJamo", "Ethiopic", "EthiopicSupplement", "Cherokee", "UnifiedCanadianAboriginalSyllabics", "Ogham", "Runic", "Tagalog", "Hanunoo", "Buhid", "Tagbanwa", "Khmer", "Mongolian", "UnifiedCanadianAboriginalSyllabicsExtended", "Limbu", "TaiLe", "NewTaiLue", "KhmerSymbols", "Buginese", "TaiTham", "CombiningDiacriticalMarksExtended", "Balinese", "Sundanese", "Batak", "Lepcha", "OlChiki", "CyrillicExtended-C", "GeorgianExtended", "SundaneseSupplement", "VedicExtensions", "PhoneticExtensions", "PhoneticExtensionsSupplement", "CombiningDiacriticalMarksSupplement", "LatinExtendedAdditional", "GreekExtended", "GeneralPunctuation", "SuperscriptsandSubscripts", "CurrencySymbols", "CombiningDiacriticalMarksforSymbols|CombiningMarksforSymbols", "LetterlikeSymbols", "NumberForms", "Arrows", "MathematicalOperators", "MiscellaneousTechnical", "ControlPictures", "OpticalCharacterRecognition", "EnclosedAlphanumerics", "BoxDrawing", "BlockElements", "GeometricShapes", "MiscellaneousSymbols", "Dingbats", "MiscellaneousMathematicalSymbols-A", "SupplementalArrows-A", "BraillePatterns", "SupplementalArrows-B", "MiscellaneousMathematicalSymbols-B", "SupplementalMathematicalOperators", "MiscellaneousSymbolsandArrows", "Glagolitic", "LatinExtended-C", "Coptic", "GeorgianSupplement", "Tifinagh", "EthiopicExtended", "CyrillicExtended-A", "SupplementalPunctuation", "CJKRadicalsSupplement", "KangxiRadicals", null, "IdeographicDescriptionCharacters", "CJKSymbolsandPunctuation", "Hiragana", "Katakana", "Bopomofo", "HangulCompatibilityJamo", "Kanbun", "BopomofoExtended", "CJKStrokes", "KatakanaPhoneticExtensions", "EnclosedCJKLettersandMonths", "CJKCompatibility", "CJKUnifiedIdeographsExtensionA", "YijingHexagramSymbols", "CJKUnifiedIdeographs", "YiSyllables", "YiRadicals", "Lisu", "Vai", "CyrillicExtended-B", "Bamum", "ModifierToneLetters", "LatinExtended-D", "SylotiNagri", "CommonIndicNumberForms", "Phags-pa", "Saurashtra", "DevanagariExtended", "KayahLi", "Rejang", "HangulJamoExtended-A", "Javanese", "MyanmarExtended-B", "Cham", "MyanmarExtended-A", "TaiViet", "MeeteiMayekExtensions", "EthiopicExtended-A", "LatinExtended-E", "CherokeeSupplement", "MeeteiMayek", "HangulSyllables", "HangulJamoExtended-B", "HighSurrogates", "HighPrivateUseSurrogates", "LowSurrogates", "PrivateUseArea|PrivateUse", "CJKCompatibilityIdeographs", "AlphabeticPresentationForms", "ArabicPresentationForms-A", "VariationSelectors", "VerticalForms", "CombiningHalfMarks", "CJKCompatibilityForms", "SmallFormVariants", "ArabicPresentationForms-B", "HalfwidthandFullwidthForms", "Specials", "LinearBSyllabary", "LinearBIdeograms", "AegeanNumbers", "AncientGreekNumbers", "AncientSymbols", "PhaistosDisc", null, "Lycian", "Carian", "CopticEpactNumbers", "OldItalic", "Gothic", "OldPermic", "Ugaritic", "OldPersian", null, "Deseret", "Shavian", "Osmanya", "Osage", "Elbasan", "CaucasianAlbanian", "Vithkuqi", null, "LinearA", "LatinExtended-F", null, "CypriotSyllabary", "ImperialAramaic", "Palmyrene", "Nabataean", null, "Hatran", "Phoenician", "Lydian", null, "MeroiticHieroglyphs", "MeroiticCursive", "Kharoshthi", "OldSouthArabian", "OldNorthArabian", null, "Manichaean", "Avestan", "InscriptionalParthian", "InscriptionalPahlavi", "PsalterPahlavi", null, "OldTurkic", null, "OldHungarian", "HanifiRohingya", null, "RumiNumeralSymbols", "Yezidi", "ArabicExtended-C", "OldSogdian", "Sogdian", "OldUyghur", "Chorasmian", "Elymaic", "Brahmi", "Kaithi", "SoraSompeng", "Chakma", "Mahajani", "Sharada", "SinhalaArchaicNumbers", "Khojki", null, "Multani", "Khudawadi", "Grantha", null, "Newa", "Tirhuta", null, "Siddham", "Modi", "MongolianSupplement", "Takri", null, "Ahom", null, "Dogra", null, "WarangCiti", "DivesAkuru", null, "Nandinagari", "ZanabazarSquare", "Soyombo", "UnifiedCanadianAboriginalSyllabicsExtended-A", "PauCinHau", "DevanagariExtended-A", null, "Bhaiksuki", "Marchen", null, "MasaramGondi", "GunjalaGondi", null, "Makasar", "Kawi", null, "LisuSupplement", "TamilSupplement", "Cuneiform", "CuneiformNumbersandPunctuation", "EarlyDynasticCuneiform", null, "Cypro-Minoan", "EgyptianHieroglyphs", "EgyptianHieroglyphFormatControls", null, "AnatolianHieroglyphs", null, "BamumSupplement", "Mro", "Tangsa", "BassaVah", "PahawhHmong", null, "Medefaidrin", null, "Miao", null, "IdeographicSymbolsandPunctuation", "Tangut", "TangutComponents", "KhitanSmallScript", "TangutSupplement", null, "KanaExtended-B", "KanaSupplement", "KanaExtended-A", "SmallKanaExtension", "Nushu", null, "Duployan", "ShorthandFormatControls", null, "ZnamennyMusicalNotation", null, "ByzantineMusicalSymbols", "MusicalSymbols", "AncientGreekMusicalNotation", null, "KaktovikNumerals", "MayanNumerals", "TaiXuanJingSymbols", "CountingRodNumerals", null, "MathematicalAlphanumericSymbols", "SuttonSignWriting", null, "LatinExtended-G", "GlagoliticSupplement", "CyrillicExtended-D", null, "NyiakengPuachueHmong", null, "Toto", "Wancho", null, "NagMundari", null, "EthiopicExtended-B", "MendeKikakui", null, "Adlam", null, "IndicSiyaqNumbers", null, "OttomanSiyaqNumbers", null, "ArabicMathematicalAlphabeticSymbols", null, "MahjongTiles", "DominoTiles", "PlayingCards", "EnclosedAlphanumericSupplement", "EnclosedIdeographicSupplement", "MiscellaneousSymbolsandPictographs", "Emoticons", "OrnamentalDingbats", "TransportandMapSymbols", "AlchemicalSymbols", "GeometricShapesExtended", "SupplementalArrows-C", "SupplementalSymbolsandPictographs", "ChessSymbols", "SymbolsandPictographsExtended-A", "SymbolsforLegacyComputing", null, "CJKUnifiedIdeographsExtensionB", null, "CJKUnifiedIdeographsExtensionC", "CJKUnifiedIdeographsExtensionD", "CJKUnifiedIdeographsExtensionE", "CJKUnifiedIdeographsExtensionF", null, "CJKCompatibilityIdeographsSupplement", null, "CJKUnifiedIdeographsExtensionG", "CJKUnifiedIdeographsExtensionH", null, "Tags", null, "VariationSelectorsSupplement", null, "SupplementaryPrivateUseArea-A|PrivateUse", "SupplementaryPrivateUseArea-B|PrivateUse"], [128, 128, 128, 208, 96, 80, 112, 144, 256, 48, 96, 112, 256, 80, 48, 64, 64, 64, 32, 16, 48, 96, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 256, 160, 96, 256, 384, 32, 96, 640, 32, 96, 32, 32, 32, 32, 128, 176, 80, 80, 48, 96, 32, 32, 144, 80, 128, 64, 64, 80, 48, 16, 48, 16, 48, 128, 64, 64, 256, 256, 112, 48, 48, 48, 80, 64, 112, 256, 256, 64, 32, 160, 128, 32, 96, 256, 192, 48, 16, 256, 128, 128, 256, 256, 96, 32, 128, 48, 80, 96, 32, 128, 128, 224, 16, 16, 64, 96, 96, 48, 96, 16, 32, 48, 16, 256, 256, 6592, 64, 20992, 1168, 64, 48, 320, 96, 96, 32, 224, 48, 16, 64, 96, 32, 48, 48, 32, 96, 32, 96, 32, 96, 32, 48, 64, 80, 64, 11184, 80, 896, 128, 1024, 6400, 512, 80, 688, 16, 16, 16, 32, 32, 144, 240, 16, 128, 128, 64, 80, 64, 48, 128, 32, 64, 32, 48, 32, 48, 32, 64, 32, 80, 48, 48, 80, 48, 64, 80, 64, 384, 64, 64, 64, 32, 32, 48, 48, 32, 32, 32, 64, 32, 96, 96, 32, 32, 32, 64, 64, 32, 32, 48, 80, 80, 48, 128, 64, 288, 32, 64, 64, 48, 64, 64, 48, 32, 128, 80, 48, 80, 48, 96, 32, 80, 48, 48, 80, 128, 128, 128, 96, 160, 128, 96, 32, 80, 48, 80, 176, 80, 80, 96, 96, 64, 96, 80, 96, 16, 64, 96, 160, 112, 80, 64, 96, 80, 304, 32, 96, 80, 16, 64, 1024, 128, 208, 2624, 112, 1072, 48, 4e3, 640, 8576, 576, 48, 96, 48, 144, 688, 96, 96, 160, 64, 32, 6144, 768, 512, 128, 8816, 16, 256, 48, 64, 400, 2304, 160, 16, 4688, 208, 48, 256, 256, 80, 112, 32, 32, 96, 32, 128, 1024, 688, 1104, 256, 48, 96, 112, 80, 320, 48, 64, 464, 48, 736, 32, 224, 32, 96, 784, 80, 64, 80, 176, 256, 256, 48, 112, 96, 256, 256, 768, 80, 48, 128, 128, 128, 256, 256, 112, 144, 256, 1024, 42720, 32, 4160, 224, 5776, 7488, 3088, 544, 1504, 4944, 4192, 711760, 128, 128, 240, 65040, 65536, 65536]), cl = function(n) {
  const e = /* @__PURE__ */ new Map(), t = n.split(""), r = Zx.map(() => []);
  let o = 0, a = 0;
  for (; a < t.length; ) {
    const d = Ds[t[a]], p = (31 & d) - 2;
    let f = 1 + Ds[t[a + 1]];
    switch (32 & d ? (f += Ds[t[a + 2]] << 6, f += Ds[t[a + 3]] << 12, f += Ds[t[a + 4]] << 18, a += 5) : a += 2, p) {
      case -2: {
        let m = 0;
        for (let y = o; y < o + f; ++y)
          r[m].push(fn(y)), m = (m + 1) % 2;
        break;
      }
      case -1:
        break;
      default: {
        const m = r[p];
        f === 1 ? m.push(fn(o)) : m.push(Ve(o, o + f - 1));
        break;
      }
    }
    o += f;
  }
  const l = /* @__PURE__ */ new Map();
  return Zx.forEach((d, p) => {
    const f = r[p].reduce(Li, Yx);
    e.set(d, f);
    const m = d.charAt(0), y = l.get(m) || [];
    l.set(m, y), y.push(f);
  }), l.forEach((d, p) => {
    e.set(p, d.reduce(Li, Yx));
  }), e;
}("bfUATCYATCPAQATAXATAOATBKJTBXCTBCZPATAQAZANAZADZPAXAQAXAbgUATAYDaATAZAaAGARAXAcAaAZAaAXAMBZADATBZAMAGASAMCTACWXACGDXXADHA3DAAPDAAtCAAFDBCAADCAABCCDBCCABCAABCCDCCAABCAAFCAADDAABCAABCBADCBDBGACADCGDCAEADACAEADACAEADAAPDAARDACAEADAABCBA7DFCAABCBDBABCCAJjDBAAGADaFRZDFLZNFEZGFAZAFAZQnvBAAADFAZACADABBFADCTACABDZBCATACCBACABACAABCQBACIDiCADBCCDCAXDDCADAXAABCBDBCyDvAhaAHEJBA1CAANDAgfBAABAClBBFATFDoTAOABBaBYABAHsOAHATAHBTAHBTAHABHGaBDGDTBBKcFXCTBYATBaBHKTAcATCGfFAGJHUKJTDGBHAmiBAATAGAHGcAaAHFFBHBaAHDGBKJGCaBGATNBAcAGAHAGdHaBBmYBAAHKGABNKJGgHIFBaATCFABBHAYBGVHDFAHIFAHCFAHEBBTOBAGYHCBBTABAGKBEGXZAGFBAcBBFHHGoFAHXcAHfIAG1HAIAHAGAICHHIDHAIBGAHGGJHBTBKJTAFAGOHAIBBAGHBBGBBBGVBAGGBAGABCGDBBHAGAICHDBBIBBBIBHAGABHIABDGBBAGCHBBBKJGBYBMFaAYAGATAHABBHBIABAGFBDGBBBGVBAGGBAGBBAGBBAGBBBHABAICHBBDHBBBHCBCHABGGDBAGABGKJHBGCHATABJHBIABAGIBAGCBAGVBAGGBAGBBAGEBBHAGAICHEBAHBIABAIBHABBGABOGBHBBBKJTAYABGGAHFBAHAIBBAGHBBGBBBGVBAGGBAGBBAGEBBHAGAIAHAIAHDBBIBBBIBHABGHBIABDGBBAGCHBBBKJaAGAMFBJHAGABAGFBCGCBAGDBCGBBAGABAGBBCGBBCGCBCGLBDIBHAIBBCICBAICHABBGABFIABNKJMCaFYAaABEHAICHAGHBAGCBAGWBAGPBBHAGAHCIDBAHCBAHDBGHBBAGCBBGABBGBHBBBKJBGTAMGaAGAHAIBTAGHBAGCBAGWBAGJBAGEBBHAGAIAHAIEBAHAIBBAIBHBBGIBBFGBBAGBHBBBKJBAGBIABLHBIBGIBAGCBAGoHBGAICHDBAICBAICHAGAaABDGCIAMGGCHBBBKJMIaAGFBAHAIBBAGRBCGXBAGIBAGABBGGBCHABDICHCBAHABAIHBFKJBBIBTABLGvHAGBHGBDYAGFFAHHTAKJTBBkGBBAGABAGEBAGXBAGABAGJHAGBHIGABBGEBAFABAHGBAKJBBGDBfGAaCTOaATAaCHBaFKJMJaAHAaAHAaAHAPAQAPAQAIBGHBAGjBDHNIAHETAHBGEHKBAHjBAaHHAaFBAaBTEaDTBBkGqIBHDIAHFIAHBIBHBGAKJTFGFIBHBGDHCGAICGBIGGCHDGMHAIBHBIFHAGAIAKJICHAaBClBACABECABBDqTAFADCmIFAABAGDBBGGBAGABAGDBBGoBAGDBBGgBAGDBBGGBAGABAGDBBGOBAG4BAGDBBmCBAABBHCTIMTBCGPaJBFiVBAABBDFBBOAmrJAAaATAGQUAGZPAQABCmKBAATCLCGHBGGRHCIABIGSHBIATBBIGRHBBLGMBAGCBAHBBLGzHBIAHGIHHAIBHKTCFATCYAGAHABBKJBFMJBFTFOATDHCcAHAKJBFGiFAG0BGGEHBGhHAGABEmFBAABJGeBAHCIDHBICBDIBHAIFHCBDaABCTBKJGdBBGEBKGrBDGZBFKJMABCahGWHBIBHABBTBG0IAHAIAHGBAHAIAHAIBHHIFHJBBHAKJBFKJBFTGFATFBBHNJAHPBwHDIAGuHAIAHEIAHAIEHAIBGHBCKJTGaJHIaITBBAHBIAGdIAHDIBHBIAHCGBKJGrHAIAHBICHAIAHCIBBHTDGjIHHHIBHBBCTEKJBCGCKJGdFFTBDIBGCqBBCCTHBHHCTAHMIAHGGDHAGFHAGBIAHBGABEDrF+DMFADhFkH/gVCAADHghBAADHCHDFBBCFBBDHCHDHCHDFBBCFBBDHBACABACABACABACADHCHDNBBDHEHDHEHDHEHDEBADBCDEAZADAZCDCBADBCDEAZCDDBBDBCDBAZCDHCEZCBBDCBADBCDEAZBBAUKcEOFTBRASAPARBSAPARATHVAWAcEUATIRASATDNBTCXAPAQATKXATANATJUAcEBAcJMAFABBMFXCPAQAFAMJXCPAQABAFMBCYgBOHMJDHAJCHLBOaBCAaDCAaBDACCDBCCDAaACAaBXACEaFCAaACAaACAaACDaADACDDAGDDAaBDBCBXECADDaAXAaBDAaAMPLiCADALDMAaBBDXEaEXBaDXAaBXAaBXAaGXAaeXBaBXAaAXAae3LEAAaHPAQAPAQAaTXBaGPAQA6QBAAXAadXYanXF6EBAABYaKBUM76NBAAMV62CAAXAaIXAa1XH6uBAAXA63DAAPAQAPAQAPAQAPAQAPAQAPAQAPAQAMdarXEPAQAXePAQAPAQAPAQAPAQAPAQAXP6/DAA3CCAAPAQAPAQAPAQAPAQAPAQAPAQAPAQAPAQAPAQAPAQAPAQAX+PAQAPAQAXfPAQA3BEAAavXUaBXFamBBafBA6oBAACvDvABCCDBAFCCADDACADFFBCBgjBAADAaFADHCCADABETDMATBDlBADABEDABBG3BGFATABNHAGWBIGGBAGGBAGGBAGGBAGGBAGGBAGGBAGGBAHfTBRASARASATCRASATARASATIOATBOATARASATBRASAPAQAPAQAPAQAPAQATEFATJOBTDOATAPATMaBTCPAQAPAQAPAQAPAQAOABhaZBA6YBAABL6VDAABZaLBDUATCaAFAGALAPAQAPAQAPAQAPAQAPAQAaBPAQAPAQAPAQAPAQAOAPAQBaALIHDIBOAFEaBLCFAGATAaBBAmVBAABBHBZBFBGAOAmZBAATAFCGABEGqBAmdBAABAaBMDaJGfajBLGPaeBAMJadMHaAMOafMJamMO6/EAAm/mBAa/mUIFAFAm2RAABCa2BIGnFFTBmLEAAFATCGPKJGBBTAtGAHAJCTAHJTAFAAbFBHBmFBAALJHBTFBHZWFIZBANDBA9FADHADCAAJFAZBADGAADDBATCDABCDAPCCADBECADABADABADAADBXFCCADAGAFBDAGGHAGCHAGDHAGWIBHBIAaDHABCMFaBYAaABFGzTDBHIBGxIPHBBHTBKJBFHRGFTCGATAGBHAKJGbHHTBGWHKIBBKTAGcBCHCIAGuHAIBHDIBHBICTMBAFAKJBDTBGEHAFAGIKJGEBAGoHFIBHBIBHBBIGCHAGHHAIABBKJBBTDGPFAGFaCGAIAHAIAGxHAGAHCGBHBGEHBGAHAGABXGBFATBGKIAHBIBTBGAFBIAHABJGFBBGFBBGFBIGGBAGGBADqZAFDDIFAZBBDjPBAAGiIBHAIBHAIBTAIAHABBKJBFmjuCABLGWBDGwhDgAA9/jBAmtFAABBmpBAABlDGBLDEBEGAHAGJXAGMBAGEBAGABAGBBAGBBAmrBAAZQBPmqFAAQAPAaPG/BBG1BGaABfGLYAaCHPTGPAQATABFHPTAOBNBPAQAPAQAPAQAPAQAPAQAPAQAPAQAPAQATBPAQATDNCTCBATDOAPAQAPAQAPAQATCXAOAXCBATAYATBBDGEBAmGCAABBcABATCYATCPAQATAXATAOATBKJTBXCTBCZPATAQAZANAZADZPAXAQAXAPAQATAPAQATBGJFAGsFBGeBCGFBBGFBBGFBBGCBCYBXAZAaAYBBAaAXDaBBJcCaBBBGLBAGZBAGSBAGBBAGOBBGNBhm6BAABETCBDMsBCaIL0MDaQMBaCBAaMBCaABuasHAhBCAAGcBCGwBOHAMaBDGfMDBIGTLAGHLABEGlHEBEGdBATAGjBDGHTALEBpCnDnmNBAABBKJBFCjBDDjBDGnBHGzBKTACKBACOBACGBACBBADKBADOBADGBADBhCBAAm2EAABIGVBJGHBXFFBAFpBAFIhEBAAGFBBGABAGrBAGBBCGABBGWBATAMHGWaBMGGeBHMIBvGSBAGBBEMEGVMFBCTAGZBETAB/G3BDMBGBMPBBMtGAHCBAHBBEHDGDBAGCBAGcBBHCBDHAMIBGTIBGGcMBTAGcMCBfGHaAGbHBBDMETGBIG1BCTGGVBBMHGSBEMHGRBGTDBLMGhPBAAmIBAAB2CyBMDyBGMFGjHDBHKJhlEAAMeBAGpBAHBOABBGBhKBAAHCGcMJGABHGVHKMDTEBVGRHDTDBlGUMGBTGWBIIAHAIAG0HOTGBDMTKJHAGBHBGABIHCIAGsICHDIBHBTBcATDHABJcABBGYBGKJBFHCGjHEIAHHBAKJTDGAIBGABHGiHATBGABIHBIAGvICHIIBGDTDHDTAIAHAKJGATAGATCBAMTBKGRBAGYICHCIBHAIAHBTFHAGBHAB9GGBAGABAGDBAGOBAGJTABFGuHAICHHBEKJBFHBIBBAGHBBGBBBGVBAGGBAGBBAGEBAHBGAIBHAIDBBIBBBICBBGABFIABEGEIBBBHGBCHEhKCAAG0ICHHIBHCIAHAGDTEKJTBBATAHAGCBdGvICHFIAHAIDHBIAHBGBTAGABHKJhlCAAGuICHDBBIDHBIAHBTWGDHBBhGvICHHIBHAIAHBTCGABKKJBFTMBSGqHAIAHAIBHFIAHAGATABFKJB1GaBBHCIBHDIAHEBDKJMBTCaAGGh4CAAGrICHIIAHBTAhjBAACfDfKJMIBLGHBBGABBGHBAGBBAGXIFBAIBBBHBIAHAGAIAGAIAHATCBIKJhFBAAGHBBGmICHDBBHBIDHAGATAGAIABaGAHJGnHFIAGAHDTHHABHGAHFIBHCGtHMIAHBTCGATEBMmIBAABGTJh1DAAGIBAGkIAHGBAHFIAHAGATEBJKJMSBCTBGdBBHVBAIAHGIAHBIAHBhIBAAGGBAGBBAGlHFBCHABAHBBAHGGAHABHKJBFGFBAGBBAGfIEBAHBBAIBHAIAHAGABGKJh1EAAGSHBIBTBBGHBGAIAGMBAGhIBHEBCIBHAIAHATMKJhVBAAGABOMUaHYDaQBMTAmZOAAhlBAAruBAABATEBKmDDAAhLpAAmgBAATBBMmvQAAcPHAGFHOhp+AAmGJAAh4GCAm4IAABGGeBAKJBDTBmOBAABAKJBFGdBBHETABJGvHGTEaDFDTAaABJKJBAMGBAGUBEGShvKAACfDfMWTDhkBAAmKBAABDHAGAI2BGHDFMB/FBTAFAHABKIBBNm3fBABHmVTAABpGIhmLCAFDBAFGBAFBBAmiEAABOGABcGCBBGABNGDBHmLGAAhDkAAmqBAABEGMBCGIBGGJBBaAHBTAcDhbJBAHtBBHWBI6zBAAB761DAABJamBBa7IBHCaCIFcHHHaBHGadHDa8BU6BBAAHCaAh5BAAMTBLMTBL6WBAABIMYhGCAACZDZCZDGBADRCZDZCABACBBBCABBCBBBCDBACHDDBADABADGBADKCZDZCBBACDBBCHBACGBADZCBBACDBACEBACABCCGBADZCZDZCZDZCZDZCZDZCZDZCZDbBBCYXADYXADFCYXADYXADFCYXADYXADFCYXADYXADFCYXADYXADFCADABBKx6/HAAH2aDHxaHHAaNHAaBTEBOHEBAHOhPRAADJGADTBFDFhUDAAHGBAHQBBHGBAHBBAHEBEF9BgHAhvBAAGsBCHGFGBBKJBDGAaAh/EAAGdHABQGrHDKJBEYAhPHAAGaFAHDKJhlLAAGGBAGDBAGBBAGOBAmEDAABBMIHGBoChDhHGFABDKJBDTBhQMAAM6aAMCYAMDhLBAAMsaAMOhBDAAGDBAGaBAGBBAGABBGABAGJBAGDBAGABAGABFGABDGABAGABAGABAGCBAGBBAGABBGABAGABAGABAGABAGABAGBBAGABBGDBAGGBAGDBAGDBAGABAGJBAGQBEGCBAGEBAGQBzXBhNEAAarBD6jBAABLaOBBaOBAaOBAakBJMM6gCAAB3acBMarBDaIBGaBBNaFhZCAA66DAAZE6XLAABDaQBCaMBC62BAABD6eBAABFaLBDaABOaLBDa3BHaJBFanBHadBBaBhNBAA6TFAABLaNBBaMBCaIBGatBAaGBHaNBDaIBGaIBG6SCAABAa2BkKJhFQAAmfbKABfm5ABABFmdDAABBmBaBABNmw0BAhewAAmdIAAhhXAAmKNBABEmfBBAhQxtCcABd8fBAAh/BAAnvDAAhP4PA99/PABB99/PA");
function ek(n) {
  return n === 32 || n === 9 || n === 10 || n === 13;
}
const Lf = [fn(dt(":")), Ve(dt("A"), dt("Z")), fn(dt("_")), Ve(dt("a"), dt("z")), Ve(192, 214), Ve(216, 246), Ve(192, 214), Ve(216, 246), Ve(248, 767), Ve(880, 893), Ve(895, 8191), Ve(8204, 8205), Ve(8304, 8591), Ve(11264, 12271), Ve(12289, 55295), Ve(63744, 64975), Ve(65008, 65533), Ve(65536, 983039)].reduce(Li), tk = [Lf, fn(dt("-")), fn(dt(".")), Ve(dt("0"), dt("9")), fn(183), Ve(768, 879), Ve(8255, 8256)].reduce(Li), dS = cl.get("Nd"), x_ = Eo(dS), pS = uS(Ve(0, 1114111), [cl.get("P"), cl.get("Z"), cl.get("C")].reduce(Li)), k_ = Eo(pS);
function A_(n) {
  return n !== 10 && n !== 13 && !cS(n);
}
const C_ = { s: ek, S: Eo(ek), i: Lf, I: Eo(Lf), c: tk, C: Eo(tk), d: dS, D: x_, w: pS, W: k_ }, ru = Xe("*"), Ns = Xe("\\"), iu = Xe("{"), Bs = Xe("}"), ou = Xe("["), su = Xe("]"), qa = Xe("^"), nk = Xe("$"), rk = Xe(","), ho = Xe("-"), au = Xe("("), lu = Xe(")"), _h = Xe("."), zh = Xe("|"), cu = Xe("+"), Va = Xe("?"), S_ = Xe("-["), Xa = dt("0");
function E_(n) {
  function e(Z) {
    return new Set(Z.split("").map((ue) => dt(ue)));
  }
  function t(Z, ue) {
    const Ye = Z.codePointAt(ue);
    return Ye === void 0 ? Go(ue, ["any character"]) : Yr(ue + String.fromCodePoint(Ye).length, Ye);
  }
  const r = n.language === "xpath" ? pn(Ns, Qe([Ne(Xe("n"), () => 10), Ne(Xe("r"), () => 13), Ne(Xe("t"), () => 9), Ne(Qe([Ns, zh, _h, ho, qa, Va, ru, cu, iu, Bs, nk, au, lu, ou, su]), (Z) => dt(Z))])) : pn(Ns, Qe([Ne(Xe("n"), () => 10), Ne(Xe("r"), () => 13), Ne(Xe("t"), () => 9), Ne(Qe([Ns, zh, _h, ho, qa, Va, ru, cu, iu, Bs, au, lu, ou, su]), (Z) => dt(Z))]));
  function o(Z, ue) {
    const Ye = e(ue);
    return $t(Xe(Z), za(uo(t, (tt) => Ye.has(tt), ue.split(""))), (tt, _i) => function(Un) {
      const N = cl.get(Un);
      if (N == null) throw new Error(Un + " is not a valid unicode category");
      return N;
    }(_i === null ? tt : tt + String.fromCodePoint(_i)));
  }
  const a = Qe([o("L", "ultmo"), o("M", "nce"), o("N", "dlo"), o("P", "cdseifo"), o("Z", "slp"), o("S", "mcko"), o("C", "cfon")]), l = [Ve(dt("a"), dt("z")), Ve(dt("A"), dt("Z")), Ve(dt("0"), dt("9")), fn(45)].reduce(Li), d = Qe([a, Ne(pn(Xe("Is"), /* @__PURE__ */ function(Z) {
    return (ue, Ye) => {
      const tt = Z(ue, Ye);
      return tt.success ? Yr(tt.offset, ue.slice(Ye, tt.offset)) : tt;
    };
  }(Qx(uo(t, l, ["block identifier"])))), (Z) => function(ue, Ye) {
    const tt = v_.get(ue);
    if (tt === void 0) {
      if (Ye) return g_;
      throw new Error(`The unicode block identifier "${ue}" is not known.`);
    }
    return tt;
  }(Z, n.language !== "xpath"))]), p = po(Xe("\\p{"), d, Bs, !0), f = Ne(po(Xe("\\P{"), d, Bs, !0), Eo), m = pn(Ns, Ne(Qe("sSiIcCdDwW".split("").map((Z) => Xe(Z))), (Z) => C_[Z])), y = Ne(_h, () => A_), v = Qe([m, p, f]), k = e("\\[]"), A = Qe([r, uo(t, (Z) => !k.has(Z), ["unescaped character"])]), S = Qe([Ne(ho, () => null), A]), B = $t(S, pn(ho, S), Ve);
  function O(Z, ue) {
    return [Z].concat(ue || []);
  }
  const L = Ne(/* @__PURE__ */ function(Z) {
    return (ue, Ye) => {
      const tt = Z(ue, Ye);
      return tt.success ? Yr(Ye, tt.value) : tt;
    };
  }(Qe([su, S_])), () => null), G = dt("-"), Y = Qe([Ne(ed(ed(ho, Gh(ou, ["not ["])), L), () => G), pn(Gh(ho, ["not -"]), A)]), z = Qe([$t(Ne(Y, fn), Qe([function(Z, ue) {
    return z(Z, ue);
  }, L]), O), $t(Qe([B, v]), Qe([ee, L]), O)]), M = Qe([$t(Ne(A, fn), Qe([z, L]), O), $t(Qe([B, v]), Qe([ee, L]), O)]);
  function ee(Z, ue) {
    return M(Z, ue);
  }
  const U = Ne(M, (Z) => Z.reduce(Li)), K = Ne(pn(qa, U), Eo), Q = $t(Qe([pn(Gh(qa, ["not ^"]), U), K]), za(pn(ho, function(Z, ue) {
    return H(Z, ue);
  })), uS), H = po(ou, Q, su, !0), j = n.language === "xpath" ? Qe([Ne(r, fn), v, H, y, Ne(qa, () => (Z) => Z === -1), Ne(nk, () => (Z) => Z === -2)]) : Qe([Ne(r, fn), v, H, y]), ce = n.language === "xpath" ? e(".\\?*+{}()|^$[]") : e(".\\?*+{}()|[]"), I = uo(t, (Z) => !ce.has(Z), ["NormalChar"]), Le = Ne(pn(Ns, $t(Ne(uo(t, Ve(dt("1"), dt("9")), ["digit"]), (Z) => Z - Xa), ku(Ne(uo(t, Ve(Xa, dt("9")), ["digit"]), (Z) => Z - Xa)), (Z, ue) => {
    ue.reduce((Ye, tt) => 10 * Ye + tt, Z);
  })), (Z) => {
    throw new Error("Backreferences in XPath patterns are not yet implemented.");
  }), Be = n.language === "xpath" ? Qe([Ne(I, (Z) => ({ kind: "predicate", value: fn(Z) })), Ne(j, (Z) => ({ kind: "predicate", value: Z })), Ne(po(au, pn(za(Xe("?:")), or), lu, !0), (Z) => ({ kind: "regexp", value: Z })), Le]) : Qe([Ne(I, (Z) => ({ kind: "predicate", value: fn(Z) })), Ne(j, (Z) => ({ kind: "predicate", value: Z })), Ne(po(au, or, lu, !0), (Z) => ({ kind: "regexp", value: Z }))]), Ge = Ne(Qx(Ne(uo(t, Ve(Xa, dt("9")), ["digit"]), (Z) => Z - Xa)), (Z) => Z.reduce((ue, Ye) => 10 * ue + Ye)), se = Qe([$t(Ge, pn(rk, Ge), (Z, ue) => {
    if (ue < Z) throw new Error("quantifier range is in the wrong order");
    return { min: Z, max: ue };
  }), $t(Ge, rk, (Z) => ({ min: Z, max: null })), Ne(Ge, (Z) => ({ min: Z, max: Z }))]), ht = n.language === "xpath" ? $t(Qe([Ne(Va, () => ({ min: 0, max: 1 })), Ne(ru, () => ({ min: 0, max: null })), Ne(cu, () => ({ min: 1, max: null })), po(iu, se, Bs, !0)]), za(Va), (Z, ue) => Z) : Qe([Ne(Va, () => ({ min: 0, max: 1 })), Ne(ru, () => ({ min: 0, max: null })), Ne(cu, () => ({ min: 1, max: null })), po(iu, se, Bs, !0)]), kt = ku($t(Be, Ne(za(ht), (Z) => Z === null ? { min: 1, max: 1 } : Z), (Z, ue) => [Z, ue])), ft = $t(kt, ku(pn(zh, lS(kt))), (Z, ue) => [Z].concat(ue));
  function or(Z, ue) {
    return ft(Z, ue);
  }
  const Qt = function(Z) {
    return $t(Z, b_, aS);
  }(ft);
  return function(Z) {
    let ue;
    try {
      ue = Qt(Z, 0);
    } catch (Ye) {
      throw new Error(`Error parsing pattern "${Z}": ${Ye instanceof Error ? Ye.message : Ye}`);
    }
    return ue.success ? ue.value : function(Ye, tt, _i) {
      const Un = _i.map((N) => `"${N}"`);
      throw new Error(`Error parsing pattern "${Ye}" at offset ${tt}: expected ${Un.length > 1 ? "one of " + Un.join(", ") : Un[0]} but found "${Ye.slice(tt, tt + 1)}"`);
    }(Z, ue.offset, ue.expected);
  };
}
function ik(n) {
  return [...n].map((e) => e.codePointAt(0));
}
function T_(n, e = { language: "xsd" }) {
  const t = E_(e)(n), r = m_((o) => {
    oS(o, t, e.language === "xpath"), o.accept();
  });
  return function(o) {
    const a = e.language === "xpath" ? [-1, ...ik(o), -2] : ik(o);
    return r.execute(a).success;
  };
}
const N_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compile: T_
}, Symbol.toStringTag, { value: "Module" }));
function Mr(n, e) {
  return { success: !0, offset: n, value: e };
}
function jn(n) {
  return Mr(n, void 0);
}
function En(n, e, t = !1) {
  return { success: !1, offset: n, expected: e, fatal: t };
}
function B_(n) {
  return (e, t) => {
    const r = t + n.length;
    return e.slice(t, r) === n ? Mr(r, n) : En(t, [n]);
  };
}
function hS(n) {
  return n > 65535 ? 2 : 1;
}
function fS(n, e) {
  return (t, r) => {
    const o = t.codePointAt(r);
    return o !== void 0 && n(o) ? jn(r + hS(o)) : En(r, e);
  };
}
function I_(n, e) {
  return (t, r) => {
    const o = r;
    for (; ; ) {
      const a = t.codePointAt(r);
      if (a === void 0 || !n(a)) break;
      r += a > 65535 ? 2 : 1;
    }
    return e !== void 0 && r === o ? En(r, e) : jn(r);
  };
}
function M_(n, e, t) {
  return fS((r) => n <= r && r <= e, t || [`${String.fromCodePoint(n)}-${String.fromCodePoint(e)}`]);
}
function O_(n) {
  return (e, t) => {
    let r = n;
    for (; r > 0; ) {
      const o = e.codePointAt(t);
      if (o === void 0) return En(t, ["any character"]);
      t += hS(o), r -= 1;
    }
    return jn(t);
  };
}
function tg(n, e) {
  return (t, r) => {
    const o = n(t, r);
    return o.success ? Mr(o.offset, e(o.value)) : o;
  };
}
function D_(n) {
  return tg(n, () => {
  });
}
function R_(n, e, t, r) {
  return (o, a) => {
    const l = n(o, a);
    return l.success ? e(l.value) ? l : En(a, t, r) : l;
  };
}
function F_(n, e) {
  return (t, r) => {
    let o = null;
    for (const a of n) {
      const l = a(t, r);
      if (l.success || (o === null || l.offset > o.offset ? o = l : l.offset === o.offset && e === void 0 && (o.expected = o.expected.concat(l.expected)), l.fatal)) return l;
    }
    return e = e || (o == null ? void 0 : o.expected) || [], o && (o.expected = e), o || En(r, e);
  };
}
function P_(n) {
  return (e, t) => {
    const r = n(e, t);
    return r.success || r.fatal ? r : Mr(t, null);
  };
}
function mS(n) {
  return (e, t) => {
    let r = [], o = t;
    for (; ; ) {
      const a = n(e, o);
      if (!a.success) {
        if (a.fatal) return a;
        break;
      }
      if (r.push(a.value), a.offset === o) break;
      o = a.offset;
    }
    return Mr(o, r);
  };
}
function gS(n) {
  return (e, t) => {
    let r = t;
    for (; ; ) {
      const o = n(e, r);
      if (!o.success) {
        if (o.fatal) return o;
        break;
      }
      if (o.offset === r) break;
      r = o.offset;
    }
    return jn(r);
  };
}
function $_(n) {
  return tg(n, (e) => e.filter((t) => t !== void 0));
}
function ga(n, e, t) {
  return (r, o) => {
    const a = n(r, o);
    if (!a.success) return a;
    const l = e(r, a.offset);
    return l.success ? Mr(l.offset, t(a.value, l.value)) : l;
  };
}
function j_(...n) {
  return (e, t) => {
    const r = [];
    for (const o of n) {
      const a = o(e, t);
      if (!a.success) return a;
      t = a.offset, r.push(a.value);
    }
    return Mr(t, r);
  };
}
function U_(...n) {
  return (e, t) => {
    for (const r of n) {
      const o = r(e, t);
      if (!o.success) return o;
      t = o.offset;
    }
    return jn(t);
  };
}
function L_(n) {
  return ga(n, mS(n), (e, t) => [e].concat(t));
}
function ng(n, e) {
  return n;
}
function rg(n, e) {
  return e;
}
function H_(n) {
  return ga(n, gS(n), rg);
}
function ig(n, e) {
  return ga(n, e, rg);
}
function Hf(n, e) {
  return ga(n, e, ng);
}
function G_(n, e, t, r = !1) {
  return ig(n, r ? wS(Hf(e, t)) : Hf(e, t));
}
function __(n) {
  return (e, t) => {
    const r = n(e, t);
    return r.success ? Mr(r.offset, e.slice(t, r.offset)) : r;
  };
}
function z_(n) {
  return (e, t) => {
    const r = n(e, t);
    return r.success ? Mr(t, r.value) : r;
  };
}
function yS(n, e) {
  return (t, r) => n(t, r).success ? En(r, e) : jn(r);
}
function q_(n, e, t) {
  return ig(yS(e, t), n);
}
function V_(n, e, t = 0, r = []) {
  return (o, a) => {
    const l = o.codePointAt(a + t);
    if (l === void 0) return En(a, r);
    const d = n[l];
    return d === void 0 ? e === void 0 ? En(a, r) : e(o, a) : d(o, a);
  };
}
function wS(n) {
  return (e, t) => {
    const r = n(e, t);
    return r.success ? r : En(r.offset, r.expected, !0);
  };
}
const X_ = (n, e) => e === 0 ? jn(e) : En(e, ["start of input"]), og = (n, e) => n.length === e ? jn(e) : En(e, ["end of input"]);
function J_(n) {
  return ga(n, og, ng);
}
function sg(n) {
  const e = [];
  let t = n.next();
  for (; !t.done; ) e.push(t.value), t = n.next();
  return [e, t.value];
}
function K_(n) {
  return function* (e, t) {
    const r = n(e, t);
    return r.success && (yield r.value), r;
  };
}
function W_(n, e) {
  return function* (t, r) {
    const o = yield* n(t, r);
    return o.success ? yield* e(t, o.offset) : o;
  };
}
function Y_(n) {
  return function* (e, t) {
    const r = n(e, t);
    let o = r.next();
    for (; !o.done; ) {
      const a = o.value;
      a !== void 0 && (yield a), o = r.next();
    }
    return o.value;
  };
}
function Q_(n) {
  return function* (e, t) {
    for (; ; ) {
      const [r, o] = sg(n(e, t));
      if (!o.success) return o.fatal ? o : jn(t);
      if (yield* r, t === o.offset) return jn(t);
      t = o.offset;
    }
  };
}
function Z_(n) {
  return function* (e, t) {
    const [r, o] = sg(n(e, t));
    return o.success ? (yield* r, o) : o.fatal ? o : jn(t);
  };
}
function ez(n) {
  return function* (e, t) {
    const r = yield* n(e, t);
    return r.success ? og(e, r.offset) : r;
  };
}
const tz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  codepoint: fS,
  codepoints: I_,
  collect: sg,
  complete: J_,
  consume: D_,
  cut: wS,
  delimited: G_,
  dispatch: V_,
  end: og,
  error: En,
  except: q_,
  filter: R_,
  filterUndefined: $_,
  first: ng,
  followed: Hf,
  map: tg,
  not: yS,
  ok: jn,
  okWithValue: Mr,
  optional: P_,
  or: F_,
  peek: z_,
  plus: L_,
  plusConsumed: H_,
  preceded: ig,
  range: M_,
  recognize: __,
  second: rg,
  sequence: j_,
  sequenceConsumed: U_,
  skipChars: O_,
  star: mS,
  starConsumed: gS,
  start: X_,
  streaming: K_,
  streamingComplete: ez,
  streamingFilterUndefined: Y_,
  streamingOptional: Z_,
  streamingStar: Q_,
  streamingThen: W_,
  then: ga,
  token: B_
}, Symbol.toStringTag, { value: "Module" })), We = (function(n, e) {
  const t = "3.33.2", r = {};
  function o(i, s) {
    if (!(i !== "0" && i !== "-0" || s !== "0" && s !== "-0")) return 0;
    var c = /(?:\+|(-))?(\d+)?(?:\.(\d+))?/;
    i = c.exec(i + "");
    var u = c.exec(s + ""), h = !i[1];
    const g = !u[1];
    return s = (i[2] || "").replace(/^0*/, ""), c = (u[2] || "").replace(/^0*/, ""), i = i[3] || "", u = u[3] || "", h && !g ? 1 : !h && g ? -1 : (h = h && g, s.length > c.length ? h ? 1 : -1 : s.length < c.length ? h ? -1 : 1 : s > c ? h ? 1 : -1 : s < c ? h ? -1 : 1 : (s = Math.max(i.length, u.length), c = i.padEnd(s, "0"), s = u.padEnd(s, "0"), c > s ? h ? 1 : -1 : c < s ? h ? -1 : 1 : 0));
  }
  function a(i, s) {
    return i = i.toString(), -1 < i.indexOf(".") && s === 0 ? !1 : (i = /^[-+]?0*([1-9]\d*)?(?:\.((?:\d*[1-9])*)0*)?$/.exec(i), i[2] ? i[2].length <= s : !0);
  }
  function l() {
    return function(i, s) {
      return 1 > o(i, s);
    };
  }
  function d() {
    return function(i, s) {
      return 0 > o(i, s);
    };
  }
  function p() {
    return function(i, s) {
      return -1 < o(i, s);
    };
  }
  function f() {
    return function(i, s) {
      return 0 < o(i, s);
    };
  }
  function m(i, s) {
    switch (s) {
      case "required":
        return /(Z)|([+-])([01]\d):([0-5]\d)$/.test(i.toString());
      case "prohibited":
        return !/(Z)|([+-])([01]\d):([0-5]\d)$/.test(i.toString());
      case "optional":
        return !0;
    }
  }
  function y(i) {
    switch (i) {
      case 1:
      case 0:
      case 6:
      case 3:
        return {};
      case 4:
        return { ka: a, wa: l(), nc: d(), xa: p(), oc: f() };
      case 18:
        return {};
      case 9:
      case 8:
      case 7:
      case 11:
      case 12:
      case 13:
      case 15:
      case 14:
        return { Ba: m };
      case 22:
      case 21:
      case 20:
      case 23:
      case 44:
        return {};
      default:
        return null;
    }
  }
  var v = {}, k = {};
  function A(i) {
    return /^([+-]?(\d*(\.\d*)?([eE][+-]?\d*)?|INF)|NaN)$/.test(i);
  }
  function S(i) {
    return /^[_:A-Za-z][-._:A-Za-z0-9]*$/.test(i);
  }
  function B(i) {
    return S(i) && /^[_A-Za-z]([-._A-Za-z0-9])*$/.test(i);
  }
  function O(i) {
    return i = i.split(":"), i.length === 1 ? B(i[0]) : i.length !== 2 ? !1 : B(i[0]) && B(i[1]);
  }
  function L(i) {
    return !/[\u0009\u000A\u000D]/.test(i);
  }
  function G(i) {
    return B(i);
  }
  const Y = /* @__PURE__ */ new Map([
    [45, function() {
      return !0;
    }],
    [46, function() {
      return !0;
    }],
    [1, function() {
      return !0;
    }],
    [0, function(i) {
      return /^(0|1|true|false)$/.test(i);
    }],
    [6, function(i) {
      return A(i);
    }],
    [3, A],
    [4, function(i) {
      return /^[+-]?\d*(\.\d*)?$/.test(i);
    }],
    [18, function(i) {
      return /^(-)?P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+(\.\d*)?S)?)?$/.test(i);
    }],
    [9, function(i) {
      return /^-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?|(24:00:00(\.0+)?))(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(i);
    }],
    [8, function(i) {
      return /^(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?|(24:00:00(\.0+)?))(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(i);
    }],
    [7, function(i) {
      return /^-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(i);
    }],
    [11, function(i) {
      return /^-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(i);
    }],
    [12, function(i) {
      return /^-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(i);
    }],
    [13, function(i) {
      return /^--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(i);
    }],
    [15, function(i) {
      return /^---(0[1-9]|[12][0-9]|3[01])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(i);
    }],
    [14, function(i) {
      return /^--(0[1-9]|1[0-2])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(i);
    }],
    [22, function(i) {
      return /^([0-9A-Fa-f]{2})*$/.test(i);
    }],
    [21, function(i) {
      return new RegExp(/^((([A-Za-z0-9+/] ?){4})*((([A-Za-z0-9+/] ?){3}[A-Za-z0-9+/])|(([A-Za-z0-9+/] ?){2}[AEIMQUYcgkosw048] ?=)|(([A-Za-z0-9+/] ?)[AQgw] ?= ?=)))?$/).test(i);
    }],
    [20, function() {
      return !0;
    }],
    [44, O],
    [48, L],
    [52, function(i) {
      return L(i) && !/^ | {2,}| $/.test(i);
    }],
    [51, function(i) {
      return /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/.test(i);
    }],
    [50, function(i) {
      return /^[-._:A-Za-z0-9]+$/.test(i);
    }],
    [25, S],
    [23, O],
    [24, B],
    [42, G],
    [41, G],
    [26, function(i) {
      return B(i);
    }],
    [5, function(i) {
      return /^[+-]?\d+$/.test(i);
    }],
    [16, function(i) {
      return /^-?P[0-9]+(Y([0-9]+M)?|M)$/.test(i);
    }],
    [17, function(i) {
      return /^-?P([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+(\.[0-9]+)?S)?)?$/.test(i);
    }]
  ]);
  var z = /* @__PURE__ */ Object.create(null);
  [
    { C: 0, name: 59 },
    { C: 0, name: 46, parent: 59, K: { whiteSpace: "preserve" } },
    { C: 0, name: 19, parent: 46 },
    { C: 0, name: 1, parent: 46 },
    { C: 0, name: 0, parent: 46, K: { whiteSpace: "collapse" } },
    { C: 0, name: 4, parent: 46, K: { whiteSpace: "collapse" } },
    { C: 0, name: 6, parent: 46, K: { whiteSpace: "collapse" } },
    { C: 0, name: 3, parent: 46, K: { whiteSpace: "collapse" } },
    { C: 0, name: 18, parent: 46, K: { whiteSpace: "collapse" } },
    { C: 0, name: 9, parent: 46, K: { Ba: "optional", whiteSpace: "collapse" } },
    { C: 0, name: 8, parent: 46, K: { Ba: "optional", whiteSpace: "collapse" } },
    {
      C: 0,
      name: 7,
      parent: 46,
      K: { Ba: "optional", whiteSpace: "collapse" }
    },
    { C: 0, name: 11, parent: 46, K: { Ba: "optional", whiteSpace: "collapse" } },
    { C: 0, name: 12, parent: 46, K: { Ba: "optional", whiteSpace: "collapse" } },
    { C: 0, name: 13, parent: 46, K: { Ba: "optional", whiteSpace: "collapse" } },
    { C: 0, name: 15, parent: 46, K: { Ba: "optional", whiteSpace: "collapse" } },
    { C: 0, name: 14, parent: 46, K: { Ba: "optional", whiteSpace: "collapse" } },
    { C: 0, name: 22, parent: 46, K: { whiteSpace: "collapse" } },
    { C: 0, name: 21, parent: 46, K: { whiteSpace: "collapse" } },
    { C: 0, name: 20, parent: 46, K: { whiteSpace: "collapse" } },
    { C: 0, name: 23, parent: 46, K: { whiteSpace: "collapse" } },
    { C: 0, name: 44, parent: 46, K: { whiteSpace: "collapse" } },
    { C: 1, name: 10, S: 9, K: { whiteSpace: "collapse", Ba: "required" } },
    { C: 1, name: 48, S: 1, K: { whiteSpace: "replace" } },
    { C: 1, name: 52, S: 48, K: { whiteSpace: "collapse" } },
    { C: 1, name: 51, S: 52, K: { whiteSpace: "collapse" } },
    { C: 1, name: 50, S: 52, K: { whiteSpace: "collapse" } },
    { C: 2, name: 49, type: 50, K: { minLength: 1, whiteSpace: "collapse" } },
    { C: 1, name: 25, S: 52, K: { whiteSpace: "collapse" } },
    { C: 1, name: 24, S: 25, K: { whiteSpace: "collapse" } },
    {
      C: 1,
      name: 42,
      S: 24,
      K: { whiteSpace: "collapse" }
    },
    { C: 1, name: 41, S: 24, K: { whiteSpace: "collapse" } },
    { C: 2, name: 43, type: 41, K: { minLength: 1, whiteSpace: "collapse" } },
    { C: 1, name: 26, S: 24, K: { whiteSpace: "collapse" } },
    { C: 2, name: 40, type: 26, K: { minLength: 1, whiteSpace: "collapse" } },
    { C: 0, name: 5, parent: 4, K: { ka: 0, whiteSpace: "collapse" } },
    { C: 1, name: 27, S: 5, K: { ka: 0, wa: "0", whiteSpace: "collapse" } },
    { C: 1, name: 28, S: 27, K: { ka: 0, wa: "-1", whiteSpace: "collapse" } },
    { C: 1, name: 31, S: 5, K: { ka: 0, wa: "9223372036854775807", xa: "-9223372036854775808", whiteSpace: "collapse" } },
    { C: 1, name: 32, S: 31, K: { ka: 0, wa: "2147483647", xa: "-2147483648", whiteSpace: "collapse" } },
    { C: 1, name: 33, S: 32, K: { ka: 0, wa: "32767", xa: "-32768", whiteSpace: "collapse" } },
    { C: 1, name: 34, S: 33, K: { ka: 0, wa: "127", xa: "-128", whiteSpace: "collapse" } },
    { C: 1, name: 30, S: 5, K: { ka: 0, xa: "0", whiteSpace: "collapse" } },
    { C: 1, name: 36, S: 30, K: { ka: 0, wa: "18446744073709551615", xa: "0", whiteSpace: "collapse" } },
    { C: 1, name: 35, S: 36, K: { ka: 0, wa: "4294967295", xa: "0", whiteSpace: "collapse" } },
    { C: 1, name: 38, S: 35, K: { ka: 0, wa: "65535", xa: "0", whiteSpace: "collapse" } },
    { C: 1, name: 37, S: 38, K: { ka: 0, wa: "255", xa: "0", whiteSpace: "collapse" } },
    { C: 1, name: 29, S: 30, K: { ka: 0, xa: "1", whiteSpace: "collapse" } },
    { C: 1, name: 16, S: 18, K: { whiteSpace: "collapse" } },
    { C: 1, name: 17, S: 18, K: { whiteSpace: "collapse" } },
    { C: 1, name: 60, S: 59 },
    { C: 3, name: 39, Ca: [] },
    { C: 1, name: 61, S: 60 },
    { C: 1, name: 62, S: 60 },
    { C: 0, name: 53, parent: 59 },
    { C: 1, name: 54, S: 53 },
    { C: 1, name: 58, S: 53 },
    { C: 1, name: 47, S: 53 },
    { C: 1, name: 56, S: 53 },
    { C: 1, name: 57, S: 53 },
    { C: 1, name: 55, S: 53 },
    { C: 3, name: 2, Ca: [4, 5, 6, 3] },
    { C: 3, name: 63, Ca: [] }
  ].forEach((i) => {
    const s = i.name, c = i.K || {};
    switch (i.C) {
      case 0:
        i = i.parent ? z[i.parent] : null;
        var u = Y.get(s) || null;
        z[s] = { C: 0, type: s, Ka: c, parent: i, gb: u, Oa: y(s), Ca: [] };
        break;
      case 1:
        i = z[i.S], u = Y.get(s) || null, z[s] = { C: 1, type: s, Ka: c, parent: i, gb: u, Oa: i.Oa, Ca: [] };
        break;
      case 2:
        z[s] = { C: 2, type: s, Ka: c, parent: z[i.type], gb: null, Oa: v, Ca: [] };
        break;
      case 3:
        i = i.Ca.map((h) => z[h]), z[s] = { C: 3, type: s, Ka: c, parent: null, gb: null, Oa: k, Ca: i };
    }
  });
  function M(i, s) {
    if (!z[s]) throw Error("Unknown type");
    return { type: s, value: i };
  }
  var ee = M(!0, 0), U = M(!1, 0), K = (i = "A wrong argument type was specified in a function call.") => Error(`FORG0006: ${i}`), Q = class {
    constructor(i, s) {
      this.done = i, this.value = s;
    }
  }, H = new Q(!0);
  function j(i) {
    return new Q(!1, i);
  }
  function ce(i, s) {
    if (s.C === 3) return !!s.Ca.find((c) => ce(i, c));
    for (; i; ) {
      if (i.type === s.type) return !0;
      if (i.C === 3) return !!i.Ca.find((c) => I(c.type, s.type));
      i = i.parent;
    }
    return !1;
  }
  function I(i, s) {
    return i === s ? !0 : ce(z[i], z[s]);
  }
  var Le = class {
    constructor(i) {
      this.o = N, this.h = i;
      let s = -1;
      this.value = { next: () => (s++, s >= i.length ? H : j(i[s])) };
    }
    hb() {
      return this;
    }
    filter(i) {
      let s = -1;
      return this.o.create({ next: () => {
        for (s++; s < this.h.length && !i(this.h[s], s, this); ) s++;
        return s >= this.h.length ? H : j(this.h[s]);
      } });
    }
    first() {
      return this.h[0];
    }
    O() {
      return this.h;
    }
    fa() {
      if (I(this.h[0].type, 53)) return !0;
      throw K("Cannot determine the effective boolean value of a sequence with a length higher than one.");
    }
    Pa() {
      return this.h.length;
    }
    F() {
      return !1;
    }
    oa() {
      return !1;
    }
    map(i) {
      let s = -1;
      return this.o.create({ next: () => ++s >= this.h.length ? H : j(i(this.h[s], s, this)) }, this.h.length);
    }
    N(i) {
      return i(this.h);
    }
    X(i) {
      return i.multiple ? i.multiple(this) : i.default(this);
    }
  }, Be = class {
    constructor() {
      this.value = { next: () => H };
    }
    hb() {
      return this;
    }
    filter() {
      return this;
    }
    first() {
      return null;
    }
    O() {
      return [];
    }
    fa() {
      return !1;
    }
    Pa() {
      return 0;
    }
    F() {
      return !0;
    }
    oa() {
      return !1;
    }
    map() {
      return this;
    }
    N(i) {
      return i([]);
    }
    X(i) {
      return i.empty ? i.empty(this) : i.default(this);
    }
  }, Ge = class {
    constructor(i, s) {
      this.type = i, this.value = s;
    }
  };
  const se = {
    0: "xs:boolean",
    1: "xs:string",
    2: "xs:numeric",
    3: "xs:double",
    4: "xs:decimal",
    5: "xs:integer",
    6: "xs:float",
    7: "xs:date",
    8: "xs:time",
    9: "xs:dateTime",
    10: "xs:dateTimeStamp",
    11: "xs:gYearMonth",
    12: "xs:gYear",
    13: "xs:gMonthDay",
    14: "xs:gMonth",
    15: "xs:gDay",
    16: "xs:yearMonthDuration",
    17: "xs:dayTimeDuration",
    18: "xs:duration",
    19: "xs:untypedAtomic",
    20: "xs:anyURI",
    21: "xs:base64Binary",
    22: "xs:hexBinary",
    23: "xs:QName",
    24: "xs:NCName",
    25: "xs:Name",
    26: "xs:ENTITY",
    27: "xs:nonPositiveInteger",
    28: "xs:negativeInteger",
    29: "xs:positiveInteger",
    30: "xs:nonNegativeInteger",
    31: "xs:long",
    32: "xs:int",
    33: "xs:short",
    34: "xs:byte",
    35: "xs:unsignedInt",
    36: "xs:unsignedLong",
    37: "xs:unsignedByte",
    38: "xs:unsignedShort",
    39: "xs:error",
    40: "xs:ENTITIES",
    41: "xs:IDREF",
    42: "xs:ID",
    43: "xs:IDREFS",
    44: "xs:NOTATION",
    45: "xs:anySimpleType",
    46: "xs:anyAtomicType",
    47: "attribute()",
    48: "xs:normalizedString",
    49: "xs:NMTOKENS",
    50: "xs:NMTOKEN",
    51: "xs:language",
    52: "xs:token",
    53: "node()",
    54: "element()",
    55: "document-node()",
    56: "text()",
    57: "processing-instruction()",
    58: "comment()",
    59: "item()",
    60: "function(*)",
    61: "map(*)",
    62: "array(*)",
    63: "none"
  }, ht = {
    "xs:boolean": 0,
    "xs:string": 1,
    "xs:numeric": 2,
    "xs:double": 3,
    "xs:decimal": 4,
    "xs:integer": 5,
    "xs:float": 6,
    "xs:date": 7,
    "xs:time": 8,
    "xs:dateTime": 9,
    "xs:dateTimeStamp": 10,
    "xs:gYearMonth": 11,
    "xs:gYear": 12,
    "xs:gMonthDay": 13,
    "xs:gMonth": 14,
    "xs:gDay": 15,
    "xs:yearMonthDuration": 16,
    "xs:dayTimeDuration": 17,
    "xs:duration": 18,
    "xs:untypedAtomic": 19,
    "xs:anyURI": 20,
    "xs:base64Binary": 21,
    "xs:hexBinary": 22,
    "xs:QName": 23,
    "xs:NCName": 24,
    "xs:Name": 25,
    "xs:ENTITY": 26,
    "xs:nonPositiveInteger": 27,
    "xs:negativeInteger": 28,
    "xs:positiveInteger": 29,
    "xs:nonNegativeInteger": 30,
    "xs:long": 31,
    "xs:int": 32,
    "xs:short": 33,
    "xs:byte": 34,
    "xs:unsignedInt": 35,
    "xs:unsignedLong": 36,
    "xs:unsignedByte": 37,
    "xs:unsignedShort": 38,
    "xs:error": 39,
    "xs:ENTITIES": 40,
    "xs:IDREF": 41,
    "xs:ID": 42,
    "xs:IDREFS": 43,
    "xs:NOTATION": 44,
    "xs:anySimpleType": 45,
    "xs:anyAtomicType": 46,
    "attribute()": 47,
    "xs:normalizedString": 48,
    "xs:NMTOKENS": 49,
    "xs:NMTOKEN": 50,
    "xs:language": 51,
    "xs:token": 52,
    "node()": 53,
    "element()": 54,
    "document-node()": 55,
    "text()": 56,
    "processing-instruction()": 57,
    "comment()": 58,
    "item()": 59,
    "function(*)": 60,
    "map(*)": 61,
    "array(*)": 62
  };
  function kt(i) {
    return i.g === 2 ? se[i.type] + "*" : i.g === 1 ? se[i.type] + "+" : i.g === 0 ? se[i.type] + "?" : se[i.type];
  }
  function ft(i) {
    if (i === "none") throw Error('XPST0051: The type "none" could not be found');
    if (!i.startsWith("xs:") && 0 <= i.indexOf(":")) throw Error(`XPST0081: Invalid prefix for input ${i}`);
    const s = ht[i];
    if (s === void 0) throw Error(`XPST0051: The type "${i}" could not be found`);
    return s;
  }
  function or(i) {
    switch (i[i.length - 1]) {
      case "*":
        return { type: ft(i.substr(0, i.length - 1)), g: 2 };
      case "?":
        return { type: ft(i.substr(0, i.length - 1)), g: 0 };
      case "+":
        return { type: ft(i.substr(0, i.length - 1)), g: 1 };
      default:
        return { type: ft(i), g: 3 };
    }
  }
  function Qt(i) {
    switch (i) {
      case "*":
        return 2;
      case "?":
        return 0;
      case "+":
        return 1;
      default:
        return 3;
    }
  }
  function Z(i) {
    const s = i.value;
    if (I(i.type, 53)) return !0;
    if (I(i.type, 0)) return s;
    if (I(i.type, 1) || I(i.type, 20) || I(i.type, 19)) return s.length !== 0;
    if (I(i.type, 2)) return !isNaN(s) && s !== 0;
    throw K(`Cannot determine the effective boolean value of a value with the type ${se[i.type]}`);
  }
  function ue(i, s = 0) {
    i.h = s;
  }
  var Ye = class {
    constructor(i, s = null) {
      this.D = N, this.value = { next: (c) => this.o !== null && this.h >= this.o ? H : this.v[this.h] !== void 0 ? j(this.v[this.h++]) : (c = i.next(c), c.done ? (this.o = this.h, c) : ((this.l || 2 > this.h) && (this.v[this.h] = c.value), this.h++, c)) }, this.l = !1, this.v = [], this.h = 0, this.o = s;
    }
    hb() {
      return this.D.create(this.O());
    }
    filter(i) {
      let s = -1;
      const c = this.value;
      return this.D.create({ next: (u) => {
        for (s++, u = c.next(u); !u.done && !i(u.value, s, this); ) s++, u = c.next(0);
        return u;
      } });
    }
    first() {
      if (this.v[0] !== void 0) return this.v[0];
      const i = this.value.next(0);
      return ue(this), i.done ? null : i.value;
    }
    O() {
      if (this.h > this.v.length && this.o !== this.v.length) throw Error("Implementation error: Sequence Iterator has progressed.");
      const i = this.value;
      this.l = !0;
      let s = i.next(0);
      for (; !s.done; ) s = i.next(0);
      return this.v;
    }
    fa() {
      const i = this.value, s = this.h;
      ue(this);
      var c = i.next(0);
      if (c.done) return ue(this, s), !1;
      if (c = c.value, I(c.type, 53)) return ue(this, s), !0;
      if (!i.next(0).done) throw K("Cannot determine the effective boolean value of a sequence with a length higher than one.");
      return ue(this, s), Z(c);
    }
    Pa(i = !1) {
      if (this.o !== null) return this.o;
      if (i) return -1;
      i = this.h;
      const s = this.O().length;
      return ue(this, i), s;
    }
    F() {
      return this.o === 0 ? !0 : this.first() === null;
    }
    oa() {
      if (this.o !== null) return this.o === 1;
      var i = this.value;
      const s = this.h;
      return ue(this), i.next(0).done ? (ue(this, s), !1) : (i = i.next(0), ue(this, s), i.done);
    }
    map(i) {
      let s = 0;
      const c = this.value;
      return this.D.create({ next: (u) => (u = c.next(u), u.done ? H : j(i(u.value, s++, this))) }, this.o);
    }
    N(i, s) {
      const c = this.value;
      let u;
      const h = [];
      let g = !0;
      return function() {
        for (let b = c.next(g ? 0 : s); !b.done; b = c.next(s)) g = !1, h.push(b.value);
        u = i(h).value;
      }(), this.D.create({ next: () => u.next(0) });
    }
    X(i) {
      let s = null;
      const c = (u) => {
        s = u.value, u = u.Pa(!0), u !== -1 && (this.o = u);
      };
      return this.D.create({ next: (u) => s ? s.next(u) : this.F() ? (c(i.empty ? i.empty(this) : i.default(this)), s.next(u)) : this.oa() ? (c(i.m ? i.m(this) : i.default(this)), s.next(u)) : (c(i.multiple ? i.multiple(this) : i.default(this)), s.next(u)) });
    }
  }, tt = class {
    constructor(i) {
      this.v = N, this.h = i;
      let s = !1;
      this.value = { next: () => s ? H : (s = !0, j(i)) }, this.o = null;
    }
    hb() {
      return this;
    }
    filter(i) {
      return i(this.h, 0, this) ? this : this.v.create();
    }
    first() {
      return this.h;
    }
    O() {
      return [this.h];
    }
    fa() {
      return this.o === null && (this.o = Z(this.h)), this.o;
    }
    Pa() {
      return 1;
    }
    F() {
      return !1;
    }
    oa() {
      return !0;
    }
    map(i) {
      return this.v.create(i(this.h, 0, this));
    }
    N(i) {
      return i([this.h]);
    }
    X(i) {
      return i.m ? i.m(this) : i.default(this);
    }
  };
  const _i = new Be();
  function Un(i = null, s = null) {
    if (i === null) return _i;
    if (Array.isArray(i)) switch (i.length) {
      case 0:
        return _i;
      case 1:
        return new tt(i[0]);
      default:
        return new Le(i);
    }
    return i.next ? new Ye(i, s) : new tt(i);
  }
  var N = { create: Un, m: (i) => new tt(i), empty: () => Un(), aa: () => Un(ee), T: () => Un(U) };
  function st(i) {
    const s = [], c = i.value;
    return () => {
      let u = 0;
      return N.create({ next: () => {
        if (s[u] !== void 0) return s[u++];
        const h = c.next(0);
        return h.done ? h : s[u++] = h;
      } });
    };
  }
  var _t = class {
    constructor(i, s, c) {
      this.namespaceURI = s || null, this.prefix = i || "", this.localName = c;
    }
    za() {
      return this.prefix ? this.prefix + ":" + this.localName : this.localName;
    }
  };
  function xS(i, s) {
    const c = i.value, u = s.map((h) => h === null ? null : st(h));
    return s = s.reduce((h, g, b) => (g === null && h.push(i.o[b]), h), []), s = new oi({ j: s, arity: s.length, Ya: !0, I: i.I, localName: "boundFunction", namespaceURI: i.l, i: i.s, value: function(h, g, b) {
      const x = Array.from(arguments).slice(3), C = u.map((T) => T === null ? x.shift() : T());
      return c.apply(void 0, [h, g, b].concat(C));
    } }), N.m(s);
  }
  var oi = class extends Ge {
    constructor({ j: i, arity: s, Ya: c = !1, I: u = !1, localName: h, namespaceURI: g, i: b, value: x }) {
      for (super(60, null), this.value = x, this.I = u, u = -1, x = 0; x < i.length; x++) i[x] === 4 && (u = x);
      -1 < u && (x = Array(s - (i.length - 1)).fill(i[u - 1]), i = i.slice(0, u).concat(x)), this.o = i, this.v = s, this.ia = c, this.D = h, this.l = g, this.s = b;
    }
    Ya() {
      return this.ia;
    }
  };
  function ug(i, s) {
    const c = [];
    return i !== 2 && i !== 1 || c.push("type-1-or-type-2"), c.push(`type-${i}`), s && c.push(`name-${s}`), c;
  }
  function dg(i) {
    const s = i.node.nodeType;
    let c;
    return (s === 2 || s === 1) && (c = i.node.localName), ug(s, c);
  }
  function Or(i) {
    let s = i.nodeType;
    s === 4 && (s = 3);
    let c;
    return (s === 2 || s === 1) && (c = i.localName), ug(s, c);
  }
  var si = class {
    getAllAttributes(i, s = null) {
      return i.nodeType !== 1 ? [] : (i = Array.from(i.attributes), s === null ? i : i.filter((c) => Or(c).includes(s)));
    }
    getAttribute(i, s) {
      return i.nodeType !== 1 ? null : i.getAttribute(s);
    }
    getChildNodes(i, s = null) {
      return i = Array.from(i.childNodes), s === null ? i : i.filter((c) => Or(c).includes(s));
    }
    getData(i) {
      return i.nodeType === 2 ? i.value : i.data;
    }
    getFirstChild(i, s = null) {
      for (i = i.firstChild; i; i = i.nextSibling) if (s === null || Or(i).includes(s)) return i;
      return null;
    }
    getLastChild(i, s = null) {
      for (i = i.lastChild; i; i = i.previousSibling) if (s === null || Or(i).includes(s)) return i;
      return null;
    }
    getNextSibling(i, s = null) {
      for (i = i.nextSibling; i; i = i.nextSibling) if (s === null || Or(i).includes(s)) return i;
      return null;
    }
    getParentNode(i, s = null) {
      return (i = i.nodeType === 2 ? i.ownerElement : i.parentNode) && (s === null || Or(i).includes(s)) ? i : null;
    }
    getPreviousSibling(i, s = null) {
      for (i = i.previousSibling; i; i = i.previousSibling) if (s === null || Or(i).includes(s)) return i;
      return null;
    }
  };
  class kS {
    insertBefore(s, c, u) {
      return s.insertBefore(c, u);
    }
    removeAttributeNS(s, c, u) {
      return s.removeAttributeNS(c, u);
    }
    removeChild(s, c) {
      return s.removeChild(c);
    }
    setAttributeNS(s, c, u, h) {
      s.setAttributeNS(c, u, h);
    }
    setData(s, c) {
      s.data = c;
    }
  }
  var Nd = new kS();
  class pg {
    constructor(s) {
      this.h = s;
    }
    insertBefore(s, c, u) {
      return this.h.insertBefore(s, c, u);
    }
    removeAttributeNS(s, c, u) {
      return this.h.removeAttributeNS(s, c, u);
    }
    removeChild(s, c) {
      return this.h.removeChild(s, c);
    }
    setAttributeNS(s, c, u, h) {
      this.h.setAttributeNS(s, c, u, h);
    }
    setData(s, c) {
      this.h.setData(s, c);
    }
  }
  function zt(i) {
    return i.Ra !== void 0;
  }
  function _o(i, s, c) {
    let u = null;
    return s && (zt(s.node) ? u = { G: s.G, offset: c, parent: s.node } : s.G && (u = s.G)), { node: i, G: u };
  }
  function zo(i, s, c = null) {
    return i.getAllAttributes(s.node, c).map((u) => _o(u, s, u.nodeName));
  }
  function Bd(i, s, c) {
    return s = s.node, zt(s) ? (i = s.attributes.find((u) => c === u.name)) ? i.value : null : (i = i.h.getAttribute(s, c)) ? i : null;
  }
  function sr(i, s, c = null) {
    return i.getChildNodes(s.node, c).map((u, h) => _o(u, s, h));
  }
  function Et(i, s) {
    return i.getData(s.node);
  }
  function Jl(i, s, c = null) {
    const u = s.node;
    return zt(u) ? i = u.childNodes[0] : ((c = i.h.getFirstChild(u, c)) && c.nodeType === 10 && (c = i.h.getNextSibling(c)), i = c), i ? _o(i, s, 0) : null;
  }
  function hg(i, s, c = null) {
    var u = s.node;
    return zt(u) ? (i = u.childNodes.length - 1, u = u.childNodes[i]) : ((u = i.h.getLastChild(u, c)) && u.nodeType === 10 && (u = i.h.getPreviousSibling(u)), i = i.getChildNodes(s.node, c).length - 1), u ? _o(u, s, i) : null;
  }
  function Ie(i, s, c = null) {
    const u = s.node, h = s.G;
    if (h) typeof h.offset == "number" && u === h.parent.childNodes[h.offset] || typeof h.offset == "string" && u === h.parent.attributes.find((g) => h.offset === g.nodeName) ? (i = h.parent, s = h.G) : (i = i.getParentNode(u, c), s = h);
    else {
      if (zt(u)) return null;
      i = i.getParentNode(u, c), s = null;
    }
    return i ? { node: i, G: s } : null;
  }
  function ai(i, s, c = null) {
    const u = s.node;
    let h, g, b;
    const x = s.G;
    if (zt(u)) x && (b = x.offset + 1, h = x.parent.childNodes[b]);
    else if (x) b = x.offset + 1, g = Ie(i, s, null), h = i.getChildNodes(g.node, c)[b];
    else {
      for (h = u; h && (!(h = i.h.getNextSibling(h, c)) || h.nodeType === 10); ) ;
      return h ? { node: h, G: null } : null;
    }
    return h ? _o(h, g || Ie(i, s, c), b) : null;
  }
  function ya(i, s, c = null) {
    const u = s.node;
    let h, g;
    const b = s.G;
    let x;
    if (zt(u)) b && (x = b.offset - 1, h = b.parent.childNodes[x]);
    else if (b) x = b.offset - 1, g = Ie(i, s, null), h = i.getChildNodes(g.node, c)[x];
    else {
      for (h = u; h && (!(h = i.h.getPreviousSibling(h, c)) || h.nodeType === 10); ) ;
      return h ? { node: h, G: null } : null;
    }
    return h ? _o(h, g || Ie(i, s, c), x) : null;
  }
  var Kl = class {
    constructor(i) {
      this.h = i, this.o = [];
    }
    getAllAttributes(i, s = null) {
      return zt(i) ? i.attributes : this.h.getAllAttributes(i, s);
    }
    getChildNodes(i, s = null) {
      return s = zt(i) ? i.childNodes : this.h.getChildNodes(i, s), i.nodeType === 9 ? s.filter((c) => c.nodeType !== 10) : s;
    }
    getData(i) {
      return zt(i) ? i.nodeType === 2 ? i.value : i.data : this.h.getData(i) || "";
    }
    getParentNode(i, s = null) {
      return this.h.getParentNode(i, s);
    }
  }, Id = (i, s, c, u, h) => h.N(([g]) => u.N(([b]) => {
    const x = g.value;
    if (0 >= x || x > b.h.length) throw Error("FOAY0001: array position out of bounds.");
    return b.h[x - 1]();
  })), qt = class extends oi {
    constructor(i) {
      super({ value: (s, c, u, h) => Id(s, c, u, N.m(this), h), localName: "get", namespaceURI: "http://www.w3.org/2005/xpath-functions/array", j: [{ type: 5, g: 3 }], arity: 1, i: { type: 59, g: 2 } }), this.type = 62, this.h = i;
    }
  };
  function AS(i) {
    switch (i.node.nodeType) {
      case 2:
        return 47;
      case 1:
        return 54;
      case 3:
      case 4:
        return 56;
      case 7:
        return 57;
      case 8:
        return 58;
      case 9:
        return 55;
      default:
        return 53;
    }
  }
  function _e(i) {
    return { type: AS(i), value: i };
  }
  function Oe(i, s) {
    return i = i.map((c) => c.first()), s(i);
  }
  function qo(i, s) {
    var c = I(i.type, 1) || I(i.type, 20) || I(i.type, 19), u = I(s.type, 1) || I(s.type, 20) || I(s.type, 19);
    return c && u ? i.value === s.value : (c = I(i.type, 4) || I(i.type, 3) || I(i.type, 6), u = I(s.type, 4) || I(s.type, 3) || I(s.type, 6), c && u ? isNaN(i.value) && isNaN(s.value) ? !0 : i.value === s.value : (c = I(i.type, 0) || I(i.type, 22) || I(i.type, 18) || I(i.type, 23) || I(i.type, 44), u = I(s.type, 0) || I(s.type, 22) || I(s.type, 18) || I(s.type, 23) || I(s.type, 44), c && u ? i.value === s.value : !1));
  }
  var Md = (i, s, c, u, h) => Oe([u, h], ([g, b]) => (g = g.h.find((x) => qo(x.key, b))) ? g.value() : N.empty()), Dr = class extends oi {
    constructor(i) {
      super({ j: [{ type: 59, g: 3 }], arity: 1, localName: "get", namespaceURI: "http://www.w3.org/2005/xpath-functions/map", value: (s, c, u, h) => Md(s, c, u, N.m(this), h), i: { type: 59, g: 2 } }), this.type = 61, this.h = i;
    }
  };
  function Rr(i, s) {
    return i.h() === s.h() && i.o() === s.o();
  }
  var Od = class {
    $a() {
      return 0;
    }
    getHours() {
      return 0;
    }
    getMinutes() {
      return 0;
    }
    ab() {
      return 0;
    }
    h() {
      return 0;
    }
    o() {
      return 0;
    }
    getSeconds() {
      return 0;
    }
    bb() {
      return 0;
    }
    na() {
      return !0;
    }
  };
  function fg(i) {
    var s = Math.abs(i.$a()), c = Math.abs(i.getHours());
    const u = Math.abs(i.getMinutes());
    return i = Math.abs(i.getSeconds()), s = `${s ? `${s}D` : ""}`, c = (c ? `${c}H` : "") + (u ? `${u}M` : "") + (i ? `${i}S` : ""), s && c ? `${s}T${c}` : s || (c ? `T${c}` : "T0S");
  }
  var zi = class extends Od {
    constructor(i) {
      if (super(), i > Number.MAX_SAFE_INTEGER || i < Number.MIN_SAFE_INTEGER) throw Error("FODT0002: Number of seconds given to construct DayTimeDuration overflows MAX_SAFE_INTEGER or MIN_SAFE_INTEGER");
      this.ca = i;
    }
    $a() {
      return Math.trunc(this.ca / 86400);
    }
    getHours() {
      return Math.trunc(this.ca % 86400 / 3600);
    }
    getMinutes() {
      return Math.trunc(this.ca % 3600 / 60);
    }
    o() {
      return this.ca;
    }
    getSeconds() {
      const i = this.ca % 60;
      return Object.is(-0, i) ? 0 : i;
    }
    na() {
      return Object.is(-0, this.ca) ? !1 : 0 <= this.ca;
    }
    toString() {
      return (this.na() ? "P" : "-P") + fg(this);
    }
  }, Dd = (i, s, c, u, h, g) => (i = 86400 * i + 3600 * s + 60 * c + u + h, new zi(g || i === 0 ? i : -i)), wa = (i) => (i = /^(-)?P(\d+Y)?(\d+M)?(\d+D)?(?:T(\d+H)?(\d+M)?(\d+(\.\d*)?S)?)?$/.exec(i)) ? Dd(i[4] ? parseInt(i[4], 10) : 0, i[5] ? parseInt(i[5], 10) : 0, i[6] ? parseInt(i[6], 10) : 0, i[7] ? parseInt(i[7], 10) : 0, i[8] ? parseFloat(i[8]) : 0, !i[1]) : null, mg = (i) => (i = /^(Z)|([+-])([01]\d):([0-5]\d)$/.exec(i), i[1] === "Z" ? Dd(0, 0, 0, 0, 0, !0) : Dd(0, i[3] ? parseInt(i[3], 10) : 0, i[4] ? parseInt(i[4], 10) : 0, 0, 0, i[2] === "+"));
  function gg(i, s) {
    if (isNaN(s)) throw Error("FOCA0005: Cannot multiply xs:dayTimeDuration by NaN");
    if (i = i.ca * s, i > Number.MAX_SAFE_INTEGER || !Number.isFinite(i)) throw Error("FODT0002: Value overflow while multiplying xs:dayTimeDuration");
    return new zi(i < Number.MIN_SAFE_INTEGER || Object.is(-0, i) ? 0 : i);
  }
  function ba(i) {
    return i ? parseInt(i, 10) : null;
  }
  function Wl(i) {
    i += "";
    const s = i.startsWith("-");
    return s && (i = i.substring(1)), (s ? "-" : "") + i.padStart(4, "0");
  }
  function Zt(i) {
    return (i + "").padStart(2, "0");
  }
  function yg(i) {
    return i += "", i.split(".")[0].length === 1 && (i = i.padStart(i.length + 1, "0")), i;
  }
  function li(i) {
    return i.getHours() === 0 && i.getMinutes() === 0 ? "Z" : (i.na() ? "+" : "-") + Zt(Math.abs(i.getHours())) + ":" + Zt(Math.abs(i.getMinutes()));
  }
  function Tn(i) {
    var s = /^(?:(-?\d{4,}))?(?:--?(\d\d))?(?:-{1,3}(\d\d))?(T)?(?:(\d\d):(\d\d):(\d\d))?(\.\d+)?(Z|(?:[+-]\d\d:\d\d))?$/.exec(i);
    i = s[1] ? parseInt(s[1], 10) : null;
    const c = ba(s[2]), u = ba(s[3]), h = s[4], g = ba(s[5]), b = ba(s[6]), x = ba(s[7]), C = s[8] ? parseFloat(s[8]) : 0;
    if (s = s[9] ? mg(s[9]) : null, i && (-271821 > i || 273860 < i)) throw Error("FODT0001: Datetime year is out of bounds");
    return h ? new Ft(i, c, u, g, b, x, C, s, 9) : g !== null && b !== null && x !== null ? new Ft(1972, 12, 31, g, b, x, C, s, 8) : i !== null && c !== null && u !== null ? new Ft(
      i,
      c,
      u,
      0,
      0,
      0,
      0,
      s,
      7
    ) : i !== null && c !== null ? new Ft(i, c, 1, 0, 0, 0, 0, s, 11) : c !== null && u !== null ? new Ft(1972, c, u, 0, 0, 0, 0, s, 13) : i !== null ? new Ft(i, 1, 1, 0, 0, 0, 0, s, 12) : c !== null ? new Ft(1972, c, 1, 0, 0, 0, 0, s, 14) : new Ft(1972, 12, u, 0, 0, 0, 0, s, 15);
  }
  function Ln(i, s) {
    switch (s) {
      case 15:
        return new Ft(1972, 12, i.o, 0, 0, 0, 0, i.Y, 15);
      case 14:
        return new Ft(1972, i.h, 1, 0, 0, 0, 0, i.Y, 14);
      case 12:
        return new Ft(i.v, 1, 1, 0, 0, 0, 0, i.Y, 12);
      case 13:
        return new Ft(1972, i.h, i.o, 0, 0, 0, 0, i.Y, 13);
      case 11:
        return new Ft(i.v, i.h, 1, 0, 0, 0, 0, i.Y, 11);
      case 8:
        return new Ft(1972, 12, 31, i.l, i.s, i.D, i.qa, i.Y, 8);
      case 7:
        return new Ft(i.v, i.h, i.o, 0, 0, 0, 0, i.Y, 7);
      default:
        return new Ft(i.v, i.h, i.o, i.l, i.s, i.D, i.qa, i.Y, 9);
    }
  }
  function va(i, s) {
    return s = i.Y || s || mg("Z"), new Date(Date.UTC(i.v, i.h - 1, i.o, i.l - s.getHours(), i.s - s.getMinutes(), i.D, 1e3 * i.qa));
  }
  var Ft = class {
    constructor(i, s, c, u, h, g, b, x, C = 9) {
      this.v = i, this.h = s, this.o = c + (u === 24 ? 1 : 0), this.l = u === 24 ? 0 : u, this.s = h, this.D = g, this.qa = b, this.Y = x, this.type = C;
    }
    getDay() {
      return this.o;
    }
    getHours() {
      return this.l;
    }
    getMinutes() {
      return this.s;
    }
    getMonth() {
      return this.h;
    }
    getSeconds() {
      return this.D;
    }
    getYear() {
      return this.v;
    }
    toString() {
      switch (this.type) {
        case 9:
          return Wl(this.v) + "-" + Zt(this.h) + "-" + Zt(this.o) + "T" + Zt(this.l) + ":" + Zt(this.s) + ":" + yg(this.D + this.qa) + (this.Y ? li(this.Y) : "");
        case 7:
          return Wl(this.v) + "-" + Zt(this.h) + "-" + Zt(this.o) + (this.Y ? li(this.Y) : "");
        case 8:
          return Zt(this.l) + ":" + Zt(this.s) + ":" + yg(this.D + this.qa) + (this.Y ? li(this.Y) : "");
        case 15:
          return "---" + Zt(this.o) + (this.Y ? li(this.Y) : "");
        case 14:
          return "--" + Zt(this.h) + (this.Y ? li(this.Y) : "");
        case 13:
          return "--" + Zt(this.h) + "-" + Zt(this.o) + (this.Y ? li(this.Y) : "");
        case 12:
          return Wl(this.v) + (this.Y ? li(this.Y) : "");
        case 11:
          return Wl(this.v) + "-" + Zt(this.h) + (this.Y ? li(this.Y) : "");
      }
      throw Error("Unexpected subType");
    }
  };
  function xa(i, s, c) {
    const u = va(i, c).getTime();
    return c = va(s, c).getTime(), u === c ? i.qa === s.qa ? 0 : i.qa > s.qa ? 1 : -1 : u > c ? 1 : -1;
  }
  function qi(i, s, c) {
    return xa(i, s, c) === 0;
  }
  function Rd(i, s, c) {
    return i = (va(i, c).getTime() - va(s, c).getTime()) / 1e3, new zi(i);
  }
  function ar(i) {
    throw Error(`Not implemented: adding durations to ${se[i.type]}`);
  }
  function lr(i) {
    throw Error(`Not implemented: subtracting durations from ${se[i.type]}`);
  }
  function Yl(i, s) {
    if (i === null) return null;
    switch (typeof i) {
      case "boolean":
        return i ? ee : U;
      case "number":
        return M(i, 3);
      case "string":
        return M(i, 1);
      case "object":
        if ("nodeType" in i) return _e({ node: i, G: null });
        if (Array.isArray(i)) return new qt(i.map((c) => c === void 0 ? () => N.empty() : (c = Yl(c), c = c === null ? N.empty() : N.m(c), st(c))));
        if (i instanceof Date) {
          const c = Tn(i.toISOString());
          return M(c, c.type);
        }
        return new Dr(Object.keys(i).filter((c) => i[c] !== void 0).map((c) => {
          var u = Yl(i[c]);
          return u = u === null ? N.empty() : N.m(u), { key: M(c, 1), value: st(u) };
        }));
    }
    throw Error(`Value ${String(i)} of type "${typeof i}" is not adaptable to an XPath value.`);
  }
  function Ql(i, s) {
    if (typeof i != "number" && (typeof i != "string" || !Y.get(s)(i))) throw Error(`Cannot convert JavaScript value '${i}' to the XPath type ${se[s]} since it is not valid.`);
  }
  function Fd(i, s, c) {
    if (s === null) return null;
    switch (i) {
      case 0:
        return s ? ee : U;
      case 1:
        return M(s + "", 1);
      case 3:
      case 2:
        return Ql(s, 3), M(+s, 3);
      case 4:
        return Ql(s, i), M(+s, 4);
      case 5:
        return Ql(s, i), M(s | 0, 5);
      case 6:
        return Ql(s, i), M(+s, 6);
      case 7:
      case 8:
      case 9:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
        if (!(s instanceof Date)) throw Error(`The JavaScript value ${s} with type ${typeof s} is not a valid type to be converted to an XPath ${se[i]}.`);
        return M(Ln(Tn(s.toISOString()), i), i);
      case 53:
      case 47:
      case 55:
      case 54:
      case 56:
      case 57:
      case 58:
        if (typeof s != "object" || !("nodeType" in s)) throw Error(`The JavaScript value ${s} with type ${typeof s} is not a valid type to be converted to an XPath ${se[i]}.`);
        return _e({ node: s, G: null });
      case 59:
        return Yl(s);
      case 61:
        return Yl(s);
      default:
        throw Error(`Values of the type "${se[i]}" can not be adapted from JavaScript to equivalent XPath values.`);
    }
  }
  function wg(i, s, c) {
    if (c.g === 0) return s = Fd(c.type, s), s === null ? [] : [s];
    if (c.g === 2 || c.g === 1) {
      if (!Array.isArray(s)) throw Error(`The JavaScript value ${s} should be an array if it is to be converted to ${kt(c)}.`);
      return s.map((h) => Fd(c.type, h)).filter((h) => h !== null);
    }
    const u = Fd(c.type, s);
    if (u === null) throw Error(`The JavaScript value ${s} should be a single entry if it is to be converted to ${kt(c)}.`);
    return [u];
  }
  function Zl(i, s, c = { type: 59, g: 0 }) {
    return N.create(wg(i, s, c));
  }
  var CS = class {
    constructor() {
      this.h = Math.abs(Math.floor(Math.random() * ec) % ec);
    }
  }, ec = 2 ** 32;
  function Fr(i, s, c, u) {
    return new Vo({ M: c, Aa: s, ta: u || i.ta, ra: i.ra }, i.h, i.o);
  }
  function bg(i, s) {
    let c = 0;
    const u = s.value;
    return { next: (h) => (h = u.next(h), h.done ? H : j(Fr(i, c++, h.value, s))) };
  }
  function Pd(i) {
    return i.h.ib || (i.h.ib = !0, i.h.qb = Tn((/* @__PURE__ */ new Date()).toISOString()), i.h.vb = wa("PT0S")), i.h.qb;
  }
  function Hn(i) {
    return i.h.ib || (i.h.ib = !0, i.h.qb = Tn((/* @__PURE__ */ new Date()).toISOString()), i.h.vb = wa("PT0S")), i.h.vb;
  }
  function ka(i, s = null) {
    return i = 29421 * (s ?? i.o.h) % ec, { rb: Math.floor(i), $b: i / ec };
  }
  function ci(i, s) {
    return new Vo({ M: i.M, Aa: i.Aa, ta: i.ta, ra: Object.assign(/* @__PURE__ */ Object.create(null), i.ra, s) }, i.h, i.o);
  }
  var Vo = class {
    constructor(i, s = { qb: null, vb: null, ib: !1 }, c = new CS()) {
      this.h = s, this.Aa = i.Aa, this.ta = i.ta, this.M = i.M, this.ra = i.ra || /* @__PURE__ */ Object.create(null), this.o = c;
    }
  }, vg = class {
    constructor(i, s, c, u, h, g, b, x, C) {
      this.debug = i, this.Ha = s, this.h = c, this.Ja = u, this.Ma = h, this.o = g, this.v = b, this.jb = x, this.Ua = C;
    }
  };
  function Gn(i) {
    let s = 0, c = null, u = !0;
    return N.create({ next: (h) => {
      for (; s < i.length; ) {
        c || (c = i[s].value, u = !0);
        const g = c.next(u ? 0 : h);
        if (u = !1, g.done) s++, c = null;
        else return g;
      }
      return H;
    } });
  }
  var Xo = (i, s, c) => Error(`FORG0001: Cannot cast ${i} to ${se[s]}${c ? `, ${c}` : ""}`), _n = (i) => Error(`XPDY0002: ${i}`), Nn = (i) => Error(`XPTY0004: ${i}`), xg = (i) => Error(`FOTY0013: Atomization is not supported for ${se[i]}.`), kg = (i) => Error(`XPST0081: The prefix ${i} could not be resolved.`);
  function Pr(i, s) {
    if (I(i.type, 46) || I(i.type, 19) || I(i.type, 0) || I(i.type, 4) || I(i.type, 3) || I(i.type, 6) || I(i.type, 5) || I(i.type, 2) || I(i.type, 23) || I(i.type, 1)) return N.create(i);
    const c = s.h;
    if (I(i.type, 53)) {
      const u = i.value;
      if (u.node.nodeType === 2 || u.node.nodeType === 3) return N.create(M(Et(c, u), 19));
      if (u.node.nodeType === 8 || u.node.nodeType === 7) return N.create(M(Et(c, u), 1));
      const h = [];
      return function g(b) {
        if (u.node.nodeType !== 8 && u.node.nodeType !== 7) {
          var x = b.nodeType;
          x === 3 || x === 4 ? h.push(c.getData(b)) : x !== 1 && x !== 9 && x !== 11 || c.getChildNodes(b).forEach((C) => {
            g(C);
          });
        }
      }(u.node), N.create(M(h.join(""), 19));
    }
    if (I(i.type, 60) && !I(i.type, 62)) throw xg(i.type);
    if (I(i.type, 62)) return Gn(i.h.map((u) => at(u(), s)));
    throw Error(`Atomizing ${i.type} is not implemented.`);
  }
  function at(i, s) {
    let c = !1;
    const u = i.value;
    let h = null;
    return N.create({ next: () => {
      for (; !c; ) {
        if (!h) {
          var g = u.next(0);
          if (g.done) {
            c = !0;
            break;
          }
          h = Pr(g.value, s).value;
        }
        if (g = h.next(0), g.done) h = null;
        else return g;
      }
      return H;
    } });
  }
  function tc(i) {
    for (i = z[i]; i && i.C !== 0; ) i = i.parent;
    return i ? i.type : null;
  }
  function $d(i, s) {
    s = z[s];
    const c = s.Ka;
    if (!c || !c.whiteSpace) return s.parent ? $d(i, s.parent.type) : i;
    switch (s.Ka.whiteSpace) {
      case "replace":
        return i.replace(/[\u0009\u000A\u000D]/g, " ");
      case "collapse":
        return i.replace(/[\u0009\u000A\u000D]/g, " ").replace(/ {2,}/g, " ").replace(/^ | $/g, "");
    }
    return i;
  }
  function nc(i, s) {
    for (s = z[s]; s && s.gb === null; ) {
      if (s.C === 2 || s.C === 3) return !0;
      s = s.parent;
    }
    return s ? s.gb(i) : !0;
  }
  function SS(i, s) {
    for (; i; ) {
      if (i.Oa && i.Oa[s]) return i.Oa[s];
      i = i.parent;
    }
    return () => !0;
  }
  function ES(i, s) {
    let c = z[s];
    for (; c; ) {
      if (c.Ka && !Object.keys(c.Ka).every((u) => {
        if (u === "whiteSpace") return !0;
        const h = SS(c, u);
        return h ? h(i, c.Ka[u]) : !0;
      })) return !1;
      c = c.parent;
    }
    return !0;
  }
  function Vi(i) {
    return i ? i.g === 2 || i.g === 0 : !0;
  }
  function TS(i) {
    return i(1) || i(19) ? (s) => ({ u: !0, value: M(s, 20) }) : () => ({ u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:anyURI or any of its derived types.") });
  }
  function NS(i) {
    return i(22) ? (s) => {
      let c = "";
      for (let u = 0; u < s.length; u += 2) c += String.fromCharCode(parseInt(s.substr(u, 2), 16));
      return { u: !0, value: M(btoa(c), 21) };
    } : i(1) || i(19) ? (s) => ({ u: !0, value: M(s, 21) }) : () => ({ error: Error("XPTY0004: Casting not supported from given type to xs:base64Binary or any of its derived types."), u: !1 });
  }
  function BS(i) {
    return i(2) ? (s) => ({ u: !0, value: s === 0 || isNaN(s) ? U : ee }) : i(1) || i(19) ? (s) => {
      switch (s) {
        case "true":
        case "1":
          return { u: !0, value: ee };
        case "false":
        case "0":
          return { u: !0, value: U };
        default:
          return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:boolean or any of its derived types.") };
      }
    } : () => ({ u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:boolean or any of its derived types.") });
  }
  function IS(i) {
    return i(9) ? (s) => ({ u: !0, value: M(Ln(s, 7), 7) }) : i(19) || i(1) ? (s) => ({ u: !0, value: M(Tn(s), 7) }) : () => ({ u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:date or any of its derived types.") });
  }
  function MS(i) {
    return i(7) ? (s) => ({ u: !0, value: M(Ln(s, 9), 9) }) : i(19) || i(1) ? (s) => ({ u: !0, value: M(Tn(s), 9) }) : () => ({ u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:dateTime or any of its derived types.") });
  }
  function OS(i) {
    return i(18) && !i(16) ? (s) => ({ u: !0, value: M(s.Ga, 17) }) : i(16) ? () => ({ u: !0, value: M(wa("PT0.0S"), 17) }) : i(19) || i(1) ? (s) => {
      const c = wa(s);
      return c ? { u: !0, value: M(c, 17) } : { u: !1, error: Error(`FORG0001: Can not cast ${s} to xs:dayTimeDuration`) };
    } : () => ({ u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:dayTimeDuration or any of its derived types.") });
  }
  function DS(i) {
    return i(5) ? (s) => ({ u: !0, value: M(s, 4) }) : i(6) || i(3) ? (s) => isNaN(s) || !isFinite(s) ? { u: !1, error: Error(`FOCA0002: Can not cast ${s} to xs:decimal`) } : Math.abs(s) > Number.MAX_VALUE ? { u: !1, error: Error(`FOAR0002: Can not cast ${s} to xs:decimal, it is out of bounds for JavaScript numbers`) } : { u: !0, value: M(s, 4) } : i(0) ? (s) => ({ u: !0, value: M(s ? 1 : 0, 4) }) : i(1) || i(19) ? (s) => {
      const c = parseFloat(s);
      return !isNaN(c) || isFinite(c) ? { u: !0, value: M(c, 4) } : { u: !1, error: Error(`FORG0001: Can not cast ${s} to xs:decimal`) };
    } : () => ({
      u: !1,
      error: Error("XPTY0004: Casting not supported from given type to xs:decimal or any of its derived types.")
    });
  }
  function Ag(i, s) {
    return i(2) ? (c) => ({ u: !0, value: c }) : i(0) ? (c) => ({ u: !0, value: c ? 1 : 0 }) : i(1) || i(19) ? (c) => {
      switch (c) {
        case "NaN":
          return { u: !0, value: NaN };
        case "INF":
        case "+INF":
          return { u: !0, value: 1 / 0 };
        case "-INF":
          return { u: !0, value: -1 / 0 };
        case "0":
        case "+0":
          return { u: !0, value: 0 };
        case "-0":
          return { u: !0, value: -0 };
      }
      const u = parseFloat(c);
      return isNaN(u) ? { u: !1, error: Xo(c, s) } : { u: !0, value: u };
    } : () => ({ u: !1, error: Error(`XPTY0004: Casting not supported from given type to ${s} or any of its derived types.`) });
  }
  function RS(i) {
    const s = Ag(i, 3);
    return (c) => (c = s(c), c.u ? { u: !0, value: M(c.value, 3) } : c);
  }
  function Cg(i) {
    const s = Math.abs(i.bb());
    return i = Math.abs(i.ab()), `${s ? `${s}Y` : ""}${i ? `${i}M` : ""}` || "0M";
  }
  var Jo = class extends Od {
    constructor(i) {
      if (super(), i > Number.MAX_SAFE_INTEGER || i < Number.MIN_SAFE_INTEGER) throw Error("FODT0002: Number of months given to construct YearMonthDuration overflows MAX_SAFE_INTEGER or MIN_SAFE_INTEGER");
      this.ea = i;
    }
    ab() {
      const i = this.ea % 12;
      return i === 0 ? 0 : i;
    }
    h() {
      return this.ea;
    }
    bb() {
      return Math.trunc(this.ea / 12);
    }
    na() {
      return Object.is(-0, this.ea) ? !1 : 0 <= this.ea;
    }
    toString() {
      return (this.na() ? "P" : "-P") + Cg(this);
    }
  }, jd = (i) => {
    var s = /^(-)?P(\d+Y)?(\d+M)?(\d+D)?(?:T(\d+H)?(\d+M)?(\d+(\.\d*)?S)?)?$/.exec(i);
    if (s) {
      if (i = !s[1], s = 12 * (s[2] ? parseInt(s[2], 10) : 0) + (s[3] ? parseInt(s[3], 10) : 0), s > Number.MAX_SAFE_INTEGER || !Number.isFinite(s)) throw Error("FODT0002: Value overflow while constructing xs:yearMonthDuration");
      i = new Jo(i || s === 0 ? s : -s);
    } else i = null;
    return i;
  };
  function Sg(i, s) {
    if (isNaN(s)) throw Error("FOCA0005: Cannot multiply xs:yearMonthDuration by NaN");
    if (i = Math.round(i.ea * s), i > Number.MAX_SAFE_INTEGER || !Number.isFinite(i)) throw Error("FODT0002: Value overflow while constructing xs:yearMonthDuration");
    return new Jo(i < Number.MIN_SAFE_INTEGER || i === 0 ? 0 : i);
  }
  var Ud = class extends Od {
    constructor(i, s) {
      super(), this.Va = i, this.Ga = s;
    }
    $a() {
      return this.Ga.$a();
    }
    getHours() {
      return this.Ga.getHours();
    }
    getMinutes() {
      return this.Ga.getMinutes();
    }
    ab() {
      return this.Va.ab();
    }
    h() {
      return this.Va.h();
    }
    o() {
      return this.Ga.o();
    }
    getSeconds() {
      return this.Ga.getSeconds();
    }
    bb() {
      return this.Va.bb();
    }
    na() {
      return this.Va.na() && this.Ga.na();
    }
    toString() {
      const i = this.na() ? "P" : "-P", s = Cg(this.Va), c = fg(this.Ga);
      return s === "0M" ? i + c : c === "T0S" ? i + s : i + s + c;
    }
  };
  function FS(i) {
    return i(16) ? (s) => ({ u: !0, value: M(new Ud(s, new zi(s.na() ? 0 : -0)), 18) }) : i(17) ? (s) => (s = new Ud(new Jo(s.na() ? 0 : -0), s), { u: !0, value: M(s, 18) }) : i(18) ? (s) => ({ u: !0, value: M(s, 18) }) : i(19) || i(1) ? (s) => {
      var c;
      return c = new Ud(jd(s), wa(s)), { u: !0, value: M(c, 18) };
    } : () => ({ u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:duration or any of its derived types.") });
  }
  function PS(i) {
    const s = Ag(i, 6);
    return (c) => (c = s(c), c.u ? { u: !0, value: M(c.value, 6) } : c);
  }
  function $S(i) {
    return i(7) || i(9) ? (s) => ({ u: !0, value: M(Ln(s, 15), 15) }) : i(19) || i(1) ? (s) => ({ u: !0, value: M(Tn(s), 15) }) : () => ({ u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:gDay or any of its derived types.") });
  }
  function jS(i) {
    return i(7) || i(9) ? (s) => ({ u: !0, value: M(Ln(s, 14), 14) }) : i(19) || i(1) ? (s) => ({ u: !0, value: M(Tn(s), 14) }) : () => ({ u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:gMonth or any of its derived types.") });
  }
  function US(i) {
    return i(7) || i(9) ? (s) => ({ u: !0, value: M(Ln(s, 13), 13) }) : i(19) || i(1) ? (s) => ({ u: !0, value: M(Tn(s), 13) }) : () => ({ u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:gMonthDay or any of its derived types.") });
  }
  function LS(i) {
    return i(7) || i(9) ? (s) => ({ u: !0, value: M(Ln(s, 12), 12) }) : i(19) || i(1) ? (s) => ({ u: !0, value: M(Tn(s), 12) }) : () => ({ u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:gYear or any of its derived types.") });
  }
  function HS(i) {
    return i(7) || i(9) ? (s) => ({ u: !0, value: M(Ln(s, 11), 11) }) : i(19) || i(1) ? (s) => ({ u: !0, value: M(Tn(s), 11) }) : () => ({ u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:gYearMonth or any of its derived types.") });
  }
  function GS(i) {
    return i(21) ? (s) => {
      s = atob(s);
      let c = "";
      for (let u = 0, h = s.length; u < h; u++) c += Number(s.charCodeAt(u)).toString(16);
      return { u: !0, value: M(c.toUpperCase(), 22) };
    } : i(1) || i(19) ? (s) => ({ u: !0, value: M(s, 22) }) : () => ({ u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:hexBinary or any of its derived types.") });
  }
  function _S(i) {
    return i(0) ? (s) => ({ u: !0, value: M(s ? 1 : 0, 5) }) : i(2) ? (s) => {
      const c = Math.trunc(s);
      return !isFinite(c) || isNaN(c) ? { u: !1, error: Error(`FOCA0002: can not cast ${s} to xs:integer`) } : Number.isSafeInteger(c) ? { u: !0, value: M(c, 5) } : { u: !1, error: Error(`FOAR0002: can not cast ${s} to xs:integer, it is out of bounds for JavaScript numbers.`) };
    } : i(1) || i(19) ? (s) => {
      const c = parseInt(s, 10);
      return isNaN(c) ? { u: !1, error: Xo(s, 5) } : Number.isSafeInteger(c) ? { u: !0, value: M(c, 5) } : { u: !1, error: Error(`FOCA0003: can not cast ${s} to xs:integer, it is out of bounds for JavaScript numbers.`) };
    } : () => ({ u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:integer or any of its derived types.") });
  }
  const zS = [3, 6, 4, 5];
  function qS(i) {
    var s = Ng;
    return (c) => {
      for (const u of zS) {
        const h = s(i, u)(c);
        if (h.u) return h;
      }
      return { u: !1, error: Error(`XPTY0004: Casting not supported from "${c}" given type to xs:numeric or any of its derived types.`) };
    };
  }
  function Eg(i) {
    if (i(1) || i(19)) return (s) => ({ u: !0, value: s + "" });
    if (i(20)) return (s) => ({ u: !0, value: s });
    if (i(23)) return (s) => ({ u: !0, value: s.prefix ? `${s.prefix}:${s.localName}` : s.localName });
    if (i(44)) return (s) => ({ u: !0, value: s.toString() });
    if (i(2)) {
      if (i(5) || i(4)) return (s) => ({ u: !0, value: (s + "").replace("e", "E") });
      if (i(6) || i(3)) return (s) => isNaN(s) ? { u: !0, value: "NaN" } : isFinite(s) ? Object.is(s, -0) ? { u: !0, value: "-0" } : { u: !0, value: (s + "").replace("e", "E").replace("E+", "E") } : { u: !0, value: `${0 > s ? "-" : ""}INF` };
    }
    return i(9) || i(7) || i(8) || i(15) || i(14) || i(13) || i(12) || i(11) ? (s) => ({ u: !0, value: s.toString() }) : i(16) ? (s) => ({ u: !0, value: s.toString() }) : i(17) ? (s) => ({ u: !0, value: s.toString() }) : i(18) ? (s) => ({ u: !0, value: s.toString() }) : i(22) ? (s) => ({ u: !0, value: s.toUpperCase() }) : (s) => ({ u: !0, value: s + "" });
  }
  function VS(i) {
    const s = Eg(i);
    return (c) => (c = s(c), c.u ? { u: !0, value: M(c.value, 1) } : c);
  }
  function XS(i) {
    return i(9) ? (s) => ({ u: !0, value: M(Ln(s, 8), 8) }) : i(19) || i(1) ? (s) => ({ u: !0, value: M(Tn(s), 8) }) : () => ({ u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:time or any of its derived types.") });
  }
  function JS(i) {
    const s = Eg(i);
    return (c) => (c = s(c), c.u ? { u: !0, value: M(c.value, 19) } : c);
  }
  function KS(i) {
    return i(18) && !i(17) ? (s) => ({ u: !0, value: M(s.Va, 16) }) : i(17) ? () => ({ u: !0, value: M(jd("P0M"), 16) }) : i(19) || i(1) ? (s) => {
      const c = jd(s);
      return c ? { u: !0, value: M(c, 16) } : { u: !1, error: Xo(s, 16) };
    } : () => ({ u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:yearMonthDuration or any of its derived types.") });
  }
  const Tg = [2, 5, 17, 16];
  function Ng(i, s) {
    const c = (u) => I(i, u);
    if (s === 39) return () => ({ u: !1, error: Error("FORG0001: Casting to xs:error is always invalid.") });
    switch (s) {
      case 19:
        return JS(c);
      case 1:
        return VS(c);
      case 6:
        return PS(c);
      case 3:
        return RS(c);
      case 4:
        return DS(c);
      case 5:
        return _S(c);
      case 2:
        return qS(i);
      case 18:
        return FS(c);
      case 16:
        return KS(c);
      case 17:
        return OS(c);
      case 9:
        return MS(c);
      case 8:
        return XS(c);
      case 7:
        return IS(c);
      case 11:
        return HS(c);
      case 12:
        return LS(c);
      case 13:
        return US(c);
      case 15:
        return $S(c);
      case 14:
        return jS(c);
      case 0:
        return BS(c);
      case 21:
        return NS(c);
      case 22:
        return GS(c);
      case 20:
        return TS(c);
      case 23:
        throw Error("Casting to xs:QName is not implemented.");
    }
    return () => ({ u: !1, error: Error(`XPTY0004: Casting not supported from ${i} to ${s}.`) });
  }
  const Bg = /* @__PURE__ */ Object.create(null);
  function WS(i, s) {
    if (i === 19 && s === 1) return (g) => ({ u: !0, value: M(g, 1) });
    if (s === 44) return () => ({ u: !1, error: Error("XPST0080: Casting to xs:NOTATION is not permitted.") });
    if (s === 39) return () => ({ u: !1, error: Error("FORG0001: Casting to xs:error is not permitted.") });
    if (i === 45 || s === 45) return () => ({ u: !1, error: Error("XPST0080: Casting from or to xs:anySimpleType is not permitted.") });
    if (i === 46 || s === 46) return () => ({ u: !1, error: Error("XPST0080: Casting from or to xs:anyAtomicType is not permitted.") });
    if (I(i, 60) && s === 1) return () => ({ u: !1, error: Error("FOTY0014: Casting from function item to xs:string is not permitted.") });
    if (i === s) return (g) => ({ u: !0, value: { type: s, value: g } });
    const c = Tg.includes(i) ? i : tc(i), u = Tg.includes(s) ? s : tc(s);
    if (u === null || c === null) return () => ({ u: !1, error: Error(`XPST0081: Can not cast: type ${u ? se[i] : se[s]} is unknown.`) });
    const h = [];
    return c !== 1 && c !== 19 || h.push((g) => {
      const b = $d(g, s);
      return nc(b, s) ? { u: !0, value: b } : { u: !1, error: Xo(g, s, "pattern validation failed.") };
    }), c !== u && (h.push(Ng(c, u)), h.push((g) => ({
      u: !0,
      value: g.value
    }))), u !== 19 && u !== 1 || h.push((g) => nc(g, s) ? { u: !0, value: g } : { u: !1, error: Xo(g, s, "pattern validation failed.") }), h.push((g) => ES(g, s) ? { u: !0, value: g } : { u: !1, error: Xo(g, s, "pattern validation failed.") }), h.push((g) => ({ u: !0, value: { type: s, value: g } })), (g) => {
      g = { u: !0, value: g };
      for (let b = 0, x = h.length; b < x && (g = h[b](g.value), g.u !== !1); ++b) ;
      return g;
    };
  }
  function Ld(i, s) {
    const c = i.type + 1e4 * s;
    let u = Bg[c];
    return u || (u = Bg[c] = WS(i.type, s)), u.call(void 0, i.value, s);
  }
  function He(i, s) {
    if (i = Ld(i, s), i.u === !0) return i.value;
    throw i.error;
  }
  function $r(i) {
    let s = !1;
    return { next: () => s ? H : (s = !0, j(i)) };
  }
  function Ig(i, s) {
    return i === s ? !0 : i && s && i.offset === s.offset && i.parent === s.parent ? Ig(i.G, s.G) : !1;
  }
  function mt(i, s) {
    return !!(i === s || i.node === s.node && Ig(i.G, s.G));
  }
  function YS(i, s, c) {
    var u = Ie(i, s, null);
    i = sr(i, u, null);
    for (let h = 0, g = i.length; h < g; ++h) {
      if (u = i[h], mt(u, s)) return -1;
      if (mt(u, c)) return 1;
    }
  }
  function Mg(i, s) {
    const c = [];
    for (; s; s = Ie(i, s, null)) c.unshift(s);
    return c;
  }
  function Og(i, s) {
    const c = [];
    for (; s; s = i.getParentNode(s, null)) c.unshift(s);
    return c;
  }
  function QS(i, s, c, u) {
    if (c.G || u.G || zt(c.node) || zt(u.node)) {
      if (mt(c, u)) return 0;
      c = Mg(s, c), u = Mg(s, u);
      const g = c[0], b = u[0];
      if (!mt(g, b)) return s = i.findIndex((x) => mt(x, g)), c = i.findIndex((x) => mt(x, b)), s === -1 && (s = i.push(g)), c === -1 && (c = i.push(b)), s - c;
      i = 1;
      for (var h = Math.min(c.length, u.length); i < h && mt(c[i], u[i]); ++i) ;
      return c[i] ? u[i] ? YS(s, c[i], u[i]) : 1 : -1;
    }
    if (c = c.node, h = u.node, c === h) return 0;
    if (u = Og(s, c), c = Og(s, h), u[0] !== c[0]) {
      const g = { node: u[0], G: null }, b = { node: c[0], G: null };
      return s = i.findIndex((x) => mt(x, g)), c = i.findIndex((x) => mt(x, b)), s === -1 && (s = i.push(g)), c === -1 && (c = i.push(b)), s - c;
    }
    for (i = 1, h = Math.min(u.length, c.length); i < h && u[i] === c[i]; ++i) ;
    if (u = u[i], h = c[i], !u) return -1;
    if (!h) return 1;
    s = s.getChildNodes(c[i - 1], null);
    for (let g = 0, b = s.length; g < b; ++g) {
      if (i = s[g], i === u) return -1;
      if (i === h) return 1;
    }
  }
  function Dg(i, s, c, u) {
    const h = I(c.type, 47), g = I(u.type, 47);
    if (h && !g) {
      if (c = Ie(s, c.value), u = u.value, mt(c, u)) return 1;
    } else if (g && !h) {
      if (c = c.value, u = Ie(s, u.value), mt(c, u)) return -1;
    } else if (h && g) {
      if (mt(Ie(s, u.value), Ie(s, c.value))) return c.value.node.localName > u.value.node.localName ? 1 : -1;
      c = Ie(s, c.value), u = Ie(s, u.value);
    } else c = c.value, u = u.value;
    return QS(i, s, c, u);
  }
  function Aa(i, s, c) {
    return Dg(i.o, i, s, c);
  }
  function Ca(i, s) {
    return Hd(s, (c, u) => Dg(i.o, i, c, u)).filter((c, u, h) => u === 0 ? !0 : !mt(c.value, h[u - 1].value));
  }
  const ZS = (i, s) => i < s ? -1 : 0;
  function Hd(i, s = ZS) {
    if (1 >= i.length) return i;
    var c = Math.floor(i.length / 2);
    const u = Hd(i.slice(0, c), s);
    for (i = Hd(i.slice(c), s), c = []; u.length && i.length; ) 0 > s(u[0], i[0]) ? c.push(u.shift()) : c.push(i.shift());
    return c.concat(u.concat(i));
  }
  function eE(i, s) {
    if (I(i.type, 2)) {
      if (I(i.type, 6)) return s === 3 ? M(i.value, 3) : null;
      if (I(i.type, 4)) {
        if (s === 6) return M(i.value, 6);
        if (s === 3) return M(i.value, 3);
      }
      return null;
    }
    return I(i.type, 20) && s === 1 ? M(i.value, 1) : null;
  }
  function rc(i, s, c, u, h) {
    if (I(i.type, s.type) || (I(s.type, 46) && I(i.type, 53) && (i = Pr(i, c).first()), I(i.type, s.type) || s.type === 46)) return i;
    if (I(i.type, 19)) {
      if (c = He(i, s.type), !c) throw Error(`XPTY0004 Unable to convert ${h ? "return" : "argument"} of type ${se[i.type]} to type ${kt(s)} while calling ${u}`);
      return c;
    }
    if (c = eE(i, s.type), !c) throw Error(`XPTY0004 Unable to cast ${h ? "return" : "argument"} of type ${se[i.type]} to type ${kt(s)} while calling ${u}`);
    return c;
  }
  function Gd(i) {
    switch (i) {
      case 2:
        return "*";
      case 1:
        return "+";
      case 0:
        return "?";
      case 3:
        return "";
    }
  }
  var cr = (i, s, c, u, h) => i.g === 0 ? s.X({ default: () => s.map((g) => rc(g, i, c, u, h)), multiple: () => {
    throw Error(`XPTY0004: Multiplicity of ${h ? "function return value" : "function argument"} of type ${se[i.type]}${Gd(i.g)} for ${u} is incorrect. Expected "?", but got "+".`);
  } }) : i.g === 1 ? s.X({ empty: () => {
    throw Error(`XPTY0004: Multiplicity of ${h ? "function return value" : "function argument"} of type ${se[i.type]}${Gd(i.g)} for ${u} is incorrect. Expected "+", but got "empty-sequence()"`);
  }, default: () => s.map((g) => rc(
    g,
    i,
    c,
    u,
    h
  )) }) : i.g === 2 ? s.map((g) => rc(g, i, c, u, h)) : s.X({ m: () => s.map((g) => rc(g, i, c, u, h)), default: () => {
    throw Error(`XPTY0004: Multiplicity of ${h ? "function return value" : "function argument"} of type ${se[i.type]}${Gd(i.g)} for ${u} is incorrect. Expected exactly one`);
  } });
  function Bn(i, s, c) {
    return (u, h, g) => {
      if (u.M === null) throw _n(`The function ${i} depends on dynamic context, which is absent.`);
      const b = cr({ type: s, g: 3 }, N.m(u.M), h, i, !1);
      return c(u, h, g, b);
    };
  }
  var tE = n;
  function _d(i, s) {
    return I(i, 5) ? M(s, 5) : I(i, 6) ? M(s, 6) : I(i, 3) ? M(s, 3) : M(s, 4);
  }
  const nE = [{ la: "M", ja: 1e3 }, { la: "CM", ja: 900 }, { la: "D", ja: 500 }, { la: "CD", ja: 400 }, { la: "C", ja: 100 }, { la: "XC", ja: 90 }, { la: "L", ja: 50 }, { la: "XL", ja: 40 }, { la: "X", ja: 10 }, { la: "IX", ja: 9 }, { la: "V", ja: 5 }, { la: "IV", ja: 4 }, { la: "I", ja: 1 }];
  function Rg(i, s) {
    const c = 0 > i;
    if (i = Math.abs(i), !i) return "-";
    let u = nE.reduce((h, g) => {
      const b = Math.floor(i / g.ja);
      return i -= b * g.ja, h + g.la.repeat(b);
    }, "");
    return s && (u = u.toLowerCase()), c && (u = `-${u}`), u;
  }
  const zd = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
  function Fg(i, s) {
    const c = 0 > i;
    if (i = Math.abs(i), !i) return "-";
    let u = "", h;
    for (; 0 < i; ) h = (i - 1) % zd.length, u = zd[h] + u, i = (i - h) / zd.length | 0;
    return s && (u = u.toLowerCase()), c && (u = `-${u}`), u;
  }
  function Pg(i, s, c = []) {
    return Array.from({ length: s }, (u, h) => h + i).filter((u) => !c.includes(u));
  }
  const qd = Pg(1488, 27, [1498, 1501, 1503, 1507, 1509]), Vd = Pg(1575, 36, [1577, 1595, 1596, 1597, 1598, 1599, 1600, 1609]), Xd = "أبجدهوزحطيكلمنسعفصقرشتثخذضظغ".split(""), ic = [[1e3, "غ"], [900, "ظ"], [800, "ض"], [700, "ذ"], [600, "خ"], [500, "ث"], [400, "ت"], [300, "ش"], [200, "ر"], [100, "ق"], [90, "ص"], [80, "ف"], [70, "ع"], [60, "س"], [
    50,
    "ن"
  ], [40, "م"], [30, "ل"], [20, "ك"], [10, "ي"], [9, "ط"], [8, "ح"], [7, "ز"], [6, "و"], [5, "ه"], [4, "د"], [3, "ج"], [2, "ب"], [1, "أ"]], rE = [[400, "ת"], [300, "ש"], [200, "ר"], [100, "ק"], [90, "צ"], [80, "פ"], [70, "ע"], [60, "ס"], [50, "נ"], [40, "מ"], [30, "ל"], [20, "כ"], [10, "י"], [9, "ט"], [8, "ח"], [7, "ז"], [6, "ו"], [5, "ה"], [4, "ד"], [3, "ג"], [2, "ב"], [1, "א"]];
  function $g(i, s = []) {
    var c = 25;
    return s.sort((u, h) => u - h), c -= s.length, function(u) {
      const h = 0 > u;
      if (u = Math.abs(u), !u) return "-";
      const g = [];
      for (; 0 < u; ) {
        let b = i + (u - 1) % c;
        s.forEach((x) => {
          b >= x && b++;
        }), g.unshift(String.fromCodePoint(b)), u = Math.floor((u - 1) / c);
      }
      return u = g.join(""), h && (u = `-${u}`), u;
    };
  }
  const jg = $g(945, [962]), Ug = $g(913, [930]);
  function ur(i) {
    return new Intl.NumberFormat([], { numberingSystem: "arab", useGrouping: !1 }).format(i);
  }
  function dr(i) {
    return new Intl.NumberFormat([], { numberingSystem: "arabext", useGrouping: !1 }).format(i);
  }
  const iE = /* @__PURE__ */ new Map([["A", function(i) {
    return Fg(i, !1);
  }], ["a", function(i) {
    return Fg(i, !0);
  }], ["I", function(i) {
    return Rg(i, !1);
  }], ["i", function(i) {
    return Rg(i, !0);
  }], ["lowerGreek", jg], ["α", jg], ["upperGreek", Ug], ["Α", Ug], ["arabicAbjadi", function(i) {
    const s = 0 > i;
    return i = Math.abs(i), i ? (i = Array(Math.floor((i - 1) / Xd.length) + 1).fill(Xd[(i - 1) % Xd.length]).join(String.fromCodePoint(8204)), s && (i = `-${i}`), i) : "-";
  }], ["arabicAbjadNumeral", function(i) {
    const s = 0 > i;
    if (i = Math.abs(i), !i) return "-";
    var c = [], u = Math.floor(i / 1e3);
    if (i -= 1e3 * u, u === 1) c.push(ic[0][1]);
    else if (1 < u) {
      for (const [g, b] of ic) {
        var h = g;
        const x = b;
        for (; u >= h; ) c.push(x), u -= h;
      }
      c.push(ic[0][1]);
    }
    for (const [g, b] of ic) for (u = g, h = b; i >= u; ) i -= u, c.push(h);
    return c = c.join(""), s && (c = `-${c}`), c;
  }], ["arabicAlifBaTa", function(i) {
    const s = 0 > i;
    return i = Math.abs(i), i ? (i = Array(Math.floor((i - 1) / Vd.length) + 1).fill(String.fromCodePoint(Vd[(i - 1) % Vd.length])).join(String.fromCodePoint(8204)), s && (i = `-${i}`), i) : "-";
  }], ["hebrewAlefBet", function(i) {
    const s = 0 > i;
    if (i = Math.abs(i), !i) return "-";
    var c = Math.floor((i - 1) / qd.length);
    const u = String.fromCodePoint(1514);
    return c = Array(c).fill(u), c.push(String.fromCodePoint(qd[(i - 1) % qd.length])), i = c.join(""), s && (i = `-${i}`), i;
  }], ["hebrewNumeral", function(i) {
    const s = 0 > i;
    if (i = Math.abs(i), !i) return "-";
    var c = [], u = Math.floor(i / 400);
    i -= 400 * u;
    for (var h = 0; h < u; h++) c.push("ת");
    for (const [g, b] of rE) for (u = g, h = b; i >= u; ) i -= u, c.push(h);
    return i = c.slice(-2).join(""), i === "יה" && c.splice(-2, 2, "ט", "ו"), i === "יו" && c.splice(-2, 2, "ט", "ז"), c = c.join(""), s && (c = `-${c}`), c;
  }], ["arabicIndicNumeral", ur], ["١", ur], ["٢", ur], ["٣", ur], ["٤", ur], ["٥", ur], ["٦", ur], ["٧", ur], ["٨", ur], ["٩", ur], ["persianNumeral", dr], ["۱", dr], ["۲", dr], ["۳", dr], ["۴", dr], ["۵", dr], ["۶", dr], ["۷", dr], ["۸", dr], ["۹", dr]]);
  function oE(i) {
    if (Math.floor(i) === i || isNaN(i)) return 0;
    i = /\d+(?:\.(\d*))?(?:[Ee](-)?(\d+))*/.exec(`${i}`);
    const s = i[1] ? i[1].length : 0;
    return i[3] ? i[2] ? s + parseInt(i[3], 10) : (i = s - parseInt(i[3], 10), 0 > i ? 0 : i) : s;
  }
  function sE(i, s, c) {
    return s && i * c % 1 % 0.5 === 0 ? Math.floor(i * c) % 2 === 0 ? Math.floor(i * c) / c : Math.ceil(i * c) / c : Math.round(i * c) / c;
  }
  function Ko(i, s, c, u, h, g) {
    let b = !1;
    return N.create({ next: () => {
      if (b) return H;
      const x = h.first();
      if (!x) return b = !0, H;
      if ((I(x.type, 6) || I(x.type, 3)) && (x.value === 0 || isNaN(x.value) || x.value === 1 / 0 || x.value === -1 / 0)) return b = !0, j(x);
      var C;
      if (g ? C = g.first().value : C = 0, b = !0, oE(x.value) < C) return j(x);
      const T = [5, 4, 3, 6].find((P) => I(x.type, P)), R = He(x, 4);
      switch (C = sE(R.value, i, Math.pow(10, C)), T) {
        case 4:
          return j(M(C, 4));
        case 3:
          return j(M(C, 3));
        case 6:
          return j(M(C, 6));
        case 5:
          return j(M(C, 5));
      }
    } });
  }
  const Lg = (i, s, c, u) => at(u, s).X({ empty: () => N.m(M(NaN, 3)), m: () => {
    const h = Ld(u.first(), 3);
    return h.u ? N.m(h.value) : N.m(M(NaN, 3));
  }, multiple: () => {
    throw Error("fn:number may only be called with zero or one values");
  } });
  function aE(i) {
    let s = 5381;
    for (let c = 0; c < i.length; ++c) s = 33 * s + i.charCodeAt(c), s %= Number.MAX_SAFE_INTEGER;
    return s;
  }
  const Hg = (i, s, c, u = N.empty()) => {
    function h(g) {
      const b = (x, C, T, R) => {
        if (R.F() || R.oa()) return R;
        for (x = R.O(), C = g, T = x.length - 1; 1 < T; T--) {
          C = ka(i, C).rb, R = C % T;
          const P = x[R];
          x[R] = x[T], x[T] = P;
        }
        return N.create(x);
      };
      return N.m(new Dr([{ key: M("number", 1), value: () => N.m(M(ka(i, g).$b, 3)) }, { key: M("next", 1), value: () => N.m(new oi({ value: () => h(ka(i, g).rb), Ya: !0, localName: "", namespaceURI: "", j: [], arity: 0, i: { type: 61, g: 3 } })) }, { key: M("permute", 1), value: () => N.m(new oi({
        value: b,
        Ya: !0,
        localName: "",
        namespaceURI: "",
        j: [{ type: 59, g: 2 }],
        arity: 1,
        i: { type: 59, g: 2 }
      })) }]));
    }
    return s = u.F() ? ka(i) : ka(i, aE(He(u.first(), 1).value)), h(s.rb);
  };
  var lE = [{ namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "abs", j: [{ type: 2, g: 0 }], i: { type: 2, g: 0 }, callFunction: (i, s, c, u) => u.map((h) => _d(h.type, Math.abs(h.value))) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "format-integer", j: [{ type: 5, g: 0 }, { type: 1, g: 3 }], i: { type: 1, g: 3 }, callFunction: (i, s, c, u, h) => (i = u.first(), h = h.first(), u.F() ? N.m(M("", 1)) : (u = iE.get(h.value), h = i.value, u ? (u = u(h), N.m(M(u, 1))) : N.m(M(h.toString(), 1)))) }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "ceiling",
    j: [{ type: 2, g: 0 }],
    i: { type: 2, g: 0 },
    callFunction: (i, s, c, u) => u.map((h) => _d(h.type, Math.ceil(h.value)))
  }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "floor", j: [{ type: 2, g: 0 }], i: { type: 2, g: 0 }, callFunction: (i, s, c, u) => u.map((h) => _d(h.type, Math.floor(h.value))) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "round", j: [{ type: 2, g: 0 }], i: { type: 2, g: 0 }, callFunction: Ko.bind(null, !1) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "round", j: [{
    type: 2,
    g: 0
  }, { type: 5, g: 3 }], i: { type: 2, g: 0 }, callFunction: Ko.bind(null, !1) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "round-half-to-even", j: [{ type: 2, g: 0 }], i: { type: 2, g: 0 }, callFunction: Ko.bind(null, !0) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "round-half-to-even", j: [{ type: 2, g: 0 }, { type: 5, g: 3 }], i: { type: 2, g: 0 }, callFunction: Ko.bind(null, !0) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "number", j: [{ type: 46, g: 0 }], i: { type: 3, g: 3 }, callFunction: Lg }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "number",
    j: [],
    i: { type: 3, g: 3 },
    callFunction: (i, s, c) => {
      const u = i.M && cr({ type: 46, g: 0 }, N.m(i.M), s, "fn:number", !1);
      if (!u) throw _n("fn:number needs an atomizable context item.");
      return Lg(i, s, c, u);
    }
  }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "random-number-generator", j: [], i: { type: 61, g: 3 }, callFunction: Hg }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "random-number-generator", j: [{ type: 46, g: 0 }], i: { type: 61, g: 3 }, callFunction: Hg }];
  function oc() {
    throw Error("FOCH0002: No collations are supported");
  }
  const Sa = (i, s, c, u) => u.X({ empty: () => N.m(M("", 1)), default: () => u.map((h) => {
    if (I(h.type, 53)) {
      const g = Pr(h, s).first();
      return I(h.type, 47) ? He(g, 1) : g;
    }
    return He(h, 1);
  }) }), Gg = (i, s, c, u, h) => Oe([h], ([g]) => at(u, s).N((b) => (b = b.map((x) => He(x, 1).value).join(g.value), N.m(M(b, 1))))), _g = (i, s, c, u) => u.F() ? N.m(M(0, 5)) : (i = u.first().value, N.m(M(Array.from(i).length, 5))), zg = (i, s, c, u, h, g) => {
    const b = Ko(!1, i, s, c, h, null), x = g !== null ? Ko(!1, i, s, c, g, null) : null;
    let C = !1, T = null, R = null, P = null;
    return N.create({ next: () => C ? H : !T && (T = u.first(), T === null) ? (C = !0, j(M("", 1))) : (R || (R = b.first()), !P && g && (P = null, P = x.first()), C = !0, j(M(Array.from(T.value).slice(Math.max(R.value - 1, 0), g ? R.value + P.value - 1 : void 0).join(""), 1))) });
  }, qg = (i, s, c, u, h) => {
    if (u.F() || u.first().value.length === 0) return N.empty();
    for (i = u.first().value, h = h.first().value, h = Xg(h), h.lastIndex = 0, s = [], c = h.exec(i), u = 0; c; ) s.push(i.slice(u, c.index)), u = h.lastIndex, c = h.exec(i);
    return s.push(i.slice(u)), N.create(s.map((g) => M(g, 1)));
  }, Jd = (i, s, c, u) => u.F() ? N.m(M(
    "",
    1
  )) : (i = u.first().value.trim(), N.m(M(i.replace(/\s+/g, " "), 1))), Vg = /* @__PURE__ */ new Map(), Kd = /* @__PURE__ */ new Map();
  function Xg(i) {
    if (Kd.has(i)) return Kd.get(i);
    let s;
    try {
      s = new RegExp(i, "g");
    } catch (c) {
      throw Error(`FORX0002: ${c}`);
    }
    if (s.test("")) throw Error(`FORX0003: the pattern ${i} matches the zero length string`);
    return Kd.set(i, s), s;
  }
  var cE = [{ namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "compare", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }], i: { type: 5, g: 0 }, callFunction: (i, s, c, u, h) => u.F() || h.F() ? N.empty() : (i = u.first().value, h = h.first().value, i > h ? N.m(M(1, 5)) : i < h ? N.m(M(-1, 5)) : N.m(M(0, 5))) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "compare", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }, { type: 1, g: 3 }], i: { type: 5, g: 0 }, callFunction: oc }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "concat",
    j: [{ type: 46, g: 0 }, { type: 46, g: 0 }, 4],
    i: { type: 1, g: 3 },
    callFunction: (i, s, c, ...u) => (u = u.map((h) => at(h, s).N((g) => N.m(M(g.map((b) => b === null ? "" : He(b, 1).value).join(""), 1)))), Oe(u, (h) => N.m(M(h.map((g) => g.value).join(""), 1))))
  }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "contains", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }, { type: 1, g: 0 }], i: { type: 0, g: 3 }, callFunction: oc }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "contains", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }], i: { type: 0, g: 3 }, callFunction: (i, s, c, u, h) => (i = u.F() ? "" : u.first().value, h = h.F() ? "" : h.first().value, h.length === 0 ? N.aa() : i.length === 0 ? N.T() : i.includes(h) ? N.aa() : N.T()) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "ends-with", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }], i: { type: 0, g: 3 }, callFunction: (i, s, c, u, h) => (i = h.F() ? "" : h.first().value, i.length === 0 ? N.aa() : (u = u.F() ? "" : u.first().value, u.length === 0 ? N.T() : u.endsWith(i) ? N.aa() : N.T())) }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "ends-with",
    j: [{ type: 1, g: 0 }, { type: 1, g: 0 }, { type: 1, g: 3 }],
    i: { type: 0, g: 3 },
    callFunction: oc
  }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "normalize-space", j: [{ type: 1, g: 0 }], i: { type: 1, g: 3 }, callFunction: Jd }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "normalize-space", j: [], i: { type: 1, g: 3 }, callFunction: Bn("normalize-space", 1, (i, s, c, u) => Jd(i, s, c, Sa(i, s, c, u))) }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "starts-with",
    j: [{ type: 1, g: 0 }, { type: 1, g: 0 }],
    i: { type: 0, g: 3 },
    callFunction: (i, s, c, u, h) => (i = h.F() ? "" : h.first().value, i.length === 0 ? N.aa() : (u = u.F() ? "" : u.first().value, u.length === 0 ? N.T() : u.startsWith(i) ? N.aa() : N.T()))
  }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "starts-with", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }, { type: 1, g: 3 }], i: { type: 0, g: 3 }, callFunction: oc }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "string", j: [{ type: 59, g: 0 }], i: { type: 1, g: 3 }, callFunction: Sa }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "string",
    j: [],
    i: { type: 1, g: 3 },
    callFunction: Bn("string", 59, Sa)
  }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "substring-before", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }], i: { type: 1, g: 3 }, callFunction: (i, s, c, u, h) => (i = u.F() ? "" : u.first().value, h = h.F() ? "" : h.first().value, h === "" ? N.m(M("", 1)) : (h = i.indexOf(h), h === -1 ? N.m(M("", 1)) : N.m(M(i.substring(0, h), 1)))) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "substring-after", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }], i: {
    type: 1,
    g: 3
  }, callFunction: (i, s, c, u, h) => (i = u.F() ? "" : u.first().value, h = h.F() ? "" : h.first().value, h === "" ? N.m(M(i, 1)) : (s = i.indexOf(h), s === -1 ? N.m(M("", 1)) : N.m(M(i.substring(s + h.length), 1)))) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "substring", j: [{ type: 1, g: 0 }, { type: 3, g: 3 }], i: { type: 1, g: 3 }, callFunction: zg }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "substring", j: [{ type: 1, g: 0 }, { type: 3, g: 3 }, { type: 3, g: 3 }], i: { type: 1, g: 3 }, callFunction: zg }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "upper-case",
    j: [{ type: 1, g: 0 }],
    i: { type: 1, g: 3 },
    callFunction: (i, s, c, u) => u.F() ? N.m(M("", 1)) : u.map((h) => M(h.value.toUpperCase(), 1))
  }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "lower-case", j: [{ type: 1, g: 0 }], i: { type: 1, g: 3 }, callFunction: (i, s, c, u) => u.F() ? N.m(M("", 1)) : u.map((h) => M(h.value.toLowerCase(), 1)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "string-join", j: [{ type: 46, g: 2 }, { type: 1, g: 3 }], i: { type: 1, g: 3 }, callFunction: Gg }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "string-join",
    j: [{ type: 46, g: 2 }],
    i: { type: 1, g: 3 },
    callFunction(i, s, c, u) {
      return Gg(i, s, c, u, N.m(M("", 1)));
    }
  }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "string-length", j: [{ type: 1, g: 0 }], i: { type: 5, g: 3 }, callFunction: _g }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "string-length", j: [], i: { type: 5, g: 3 }, callFunction: Bn("string-length", 46, (i, s, c, u) => _g(i, s, c, Sa(i, s, c, u))) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "tokenize", j: [{
    type: 1,
    g: 0
  }, { type: 1, g: 3 }, { type: 1, g: 3 }], i: { type: 1, g: 2 }, callFunction() {
    throw Error("Not implemented: Using flags in tokenize is not supported");
  } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "tokenize", j: [{ type: 1, g: 0 }, { type: 1, g: 3 }], i: { type: 1, g: 2 }, callFunction: qg }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "tokenize", j: [{ type: 1, g: 0 }], i: { type: 1, g: 2 }, callFunction(i, s, c, u) {
    return qg(i, s, c, Jd(i, s, c, u), N.m(M(" ", 1)));
  } }, { j: [{ type: 1, g: 0 }, { type: 1, g: 3 }, { type: 1, g: 3 }], callFunction: (i, s, c, u, h, g) => Oe([u, h, g], ([b, x, C]) => {
    b = Array.from(b ? b.value : "");
    const T = Array.from(x.value), R = Array.from(C.value);
    return x = b.map((P) => {
      if (T.includes(P)) {
        if (P = T.indexOf(P), P <= R.length) return R[P];
      } else return P;
    }), N.m(M(x.join(""), 1));
  }), localName: "translate", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 } }, { j: [{ type: 5, g: 2 }], callFunction: (i, s, c, u) => u.N((h) => (h = h.map((g) => {
    if (g = g.value, g === 9 || g === 10 || g === 13 || 32 <= g && 55295 >= g || 57344 <= g && 65533 >= g || 65536 <= g && 1114111 >= g) return String.fromCodePoint(g);
    throw Error("FOCH0001");
  }).join(""), N.m(M(h, 1)))), localName: "codepoints-to-string", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 } }, { j: [{ type: 1, g: 0 }], callFunction: (i, s, c, u) => Oe([u], ([h]) => (h = h ? h.value.split("") : [], h.length === 0 ? N.empty() : N.create(h.map((g) => M(g.codePointAt(0), 5))))), localName: "string-to-codepoints", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 5, g: 2 } }, { j: [{ type: 1, g: 0 }], callFunction: (i, s, c, u) => Oe([u], ([h]) => h === null || h.value.length === 0 ? N.create(M("", 1)) : N.create(M(encodeURIComponent(h.value).replace(/[!'()*]/g, (g) => "%" + g.charCodeAt(0).toString(16).toUpperCase()), 1))), localName: "encode-for-uri", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 } }, {
    j: [{ type: 1, g: 0 }],
    callFunction: (i, s, c, u) => Oe([u], ([h]) => h === null || h.value.length === 0 ? N.create(M("", 1)) : N.create(M(h.value.replace(/([\u00A0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFEF "<>{}|\\^`/\n\u007f\u0080-\u009f]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g, (g) => encodeURI(g)), 1))),
    localName: "iri-to-uri",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: { type: 1, g: 3 }
  }, { j: [{ type: 1, g: 0 }, { type: 1, g: 0 }], callFunction: (i, s, c, u, h) => Oe([u, h], ([g, b]) => {
    if (g === null || b === null) return N.empty();
    g = g.value;
    var x = b.value;
    if (g.length !== x.length) return N.T();
    for (b = g.split(""), g = x.split(""), x = 0; x < b.length; x++) if (b[x].codePointAt(0) !== g[x].codePointAt(0)) return N.T();
    return N.aa();
  }), localName: "codepoint-equal", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 0, g: 0 } }, { j: [{ type: 1, g: 0 }, { type: 1, g: 3 }], callFunction: (i, s, c, u, h) => Oe([u, h], ([g, b]) => {
    g = g ? g.value : "", b = b.value;
    let x = Vg.get(b);
    if (!x) {
      try {
        x = (0, tE.compile)(b, { language: "xpath" });
      } catch (C) {
        throw Error(`FORX0002: ${C}`);
      }
      Vg.set(b, x);
    }
    return x(g) ? N.aa() : N.T();
  }), localName: "matches", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 0, g: 3 } }, { j: [{ type: 1, g: 0 }, { type: 1, g: 3 }, { type: 1, g: 3 }], callFunction: (i, s, c, u, h, g) => Oe([u, h, g], ([b, x, C]) => {
    if (b = b ? b.value : "", x = x.value, C = C.value, C.includes("$0")) throw Error("Using $0 in fn:replace to replace substrings with full matches is not supported.");
    return C = C.split(/((?:\$\$)|(?:\\\$)|(?:\\\\))/).map((T) => {
      switch (T) {
        case "\\$":
          return "$$";
        case "\\\\":
          return "\\";
        case "$$":
          throw Error('FORX0004: invalid replacement: "$$"');
        default:
          return T;
      }
    }).join(""), x = Xg(x), b = b.replace(x, C), N.m(M(b, 1));
  }), localName: "replace", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 } }, { j: [{ type: 1, g: 0 }, { type: 1, g: 3 }, { type: 1, g: 3 }, { type: 1, g: 3 }], localName: "replace", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 }, callFunction() {
    throw Error("Not implemented: Using flags in replace is not supported");
  } }];
  const Wd = /* @__PURE__ */ new WeakMap();
  let uE = 0;
  const Xi = (i, s, c, u) => Oe([u], ([h]) => {
    if (h === null) return N.empty();
    switch (h = h.value, h.node.nodeType) {
      case 1:
      case 2:
        return N.m(M(new _t(h.node.prefix, h.node.namespaceURI, h.node.localName), 23));
      case 7:
        return N.m(M(new _t("", "", h.node.target), 23));
      default:
        return N.empty();
    }
  }), Jg = (i, s, c, u) => u.X({ default: () => Sa(i, s, c, Xi(i, s, c, u)), empty: () => N.m(M("", 1)) }), Kg = (i, s, c, u) => at(u, s), Wg = (i, s, c, u) => {
    if (u.F()) return N.m(M("", 1));
    if (!I(u.first().type, 53)) throw Error("XPTY0004: The context item must be a node.");
    return c = u.first().value, i = N, s = i.m, c = c.node, Wd.has(c) || Wd.set(c, `id${++uE}`), c = Wd.get(c), s.call(i, M(c, 1));
  }, Yg = (i, s, c, u) => Oe([u], ([h]) => (h = h ? h.value : null, h !== null && Jl(s.h, h, null) ? N.aa() : N.T()));
  function Qg(i, s) {
    return i = i.toLowerCase(), s = s.toLowerCase(), i === s ? !0 : 5 > i.length || !i.startsWith(s) ? !1 : Qg(i.replace(/-[a-z0-9]+$/, ""), s);
  }
  const Zg = (i, s, c, u, h) => {
    if (s = s.h, u.F()) u = "";
    else if (I(u.first().type, 1)) u = u.first().value;
    else throw Error("XPTY0004: The first argument of lang must be a string.");
    if (h) h = h.first().value;
    else {
      if (!i || !i.M) throw _n("The function lang depends on dynamic context if a node is not passed as the second argument.");
      if (!I(i.M.type, 53)) throw Error("XPTY0004: The context item must be a node.");
      h = i.M.value;
    }
    e: {
      for (i = u; h; ) if (h.node.nodeType !== 1) h = Ie(s, h);
      else if (h.node.nodeType === 1) {
        if (u = Bd(s, h, "xml:lang")) {
          s = Qg(
            u,
            i
          ) ? N.aa() : N.T();
          break e;
        }
        h = Ie(s, h);
      }
      s = N.T();
    }
    return s;
  }, ey = (i, s, c, u) => Oe([u], ([h]) => {
    function g(T) {
      let R = 0, P = T;
      for (; P !== null; ) T.node.nodeType === P.node.nodeType && (P.node.nodeType === 1 ? P.node.localName === T.node.localName && P.node.namespaceURI === T.node.namespaceURI : P.node.nodeType !== 7 || P.node.target === T.node.target) && R++, P = ya(b, P, null);
      return R;
    }
    if (h === null) return N.empty();
    const b = s.h;
    let x = "";
    for (h = h.value; Ie(s.h, h, null) !== null; h = Ie(s.h, h, null)) switch (h.node.nodeType) {
      case 1:
        var C = h;
        x = `/Q{${C.node.namespaceURI || ""}}${C.node.localName}[${g(C)}]${x}`;
        break;
      case 2:
        C = h, x = `/@${C.node.namespaceURI ? `Q{${C.node.namespaceURI}}` : ""}${C.node.localName}${x}`;
        break;
      case 3:
        x = `/text()[${g(h)}]${x}`;
        break;
      case 7:
        C = h, x = `/processing-instruction(${C.node.target})[${g(C)}]${x}`;
        break;
      case 8:
        x = `/comment()[${g(h)}]${x}`;
    }
    return h.node.nodeType === 9 ? N.create(M(x || "/", 1)) : N.create(M("Q{http://www.w3.org/2005/xpath-functions}root()" + x, 1));
  }), ty = (i, s, c, u) => u.map((h) => M(h.value.node.namespaceURI || "", 20)), ny = (i, s, c, u) => u.X({ default: () => u.map((h) => h.value.node.nodeType === 7 ? M(h.value.node.target, 1) : M(h.value.node.localName || "", 1)), empty: () => N.m(M("", 1)) });
  function ry(i, s, c) {
    if (s.node.nodeType === 2) return mt(s, c);
    for (; c; ) {
      if (mt(s, c)) return !0;
      if (c.node.nodeType === 9) break;
      c = Ie(i, c, null);
    }
    return !1;
  }
  const iy = (i, s, c, u) => u.map((h) => {
    if (!I(h.type, 53)) throw Error("XPTY0004 Argument passed to fn:root() should be of the type node()");
    let g;
    for (h = h.value; h; ) g = h, h = Ie(s.h, g, null);
    return _e(g);
  });
  var dE = [{ j: [{ type: 53, g: 0 }], callFunction: Jg, localName: "name", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 } }, { j: [], callFunction: Bn("name", 53, Jg), localName: "name", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 } }, { j: [{ type: 53, g: 3 }], callFunction: ty, localName: "namespace-uri", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 20, g: 3 } }, {
    j: [],
    callFunction: Bn("namespace-uri", 53, ty),
    localName: "namespace-uri",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: { type: 20, g: 3 }
  }, { j: [{ type: 53, g: 2 }], callFunction: (i, s, c, u) => u.N((h) => h.length ? (h = Ca(s.h, h).reduceRight((g, b, x, C) => x === C.length - 1 ? (g.push(b), g) : (ry(s.h, b.value, g[0].value) || g.unshift(b), g), []), N.create(h)) : N.empty()), localName: "innermost", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 53, g: 2 } }, { j: [{ type: 53, g: 2 }], callFunction: (i, s, c, u) => u.N((h) => h.length ? (h = Ca(s.h, h).reduce((g, b, x) => x === 0 ? (g.push(b), g) : (ry(s.h, g[g.length - 1].value, b.value) || g.push(b), g), []), N.create(h)) : N.empty(), 1), localName: "outermost", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 53, g: 2 } }, { j: [{ type: 53, g: 0 }], callFunction: Yg, localName: "has-children", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 0, g: 3 } }, { j: [], callFunction: Bn("has-children", 53, Yg), localName: "has-children", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 0, g: 3 } }, {
    j: [{ type: 53, g: 0 }],
    callFunction: ey,
    localName: "path",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: { type: 1, g: 0 }
  }, { j: [], callFunction: Bn("path", 53, ey), localName: "path", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 0 } }, { j: [{ type: 53, g: 0 }], callFunction: Xi, localName: "node-name", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 23, g: 0 } }, { j: [], callFunction: Bn("node-name", 53, Xi), localName: "node-name", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 23, g: 0 } }, {
    j: [{ type: 53, g: 0 }],
    callFunction: ny,
    localName: "local-name",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: { type: 1, g: 3 }
  }, { j: [], callFunction: Bn("local-name", 53, ny), localName: "local-name", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 } }, { j: [{ type: 53, g: 0 }], callFunction: iy, localName: "root", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 53, g: 0 } }, { j: [], callFunction: Bn("root", 53, iy), localName: "root", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 53, g: 0 } }, {
    j: [],
    callFunction: Bn("data", 59, Kg),
    localName: "data",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: { type: 46, g: 2 }
  }, { j: [{ type: 59, g: 2 }], callFunction: Kg, localName: "data", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 2 } }, { j: [{ type: 1, g: 0 }], callFunction: Zg, localName: "lang", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 0, g: 3 } }, { j: [{ type: 1, g: 0 }, { type: 53, g: 3 }], callFunction: Zg, localName: "lang", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 0, g: 3 } }, {
    j: [],
    callFunction: Bn("generate-id", 53, Wg),
    localName: "generate-id",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: { type: 1, g: 3 }
  }, { j: [{ type: 53, g: 0 }], callFunction: Wg, localName: "generate-id", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 } }];
  function oy(i, s) {
    let c = 0;
    const u = i.length;
    let h = !1, g = null;
    return { next: () => {
      if (!h) {
        for (; c < u; ) {
          g || (g = s(i[c], c, i));
          const b = g.next(0);
          if (g = null, b.value) c++;
          else return j(!1);
        }
        return h = !0, j(!0);
      }
      return H;
    } };
  }
  function sy(i) {
    return i = i.node.nodeType, i === 1 || i === 3;
  }
  function Ea(i, s) {
    if ((I(i.type, 4) || I(i.type, 6)) && (I(s.type, 4) || I(s.type, 6))) {
      var c = He(i, 6), u = He(s, 6);
      return c.value === u.value || isNaN(i.value) && isNaN(s.value);
    }
    return (I(i.type, 4) || I(i.type, 6) || I(i.type, 3)) && (I(s.type, 4) || I(s.type, 6) || I(s.type, 3)) ? (c = He(i, 3), u = He(s, 3), c.value === u.value || isNaN(i.value) && isNaN(s.value)) : I(i.type, 23) && I(s.type, 23) ? i.value.namespaceURI === s.value.namespaceURI && i.value.localName === s.value.localName : (I(i.type, 9) || I(i.type, 7) || I(i.type, 8) || I(i.type, 11) || I(i.type, 12) || I(
      i.type,
      13
    ) || I(i.type, 14) || I(i.type, 15)) && (I(s.type, 9) || I(s.type, 7) || I(s.type, 8) || I(s.type, 11) || I(s.type, 12) || I(s.type, 13) || I(s.type, 14) || I(s.type, 15)) ? qi(i.value, s.value) : (I(i.type, 16) || I(i.type, 17) || I(i.type, 18)) && (I(s.type, 16) || I(s.type, 17) || I(s.type, 17)) ? Rr(i.value, s.value) : i.value === s.value;
  }
  function pE(i, s, c) {
    const [u, h] = [s, c].map((g) => ({ type: 1, value: g.reduce((b, x) => b += Pr(x, i).first().value, "") }));
    return j(Ea(u, h));
  }
  function ay(i, s, c, u) {
    for (; i.value && I(i.value.type, 56); ) {
      s.push(i.value);
      const h = ai(u, i.value.value);
      if (i = c.next(0), h && h.node.nodeType !== 3) break;
    }
    return i;
  }
  function ui(i, s, c, u, h) {
    const g = s.h, b = u.value, x = h.value;
    let C = null, T = null, R = null, P;
    const q = [], _ = [];
    return { next: () => {
      for (; !P; ) if (C || (C = b.next(0)), C = ay(C, q, b, g), T || (T = x.next(0)), T = ay(T, _, x, g), q.length || _.length) {
        var ie = pE(s, q, _);
        if (q.length = 0, _.length = 0, ie.value === !1) return P = !0, ie;
      } else {
        if (C.done || T.done) return P = !0, j(C.done === T.done);
        if (R || (R = Yd(i, s, c, C.value, T.value)), ie = R.next(0), R = null, ie.value === !1) return P = !0, ie;
        T = C = null;
      }
      return H;
    } };
  }
  function hE(i, s, c, u, h) {
    return u.h.length !== h.h.length ? $r(!1) : oy(u.h, (g) => {
      const b = h.h.find((x) => Ea(x.key, g.key));
      return b ? ui(i, s, c, g.value(), b.value()) : $r(!1);
    });
  }
  function fE(i, s, c, u, h) {
    return u.h.length !== h.h.length ? $r(!1) : oy(u.h, (g, b) => (b = h.h[b], ui(i, s, c, g(), b())));
  }
  function ly(i, s, c, u, h) {
    return u = sr(s.h, u.value), h = sr(s.h, h.value), u = u.filter((g) => sy(g)), h = h.filter((g) => sy(g)), u = N.create(u.map((g) => _e(g))), h = N.create(h.map((g) => _e(g))), ui(i, s, c, u, h);
  }
  function mE(i, s, c, u, h) {
    const g = ui(i, s, c, Xi(i, s, c, N.m(u)), Xi(i, s, c, N.m(h))), b = ly(i, s, c, u, h);
    u = zo(s.h, u.value).filter((T) => T.node.namespaceURI !== "http://www.w3.org/2000/xmlns/").sort((T, R) => T.node.nodeName > R.node.nodeName ? 1 : -1).map((T) => _e(T)), h = zo(s.h, h.value).filter((T) => T.node.namespaceURI !== "http://www.w3.org/2000/xmlns/").sort((T, R) => T.node.nodeName > R.node.nodeName ? 1 : -1).map((T) => _e(T));
    const x = ui(i, s, c, N.create(u), N.create(h));
    let C = !1;
    return { next: () => {
      if (C) return H;
      var T = g.next(0);
      return !T.done && T.value === !1 || (T = x.next(0), !T.done && T.value === !1) ? (C = !0, T) : (T = b.next(0), C = !0, T);
    } };
  }
  function gE(i, s, c, u, h) {
    const g = ui(i, s, c, Xi(i, s, c, N.m(u)), Xi(i, s, c, N.m(h)));
    let b = !1;
    return { next: () => {
      if (b) return H;
      const x = g.next(0);
      return x.done || x.value !== !1 ? j(Ea(Pr(u, s).first(), Pr(h, s).first())) : (b = !0, x);
    } };
  }
  function Yd(i, s, c, u, h) {
    if (I(u.type, 46) && I(h.type, 46)) return $r(Ea(u, h));
    if (I(u.type, 61) && I(h.type, 61)) return hE(i, s, c, u, h);
    if (I(u.type, 62) && I(h.type, 62)) return fE(i, s, c, u, h);
    if (I(u.type, 53) && I(h.type, 53)) {
      if (I(u.type, 55) && I(h.type, 55)) return ly(i, s, c, u, h);
      if (I(u.type, 54) && I(h.type, 54)) return mE(i, s, c, u, h);
      if (I(u.type, 47) && I(h.type, 47) || I(u.type, 57) && I(h.type, 57) || I(u.type, 58) && I(h.type, 58)) return gE(i, s, c, u, h);
    }
    return $r(!1);
  }
  var yE = class extends Vo {
    constructor() {
      super({ M: null, Aa: -1, ta: N.empty(), ra: {} });
    }
  }, jr = (i = "Can not execute an updating expression in a non-updating context.") => Error(`XUST0001: ${i}`), wE = (i) => Error(`XUTY0004: The attribute ${i.name}="${i.value}" follows a node that is not an attribute node.`), cy = () => Error("XUTY0005: The target of a insert expression with into must be a single element or document node."), uy = () => Error("XUTY0006: The target of a insert expression with before or after must be a single element, text, comment, or processing instruction node."), sc = () => Error("XUTY0008: The target of a replace expression must be a single element, attribute, text, comment, or processing instruction node."), dy = () => Error("XUTY0012: The target of a rename expression must be a single element, attribute, or processing instruction node."), py = (i) => Error(`XUDY0017: The target ${i.outerHTML} is used in more than one replace value of expression.`), hy = (i) => Error(`XUDY0021: Applying the updates will result in the XDM instance violating constraint: '${i}'`), ac = (i) => Error(`XUDY0023: The namespace binding ${i} is conflicting.`), lc = (i) => Error(`XUDY0024: The namespace binding ${i} is conflicting.`), cc = () => Error("XUDY0027: The target for an insert, replace, or rename expression expression should not be empty.");
  function he(i, s, c) {
    return s && s.M !== null && i.B ? (i.ob === null && (i.ob = st(i.h(new yE(), c).hb())), i = i.ob()) : i = i.h(s, c), i;
  }
  var Ae = class {
    constructor(i, s, c = { B: !1, W: !1, R: "unsorted", subtree: !1 }, u = !1, h) {
      this.o = i, this.ia = c.R || "unsorted", this.subtree = !!c.subtree, this.W = !!c.W, this.B = !!c.B, this.Fa = s, this.I = !1, this.ob = null, this.Qb = u, this.type = h;
    }
    D() {
      return null;
    }
    v(i) {
      if (this.Fa.forEach((s) => s.v(i)), !this.Qb && this.Fa.some((s) => s.I)) throw jr();
    }
  }, fy = class {
    constructor(i, s) {
      this.J = i, this.da = s;
    }
  }, my = class {
    constructor(i) {
      i && typeof i == "object" && "nodeType" in i && (i = i.ownerDocument || i, typeof i.createElementNS == "function" && typeof i.createProcessingInstruction == "function" && typeof i.createTextNode == "function" && typeof i.createComment == "function" && (this.h = i)), this.h || (this.h = null);
    }
    createAttributeNS(i, s) {
      if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors");
      return this.h.createAttributeNS(i, s);
    }
    createCDATASection(i) {
      if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors");
      return this.h.createCDATASection(i);
    }
    createComment(i) {
      if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors");
      return this.h.createComment(i);
    }
    createDocument() {
      if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors");
      return this.h.implementation.createDocument(null, null, null);
    }
    createElementNS(i, s) {
      if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors");
      return this.h.createElementNS(
        i,
        s
      );
    }
    createProcessingInstruction(i, s) {
      if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors");
      return this.h.createProcessingInstruction(i, s);
    }
    createTextNode(i) {
      if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors");
      return this.h.createTextNode(i);
    }
  };
  function gy(i, s, c, u) {
    return zo(u, i, `name-${s}`).some((h) => h.node.localName === s && h.node.namespaceURI === c);
  }
  var bE = (i, s, c, u) => {
    const h = Ie(c, i).node, g = (i = ai(c, i)) ? i.node : null;
    s.forEach((b) => {
      u.insertBefore(h, b.node, g);
    });
  }, vE = (i, s, c, u) => {
    const h = Ie(c, i).node;
    s.forEach((g) => {
      u.insertBefore(h, g.node, i.node);
    });
  }, xE = (i, s, c, u) => {
    const h = (c = Jl(c, i)) ? c.node : null;
    s.forEach((g) => {
      u.insertBefore(i.node, g.node, h);
    });
  }, yy = (i, s, c) => {
    s.forEach((u) => {
      c.insertBefore(i.node, u.node, null);
    });
  }, kE = (i, s, c, u) => {
    s.forEach((h) => {
      const g = h.node.localName, b = h.node.namespaceURI;
      if (gy(i, g, b, c)) throw hy(`An attribute ${b ? `Q{${b}}${g}` : g} already exists.`);
      u.setAttributeNS(i.node, b, g, Et(c, h));
    });
  }, AE = (i, s, c, u, h) => {
    u || (u = new my(i ? i.node : null));
    let g;
    switch (i.node.nodeType) {
      case 1:
        const b = c.getAllAttributes(i.node), x = c.getChildNodes(i.node), C = u.createElementNS(s.namespaceURI, s.za());
        g = { node: C, G: null }, b.forEach((T) => {
          h.setAttributeNS(C, T.namespaceURI, T.nodeName, T.value);
        }), x.forEach((T) => {
          h.insertBefore(C, T, null);
        });
        break;
      case 2:
        s = u.createAttributeNS(s.namespaceURI, s.za()), s.value = Et(c, i), g = { node: s, G: null };
        break;
      case 7:
        g = { node: u.createProcessingInstruction(
          s.za(),
          Et(c, i)
        ), G: null };
    }
    if (!Ie(c, i)) throw Error("Not supported: renaming detached nodes.");
    wy(i, [g], c, h);
  }, CE = (i, s, c, u) => {
    c.getChildNodes(i.node).forEach((h) => u.removeChild(i.node, h)), s && u.insertBefore(i.node, s.node, null);
  }, wy = (i, s, c, u) => {
    const h = Ie(c, i);
    var g = i.node.nodeType;
    if (g === 2) {
      if (s.some((x) => x.node.nodeType !== 2)) throw Error('Constraint "If $target is an attribute node, $replacement must consist of zero or more attribute nodes." failed.');
      const b = h ? h.node : null;
      u.removeAttributeNS(b, i.node.namespaceURI, i.node.localName), s.forEach((x) => {
        const C = x.node.localName, T = x.node.namespaceURI;
        if (gy(h, C, T, c)) throw hy(`An attribute ${T ? `Q{${T}}${C}` : C} already exists.`);
        u.setAttributeNS(b, T, C, Et(c, x));
      });
    }
    if (g === 1 || g === 3 || g === 8 || g === 7) {
      const b = (g = ai(c, i)) ? g.node : null;
      u.removeChild(h.node, i.node), s.forEach((x) => {
        u.insertBefore(h.node, x.node, b);
      });
    }
  }, by = (i, s, c, u) => {
    if (SE(i, s), i.filter((h) => ["insertInto", "insertAttributes", "replaceValue", "rename"].indexOf(h.type) !== -1).forEach((h) => {
      switch (h.type) {
        case "insertInto":
          yy(h.target, h.content, u);
          break;
        case "insertAttributes":
          kE(h.target, h.content, s, u);
          break;
        case "rename":
          AE(h.target, h.o, s, c, u);
          break;
        case "replaceValue":
          var g = h.target;
          if (h = h.o, g.node.nodeType === 2) {
            const b = Ie(s, g);
            b ? u.setAttributeNS(b.node, g.node.namespaceURI, g.node.localName, h) : g.node.value = h;
          } else u.setData(g.node, h);
      }
    }), i.filter((h) => ["insertBefore", "insertAfter", "insertIntoAsFirst", "insertIntoAsLast"].indexOf(h.type) !== -1).forEach((h) => {
      switch (h.type) {
        case "insertAfter":
          bE(h.target, h.content, s, u);
          break;
        case "insertBefore":
          vE(h.target, h.content, s, u);
          break;
        case "insertIntoAsFirst":
          xE(h.target, h.content, s, u);
          break;
        case "insertIntoAsLast":
          yy(h.target, h.content, u);
      }
    }), i.filter((h) => h.type === "replaceNode").forEach((h) => {
      wy(h.target, h.o, s, u);
    }), i.filter((h) => h.type === "replaceElementContent").forEach((h) => {
      CE(h.target, h.text, s, u);
    }), i.filter((h) => h.type === "delete").forEach((h) => {
      h = h.target;
      var g = Ie(s, h);
      (g = g ? g.node : null) && (h.node.nodeType === 2 ? u.removeAttributeNS(g, h.node.namespaceURI, h.node.localName) : u.removeChild(g, h.node));
    }), i.some((h) => h.type === "put")) throw Error('Not implemented: the execution for pendingUpdate "put" is not yet implemented.');
  };
  const SE = (i, s) => {
    function c(g, b) {
      const x = /* @__PURE__ */ new Set();
      i.filter((C) => C.type === g).map((C) => C.target).forEach((C) => {
        C = C ? C.node : null, x.has(C) && b(C), x.add(C);
      });
    }
    c("rename", (g) => {
      throw Error(`XUDY0015: The target ${g.outerHTML} is used in more than one rename expression.`);
    }), c("replaceNode", (g) => {
      throw Error(`XUDY0016: The target ${g.outerHTML} is used in more than one replace expression.`);
    }), c("replaceValue", (g) => {
      throw py(g);
    }), c("replaceElementContent", (g) => {
      throw py(g);
    });
    const u = /* @__PURE__ */ new Map(), h = (g) => new _t(
      g.node.prefix,
      g.node.namespaceURI,
      g.node.localName
    );
    i.filter((g) => g.type === "replaceNode" && g.target.node.nodeType === 2).forEach((g) => {
      var b = Ie(s, g.target);
      b = b ? b.node : null;
      const x = u.get(b);
      x ? x.push(...g.o.map(h)) : u.set(b, g.o.map(h));
    }), i.filter((g) => g.type === "rename" && g.target.node.nodeType === 2).forEach((g) => {
      var b = Ie(s, g.target);
      if (b) {
        b = b.node;
        var x = u.get(b);
        x ? x.push(g.o) : u.set(b, [g.o]);
      }
    }), u.forEach((g) => {
      const b = {};
      g.forEach((x) => {
        if (b[x.prefix] || (b[x.prefix] = x.namespaceURI), b[x.prefix] !== x.namespaceURI) throw lc(x.namespaceURI);
      });
    });
  };
  var zn = (i, ...s) => i.concat(...s.filter(Boolean));
  function pr(i) {
    return i.I ? (s, c) => i.s(s, c) : (s, c) => {
      const u = i.h(s, c);
      return { next: () => {
        const h = u.O();
        return j({ da: [], J: h });
      } };
    };
  }
  var Wo = class extends Ae {
    constructor(i, s, c, u) {
      super(i, s, c, !0, u), this.I = !0;
    }
    h() {
      throw jr();
    }
  };
  function Yo(i, s) {
    return i = i.next(0), s(i.value.da), N.create(i.value.J);
  }
  function EE(i) {
    i.Fa.some((s) => s.I) && (i.I = !0);
  }
  var Qo = class extends Wo {
    constructor(i, s, c, u) {
      super(i, s, c, u), this.I = this.Fa.some((h) => h.I);
    }
    h(i, s) {
      return this.A(i, s, this.Fa.map((c) => (u) => c.h(u, s)));
    }
    s(i, s) {
      let c = [];
      const u = this.A(i, s, this.Fa.map((g) => g.I ? (b) => (b = g.s(b, s), Yo(b, (x) => c = zn(c, x))) : (b) => g.h(b, s)));
      let h = !1;
      return { next: () => {
        if (h) return H;
        const g = u.O();
        return h = !0, j(new fy(g, c));
      } };
    }
    v(i) {
      super.v(i), EE(this);
    }
  };
  const uc = ["external", "attribute", "nodeName", "nodeType", "universal"], TE = uc.length;
  function dc(i, s) {
    for (let c = 0; c < TE; ++c) {
      if (s.h[c] < i.h[c]) return 1;
      if (s.h[c] > i.h[c]) return -1;
    }
    return 0;
  }
  var Fe = class {
    constructor(i) {
      if (this.h = uc.map((s) => i[s] || 0), Object.keys(i).some((s) => !uc.includes(s))) throw Error("Invalid specificity kind passed");
    }
    add(i) {
      const s = uc.reduce((c, u, h) => (c[u] = this.h[h] + i.h[h], c), /* @__PURE__ */ Object.create(null));
      return new Fe(s);
    }
  };
  const Qd = () => Nn("Expected base expression of a function call to evaluate to a sequence of single function item");
  function Zo(i, s, c, u) {
    const h = [];
    for (let g = 0; g < s.length; ++g) {
      if (s[g] === null) {
        h.push(null);
        continue;
      }
      const b = cr(i[g], s[g], c, u, !1);
      h.push(b);
    }
    return h;
  }
  function vy(i, s) {
    if (!I(i.type, 60)) throw Nn("Expected base expression to evaluate to a function item");
    if (i.v !== s) throw Qd();
    return i;
  }
  function Zd(i, s, c, u, h, g, b) {
    let x = 0;
    return h = h.map((C) => C ? null : g[x++](c)), h = Zo(i.o, h, u, i.D), 0 <= h.indexOf(null) ? xS(i, h) : (s = s.apply(void 0, [c, u, b, ...h]), cr(i.s, s, u, i.D, !0));
  }
  var Ta = class extends Qo {
    constructor(i, s, c) {
      super(new Fe({ external: 1 }), [i].concat(s.filter((u) => !!u)), { R: "unsorted", W: !1, subtree: !1, B: !1 }, c), this.ma = s.length, this.P = s.map((u) => u === null), this.L = null, this.ya = i, this.La = s;
    }
    s(i, s) {
      if (!this.l || !this.l.I) return super.s(i, s);
      let c = [];
      const u = Zd(this.l, (g, b, x, ...C) => Yo(this.l.value(g, b, x, ...C), (T) => {
        c = zn(c, T);
      }), i, s, this.P, this.La.map((g) => () => g.I ? Yo(g.s(i, s), (b) => {
        c = zn(c, b);
      }) : he(g, i, s)), this.L);
      let h = !1;
      return { next: () => {
        if (h) return H;
        const g = u.O();
        return h = !0, j({
          da: c,
          J: g
        });
      } };
    }
    A(i, s, [c, ...u]) {
      if (this.l) return Zd(this.l, (g, b, x, ...C) => this.l.value(g, b, x, ...C), i, s, this.P, u, this.L);
      const h = c(i);
      return h.X({ default: () => {
        throw Qd();
      }, m: () => h.N(([g]) => {
        if (g = vy(g, this.ma), g.I) throw Error("XUDY0038: The function returned by the PrimaryExpr of a dynamic function invocation can not be an updating function");
        return Zd(g, g.value, i, s, this.P, u, this.L);
      }) });
    }
    v(i) {
      if (this.L = fc(i), super.v(i), this.ya.B) {
        if (i = he(this.ya, null, null), !i.oa()) throw Qd();
        this.l = vy(i.first(), this.ma), this.l.I && (this.I = !0);
      }
    }
  };
  const xy = (i, s, c, u, h, g) => Oe([u, h, g], ([b, x, C]) => {
    if (x = x.value, C = C.value, x > b.h.length || 0 >= x) throw Error("FOAY0001: subarray start out of bounds.");
    if (0 > C) throw Error("FOAY0002: subarray length out of bounds.");
    if (x + C > b.h.length + 1) throw Error("FOAY0001: subarray start + length out of bounds.");
    return N.m(new qt(b.h.slice(x - 1, C + x - 1)));
  }), ky = (i, s, c, u, h) => Oe([u], ([g]) => h.N((b) => {
    b = b.map((C) => C.value).sort((C, T) => T - C).filter((C, T, R) => R[T - 1] !== C);
    const x = g.h.concat();
    for (let C = 0, T = b.length; C < T; ++C) {
      const R = b[C];
      if (R > g.h.length || 0 >= R) throw Error("FOAY0001: subarray position out of bounds.");
      x.splice(R - 1, 1);
    }
    return N.m(new qt(x));
  })), Ay = (i) => I(i, 1) || I(i, 20) || I(i, 19), Cy = (i, s, c, u, h) => u.length === 0 ? h.length !== 0 : h.length !== 0 && Yd(i, s, c, u[0], h[0]).next(0).value ? Cy(i, s, c, u.slice(1), h.slice(1)) : u[0].value !== u[0].value ? !0 : Ay(u[0].type) && h.length !== 0 && Ay(h[0].type) ? u[0].value < h[0].value : h.length === 0 ? !1 : u[0].value < h[0].value, NE = (i, s, c, u) => (u.sort((h, g) => ui(i, s, c, N.create(h), N.create(g)).next(0).value ? 0 : Cy(i, s, c, h, g) ? -1 : 1), N.m(new qt(u.map((h) => () => N.create(h)))));
  function Sy(i) {
    return I(i.type, 62) ? Gn(i.h.map((s) => s().N((c) => Gn(c.map(Sy))))) : N.m(i);
  }
  var BE = [
    { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "size", j: [{ type: 62, g: 3 }], i: { type: 5, g: 3 }, callFunction: (i, s, c, u) => Oe([u], ([h]) => N.m(M(h.h.length, 5))) },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "get", j: [{ type: 62, g: 3 }, { type: 5, g: 3 }], i: { type: 59, g: 2 }, callFunction: Id },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "put", j: [{ type: 62, g: 3 }, { type: 5, g: 3 }, { type: 59, g: 2 }], i: { type: 62, g: 3 }, callFunction: (i, s, c, u, h, g) => Oe([h, u], ([b, x]) => {
      if (b = b.value, 0 >= b || b > x.h.length) throw Error("FOAY0001: array position out of bounds.");
      return x = x.h.concat(), x.splice(b - 1, 1, st(g)), N.m(new qt(x));
    }) },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "append", j: [{ type: 62, g: 3 }, { type: 59, g: 2 }], i: { type: 62, g: 3 }, callFunction: (i, s, c, u, h) => Oe([u], ([g]) => N.m(new qt(g.h.concat([st(h)])))) },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "subarray", j: [{ type: 62, g: 3 }, { type: 5, g: 3 }, { type: 5, g: 3 }], i: { type: 62, g: 3 }, callFunction: xy },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "subarray", j: [{ type: 62, g: 3 }, { type: 5, g: 3 }], i: { type: 62, g: 3 }, callFunction(i, s, c, u, h) {
      const g = N.m(M(u.first().value.length - h.first().value + 1, 5));
      return xy(i, s, c, u, h, g);
    } },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "remove", j: [{ type: 62, g: 3 }, { type: 5, g: 2 }], i: { type: 62, g: 3 }, callFunction: ky },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "insert-before", j: [{ type: 62, g: 3 }, { type: 5, g: 3 }, {
      type: 59,
      g: 2
    }], i: { type: 62, g: 3 }, callFunction: (i, s, c, u, h, g) => Oe([u, h], ([b, x]) => {
      if (x = x.value, x > b.h.length + 1 || 0 >= x) throw Error("FOAY0001: subarray position out of bounds.");
      return b = b.h.concat(), b.splice(x - 1, 0, st(g)), N.m(new qt(b));
    }) },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "head", j: [{ type: 62, g: 3 }], i: { type: 59, g: 2 }, callFunction(i, s, c, u) {
      return Id(i, s, c, u, N.m(M(1, 5)));
    } },
    {
      namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
      localName: "tail",
      j: [{ type: 62, g: 3 }],
      i: { type: 59, g: 2 },
      callFunction(i, s, c, u) {
        return ky(i, s, c, u, N.m(M(1, 5)));
      }
    },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "reverse", j: [{ type: 62, g: 3 }], i: { type: 62, g: 3 }, callFunction: (i, s, c, u) => Oe([u], ([h]) => N.m(new qt(h.h.concat().reverse()))) },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "join", j: [{ type: 62, g: 2 }], i: { type: 62, g: 3 }, callFunction: (i, s, c, u) => u.N((h) => (h = h.reduce((g, b) => g.concat(b.h), []), N.m(new qt(h)))) },
    {
      namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
      localName: "for-each",
      j: [{ type: 62, g: 3 }, { type: 60, g: 3 }],
      i: { type: 62, g: 3 },
      callFunction: (i, s, c, u, h) => Oe([u, h], ([g, b]) => {
        if (b.v !== 1) throw Nn("The callback passed into array:for-each has a wrong arity.");
        return g = g.h.map((x) => st(b.value.call(void 0, i, s, c, Zo(b.o, [x()], s, "array:for-each")[0]))), N.m(new qt(g));
      })
    },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "filter", j: [{ type: 62, g: 3 }, { type: 60, g: 3 }], i: { type: 62, g: 3 }, callFunction: (i, s, c, u, h) => Oe([u, h], ([g, b]) => {
      if (b.v !== 1) throw Nn("The callback passed into array:filter has a wrong arity.");
      const x = g.h.map((R) => {
        R = Zo(b.o, [R()], s, "array:filter")[0];
        const P = b.value;
        return P(i, s, c, R);
      }), C = [];
      let T = !1;
      return N.create({ next: () => {
        if (T) return H;
        for (let P = 0, q = g.h.length; P < q; ++P) {
          var R = x[P].fa();
          C[P] = R;
        }
        return R = g.h.filter((P, q) => C[q]), T = !0, j(new qt(R));
      } });
    }) },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "fold-left", j: [{ type: 62, g: 3 }, { type: 59, g: 2 }, { type: 60, g: 3 }], i: { type: 59, g: 2 }, callFunction: (i, s, c, u, h, g) => Oe([u, g], ([b, x]) => {
      if (x.v !== 2) throw Nn("The callback passed into array:fold-left has a wrong arity.");
      return b.h.reduce((C, T) => (T = Zo(x.o, [T()], s, "array:fold-left")[0], x.value.call(void 0, i, s, c, C, T)), h);
    }) },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "fold-right", j: [{ type: 62, g: 3 }, { type: 59, g: 2 }, { type: 60, g: 3 }], i: { type: 59, g: 2 }, callFunction: (i, s, c, u, h, g) => Oe([u, g], ([b, x]) => {
      if (x.v !== 2) throw Nn("The callback passed into array:fold-right has a wrong arity.");
      return b.h.reduceRight((C, T) => (T = Zo(x.o, [T()], s, "array:fold-right")[0], x.value.call(void 0, i, s, c, C, T)), h);
    }) },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "for-each-pair", j: [{ type: 62, g: 3 }, { type: 62, g: 3 }, { type: 60, g: 3 }], i: { type: 62, g: 3 }, callFunction: (i, s, c, u, h, g) => Oe([u, h, g], ([b, x, C]) => {
      if (C.v !== 2) throw Nn("The callback passed into array:for-each-pair has a wrong arity.");
      const T = [];
      for (let R = 0, P = Math.min(b.h.length, x.h.length); R < P; ++R) {
        const [q, _] = Zo(C.o, [b.h[R](), x.h[R]()], s, "array:for-each-pair");
        T[R] = st(C.value.call(void 0, i, s, c, q, _));
      }
      return N.m(new qt(T));
    }) },
    {
      namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
      localName: "sort",
      j: [{ type: 62, g: 3 }],
      i: { type: 62, g: 3 },
      callFunction: (i, s, c, u) => Oe([u], ([h]) => (h = h.h.map((g) => g().O()), NE(i, s, c, h)))
    },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "flatten", j: [{ type: 59, g: 2 }], i: { type: 59, g: 2 }, callFunction: (i, s, c, u) => u.N((h) => Gn(h.map(Sy))) }
  ];
  function xe(i, s, c, u, h) {
    return h.F() ? h : N.m(He(h.first(), i));
  }
  var IE = [{ namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "untypedAtomic", j: [{ type: 46, g: 0 }], i: { type: 19, g: 0 }, callFunction: xe.bind(null, 19) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "error", j: [{ type: 46, g: 0 }], i: { type: 39, g: 0 }, callFunction: xe.bind(null, 39) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "string", j: [{ type: 46, g: 0 }], i: { type: 1, g: 0 }, callFunction: xe.bind(null, 1) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "boolean", j: [{ type: 46, g: 0 }], i: {
    type: 0,
    g: 0
  }, callFunction: xe.bind(null, 0) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "decimal", j: [{ type: 46, g: 0 }], i: { type: 4, g: 0 }, callFunction: xe.bind(null, 4) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "float", j: [{ type: 46, g: 0 }], i: { type: 6, g: 0 }, callFunction: xe.bind(null, 6) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "double", j: [{ type: 46, g: 0 }], i: { type: 3, g: 0 }, callFunction: xe.bind(null, 3) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "duration", j: [{
    type: 46,
    g: 0
  }], i: { type: 18, g: 0 }, callFunction: xe.bind(null, 18) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "dateTime", j: [{ type: 46, g: 0 }], i: { type: 9, g: 0 }, callFunction: xe.bind(null, 9) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "dateTimeStamp", j: [{ type: 46, g: 0 }], i: { type: 10, g: 0 }, callFunction: xe.bind(null, 10) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "time", j: [{ type: 46, g: 0 }], i: { type: 8, g: 0 }, callFunction: xe.bind(null, 8) }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "date",
    j: [{ type: 46, g: 0 }],
    i: { type: 7, g: 0 },
    callFunction: xe.bind(null, 7)
  }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "gYearMonth", j: [{ type: 46, g: 0 }], i: { type: 11, g: 0 }, callFunction: xe.bind(null, 11) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "gYear", j: [{ type: 46, g: 0 }], i: { type: 12, g: 0 }, callFunction: xe.bind(null, 12) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "gMonthDay", j: [{ type: 46, g: 0 }], i: { type: 13, g: 0 }, callFunction: xe.bind(null, 13) }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "gDay",
    j: [{ type: 46, g: 0 }],
    i: { type: 15, g: 0 },
    callFunction: xe.bind(null, 15)
  }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "gMonth", j: [{ type: 46, g: 0 }], i: { type: 14, g: 0 }, callFunction: xe.bind(null, 14) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "hexBinary", j: [{ type: 46, g: 0 }], i: { type: 22, g: 0 }, callFunction: xe.bind(null, 22) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "base64Binary", j: [{ type: 46, g: 0 }], i: { type: 21, g: 0 }, callFunction: xe.bind(null, 21) }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "QName",
    j: [{ type: 46, g: 0 }],
    i: { type: 23, g: 0 },
    callFunction: (i, s, c, u) => {
      if (u.F()) return u;
      if (i = u.first(), I(i.type, 2)) throw Error("XPTY0004: The provided QName is not a string-like value.");
      if (i = He(i, 1).value, i = $d(i, 23), !nc(i, 23)) throw Error("FORG0001: The provided QName is invalid.");
      if (!i.includes(":")) return c = c.$(""), N.m(M(new _t("", c, i), 23));
      const [h, g] = i.split(":");
      if (c = c.$(h), !c) throw Error(`FONS0004: The value ${i} can not be cast to a QName. Did you mean to use fn:QName?`);
      return N.m(M(new _t(
        h,
        c,
        g
      ), 23));
    }
  }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "anyURI", j: [{ type: 46, g: 0 }], i: { type: 20, g: 0 }, callFunction: xe.bind(null, 20) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "normalizedString", j: [{ type: 46, g: 0 }], i: { type: 48, g: 0 }, callFunction: xe.bind(null, 48) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "token", j: [{ type: 46, g: 0 }], i: { type: 52, g: 0 }, callFunction: xe.bind(null, 52) }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "language",
    j: [{ type: 46, g: 0 }],
    i: { type: 51, g: 0 },
    callFunction: xe.bind(null, 51)
  }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "NMTOKEN", j: [{ type: 46, g: 0 }], i: { type: 50, g: 0 }, callFunction: xe.bind(null, 50) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "NMTOKENS", j: [{ type: 46, g: 0 }], i: { type: 49, g: 2 }, callFunction: xe.bind(null, 49) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "Name", j: [{ type: 46, g: 0 }], i: { type: 25, g: 0 }, callFunction: xe.bind(null, 25) }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "NCName",
    j: [{ type: 46, g: 0 }],
    i: { type: 24, g: 0 },
    callFunction: xe.bind(null, 24)
  }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "ID", j: [{ type: 46, g: 0 }], i: { type: 42, g: 0 }, callFunction: xe.bind(null, 42) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "IDREF", j: [{ type: 46, g: 0 }], i: { type: 41, g: 0 }, callFunction: xe.bind(null, 41) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "IDREFS", j: [{ type: 46, g: 0 }], i: { type: 43, g: 2 }, callFunction: xe.bind(null, 43) }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "ENTITY",
    j: [{ type: 46, g: 0 }],
    i: { type: 26, g: 0 },
    callFunction: xe.bind(null, 26)
  }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "ENTITIES", j: [{ type: 46, g: 0 }], i: { type: 40, g: 2 }, callFunction: xe.bind(null, 40) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "integer", j: [{ type: 46, g: 0 }], i: { type: 5, g: 0 }, callFunction: xe.bind(null, 5) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "nonPositiveInteger", j: [{ type: 46, g: 0 }], i: { type: 27, g: 0 }, callFunction: xe.bind(null, 27) }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "negativeInteger",
    j: [{ type: 46, g: 0 }],
    i: { type: 28, g: 0 },
    callFunction: xe.bind(null, 28)
  }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "long", j: [{ type: 46, g: 0 }], i: { type: 31, g: 0 }, callFunction: xe.bind(null, 31) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "int", j: [{ type: 46, g: 0 }], i: { type: 32, g: 0 }, callFunction: xe.bind(null, 32) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "short", j: [{ type: 46, g: 0 }], i: { type: 33, g: 0 }, callFunction: xe.bind(null, 33) }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "byte",
    j: [{ type: 46, g: 0 }],
    i: { type: 34, g: 0 },
    callFunction: xe.bind(null, 34)
  }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "nonNegativeInteger", j: [{ type: 46, g: 0 }], i: { type: 30, g: 0 }, callFunction: xe.bind(null, 30) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "unsignedLong", j: [{ type: 46, g: 0 }], i: { type: 36, g: 0 }, callFunction: xe.bind(null, 36) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "unsignedInt", j: [{ type: 46, g: 0 }], i: { type: 35, g: 0 }, callFunction: xe.bind(null, 35) }, {
    namespaceURI: "http://www.w3.org/2001/XMLSchema",
    localName: "unsignedShort",
    j: [{ type: 46, g: 0 }],
    i: { type: 38, g: 0 },
    callFunction: xe.bind(null, 38)
  }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "unsignedByte", j: [{ type: 46, g: 0 }], i: { type: 37, g: 0 }, callFunction: xe.bind(null, 37) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "positiveInteger", j: [{ type: 46, g: 0 }], i: { type: 29, g: 0 }, callFunction: xe.bind(null, 29) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "yearMonthDuration", j: [{ type: 46, g: 0 }], i: { type: 16, g: 0 }, callFunction: xe.bind(
    null,
    16
  ) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "dayTimeDuration", j: [{ type: 46, g: 0 }], i: { type: 17, g: 0 }, callFunction: xe.bind(null, 17) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "dateTimeStamp", j: [{ type: 46, g: 0 }], i: { type: 10, g: 0 }, callFunction: xe.bind(null, 10) }];
  const Ey = (i, s, c, u) => u.F() ? u : N.m(M(u.first().value.getYear(), 5)), Ty = (i, s, c, u) => u.F() ? u : N.m(M(u.first().value.getMonth(), 5)), Ny = (i, s, c, u) => u.F() ? u : N.m(M(u.first().value.getDay(), 5)), By = (i, s, c, u) => u.F() ? u : N.m(M(u.first().value.getHours(), 5)), Iy = (i, s, c, u) => u.F() ? u : N.m(M(u.first().value.getMinutes(), 5)), My = (i, s, c, u) => (u.F() || (i = N, s = i.m, u = u.first().value, u = s.call(i, M(u.D + u.qa, 4))), u), ep = (i, s, c, u) => u.F() ? u : (i = u.first().value.Y) ? N.m(M(i, 17)) : N.empty();
  var ME = [
    { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "dateTime", j: [{ type: 7, g: 0 }, { type: 8, g: 0 }], i: { type: 9, g: 0 }, callFunction: (i, s, c, u, h) => {
      if (u.F()) return u;
      if (h.F()) return h;
      if (i = u.first().value, h = h.first().value, s = i.Y, c = h.Y, s || c) {
        if (!s || c) {
          if (!s && c) s = c;
          else if (!Rr(s, c)) throw Error("FORG0008: fn:dateTime: got a date and time value with different timezones.");
        }
      } else s = null;
      return N.m(M(new Ft(i.getYear(), i.getMonth(), i.getDay(), h.getHours(), h.getMinutes(), h.getSeconds(), h.qa, s), 9));
    } },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "year-from-dateTime", j: [{ type: 9, g: 0 }], i: { type: 5, g: 0 }, callFunction: Ey },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "month-from-dateTime", j: [{ type: 9, g: 0 }], i: { type: 5, g: 0 }, callFunction: Ty },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "day-from-dateTime", j: [{ type: 9, g: 0 }], i: { type: 5, g: 0 }, callFunction: Ny },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "hours-from-dateTime", j: [{
      type: 9,
      g: 0
    }], i: { type: 5, g: 0 }, callFunction: By },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "minutes-from-dateTime", j: [{ type: 9, g: 0 }], i: { type: 5, g: 0 }, callFunction: Iy },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "seconds-from-dateTime", j: [{ type: 9, g: 0 }], i: { type: 4, g: 0 }, callFunction: My },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "timezone-from-dateTime", j: [{ type: 9, g: 0 }], i: { type: 17, g: 0 }, callFunction: ep },
    {
      namespaceURI: "http://www.w3.org/2005/xpath-functions",
      localName: "year-from-date",
      j: [{ type: 7, g: 0 }],
      i: { type: 5, g: 0 },
      callFunction: Ey
    },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "month-from-date", j: [{ type: 7, g: 0 }], i: { type: 5, g: 0 }, callFunction: Ty },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "day-from-date", j: [{ type: 7, g: 0 }], i: { type: 5, g: 0 }, callFunction: Ny },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "timezone-from-date", j: [{ type: 7, g: 0 }], i: { type: 17, g: 0 }, callFunction: ep },
    {
      namespaceURI: "http://www.w3.org/2005/xpath-functions",
      localName: "hours-from-time",
      j: [{ type: 8, g: 0 }],
      i: { type: 5, g: 0 },
      callFunction: By
    },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "minutes-from-time", j: [{ type: 8, g: 0 }], i: { type: 5, g: 0 }, callFunction: Iy },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "seconds-from-time", j: [{ type: 8, g: 0 }], i: { type: 4, g: 0 }, callFunction: My },
    { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "timezone-from-time", j: [{ type: 8, g: 0 }], i: { type: 17, g: 0 }, callFunction: ep }
  ];
  function pc(i, s) {
    const c = s.h, u = s.Ja, h = s.Ma;
    switch (i.node.nodeType) {
      case 1:
        const b = u.createElementNS(i.node.namespaceURI, i.node.nodeName);
        c.getAllAttributes(i.node).forEach((x) => h.setAttributeNS(b, x.namespaceURI, x.nodeName, x.value));
        for (var g of sr(c, i)) i = pc(g, s), h.insertBefore(b, i.node, null);
        return { node: b, G: null };
      case 2:
        return s = u.createAttributeNS(i.node.namespaceURI, i.node.nodeName), s.value = Et(c, i), { node: s, G: null };
      case 4:
        return { node: u.createCDATASection(Et(c, i)), G: null };
      case 8:
        return { node: u.createComment(Et(
          c,
          i
        )), G: null };
      case 9:
        g = u.createDocument();
        for (const x of sr(c, i)) i = pc(x, s), h.insertBefore(g, i.node, null);
        return { node: g, G: null };
      case 7:
        return { node: u.createProcessingInstruction(i.node.target, Et(c, i)), G: null };
      case 3:
        return { node: u.createTextNode(Et(c, i)), G: null };
    }
  }
  function tp(i, s) {
    const c = s.Ma;
    var u = s.Ja;
    const h = s.h;
    if (zt(i.node)) switch (i.node.nodeType) {
      case 2:
        return u = u.createAttributeNS(i.node.namespaceURI, i.node.nodeName), u.value = Et(h, i), u;
      case 8:
        return u.createComment(Et(h, i));
      case 1:
        const g = i.node.prefix, b = i.node.localName, x = u.createElementNS(i.node.namespaceURI, g ? g + ":" + b : b);
        return sr(h, i).forEach((C) => {
          C = tp(C, s), c.insertBefore(x, C, null);
        }), zo(h, i).forEach((C) => {
          c.setAttributeNS(x, C.node.namespaceURI, C.node.nodeName, Et(h, C));
        }), x.normalize(), x;
      case 7:
        return u.createProcessingInstruction(
          i.node.target,
          Et(h, i)
        );
      case 3:
        return u.createTextNode(Et(h, i));
    }
    else return pc(i, s).node;
  }
  function OE(i, s, c) {
    let u = i;
    for (i = Ie(c, u); i !== null; ) {
      if (u.node.nodeType === 2) s.push(u.node.nodeName);
      else {
        const h = sr(c, i);
        s.push(h.findIndex((g) => mt(g, u)));
      }
      u = i, i = Ie(c, u);
    }
    return u;
  }
  function DE(i, s, c) {
    for (; 0 < s.length; ) {
      const u = s.pop();
      typeof u == "string" ? i = zo(c, i).find((h) => h.node.nodeName === u) : i = sr(c, i)[u];
    }
    return i.node;
  }
  function Pt(i, s, c) {
    var u = i.node;
    if (!(zt(u) || c || i.G)) return u;
    u = s.v;
    const h = [];
    return c ? tp(i, s) : (i = OE(i, h, s.h), c = u.get(i.node), c || (c = { node: tp(i, s), G: null }, u.set(i.node, c)), DE(c, h, s.h));
  }
  const Oy = (i, s, c, u, h) => u.N((g) => {
    var b;
    let x = "";
    for (let C = 0; C < g.length; C++) {
      const T = g[C], R = s.Ua && I(T.type, 53) ? s.Ua.serializeToString(Pt(T.value, s, !1)) : (b = at(N.m(T), s).map((P) => He(P, 1)).first()) === null || b === void 0 ? void 0 : b.value;
      R && (x += `{type: ${se[T.type]}, value: ${R}}
`);
    }
    return h !== void 0 && (x += h.first().value), s.jb.trace(x), N.create(g);
  });
  var RE = [{ j: [{ type: 59, g: 2 }], callFunction: Oy, localName: "trace", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 } }, { j: [{ type: 59, g: 2 }, { type: 1, g: 3 }], callFunction: Oy, localName: "trace", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 } }];
  const np = (i, s, c, u, h) => {
    throw i = u === void 0 || u.F() ? new _t("err", "http://www.w3.org/2005/xqt-errors", "FOER0000") : u.first().value, s = "", h === void 0 || h.F() || (s = `: ${h.first().value}`), Error(`${i.localName}${s}`);
  };
  var FE = [{ namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "error", j: [], i: { type: 63, g: 3 }, callFunction: np }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "error", j: [{ type: 23, g: 0 }], i: { type: 63, g: 3 }, callFunction: np }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "error", j: [{ type: 23, g: 0 }, { type: 1, g: 3 }], i: { type: 63, g: 3 }, callFunction: np }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "error", j: [{ type: 23, g: 0 }, { type: 1, g: 3 }, { type: 59, g: 2 }], i: {
    type: 63,
    g: 3
  }, callFunction() {
    throw Error("Not implemented: Using an error object in error is not supported");
  } }];
  function hr(i) {
    return typeof i == "string" ? i : (i = new si().getChildNodes(i).find((s) => s.nodeType === 8)) ? i.data : "some expression";
  }
  var Dy = class extends Error {
    constructor(i, s) {
      super(i), this.position = { end: { ha: s.end.ha, line: s.end.line, offset: s.end.offset }, start: { ha: s.start.ha, line: s.start.line, offset: s.start.offset } };
    }
  };
  function dn(i, s) {
    if (s instanceof Error) throw s;
    typeof i != "string" && (i = hr(i));
    const c = r0(s);
    i = i.replace(/\r/g, "").split(`
`);
    const u = Math.floor(Math.log10(Math.min(c.end.line + 2, i.length))) + 1;
    throw i = i.reduce((h, g, b) => {
      var x = b + 1;
      if (2 < c.start.line - x || 2 < x - c.end.line) return h;
      if (b = `${Array(u).fill(" ", 0, Math.floor(Math.log10(x)) + 1 - u).join("")}${x}: `, h.push(`${b}${g}`), x >= c.start.line && x <= c.end.line) {
        const C = x < c.end.line ? g.length + b.length : c.end.ha - 1 + b.length;
        x = x > c.start.line ? b.length : c.start.ha - 1 + b.length, g = " ".repeat(b.length) + Array.from(g.substring(0, x - b.length), (T) => T === "	" ? "	" : " ").join("") + "^".repeat(C - x), h.push(g);
      }
      return h;
    }, []), s = i0(s).join(`
`), new Dy(i.join(`
`) + `

` + s, c);
  }
  const di = /* @__PURE__ */ Object.create(null);
  function PE(i, s) {
    const c = /* @__PURE__ */ new Map();
    for (let u = 0; u < i.length + 1; ++u) c.set(u, /* @__PURE__ */ new Map());
    return function u(h, g) {
      if (h === 0) return g;
      if (g === 0) return h;
      if (c.get(h).has(g)) return c.get(h).get(g);
      var b = 0;
      return i[h - 1] !== s[g - 1] && (b = 1), b = Math.min(u(h - 1, g) + 1, u(h, g - 1) + 1, u(h - 1, g - 1) + b), c.get(h).set(g, b), b;
    }(i.length, s.length);
  }
  function rp(i) {
    const s = di[i] ? di[i] : Object.keys(di).map((c) => ({ name: c, sb: PE(i, c.slice(c.lastIndexOf(":") + 1)) })).sort((c, u) => c.sb - u.sb).slice(0, 5).filter((c) => c.sb < i.length / 2).reduce((c, u) => c.concat(di[u.name]), []).slice(0, 5);
    return s.length ? s.map((c) => `"Q{${c.namespaceURI}}${c.localName} (${c.j.map((u) => u === 4 ? "..." : kt(u)).join(", ")})"`).reduce((c, u, h, g) => h === 0 ? c + u : c + ((h !== g.length - 1 ? ", " : " or ") + u), "Did you mean ") + "?" : "No similar functions found.";
  }
  function ip(i, s, c) {
    var u = di[i + ":" + s];
    return u && (u = u.find((h) => h.j.some((g) => g === 4) ? h.j.length - 1 <= c : h.j.length === c)) ? { j: u.j, arity: c, callFunction: u.callFunction, I: u.I, localName: s, namespaceURI: i, i: u.i } : null;
  }
  function Ry(i, s, c, u, h) {
    di[i + ":" + s] || (di[i + ":" + s] = []), di[i + ":" + s].push({ j: c, arity: c.length, callFunction: h, I: !1, localName: s, namespaceURI: i, i: u });
  }
  var Na = { xml: "http://www.w3.org/XML/1998/namespace", xs: "http://www.w3.org/2001/XMLSchema", fn: "http://www.w3.org/2005/xpath-functions", map: "http://www.w3.org/2005/xpath-functions/map", array: "http://www.w3.org/2005/xpath-functions/array", math: "http://www.w3.org/2005/xpath-functions/math", fontoxpath: "http://fontoxml.com/fontoxpath", local: "http://www.w3.org/2005/xquery-local-functions" }, hc = class {
    constructor(i, s, c, u) {
      this.Da = [/* @__PURE__ */ Object.create(null)], this.Ea = /* @__PURE__ */ Object.create(null), this.s = i, this.ia = Object.keys(s).reduce((h, g) => (s[g] === void 0 || (h[g] = `Q{}${g}[0]`), h), /* @__PURE__ */ Object.create(null)), this.o = /* @__PURE__ */ Object.create(null), this.h = /* @__PURE__ */ Object.create(null), this.v = c, this.l = u, this.D = [];
    }
    va(i, s, c) {
      return ip(i, s, c);
    }
    eb(i, s) {
      return i ? null : (i = this.ia[s], this.o[s] || (this.o[s] = { name: s }), i);
    }
    Sa(i, s) {
      const c = this.l(i, s);
      if (c) this.D.push({ dc: i, arity: s, Db: c });
      else if (i.prefix === "") {
        if (this.v) return {
          namespaceURI: this.v,
          localName: i.localName
        };
      } else if (s = this.$(i.prefix, !0)) return { namespaceURI: s, localName: i.localName };
      return c;
    }
    $(i, s = !0) {
      return s ? Na[i] ? Na[i] : (s = this.s(i), this.h[i] || (this.h[i] = { namespaceURI: s, prefix: i }), s !== void 0 || i ? s : null) : null;
    }
  }, $E = (i, s) => (i = i.node.nodeType === 2 ? `${i.node.nodeName}="${Et(s, i)}"` : i.node.outerHTML, Error(`XQTY0024: The node ${i} follows a node that is not an attribute node or a namespace node.`)), Ba = (i) => Error(`XQDY0044: The node name "${i.za()}" is invalid for a computed attribute constructor.`), Fy = () => Error("XQST0045: Functions and variables may not be declared in one of the reserved namespace URIs."), Py = (i, s) => Error(`XQST0049: The function or variable "Q{${i}}${s}" is declared more than once.`), op = () => Error("XQST0060: Functions declared in a module or as an external function must reside in a namespace."), $y = () => Error("XQST0066: A Prolog may contain at most one default function namespace declaration."), sp = () => Error("XQST0070: The prefixes xml and xmlns may not be used in a namespace declaration or be bound to another namespaceURI."), jy = (i) => Error(`XQDY0074: The value "${i}" of a name expressions cannot be converted to an expanded QName.`), Uy = (i) => Error(`XPST0081: The prefix "${i}" could not be resolved`);
  function es(i, s) {
    return `Q{${i || ""}}${s}`;
  }
  function Ly(i, s) {
    for (let c = i.length - 1; 0 <= c; --c) if (s in i[c]) return i[c][s];
  }
  function fc(i) {
    const s = new Ki(i.o);
    for (let c = 0; c < i.h + 1; ++c) s.D = [Object.assign(/* @__PURE__ */ Object.create(null), s.D[0], i.D[c])], s.Da = [Object.assign(/* @__PURE__ */ Object.create(null), s.Da[0], i.Da[c])], s.l = Object.assign(/* @__PURE__ */ Object.create(null), i.l), s.Ea = i.Ea, s.v = i.v;
    return s;
  }
  function ts(i) {
    i.s++, i.h++, i.D[i.h] = /* @__PURE__ */ Object.create(null), i.Da[i.h] = /* @__PURE__ */ Object.create(null);
  }
  function jE(i, s, c) {
    return (i = i.Ea[es(s, c)]) ? i : null;
  }
  function ap(i, s, c, u, h) {
    if (u = es(s, c) + "~" + u, i.l[u]) throw Py(s, c);
    i.l[u] = h;
  }
  function Ji(i, s, c) {
    i.D[i.h][s] = c;
  }
  function fr(i, s, c) {
    return s = es(s || "", c), i.Da[i.h][s] = `${s}[${i.s}]`;
  }
  function Hy(i, s, c, u) {
    i.Ea[`${es(s || "", c)}[${i.s}]`] = u;
  }
  function ns(i) {
    i.D.length = i.h, i.Da.length = i.h, i.h--;
  }
  var Ki = class {
    constructor(i) {
      this.o = i, this.s = this.h = 0, this.D = [/* @__PURE__ */ Object.create(null)], this.l = /* @__PURE__ */ Object.create(null), this.v = null, this.Ea = i && i.Ea, this.Da = i && i.Da;
    }
    va(i, s, c, u = !1) {
      const h = this.l[es(i, s) + "~" + c];
      return !h || u && h.wb ? this.o === null ? null : this.o.va(i, s, c, u) : h;
    }
    eb(i, s) {
      const c = Ly(this.Da, es(i, s));
      return c || (this.o === null ? null : this.o.eb(i, s));
    }
    Sa(i, s) {
      var c = i.prefix;
      const u = i.localName;
      return c === "" && this.v ? { localName: u, namespaceURI: this.v } : c && (c = this.$(c, !1)) ? { localName: u, namespaceURI: c } : this.o === null ? null : this.o.Sa(i, s);
    }
    $(i, s = !0) {
      const c = Ly(this.D, i || "");
      return c === void 0 ? this.o === null ? void 0 : this.o.$(i || "", s) : c;
    }
  };
  function F(i, s) {
    s === "*" || Array.isArray(s) || (s = [s]);
    for (let c = 1; c < i.length; ++c) {
      if (!Array.isArray(i[c])) continue;
      const u = i[c];
      if (s === "*" || s.includes(u[0])) return u;
    }
    return null;
  }
  function Se(i) {
    return 2 > i.length ? "" : typeof i[1] == "object" ? i[2] || "" : i[1] || "";
  }
  function le(i, s) {
    return Array.isArray(i) ? (i = i[1], typeof i != "object" || Array.isArray(i) ? null : s in i ? i[s] : null) : null;
  }
  function oe(i, s) {
    return s.reduce(F, i);
  }
  function ae(i, s) {
    const c = [];
    for (let u = 1; u < i.length; ++u) {
      if (!Array.isArray(i[u])) continue;
      const h = i[u];
      s !== "*" && h[0] !== s || c.push(h);
    }
    return c;
  }
  function ze(i) {
    return { localName: Se(i), namespaceURI: le(i, "URI"), prefix: le(i, "prefix") };
  }
  function mc(i) {
    const s = F(i, "typeDeclaration");
    if (!s || F(s, "voidSequenceType")) return { type: 59, g: 2 };
    const c = (g) => {
      switch (g[0]) {
        case "documentTest":
          return 55;
        case "elementTest":
          return 54;
        case "attributeTest":
          return 47;
        case "piTest":
          return 57;
        case "commentTest":
          return 58;
        case "textTest":
          return 56;
        case "anyKindTest":
          return 53;
        case "anyItemType":
          return 59;
        case "anyFunctionTest":
        case "functionTest":
        case "typedFunctionTest":
          return 60;
        case "anyMapTest":
        case "typedMapTest":
          return 61;
        case "anyArrayTest":
        case "typedArrayTest":
          return 62;
        case "atomicType":
          return ft([le(g, "prefix"), Se(g)].join(":"));
        case "parenthesizedItemType":
          return c(F(g, "*"));
        default:
          throw Error(`Type declaration "${F(s, "*")[0]}" is not supported.`);
      }
    };
    i = { type: c(F(s, "*")), g: 3 };
    let u = null;
    const h = F(s, "occurrenceIndicator");
    switch (h && (u = Se(h)), u) {
      case "*":
        return i.g = 2, i;
      case "?":
        return i.g = 0, i;
      case "+":
        return i.g = 1, i;
      case "":
      case null:
        return i;
    }
  }
  function we(i, s, c) {
    if (typeof i[1] != "object" || Array.isArray(i[1])) {
      const u = {};
      u[s] = c, i.splice(1, 0, u);
    } else i[1][s] = c;
  }
  function UE(i) {
    const s = { type: 62, g: 3 };
    return we(i, "type", s), s;
  }
  function LE(i, s) {
    if (!s || !s.ga) return { type: 59, g: 2 };
    var c = F(i, "EQName");
    if (!c) return { type: 59, g: 2 };
    var u = ze(c);
    c = u.localName;
    const h = u.prefix;
    return u = ae(F(i, "arguments"), "*"), c = s.ga.Sa({ localName: c, prefix: h }, u.length), c ? (s = s.ga.va(c.namespaceURI, c.localName, u.length + 1), s ? (s.i.type !== 59 && we(i, "type", s.i), s.i) : { type: 59, g: 2 }) : { type: 59, g: 2 };
  }
  function te(i, s, c) {
    return (i << 20) + (s << 12) + (c.charCodeAt(0) << 8) + c.charCodeAt(1);
  }
  var gc = { [te(2, 2, "idivOp")]: 5, [te(16, 16, "addOp")]: 16, [te(16, 16, "subtractOp")]: 16, [te(16, 16, "divOp")]: 4, [te(16, 2, "multiplyOp")]: 16, [te(16, 2, "divOp")]: 16, [te(2, 16, "multiplyOp")]: 16, [te(17, 17, "addOp")]: 17, [te(17, 17, "subtractOp")]: 17, [te(17, 17, "divOp")]: 4, [te(17, 2, "multiplyOp")]: 17, [te(17, 2, "divOp")]: 17, [te(2, 17, "multiplyOp")]: 17, [te(9, 9, "subtractOp")]: 17, [te(7, 7, "subtractOp")]: 17, [te(8, 8, "subtractOp")]: 17, [te(9, 16, "addOp")]: 9, [te(9, 16, "subtractOp")]: 9, [te(9, 17, "addOp")]: 9, [te(9, 17, "subtractOp")]: 9, [te(7, 16, "addOp")]: 7, [te(
    7,
    16,
    "subtractOp"
  )]: 7, [te(7, 17, "addOp")]: 7, [te(7, 17, "subtractOp")]: 7, [te(8, 17, "addOp")]: 8, [te(8, 17, "subtractOp")]: 8, [te(9, 16, "addOp")]: 9, [te(9, 16, "subtractOp")]: 9, [te(9, 17, "addOp")]: 9, [te(9, 17, "subtractOp")]: 9, [te(7, 17, "addOp")]: 7, [te(7, 17, "subtractOp")]: 7, [te(7, 16, "addOp")]: 7, [te(7, 16, "subtractOp")]: 7, [te(8, 17, "addOp")]: 8, [te(8, 17, "subtractOp")]: 8 }, Gy = {
    [te(2, 2, "addOp")]: (i, s) => i + s,
    [te(2, 2, "subtractOp")]: (i, s) => i - s,
    [te(2, 2, "multiplyOp")]: (i, s) => i * s,
    [te(2, 2, "divOp")]: (i, s) => i / s,
    [te(2, 2, "modOp")]: (i, s) => i % s,
    [te(2, 2, "idivOp")]: (i, s) => Math.trunc(i / s),
    [te(16, 16, "addOp")]: function(i, s) {
      return new Jo(i.ea + s.ea);
    },
    [te(16, 16, "subtractOp")]: function(i, s) {
      return new Jo(i.ea - s.ea);
    },
    [te(16, 16, "divOp")]: function(i, s) {
      return i.ea / s.ea;
    },
    [te(16, 2, "multiplyOp")]: Sg,
    [te(16, 2, "divOp")]: function(i, s) {
      if (isNaN(s)) throw Error("FOCA0005: Cannot divide xs:yearMonthDuration by NaN");
      if (i = Math.round(i.ea / s), i > Number.MAX_SAFE_INTEGER || !Number.isFinite(i)) throw Error("FODT0002: Value overflow while dividing xs:yearMonthDuration");
      return new Jo(i < Number.MIN_SAFE_INTEGER || i === 0 ? 0 : i);
    },
    [te(2, 16, "multiplyOp")]: (i, s) => Sg(s, i),
    [te(17, 17, "addOp")]: function(i, s) {
      return new zi(i.ca + s.ca);
    },
    [te(17, 17, "subtractOp")]: function(i, s) {
      return new zi(i.ca - s.ca);
    },
    [te(17, 17, "divOp")]: function(i, s) {
      if (s.ca === 0) throw Error("FOAR0001: Division by 0");
      return i.ca / s.ca;
    },
    [te(17, 2, "multiplyOp")]: gg,
    [te(17, 2, "divOp")]: function(i, s) {
      if (isNaN(s)) throw Error("FOCA0005: Cannot divide xs:dayTimeDuration by NaN");
      if (i = i.ca / s, i > Number.MAX_SAFE_INTEGER || !Number.isFinite(i)) throw Error("FODT0002: Value overflow while dividing xs:dayTimeDuration");
      return new zi(i < Number.MIN_SAFE_INTEGER || Object.is(-0, i) ? 0 : i);
    },
    [te(2, 17, "multiplyOp")]: (i, s) => gg(s, i),
    [te(9, 9, "subtractOp")]: Rd,
    [te(7, 7, "subtractOp")]: Rd,
    [te(8, 8, "subtractOp")]: Rd,
    [te(9, 16, "addOp")]: ar,
    [te(9, 16, "subtractOp")]: lr,
    [te(9, 17, "addOp")]: ar,
    [te(9, 17, "subtractOp")]: lr,
    [te(7, 16, "addOp")]: ar,
    [te(7, 16, "subtractOp")]: lr,
    [te(7, 17, "addOp")]: ar,
    [te(7, 17, "subtractOp")]: lr,
    [te(8, 17, "addOp")]: ar,
    [te(8, 17, "subtractOp")]: lr,
    [te(9, 16, "addOp")]: ar,
    [te(9, 16, "subtractOp")]: lr,
    [te(9, 17, "addOp")]: ar,
    [te(9, 17, "subtractOp")]: lr,
    [te(7, 17, "addOp")]: ar,
    [te(7, 17, "subtractOp")]: lr,
    [te(7, 16, "addOp")]: ar,
    [te(7, 16, "subtractOp")]: lr,
    [te(8, 17, "addOp")]: ar,
    [te(8, 17, "subtractOp")]: lr
  };
  function _y(i, s) {
    return I(i, 5) && I(s, 5) ? 5 : I(i, 4) && I(s, 4) ? 4 : I(i, 6) && I(s, 6) ? 6 : 3;
  }
  const yc = [2, 16, 17, 9, 7, 8];
  function zy(i, s, c) {
    function u(C, T) {
      return { U: h ? h(C) : C, V: g ? g(T) : T };
    }
    let h = null, g = null;
    I(s, 19) && (h = (C) => He(C, 3), s = 3), I(c, 19) && (g = (C) => He(C, 3), c = 3);
    const b = yc.filter((C) => I(s, C)), x = yc.filter((C) => I(c, C));
    if (b.includes(2) && x.includes(2)) {
      const C = Gy[te(2, 2, i)];
      let T = gc[te(2, 2, i)];
      return T || (T = _y(s, c)), i === "divOp" && T === 5 && (T = 4), i === "idivOp" ? qy(u, C)[0] : (R, P) => {
        const { U: q, V: _ } = u(R, P);
        return M(C(q.value, _.value), T);
      };
    }
    for (const C of b) for (const T of x) {
      const R = Gy[te(C, T, i)], P = gc[te(C, T, i)];
      if (R && P !== void 0) return (q, _) => {
        const {
          U: ie,
          V: me
        } = u(q, _);
        return M(R(ie.value, me.value), P);
      };
    }
  }
  function HE(i, s, c) {
    function u(T, R) {
      return { U: g ? g(T) : T, V: b ? b(R) : R };
    }
    var h = [2, 53, 59, 46, 47];
    if (h.includes(s) || h.includes(c)) return 2;
    let g = null, b = null;
    I(s, 19) && (g = (T) => He(T, 3), s = 3), I(c, 19) && (b = (T) => He(T, 3), c = 3);
    var x = yc.filter((T) => I(s, T));
    if (h = yc.filter((T) => I(c, T)), x.includes(2) && h.includes(2)) {
      var C = gc[te(2, 2, i)];
      return C === void 0 && (C = _y(s, c)), i === "divOp" && C === 5 && (C = 4), i === "idivOp" ? qy(u, (T, R) => Math.trunc(T / R))[1] : C;
    }
    for (C of x) for (const T of h) if (x = gc[te(C, T, i)], x !== void 0) return x;
  }
  function qy(i, s) {
    return [(c, u) => {
      const { U: h, V: g } = i(c, u);
      if (g.value === 0) throw Error("FOAR0001: Divisor of idiv operator cannot be (-)0");
      if (Number.isNaN(h.value) || Number.isNaN(g.value) || !Number.isFinite(h.value)) throw Error("FOAR0002: One of the operands of idiv is NaN or the first operand is (-)INF");
      return Number.isFinite(h.value) && !Number.isFinite(g.value) ? M(0, 5) : M(s(h.value, g.value), 5);
    }, 5];
  }
  const Vy = /* @__PURE__ */ Object.create(null);
  var GE = class extends Ae {
    constructor(i, s, c, u, h) {
      super(s.o.add(c.o), [s, c], { B: !1 }, !1, u), this.A = s, this.L = c, this.l = i, this.s = h;
    }
    h(i, s) {
      return at(he(this.A, i, s), s).N((c) => c.length === 0 ? N.empty() : at(he(this.L, i, s), s).N((u) => {
        if (u.length === 0) return N.empty();
        if (1 < c.length || 1 < u.length) throw Error('XPTY0004: the operands of the "' + this.l + '" operator should be empty or singleton.');
        const h = c[0];
        if (u = u[0], this.s && this.type) return N.m(this.s(h, u));
        var g = h.type, b = u.type, x = this.l;
        const C = `${g}~${b}~${x}`;
        let T = Vy[C];
        if (T || (T = Vy[C] = zy(x, g, b)), g = T, !g) throw Error(`XPTY0004: ${this.l} not available for types ${se[h.type]} and ${se[u.type]}`);
        return N.m(g(h, u));
      }));
    }
  };
  function _E(i, s) {
    var c = ke;
    let u = !1;
    for (var h = 1; h < i.length; h++) switch (i[h][0]) {
      case "letClause":
        wc(s);
        var g = i[h], b = s, x = c, C = oe(g, ["letClauseItem", "typedVariableBinding", "varName"]);
        C = ze(C), g = oe(g, ["letClauseItem", "letExpr"]), x = x(g[1], b), Yy(b, C.localName, x);
        break;
      case "forClause":
        u = !0, wc(s), zE(i[h], s, c);
        break;
      case "whereClause":
        wc(s), b = i[h], c(b, s), we(b, "type", { type: 0, g: 3 });
        break;
      case "orderByClause":
        wc(s);
        break;
      case "returnClause":
        return h = i[h], b = c, c = oe(h, ["*"]), s = b(c, s), we(c, "type", s), we(h, "type", s), c = s, c ? (u && (c = { type: c.type, g: 2 }), c.type !== 59 && we(i, "type", c), c) : {
          type: 59,
          g: 2
        };
      default:
        return c = c(i[h], s), c ? (u && (c = { type: c.type, g: 2 }), c.type !== 59 && we(i, "type", c), c) : { type: 59, g: 2 };
    }
    if (0 < s.h) s.h--, s.o.pop(), s.v.pop();
    else throw Error("Variable scope out of bound");
  }
  function zE(i, s, c) {
    const u = ze(oe(i, ["forClauseItem", "typedVariableBinding", "varName"]));
    (i = oe(i, ["forClauseItem", "forExpr", "sequenceExpr"])) && (i = ae(i, "*").map((h) => c(h, s)), i.includes(void 0) || i.includes(null) || (i = Xy(i), i.length === 1 && Yy(s, u.localName, i[0])));
  }
  function Xy(i) {
    return i.filter((s, c, u) => u.findIndex((h) => h.type === s.type && h.g === s.g) === c);
  }
  function qE(i, s) {
    if (!s || !s.ga) return { type: 59, g: 2 };
    const c = F(i, "functionName");
    var u = ze(c);
    let h = u.localName;
    var g = u.prefix;
    let b = u.namespaceURI;
    if (u = ae(F(i, "arguments"), "*"), b === null) {
      if (g = s.ga.Sa({ localName: h, prefix: g }, u.length), !g) return { type: 59, g: 2 };
      h = g.localName, b = g.namespaceURI, we(c, "URI", b), c[2] = h;
    }
    return s = s.ga.va(b, h, u.length), !s || s.i.type === 63 ? { type: 59, g: 2 } : (s.i.type !== 59 && we(i, "type", s.i), s.i);
  }
  function VE(i) {
    const s = { type: 61, g: 3 };
    return we(i, "type", s), s;
  }
  function XE(i, s) {
    if (!s || !s.ga) return { type: 59, g: 2 };
    const c = F(i, "functionName");
    var u = ze(c);
    let h = u.localName;
    var g = u.namespaceURI;
    const b = u.prefix;
    if (u = Number(oe(i, ["integerConstantExpr", "value"])[1]), !g) {
      if (g = s.ga.Sa({ localName: h, prefix: b }, u), !g) return { type: 59, g: 2 };
      h = g.localName, g = g.namespaceURI, we(c, "URI", g);
    }
    return s = s.ga.va(g, h, u) || null, s ? (s.i.type !== 59 && s.i.type !== 63 && we(i, "type", s.i), s.i) : { type: 59, g: 2 };
  }
  function JE(i, s) {
    var c = ae(i, "stepExpr");
    if (!c) return { type: 59, g: 2 };
    for (const g of c) {
      e: {
        c = g;
        var u = s;
        let b = null;
        if (!c) break e;
        var h = ae(c, "*");
        let x = "";
        for (const C of h) switch (C[0]) {
          case "filterExpr":
            b = le(oe(C, ["*"]), "type");
            break;
          case "xpathAxis":
            x = C[1];
            t: {
              switch (x) {
                case "attribute":
                  b = { type: 47, g: 2 };
                  break t;
                case "child":
                case "decendant":
                case "self":
                case "descendant-or-self":
                case "following-sibling":
                case "following":
                case "namespace":
                case "parent":
                case "ancestor":
                case "preceding-sibling":
                case "preceding":
                case "ancestor-or-self":
                  b = { type: 53, g: 2 };
                  break t;
              }
              b = void 0;
            }
            break;
          case "nameTest":
            if (h = ze(C), h.namespaceURI !== null || x === "attribute" && !h.prefix) break;
            h = u.$(h.prefix || ""), h !== void 0 && we(C, "URI", h);
            break;
          case "lookup":
            b = { type: 59, g: 2 };
        }
        b && b.type !== 59 && we(c, "type", b);
      }
      u = le(g, "type");
    }
    return u && u.type !== 59 && we(i, "type", u), u;
  }
  function KE(i) {
    const s = { type: 0, g: 3 };
    return we(i, "type", s), s;
  }
  function WE(i, s, c) {
    return s === 0 ? s = { type: 53, g: 2 } : s === 1 ? s = c[0] : c.includes(void 0) || c.includes(null) ? s = { type: 59, g: 2 } : (s = Xy(c), s = 1 < s.length ? { type: 59, g: 2 } : { type: s[0].type, g: 2 }), s && s.type !== 59 && we(i, "type", s), s;
  }
  function YE(i, s, c, u) {
    if (!s || c.includes(void 0)) return { type: 59, g: 2 };
    var h = ae(i, "typeswitchExprCaseClause");
    for (let b = 0; b < c.length; b++) {
      var g = F(h[b], "*");
      switch (g[0]) {
        case "sequenceType":
          if (g = Jy(g, s, c[b])) return g.type !== 59 && we(i, "type", g), g;
          continue;
        case "sequenceTypeUnion":
          for (u = ae(g, "*"), h = 0; 2 > h; h++) if (g = Jy(u[h], s, c[b])) return g.type !== 59 && we(i, "type", g), g;
        default:
          return { type: 59, g: 2 };
      }
    }
    return u.type !== 59 && we(i, "type", u), u;
  }
  function Jy(i, s, c) {
    const u = ae(i, "*"), h = F(i, "atomicType");
    if (!h) return { type: 59, g: 2 };
    if (ft(le(h, "prefix") + ":" + h[2]) === s.type) {
      if (u.length === 1) {
        if (s.g === 3) return c;
      } else if (i = F(i, "occurrenceIndicator")[1], s.g === Qt(i)) return c;
    }
  }
  function Ky(i, s) {
    ke(i, s);
  }
  function ke(i, s) {
    var c = QE.get(i[0]);
    if (c) return c(i, s);
    for (c = 1; c < i.length; c++) i[c] && ke(i[c], s);
  }
  const rs = (i, s) => {
    var c = ke(F(i, "firstOperand")[1], s);
    const u = ke(F(i, "secondOperand")[1], s);
    var h = i[0];
    if (c && u) if (s = HE(h, c.type, u.type)) c = { type: s, g: c.g }, s !== 2 && s !== 59 && we(i, "type", c), i = c;
    else throw Error(`XPTY0004: ${h} not available for types ${kt(c)} and ${kt(u)}`);
    else i = { type: 2, g: 3 };
    return i;
  }, Wy = (i, s) => {
    ke(F(i, "firstOperand")[1], s), ke(F(i, "secondOperand")[1], s);
    e: {
      switch (i[0]) {
        case "orOp":
          s = { type: 0, g: 3 }, we(i, "type", s), i = s;
          break e;
        case "andOp":
          s = { type: 0, g: 3 }, we(i, "type", s), i = s;
          break e;
      }
      i = void 0;
    }
    return i;
  }, lp = (i, s) => {
    ke(F(i, "firstOperand")[1], s), ke(F(i, "secondOperand")[1], s);
    e: {
      switch (i[0]) {
        case "unionOp":
          s = { type: 53, g: 2 }, we(i, "type", s), i = s;
          break e;
        case "intersectOp":
          s = { type: 53, g: 2 }, we(i, "type", s), i = s;
          break e;
        case "exceptOp":
          s = { type: 53, g: 2 }, we(i, "type", s), i = s;
          break e;
      }
      i = void 0;
    }
    return i;
  }, is = (i, s) => (ke(F(i, "firstOperand")[1], s), ke(F(i, "secondOperand")[1], s), s = { type: 0, g: 3 }, we(i, "type", s), s), ss = (i, s) => {
    ke(F(i, "firstOperand")[1], s), ke(F(i, "secondOperand")[1], s), s = le(oe(i, ["firstOperand", "*"]), "type");
    const c = le(oe(
      i,
      ["secondOperand", "*"]
    ), "type");
    return s = { type: 0, g: Vi(s) || Vi(c) ? 0 : 3 }, we(i, "type", s), s;
  }, cp = (i, s) => {
    ke(F(i, "firstOperand")[1], s), ke(F(i, "secondOperand")[1], s), s = le(oe(i, ["firstOperand", "*"]), "type");
    const c = le(oe(i, ["secondOperand", "*"]), "type");
    return s = { type: 0, g: Vi(s) || Vi(c) ? 0 : 3 }, we(i, "type", s), s;
  }, QE = /* @__PURE__ */ new Map([["unaryMinusOp", (i, s) => (s = ke(F(i, "operand")[1], s), s ? I(s.type, 2) ? (s = { type: s.type, g: s.g }, we(i, "type", s), i = s) : (s = { type: 3, g: 3 }, we(i, "type", s), i = s) : (s = { type: 2, g: 2 }, we(i, "type", s), i = s), i)], [
    "unaryPlusOp",
    (i, s) => (s = ke(F(i, "operand")[1], s), s ? I(s.type, 2) ? (s = { type: s.type, g: s.g }, we(i, "type", s), i = s) : (s = { type: 3, g: 3 }, we(i, "type", s), i = s) : (s = { type: 2, g: 2 }, we(i, "type", s), i = s), i)
  ], ["addOp", rs], ["subtractOp", rs], ["divOp", rs], ["idivOp", rs], ["modOp", rs], ["multiplyOp", rs], ["andOp", Wy], ["orOp", Wy], ["sequenceExpr", (i, s) => {
    const c = ae(i, "*"), u = c.map((h) => ke(h, s));
    return WE(i, c.length, u);
  }], ["unionOp", lp], ["intersectOp", lp], ["exceptOp", lp], ["stringConcatenateOp", (i, s) => (ke(F(i, "firstOperand")[1], s), ke(
    F(i, "secondOperand")[1],
    s
  ), s = { type: 1, g: 3 }, we(i, "type", s), s)], ["rangeSequenceExpr", (i, s) => (ke(F(i, "startExpr")[1], s), ke(F(i, "endExpr")[1], s), s = { type: 5, g: 1 }, we(i, "type", s), s)], ["equalOp", is], ["notEqualOp", is], ["lessThanOrEqualOp", is], ["lessThanOp", is], ["greaterThanOrEqualOp", is], ["greaterThanOp", is], ["eqOp", ss], ["neOp", ss], ["ltOp", ss], ["leOp", ss], ["gtOp", ss], ["geOp", ss], ["isOp", cp], ["nodeBeforeOp", cp], ["nodeAfterOp", cp], ["pathExpr", (i, s) => {
    const c = F(i, "rootExpr");
    return c && c[1] && ke(c[1], s), ae(i, "stepExpr").map((u) => ke(u, s)), JE(i, s);
  }], ["contextItemExpr", () => ({ type: 59, g: 2 })], ["ifThenElseExpr", (i, s) => {
    var c = F(i, "ifClause") || F(ae(i, "x:stackTrace")[0], "ifClause");
    const u = F(i, "thenClause") || F(ae(i, "x:stackTrace")[1], "thenClause"), h = F(i, "elseClause") || F(ae(i, "x:stackTrace")[2], "elseClause");
    return ke(F(c, "*"), s), c = ke(F(u, "*"), s), s = ke(F(h, "*"), s), c && s ? c.type === s.type && c.g === s.g ? (c.type !== 59 && we(i, "type", c), i = c) : i = { type: 59, g: 2 } : i = { type: 59, g: 2 }, i;
  }], ["instanceOfExpr", (i, s) => (ke(F(i, "argExpr"), s), ke(F(i, "sequenceType"), s), s = {
    type: 0,
    g: 3
  }, we(i, "type", s), s)], ["integerConstantExpr", (i) => {
    const s = { type: 5, g: 3 };
    return we(i, "type", s), s;
  }], ["doubleConstantExpr", (i) => {
    const s = { type: 3, g: 3 };
    return we(i, "type", s), s;
  }], ["decimalConstantExpr", (i) => {
    const s = { type: 4, g: 3 };
    return we(i, "type", s), s;
  }], ["stringConstantExpr", (i) => {
    const s = { type: 1, g: 3 };
    return we(i, "type", s), s;
  }], ["functionCallExpr", (i, s) => {
    const c = F(i, "arguments");
    return ae(c, "*").map((u) => ke(u, s)), qE(i, s);
  }], ["arrowExpr", (i, s) => (ke(F(i, "argExpr")[1], s), LE(i, s))], [
    "dynamicFunctionInvocationExpr",
    (i, s) => (ke(oe(i, ["functionItem", "*"]), s), (i = F(i, "arguments")) && ke(i, s), { type: 59, g: 2 })
  ], ["namedFunctionRef", (i, s) => XE(i, s)], ["inlineFunctionExpr", (i, s) => (ke(F(i, "functionBody")[1], s), s = { type: 60, g: 3 }, we(i, "type", s), s)], ["castExpr", (i) => {
    var s = oe(i, ["singleType", "atomicType"]);
    return s = { type: ft(le(s, "prefix") + ":" + s[2]), g: 3 }, s.type !== 59 && we(i, "type", s), s;
  }], ["castableExpr", (i) => {
    const s = { type: 0, g: 3 };
    return we(i, "type", s), s;
  }], ["simpleMapExpr", (i, s) => {
    const c = ae(i, "pathExpr");
    let u;
    for (let h = 0; h < c.length; h++) u = ke(c[h], s);
    return u != null ? (s = { type: u.type, g: 2 }, s.type !== 59 && we(i, "type", s), i = s) : i = { type: 59, g: 2 }, i;
  }], ["mapConstructor", (i, s) => (ae(i, "mapConstructorEntry").map((c) => ({ key: ke(oe(c, ["mapKeyExpr", "*"]), s), value: ke(oe(c, ["mapValueExpr", "*"]), s) })), VE(i))], ["arrayConstructor", (i, s) => (ae(F(i, "*"), "arrayElem").map((c) => ke(c, s)), UE(i))], ["unaryLookup", (i) => (F(i, "NCName"), { type: 59, g: 2 })], ["typeswitchExpr", (i, s) => {
    const c = ke(F(i, "argExpr")[1], s), u = ae(i, "typeswitchExprCaseClause").map((g) => ke(oe(
      g,
      ["resultExpr"]
    )[1], s)), h = ke(oe(i, ["typeswitchExprDefaultClause", "resultExpr"])[1], s);
    return YE(i, c, u, h);
  }], ["quantifiedExpr", (i, s) => (ae(i, "*").map((c) => ke(c, s)), KE(i))], ["x:stackTrace", (i, s) => (i = ae(i, "*"), ke(i[0], s))], ["queryBody", (i, s) => ke(i[1], s)], ["flworExpr", (i, s) => _E(i, s)], ["varRef", (i, s) => {
    const c = ze(F(i, "name"));
    var u;
    e: {
      for (u = s.h; 0 <= u; u--) {
        const h = s.o[u][c.localName];
        if (h) {
          u = h;
          break e;
        }
      }
      u = void 0;
    }
    return u && u.type !== 59 && we(i, "type", u), c.namespaceURI === null && (s = s.$(c.prefix), s !== void 0 && we(
      i,
      "URI",
      s
    )), u;
  }]]);
  function wc(i) {
    i.h++, i.o.push({}), i.v.push({});
  }
  function Yy(i, s, c) {
    if (i.o[i.h][s]) throw Error(`Another variable of in the scope ${i.h} with the same name ${s} already exists`);
    i.o[i.h][s] = c;
  }
  var bc = class {
    constructor(i) {
      this.h = 0, this.ga = i, this.o = [{}], this.v = [{}];
    }
    $(i) {
      for (let s = this.h; 0 <= s; s--) {
        const c = this.v[s][i];
        if (c !== void 0) return c;
      }
      return this.ga ? this.ga.$(i) : void 0;
    }
  }, ZE = class extends Ae {
    constructor(i, s) {
      super(new Fe({ external: 1 }), i, { B: i.every((c) => c.B) }, !1, s), this.l = i;
    }
    h(i, s) {
      return this.l.length === 0 ? N.m(new qt([])) : he(this.l[0], i, s).N((c) => N.m(new qt(c.map((u) => st(N.m(u))))));
    }
  }, eT = class extends Ae {
    constructor(i, s) {
      super(new Fe({ external: 1 }), i, { B: i.every((c) => c.B) }, !1, s), this.l = i;
    }
    h(i, s) {
      return N.m(new qt(this.l.map((c) => st(he(c, i, s)))));
    }
  };
  function mr(i) {
    if (i === null) throw _n("context is absent, it needs to be present to use axes.");
    if (!I(i.type, 53)) throw Error("XPTY0020: Axes can only be applied to nodes.");
    return i.value;
  }
  function tT(i, s, c) {
    let u = s;
    return { next: () => {
      if (!u) return H;
      const h = u;
      return u = Ie(i, h, c), j(_e(h));
    } };
  }
  var Qy = class extends Ae {
    constructor(i, s) {
      s = s || { Qa: !1 }, super(i.o, [i], { R: "reverse-sorted", W: !1, subtree: !1, B: !1 }), this.l = i, this.s = !!s.Qa;
    }
    h(i, s) {
      s = s.h, i = mr(i.M);
      var c = this.l.D();
      return c = c && (c.startsWith("name-") || c === "type-1") ? "type-1" : null, N.create(tT(s, this.s ? i : Ie(s, i, c), c)).filter((u) => this.l.l(u));
    }
  };
  const Zy = /* @__PURE__ */ new Map([["type-1-or-type-2", ["name", "type-1", "type-2"]], ["type-1", ["name"]], ["type-2", ["name"]]]);
  function vn(i, s) {
    if (i === null) return s;
    if (s === null || i === s) return i;
    const c = i.startsWith("name-") ? "name" : i, u = s.startsWith("name-") ? "name" : s, h = Zy.get(c);
    return h !== void 0 && h.includes(u) ? s : (s = Zy.get(u), s !== void 0 && s.includes(c) ? i : "empty");
  }
  var nT = class extends Ae {
    constructor(i, s) {
      super(new Fe({ attribute: 1 }), [i], { R: "unsorted", subtree: !0, W: !0, B: !1 }), this.l = i, this.s = vn(this.l.D(), s);
    }
    h(i, s) {
      return s = s.h, i = mr(i.M), i.node.nodeType !== 1 ? N.empty() : (i = zo(s, i, this.s).filter((c) => c.node.namespaceURI !== "http://www.w3.org/2000/xmlns/").map((c) => _e(c)).filter((c) => this.l.l(c)), N.create(i));
    }
    D() {
      return "type-1";
    }
  }, rT = class extends Ae {
    constructor(i, s) {
      super(i.o, [i], { R: "sorted", subtree: !0, W: !0, B: !1 }), this.s = i, this.l = vn(s, i.D());
    }
    h(i, s) {
      const c = s.h, u = mr(i.M);
      if (i = u.node.nodeType, i !== 1 && i !== 9) return N.empty();
      let h = null, g = !1;
      return N.create({ next: () => {
        for (; !g; ) {
          if (!h) {
            if (h = Jl(c, u, this.l), !h) {
              g = !0;
              continue;
            }
            return j(_e(h));
          }
          if (h = ai(c, h, this.l)) return j(_e(h));
          g = !0;
        }
        return H;
      } }).filter((b) => this.s.l(b));
    }
  };
  function up(i, s, c) {
    const u = s.node.nodeType;
    if (u !== 1 && u !== 9) return { next: () => H };
    let h = Jl(i, s, c);
    return { next() {
      if (!h) return H;
      const g = h;
      return h = ai(i, h, c), j(g);
    } };
  }
  function iT(i, s, c) {
    const u = [$r(s)];
    return { next: (h) => {
      if (0 < u.length && h & 1 && u.shift(), !u.length) return H;
      for (h = u[0].next(0); h.done; ) {
        if (u.shift(), !u.length) return H;
        h = u[0].next(0);
      }
      return u.unshift(up(i, h.value, c)), j(_e(h.value));
    } };
  }
  var e0 = class extends Ae {
    constructor(i, s) {
      s = s || { Qa: !1 }, super(i.o, [i], { B: !1, W: !1, R: "sorted", subtree: !0 }), this.l = i, this.s = !!s.Qa, this.A = (i = this.l.D()) && (i.startsWith("name-") || i === "type-1") || i === "type-1-or-type-2" ? "type-1" : null;
    }
    h(i, s) {
      return s = s.h, i = mr(i.M), i = iT(s, i, this.A), this.s || i.next(0), N.create(i).filter((c) => this.l.l(c));
    }
  };
  function t0(i, s, c) {
    var u = i.node.nodeType;
    if (u !== 1 && u !== 9) return i;
    for (u = hg(s, i, c); u !== null; ) {
      if (u.node.nodeType !== 1) return u;
      i = u, u = hg(s, i, c);
    }
    return i;
  }
  function n0(i, s, c = !1, u) {
    if (c) {
      let g = s, b = !1;
      return { next: () => {
        if (b) return H;
        if (mt(g, s)) return g = t0(s, i, u), mt(g, s) ? (b = !0, H) : j(_e(g));
        const x = g.node.nodeType, C = x === 9 || x === 2 ? null : ya(i, g, u);
        return C !== null ? (g = t0(C, i, u), j(_e(g))) : (g = x === 9 ? null : Ie(i, g, u), mt(g, s) ? (b = !0, H) : j(_e(g)));
      } };
    }
    const h = [up(i, s, u)];
    return { next: () => {
      if (!h.length) return H;
      let g = h[0].next(0);
      for (; g.done; ) {
        if (h.shift(), !h.length) return H;
        g = h[0].next(0);
      }
      return h.unshift(up(i, g.value, u)), j(_e(g.value));
    } };
  }
  function oT(i, s, c) {
    const u = [];
    for (; s && s.node.nodeType !== 9; s = Ie(i, s, null)) {
      const g = ai(i, s, c);
      g && u.push(g);
    }
    let h = null;
    return { next: () => {
      for (; h || u.length; ) {
        if (!h) {
          h = n0(i, u[0], !1, c);
          var g = j(_e(u[0]));
          const b = ai(i, u[0], c);
          return b ? u[0] = b : u.shift(), g;
        }
        if (g = h.next(0), g.done) h = null;
        else return g;
      }
      return H;
    } };
  }
  var sT = class extends Ae {
    constructor(i) {
      super(i.o, [i], { R: "sorted", W: !0, subtree: !1, B: !1 }), this.l = i, this.s = (i = this.l.D()) && (i.startsWith("name-") || i === "type-1") ? "type-1" : null;
    }
    h(i, s) {
      return s = s.h, i = mr(i.M), N.create(oT(s, i, this.s)).filter((c) => this.l.l(c));
    }
  };
  function aT(i, s, c) {
    return { next: () => (s = s && ai(i, s, c)) ? j(_e(s)) : H };
  }
  var lT = class extends Ae {
    constructor(i, s) {
      super(i.o, [i], { R: "sorted", W: !0, subtree: !1, B: !1 }), this.l = i, this.s = vn(this.l.D(), s);
    }
    h(i, s) {
      return s = s.h, i = mr(i.M), N.create(aT(s, i, this.s)).filter((c) => this.l.l(c));
    }
  }, cT = class extends Ae {
    constructor(i, s) {
      super(i.o, [i], { R: "reverse-sorted", W: !0, subtree: !0, B: !1 }), this.l = i, this.s = vn(s, this.l.D());
    }
    h(i, s) {
      return s = s.h, i = mr(i.M), i = Ie(s, i, this.s), i ? (i = _e(i), this.l.l(i) ? N.m(i) : N.empty()) : N.empty();
    }
  };
  function uT(i, s, c) {
    const u = [];
    for (; s && s.node.nodeType !== 9; s = Ie(i, s, null)) {
      const g = ya(i, s, c);
      g !== null && u.push(g);
    }
    let h = null;
    return { next: () => {
      for (; h || u.length; ) {
        h || (h = n0(i, u[0], !0, c));
        var g = h.next(0);
        if (g.done) {
          h = null, g = ya(i, u[0], c);
          const b = j(_e(u[0]));
          return g === null ? u.shift() : u[0] = g, b;
        }
        return g;
      }
      return H;
    } };
  }
  var dT = class extends Ae {
    constructor(i) {
      super(i.o, [i], { B: !1, W: !0, R: "reverse-sorted", subtree: !1 }), this.l = i, this.s = (i = this.l.D()) && (i.startsWith("name-") || i === "type-1") ? "type-1" : null;
    }
    h(i, s) {
      return s = s.h, i = mr(i.M), N.create(uT(s, i, this.s)).filter((c) => this.l.l(c));
    }
  };
  function pT(i, s, c) {
    return { next: () => (s = s && ya(i, s, c)) ? j(_e(s)) : H };
  }
  var hT = class extends Ae {
    constructor(i, s) {
      super(i.o, [i], { B: !1, W: !0, R: "reverse-sorted", subtree: !1 }), this.l = i, this.s = vn(this.l.D(), s);
    }
    h(i, s) {
      return s = s.h, i = mr(i.M), N.create(pT(s, i, this.s)).filter((c) => this.l.l(c));
    }
  }, fT = class extends Ae {
    constructor(i, s) {
      super(i.o, [i], { R: "sorted", subtree: !0, W: !0, B: !1 }), this.l = i, this.s = vn(this.l.D(), s);
    }
    h(i) {
      return mr(i.M), this.l.l(i.M) ? N.m(i.M) : N.empty();
    }
    D() {
      return this.s;
    }
  }, mT = class extends Qo {
    constructor(i, s, c, u) {
      super(i.o.add(s.o).add(c.o), [i, s, c], { B: i.B && s.B && c.B, W: s.W === c.W && s.W, R: s.ia === c.ia ? s.ia : "unsorted", subtree: s.subtree === c.subtree && s.subtree }, u), this.l = i;
    }
    A(i, s, c) {
      let u = null;
      const h = c[0](i);
      return N.create({ next: (g) => (u || (u = (h.fa() ? c[1](i) : c[2](i)).value), u.next(g)) });
    }
    v(i) {
      if (super.v(i), this.l.I) throw jr();
    }
  };
  function r0(i) {
    return i.h instanceof Error ? i.location : r0(i.h);
  }
  function i0(i) {
    let s;
    return s = i.h instanceof Dy ? ["Inner error:", i.h.message] : i.h instanceof Error ? [i.h.toString()] : i0(i.h), s.push(`  at <${i.o}${i.Wa ? ` (${i.Wa})` : ""}>:${i.location.start.line}:${i.location.start.ha} - ${i.location.end.line}:${i.location.end.ha}`), s;
  }
  var vc = class {
    constructor(i, s, c, u) {
      this.location = i, this.o = s, this.Wa = c, this.h = u;
    }
  }, gT = class extends Qo {
    constructor(i, s, c, u) {
      super(c.o, [c], { B: c.B, W: c.W, R: c.ia, subtree: c.subtree }), this.L = s, this.P = { end: { ha: i.end.ha, line: i.end.line, offset: i.end.offset }, start: { ha: i.start.ha, line: i.start.line, offset: i.start.offset } }, this.l = u;
    }
    A(i, s, [c]) {
      let u;
      try {
        u = c(i);
      } catch (h) {
        throw new vc(this.P, this.L, this.l, h);
      }
      return N.create({ next: (h) => {
        try {
          return u.value.next(h);
        } catch (g) {
          throw new vc(this.P, this.L, this.l, g);
        }
      } });
    }
    v(i) {
      try {
        super.v(i);
      } catch (s) {
        throw new vc(this.P, this.L, this.l, s);
      }
    }
    D() {
      return this.Fa[0].D();
    }
  };
  function o0(i, s, c, u) {
    let h = [];
    const g = i.L(s, c, u, (x) => {
      if (i.l instanceof Wi) {
        const T = o0(i.l, s, x, u);
        return Yo(T, (R) => h = R);
      }
      let C = null;
      return N.create({ next: () => {
        for (; ; ) {
          if (!C) {
            var T = x.next(0);
            if (T.done) return H;
            T = i.l.s(T.value, u), C = Yo(T, (R) => h = zn(h, R)).value;
          }
          if (T = C.next(0), T.done) C = null;
          else return T;
        }
      } });
    });
    let b = !1;
    return { next: () => {
      if (b) return H;
      const x = g.O();
      return b = !0, j(new fy(x, h));
    } };
  }
  function s0(i, s, c, u) {
    return i.L(s, c, u, (h) => {
      if (i.l instanceof Wi) return s0(i.l, s, h, u);
      let g = null;
      return N.create({ next: () => {
        for (; ; ) {
          if (!g) {
            var b = h.next(0);
            if (b.done) return H;
            g = he(i.l, b.value, u).value;
          }
          if (b = g.next(0), b.done) g = null;
          else return b;
        }
      } });
    });
  }
  var Wi = class extends Ae {
    constructor(i, s, c, u) {
      super(i, s, c, !0), this.l = u, this.I = this.l.I;
    }
    h(i, s) {
      return this.L(i, $r(i), s, (c) => {
        if (this.l instanceof Wi) return s0(this.l, i, c, s);
        let u = null;
        return N.create({ next: (h) => {
          for (; ; ) {
            if (!u) {
              var g = c.next(0);
              if (g.done) return H;
              u = he(this.l, g.value, s).value;
            }
            if (g = u.next(h), g.done) u = null;
            else return g;
          }
        } });
      });
    }
    s(i, s) {
      return o0(this, i, $r(i), s);
    }
    v(i) {
      super.v(i), this.I = this.l.I;
      for (const s of this.Fa) if (s !== this.l && s.I) throw jr();
    }
  }, yT = class extends Wi {
    constructor(i, s, c, u) {
      super(s.o.add(u.o), [s, u], { B: !1 }, u), this.P = i.prefix, this.ma = i.namespaceURI, this.Pb = i.localName, this.yb = null, this.A = c, this.La = null, this.ya = s;
    }
    L(i, s, c, u) {
      let h = null, g = null, b = 0;
      return u({ next: () => {
        for (; ; ) {
          if (!h) {
            var x = s.next(0);
            if (x.done) return H;
            g = x.value, b = 0, h = he(this.ya, g, c).value;
          }
          const C = h.next(0);
          if (C.done) h = null;
          else return b++, x = { [this.yb]: () => N.m(C.value) }, this.La && (x[this.La] = () => N.m(new Ge(5, b))), j(ci(g, x));
        }
      } });
    }
    v(i) {
      if (this.P && (this.ma = i.$(this.P), !this.ma && this.P)) throw Error(`XPST0081: Could not resolve namespace for prefix ${this.P} in a for expression`);
      if (this.ya.v(i), ts(i), this.yb = fr(i, this.ma, this.Pb), this.A) {
        if (this.A.prefix && (this.A.namespaceURI = i.$(this.A.prefix), !this.A.namespaceURI && this.A.prefix)) throw Error(`XPST0081: Could not resolve namespace for prefix ${this.P} in the positionalVariableBinding in a for expression`);
        this.La = fr(i, this.A.namespaceURI, this.A.localName);
      }
      if (this.l.v(i), ns(i), this.ya.I) throw jr();
      this.l.I && (this.I = !0);
    }
  }, wT = class extends Ae {
    constructor(i, s, c) {
      super(new Fe({ external: 1 }), [c], { B: !1, R: "unsorted" }), this.P = i.map(({ name: u }) => u), this.A = i.map(({ type: u }) => u), this.s = null, this.L = s, this.l = c;
    }
    h(i, s) {
      const c = new oi({ j: this.A, arity: this.A.length, Ya: !0, I: this.l.I, localName: "dynamic-function", namespaceURI: "", i: this.L, value: (u, h, g, ...b) => (u = ci(Fr(i, -1, null, N.empty()), this.s.reduce((x, C, T) => (x[C] = st(b[T]), x), /* @__PURE__ */ Object.create(null))), he(this.l, u, s)) });
      return N.m(c);
    }
    v(i) {
      if (ts(i), this.s = this.P.map((s) => fr(
        i,
        s.namespaceURI,
        s.localName
      )), this.l.v(i), ns(i), this.l.I) throw Error("Not implemented: inline functions can not yet be updating.");
    }
  }, bT = class extends Wi {
    constructor(i, s, c) {
      if (super(s.o.add(c.o), [s, c], { B: !1, W: c.W, R: c.ia, subtree: c.subtree }, c), i.prefix || i.namespaceURI) throw Error("Not implemented: let expressions with namespace usage.");
      this.A = i.prefix, this.P = i.namespaceURI, this.La = i.localName, this.ma = s, this.ya = null;
    }
    L(i, s, c, u) {
      return u({ next: () => {
        var h = s.next(0);
        return h.done ? H : (h = h.value, h = ci(h, { [this.ya]: st(he(this.ma, h, c)) }), j(h));
      } });
    }
    v(i) {
      if (this.A && (this.P = i.$(this.A), !this.P && this.A)) throw Error(`XPST0081: Could not resolve namespace for prefix ${this.A} using in a for expression`);
      if (this.ma.v(i), ts(i), this.ya = fr(i, this.P, this.La), this.l.v(i), ns(i), this.I = this.l.I, this.ma.I) throw jr();
    }
  }, as = class extends Ae {
    constructor(i, s) {
      super(new Fe({}), [], { B: !0, R: "sorted" }, !1, s);
      let c;
      switch (s.type) {
        case 5:
          c = M(parseInt(i, 10), s.type);
          break;
        case 1:
          c = M(i, s.type);
          break;
        case 4:
        case 3:
          c = M(parseFloat(i), s.type);
          break;
        default:
          throw new TypeError("Type " + s + " not expected in a literal");
      }
      this.l = () => N.m(c);
    }
    h() {
      return this.l();
    }
  }, vT = class extends Ae {
    constructor(i, s) {
      super(new Fe({ external: 1 }), i.reduce((c, { key: u, value: h }) => c.concat(u, h), []), { B: !1 }, !1, s), this.l = i;
    }
    h(i, s) {
      const c = this.l.map((u) => at(he(u.key, i, s), s).X({ default: () => {
        throw Error("XPTY0004: A key of a map should be a single atomizable value.");
      }, m: (h) => h }));
      return Oe(c, (u) => N.m(new Dr(u.map((h, g) => ({ key: h, value: st(he(this.l[g].value, i, s)) })))));
    }
  }, Ia = class extends Ae {
    constructor(i, s, c) {
      super(new Fe({ external: 1 }), [], { B: !0 }, !1, c), this.s = s, this.A = i, this.l = null;
    }
    h() {
      const i = new oi({ j: this.l.j, I: this.l.I, arity: this.s, localName: this.l.localName, namespaceURI: this.l.namespaceURI, i: this.l.i, value: this.l.callFunction });
      return N.m(i);
    }
    v(i) {
      let s = this.A.namespaceURI, c = this.A.localName;
      const u = this.A.prefix;
      if (s === null) {
        const h = i.Sa({ localName: c, prefix: u }, this.s);
        if (!h) throw Error(`XPST0017: The function ${u ? u + ":" : ""}${c} with arity ${this.s} could not be resolved. ${rp(c)}`);
        s = h.namespaceURI, c = h.localName;
      }
      if (this.l = i.va(s, c, this.s) || null, !this.l) throw i = this.A, Error(`XPST0017: Function ${`${i.namespaceURI ? `Q{${i.namespaceURI}}` : i.prefix ? `${i.prefix}:` : ""}${i.localName}`} with arity of ${this.s} not registered. ${rp(c)}`);
      super.v(i);
    }
  };
  const xT = { 5: 5, 27: 5, 28: 5, 31: 5, 32: 5, 33: 5, 34: 5, 30: 5, 36: 5, 35: 5, 38: 5, 37: 5, 29: 5, 4: 4, 6: 6, 3: 3 };
  var a0 = class extends Ae {
    constructor(i, s, c) {
      super(s.o, [s], { B: !1 }, !1, c), this.s = s, this.l = i;
    }
    h(i, s) {
      return at(he(this.s, i, s), s).N((c) => {
        if (c.length === 0) return N.empty();
        var u = c[0];
        if (this.type) return c = this.l === "+" ? +u.value : -u.value, u.type === 0 && (c = Number.NaN), N.m(M(c, this.type.type));
        if (1 < c.length) throw Error("XPTY0004: The operand to a unary operator must be a sequence with a length less than one");
        return I(u.type, 19) ? (u = He(u, 3).value, N.m(M(this.l === "+" ? u : -u, 3))) : I(u.type, 2) ? this.l === "+" ? N.m(u) : N.m(M(-1 * u.value, xT[u.type])) : N.m(M(Number.NaN, 3));
      });
    }
  }, kT = class extends Ae {
    constructor(i, s) {
      super(i.reduce((c, u) => c.add(u.o), new Fe({})), i, { B: i.every((c) => c.B) }, !1, s), this.l = i, this.s = i.reduce((c, u) => vn(c, u.D()), null);
    }
    h(i, s) {
      let c = 0, u = null, h = !1, g = null;
      if (i !== null) {
        const b = i.M;
        b !== null && I(b.type, 53) && (g = dg(b.value));
      }
      return N.create({ next: () => {
        if (!h) {
          for (; c < this.l.length; ) {
            if (!u) {
              const b = this.l[c];
              if (g !== null && b.D() !== null && !g.includes(b.D())) return c++, h = !0, j(U);
              u = he(b, i, s);
            }
            if (u.fa() === !1) return h = !0, j(U);
            u = null, c++;
          }
          return h = !0, j(ee);
        }
        return H;
      } });
    }
    D() {
      return this.s;
    }
  }, AT = class extends Ae {
    constructor(i, s) {
      super(i.reduce((u, h) => 0 < dc(u, h.o) ? u : h.o, new Fe({})), i, { B: i.every((u) => u.B) }, !1, s);
      let c;
      for (s = 0; s < i.length && (c === void 0 && (c = i[s].D()), c !== null); ++s)
        if (c !== i[s].D()) {
          c = null;
          break;
        }
      this.s = c, this.l = i;
    }
    h(i, s) {
      let c = 0, u = null, h = !1, g = null;
      if (i !== null) {
        const b = i.M;
        b !== null && I(b.type, 53) && (g = dg(b.value));
      }
      return N.create({ next: () => {
        if (!h) {
          for (; c < this.l.length; ) {
            if (!u) {
              const b = this.l[c];
              if (g !== null && b.D() !== null && !g.includes(b.D())) {
                c++;
                continue;
              }
              u = he(b, i, s);
            }
            if (u.fa() === !0) return h = !0, j(ee);
            u = null, c++;
          }
          return h = !0, j(U);
        }
        return H;
      } });
    }
    D() {
      return this.s;
    }
  };
  function ls(i, s) {
    let c;
    return N.create({ next: (u) => {
      for (; ; ) {
        if (!c) {
          var h = i.value.next(u);
          if (h.done) return H;
          c = Pr(h.value, s);
        }
        if (h = c.value.next(u), h.done) c = null;
        else return h;
      }
    } });
  }
  function CT(i, s) {
    if (i === "eqOp") return (c, u) => {
      const { U: h, V: g } = s(c, u);
      return h.value.namespaceURI === g.value.namespaceURI && h.value.localName === g.value.localName;
    };
    if (i === "neOp") return (c, u) => {
      const { U: h, V: g } = s(c, u);
      return h.value.namespaceURI !== g.value.namespaceURI || h.value.localName !== g.value.localName;
    };
    throw Error('XPTY0004: Only the "eq" and "ne" comparison is defined for xs:QName');
  }
  function ST(i, s) {
    switch (i) {
      case "eqOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return h.value === g.value;
        };
      case "neOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return h.value !== g.value;
        };
      case "ltOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return h.value < g.value;
        };
      case "leOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return h.value <= g.value;
        };
      case "gtOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return h.value > g.value;
        };
      case "geOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return h.value >= g.value;
        };
    }
  }
  function ET(i, s) {
    switch (i) {
      case "ltOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return h.value.ea < g.value.ea;
        };
      case "leOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return Rr(h.value, g.value) || h.value.ea < g.value.ea;
        };
      case "gtOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return h.value.ea > g.value.ea;
        };
      case "geOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return Rr(h.value, g.value) || h.value.ea > g.value.ea;
        };
    }
  }
  function TT(i, s) {
    switch (i) {
      case "eqOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return Rr(h.value, g.value);
        };
      case "ltOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return h.value.ca < g.value.ca;
        };
      case "leOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return Rr(h.value, g.value) || h.value.ca < g.value.ca;
        };
      case "gtOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return h.value.ca > g.value.ca;
        };
      case "geOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return Rr(h.value, g.value) || h.value.ca > g.value.ca;
        };
    }
  }
  function NT(i, s) {
    switch (i) {
      case "eqOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return Rr(h.value, g.value);
        };
      case "neOp":
        return (c, u) => {
          const { U: h, V: g } = s(c, u);
          return !Rr(h.value, g.value);
        };
    }
  }
  function BT(i, s) {
    switch (i) {
      case "eqOp":
        return (c, u, h) => {
          const { U: g, V: b } = s(c, u);
          return qi(g.value, b.value, Hn(h));
        };
      case "neOp":
        return (c, u, h) => {
          const { U: g, V: b } = s(c, u);
          return !qi(g.value, b.value, Hn(h));
        };
      case "ltOp":
        return (c, u, h) => {
          const { U: g, V: b } = s(c, u);
          return c = Hn(h), 0 > xa(g.value, b.value, c);
        };
      case "leOp":
        return (c, u, h) => {
          const { U: g, V: b } = s(c, u);
          return (c = qi(g.value, b.value, Hn(h))) || (h = Hn(h), c = 0 > xa(g.value, b.value, h)), c;
        };
      case "gtOp":
        return (c, u, h) => {
          const { U: g, V: b } = s(c, u);
          return c = Hn(h), 0 < xa(
            g.value,
            b.value,
            c
          );
        };
      case "geOp":
        return (c, u, h) => {
          const { U: g, V: b } = s(c, u);
          return (c = qi(g.value, b.value, Hn(h))) || (h = Hn(h), c = 0 < xa(g.value, b.value, h)), c;
        };
    }
  }
  function IT(i, s) {
    switch (i) {
      case "eqOp":
        return (c, u, h) => {
          const { U: g, V: b } = s(c, u);
          return qi(g.value, b.value, Hn(h));
        };
      case "neOp":
        return (c, u, h) => {
          const { U: g, V: b } = s(c, u);
          return !qi(g.value, b.value, Hn(h));
        };
    }
  }
  function MT(i, s, c) {
    function u(T, R) {
      return { U: b ? b(T) : T, V: x ? x(R) : R };
    }
    function h(T) {
      return I(s, T) && I(c, T);
    }
    function g(T) {
      return 0 < T.filter((R) => I(s, R)).length && 0 < T.filter((R) => I(c, R)).length;
    }
    let b = null, x = null;
    if (I(s, 19) && I(c, 19) ? s = c = 1 : I(s, 19) ? (b = (T) => He(T, c), s = c) : I(c, 19) && (x = (T) => He(T, s), c = s), I(s, 23) && I(c, 23)) return CT(i, u);
    if (h(0) || g([1, 47, 61]) || g([2, 47, 61]) || h(20) || h(22) || h(21) || g([1, 20])) {
      var C = ST(i, u);
      if (C !== void 0) return C;
    }
    if (h(16) && (C = ET(i, u), C !== void 0) || h(17) && (C = TT(i, u), C !== void 0) || h(18) && (C = NT(i, u), C !== void 0) || (h(9) || h(7) || h(8)) && (C = BT(i, u), C !== void 0) || (h(11) || h(12) || h(13) || h(14) || h(15)) && (C = IT(i, u), C !== void 0)) return C;
    throw Error(`XPTY0004: ${i} not available for ${se[s]} and ${se[c]}`);
  }
  const l0 = /* @__PURE__ */ Object.create(null);
  function xc(i, s, c) {
    const u = `${s}~${c}~${i}`;
    let h = l0[u];
    return h || (h = l0[u] = MT(i, s, c)), h;
  }
  var OT = class extends Ae {
    constructor(i, s, c) {
      super(s.o.add(c.o), [s, c], { B: !1 }), this.l = s, this.A = c, this.s = i;
    }
    h(i, s) {
      const c = he(this.l, i, s), u = he(this.A, i, s), h = ls(c, s), g = ls(u, s);
      return h.X({ empty: () => N.empty(), m: () => g.X({ empty: () => N.empty(), m: () => {
        const b = h.first(), x = g.first();
        return xc(this.s, b.type, x.type)(b, x, i) ? N.aa() : N.T();
      }, multiple: () => {
        throw Error("XPTY0004: Sequences to compare are not singleton.");
      } }), multiple: () => {
        throw Error("XPTY0004: Sequences to compare are not singleton.");
      } });
    }
  };
  const DT = { equalOp: "eqOp", notEqualOp: "neOp", lessThanOrEqualOp: "leOp", lessThanOp: "ltOp", greaterThanOrEqualOp: "geOp", greaterThanOp: "gtOp" };
  function RT(i, s, c, u) {
    return i = DT[i], c.N((h) => s.filter((g) => {
      for (let C = 0, T = h.length; C < T; ++C) {
        let R = h[C], P, q;
        var b = g.type, x = R.type;
        (I(b, 19) || I(x, 19)) && (I(b, 2) ? P = 3 : I(x, 2) ? q = 3 : I(b, 17) ? P = 17 : I(x, 17) ? q = 17 : I(b, 16) ? P = 16 : I(x, 16) ? q = 16 : I(b, 19) ? q = x : I(x, 19) && (P = b));
        const [_, ie] = [q, P];
        if (b = _, x = ie, b ? g = He(g, b) : x && (R = He(R, x)), xc(i, g.type, R.type)(g, R, u)) return !0;
      }
      return !1;
    }).X({ default: () => N.aa(), empty: () => N.T() }));
  }
  var FT = class extends Ae {
    constructor(i, s, c) {
      super(s.o.add(c.o), [s, c], { B: !1 }), this.l = s, this.A = c, this.s = i;
    }
    h(i, s) {
      const c = he(this.l, i, s), u = he(this.A, i, s);
      return c.X({ empty: () => N.T(), default: () => u.X({ empty: () => N.T(), default: () => {
        const h = ls(c, s), g = ls(u, s);
        return RT(this.s, h, g, i);
      } }) });
    }
  };
  function PT(i, s, c, u) {
    if (!I(c, 53) || !I(u, 53)) throw Error("XPTY0004: Sequences to compare are not nodes");
    switch (i) {
      case "isOp":
        return $T(c, u);
      case "nodeBeforeOp":
        return s ? (h, g) => 0 > Aa(s, h.first(), g.first()) : void 0;
      case "nodeAfterOp":
        return s ? (h, g) => 0 < Aa(s, h.first(), g.first()) : void 0;
      default:
        throw Error("Unexpected operator");
    }
  }
  function $T(i, s) {
    return i !== s || i !== 47 && i !== 53 && i !== 54 && i !== 55 && i !== 56 && i !== 57 && i !== 58 ? () => !1 : (c, u) => mt(c.first().value, u.first().value);
  }
  var jT = class extends Ae {
    constructor(i, s, c) {
      super(s.o.add(c.o), [s, c], { B: !1 }), this.l = s, this.A = c, this.s = i;
    }
    h(i, s) {
      const c = he(this.l, i, s), u = he(this.A, i, s);
      return c.X({ empty: () => N.empty(), multiple: () => {
        throw Error("XPTY0004: Sequences to compare are not singleton");
      }, m: () => u.X({ empty: () => N.empty(), multiple: () => {
        throw Error("XPTY0004: Sequences to compare are not singleton");
      }, m: () => {
        const h = c.first(), g = u.first();
        return PT(this.s, s.h, h.type, g.type)(c, u, i) ? N.aa() : N.T();
      } }) });
    }
  };
  function c0(i, s, c, u) {
    return c.N((h) => {
      if (h.some((g) => !I(g.type, 53))) throw Error(`XPTY0004: Sequences given to ${i} should only contain nodes.`);
      return u === "sorted" ? N.create(h) : u === "reverse-sorted" ? N.create(h.reverse()) : N.create(Ca(s, h));
    });
  }
  var UT = class extends Ae {
    constructor(i, s, c, u) {
      super(0 < dc(s.o, c.o) ? s.o : c.o, [s, c], { B: s.B && c.B }, !1, u), this.l = i, this.s = s, this.A = c;
    }
    h(i, s) {
      const c = c0(this.l, s.h, he(this.s, i, s), this.s.ia);
      i = c0(this.l, s.h, he(this.A, i, s), this.A.ia);
      const u = c.value, h = i.value;
      let g = null, b = null, x = !1, C = !1;
      return N.create({ next: () => {
        if (x) return H;
        for (; !C; ) {
          if (!g) {
            var T = u.next(0);
            if (T.done) return x = !0, H;
            g = T.value;
          }
          if (!b) {
            if (T = h.next(0), T.done) {
              C = !0;
              break;
            }
            b = T.value;
          }
          if (mt(g.value, b.value)) {
            if (T = j(g), b = g = null, this.l === "intersectOp") return T;
          } else if (0 > Aa(s.h, g, b)) {
            if (T = j(g), g = null, this.l === "exceptOp") return T;
          } else b = null;
        }
        return this.l === "exceptOp" ? g !== null ? (T = j(g), g = null, T) : u.next(0) : (x = !0, H);
      } });
    }
  }, dp = class extends Qo {
    constructor(i, s) {
      super(i.reduce((c, u) => c.add(u.o), new Fe({})), i, { R: "unsorted", B: i.every((c) => c.B) }, s);
    }
    A(i, s, c) {
      return c.length ? Gn(c.map((u) => u(i))) : N.empty();
    }
  }, LT = class extends Ae {
    constructor(i, s, c) {
      super(new Fe({}).add(i.o), [i, s], { B: i.B && s.B }, !1, c), this.l = i, this.s = s;
    }
    h(i, s) {
      const c = he(this.l, i, s), u = bg(i, c);
      let h = null, g = null, b = !1;
      return N.create({ next: (x) => {
        for (; !b; ) {
          if (!h && (h = u.next(x), h.done)) return b = !0, H;
          g || (g = he(this.s, h.value, s));
          const C = g.value.next(x);
          if (C.done) h = g = null;
          else return C;
        }
      } });
    }
  }, HT = class extends Ae {
    constructor(i, s, c) {
      if (super(i.o, [i], { B: !1 }), this.l = ft(s.prefix ? `${s.prefix}:${s.localName}` : s.localName), this.l === 46 || this.l === 45 || this.l === 44) throw Error("XPST0080: Casting to xs:anyAtomicType, xs:anySimpleType or xs:NOTATION is not permitted.");
      if (s.namespaceURI) throw Error("Not implemented: castable as expressions with a namespace URI.");
      this.A = i, this.s = c;
    }
    h(i, s) {
      const c = at(he(this.A, i, s), s);
      return c.X({ empty: () => this.s ? N.aa() : N.T(), m: () => c.map((u) => Ld(u, this.l).u ? ee : U), multiple: () => N.T() });
    }
  }, GT = class extends Ae {
    constructor(i, s, c) {
      if (super(i.o, [i], { B: !1 }), this.l = ft(s.prefix ? `${s.prefix}:${s.localName}` : s.localName), this.l === 46 || this.l === 45 || this.l === 44) throw Error("XPST0080: Casting to xs:anyAtomicType, xs:anySimpleType or xs:NOTATION is not permitted.");
      if (s.namespaceURI) throw Error("Not implemented: casting expressions with a namespace URI.");
      this.A = i, this.s = c;
    }
    h(i, s) {
      const c = at(he(this.A, i, s), s);
      return c.X({ empty: () => {
        if (!this.s) throw Error("XPTY0004: Sequence to cast is empty while target type is singleton.");
        return N.empty();
      }, m: () => c.map((u) => He(u, this.l)), multiple: () => {
        throw Error("XPTY0004: Sequence to cast is not singleton or empty.");
      } });
    }
  };
  function u0(i, s) {
    const c = i.value;
    let u = null, h = !1;
    return N.create({ next: () => {
      for (; !h; ) {
        if (!u) {
          var g = c.next(0);
          if (g.done) return h = !0, j(ee);
          u = s(g.value);
        }
        if (g = u.fa(), u = null, g === !1) return h = !0, j(U);
      }
      return H;
    } });
  }
  var _T = class extends Ae {
    constructor(i, s, c, u) {
      super(i.o, [i], { B: !1 }, !1, u), this.A = i, this.s = s, this.l = c;
    }
    h(i, s) {
      const c = he(this.A, i, s);
      return c.X({ empty: () => this.l === "?" || this.l === "*" ? N.aa() : N.T(), multiple: () => this.l === "+" || this.l === "*" ? u0(c, (u) => {
        const h = N.m(u);
        return u = Fr(i, 0, u, h), he(this.s, u, s);
      }) : N.T(), m: () => u0(c, (u) => {
        const h = N.m(u);
        return u = Fr(i, 0, u, h), he(this.s, u, s);
      }) });
    }
  };
  function d0(i, s) {
    return i !== null && s !== null && I(i.type, 53) && I(s.type, 53) ? mt(i.value, s.value) : !1;
  }
  function pp(i) {
    let s = i.next(0);
    if (s.done) return N.empty();
    let c = null, u = null;
    return N.create({ next(h) {
      if (s.done) return H;
      c || (c = s.value.value);
      let g;
      do
        if (g = c.next(h), g.done) {
          if (s = i.next(0), s.done) return g;
          c = s.value.value;
        }
      while (g.done || d0(g.value, u));
      return u = g.value, g;
    } });
  }
  function p0(i, s) {
    const c = [];
    (function() {
      for (var g = s.next(0); !g.done; ) {
        const b = g.value.value;
        g = { current: b.next(0), next: (x) => b.next(x) }, g.current.done || c.push(g), g = s.next(0);
      }
    })();
    let u = null, h = !1;
    return N.create({ [Symbol.iterator]() {
      return this;
    }, next: () => {
      h || (h = !0, c.every((b) => I(b.current.value.type, 53)) && c.sort((b, x) => Aa(i, b.current.value, x.current.value)));
      let g;
      do {
        if (!c.length) return H;
        const b = c.shift();
        if (g = b.current, b.current = b.next(0), !I(g.value.type, 53)) return g;
        if (!b.current.done) {
          let x = 0, C = c.length - 1, T = 0;
          for (; x <= C; ) {
            T = Math.floor((x + C) / 2);
            const R = Aa(i, b.current.value, c[T].current.value);
            if (R === 0) {
              x = T;
              break;
            }
            0 < R ? x = T + 1 : C = T - 1;
          }
          c.splice(x, 0, b);
        }
      } while (d0(g.value, u));
      return u = g.value, g;
    } });
  }
  var zT = class extends Ae {
    constructor(i, s) {
      super(i.reduce((c, u) => 0 < dc(c, u.o) ? c : u.o, new Fe({})), i, { B: i.every((c) => c.B) }, !1, s), this.l = i;
    }
    h(i, s) {
      if (this.l.every((c) => c.ia === "sorted")) {
        let c = 0;
        return p0(s.h, { next: () => c >= this.l.length ? H : j(he(this.l[c++], i, s)) }).map((u) => {
          if (!I(u.type, 53)) throw Error("XPTY0004: The sequences to union are not of type node()*");
          return u;
        });
      }
      return Gn(this.l.map((c) => he(c, i, s))).N((c) => {
        if (c.some((u) => !I(u.type, 53))) throw Error("XPTY0004: The sequences to union are not of type node()*");
        return c = Ca(
          s.h,
          c
        ), N.create(c);
      });
    }
  };
  function kc(i) {
    return i.every((s) => s === null || I(s.type, 5) || I(s.type, 4)) || i.map((s) => s ? tc(s.type) : null).reduce((s, c) => c === null || c === s ? s : null) !== null ? i : i.every((s) => s === null || I(s.type, 1) || I(s.type, 20)) ? i.map((s) => s ? He(s, 1) : null) : i.every((s) => s === null || I(s.type, 4) || I(s.type, 6)) ? i.map((s) => s && He(s, 6)) : i.every((s) => s === null || I(s.type, 4) || I(s.type, 6) || I(s.type, 3)) ? i.map((s) => s && He(s, 3)) : null;
  }
  function qT(i) {
    return (i = i.find((s) => !!s)) ? tc(i.type) : null;
  }
  var VT = class extends Wi {
    constructor(i, s) {
      super(new Fe({}), [s, ...i.map((c) => c.ba)], { B: !1, W: !1, R: "unsorted", subtree: !1 }, s), this.A = i;
    }
    L(i, s, c, u) {
      if (this.A[1]) throw Error("More than one order spec is not supported for the order by clause.");
      const h = [];
      let g = !1, b, x, C = null;
      const T = this.A[0];
      return N.create({ next: () => {
        if (!g) {
          for (var R = s.next(0); !R.done; ) h.push(R.value), R = s.next(0);
          if (R = h.map((q) => T.ba.h(q, c)).map((q) => at(q, c)), R.find((q) => !q.F() && !q.oa())) throw Error("XPTY0004: Order by only accepts empty or singleton sequences");
          if (b = R.map((q) => q.first()), b = b.map((q) => q === null ? q : I(19, q.type) ? He(q, 1) : q), qT(b) && (b = kc(b), !b)) throw Error("XPTY0004: Could not cast values");
          R = b.length, x = b.map((q, _) => _);
          for (let q = 0; q < R; q++) if (q + 1 !== R) for (let _ = q; 0 <= _; _--) {
            const ie = _, me = _ + 1;
            if (me === R) continue;
            const Ce = b[x[ie]], $e = b[x[me]];
            if ($e !== null || Ce !== null) {
              if (T.cc) {
                if (Ce === null) continue;
                if ($e === null && Ce !== null) {
                  [x[ie], x[me]] = [x[me], x[ie]];
                  continue;
                }
                if (isNaN($e.value) && Ce !== null && !isNaN(Ce.value)) {
                  [x[ie], x[me]] = [x[me], x[ie]];
                  continue;
                }
              } else {
                if ($e === null) continue;
                if (Ce === null && $e !== null) {
                  [x[ie], x[me]] = [x[me], x[ie]];
                  continue;
                }
                if (isNaN(Ce.value) && $e !== null && !isNaN($e.value)) {
                  [x[ie], x[me]] = [x[me], x[ie]];
                  continue;
                }
              }
              xc("gtOp", Ce.type, $e.type)(Ce, $e, i) && ([x[ie], x[me]] = [x[me], x[ie]]);
            }
          }
          let P = T.Bb ? 0 : b.length - 1;
          C = u({ next: () => T.Bb ? P >= b.length ? H : j(h[x[P++]]) : 0 > P ? H : j(h[x[P--]]) }).value, g = !0;
        }
        return C.next(0);
      } });
    }
  }, h0 = class extends Ae {
    constructor(i) {
      super(i ? i.o : new Fe({}), i ? [i] : [], { R: "sorted", subtree: !1, W: !1, B: !1 }), this.l = i;
    }
    h(i, s) {
      if (i.M === null) throw _n("context is absent, it needs to be present to use paths.");
      var c = s.h;
      let u = i.M.value;
      for (; u.node.nodeType !== 9; ) if (u = Ie(c, u), u === null) throw Error("XPDY0050: the root node of the context node is not a document node.");
      return c = N.m(_e(u)), this.l ? he(this.l, Fr(i, 0, c.first(), c), s) : c;
    }
  }, XT = class extends Ae {
    constructor(i) {
      super(new Fe({}), [], { R: "sorted" }, !1, i);
    }
    h(i) {
      if (i.M === null) throw _n('context is absent, it needs to be present to use the "." operator');
      return N.m(i.M);
    }
  };
  function JT(i, s) {
    let c = !1, u = !1;
    if (s.forEach((h) => {
      I(h.type, 53) ? c = !0 : u = !0;
    }), u && c) throw Error("XPTY0018: The path operator should either return nodes or non-nodes. Mixed sequences are not allowed.");
    return c ? Ca(i, s) : s;
  }
  var KT = class extends Ae {
    constructor(i, s) {
      const c = i.every((h) => h.W), u = i.every((h) => h.subtree);
      super(i.reduce((h, g) => h.add(g.o), new Fe({})), i, { B: !1, W: c, R: s ? "sorted" : "unsorted", subtree: u }), this.l = i, this.s = s;
    }
    h(i, s) {
      let c = !0;
      return this.l.reduce((u, h, g) => {
        const b = u === null ? $r(i) : bg(i, u);
        u = { next: (C) => {
          if (C = b.next(C), C.done) return H;
          if (C.value.M !== null && !I(C.value.M.type, 53) && 0 < g) throw Error("XPTY0019: The result of E1 in a path expression E1/E2 should not evaluate to a sequence of nodes.");
          return j(he(
            h,
            C.value,
            s
          ));
        } };
        let x;
        if (this.s) switch (h.ia) {
          case "reverse-sorted":
            const C = u;
            u = { next: (T) => (T = C.next(T), T.done ? T : j(T.value.N((R) => N.create(R.reverse())))) };
          case "sorted":
            if (h.subtree && c) {
              x = pp(u);
              break;
            }
            x = p0(s.h, u);
            break;
          case "unsorted":
            return pp(u).N((T) => N.create(JT(s.h, T)));
        }
        else x = pp(u);
        return c = c && h.W, x;
      }, null);
    }
    D() {
      return this.l[0].D();
    }
  }, WT = class extends Ae {
    constructor(i, s) {
      super(i.o.add(s.o), [i, s], { B: i.B && s.B, W: i.W, R: i.ia, subtree: i.subtree }), this.s = i, this.l = s;
    }
    h(i, s) {
      const c = he(this.s, i, s);
      if (this.l.B) {
        const x = he(this.l, i, s);
        if (x.F()) return x;
        const C = x.first();
        if (I(C.type, 2)) {
          let T = C.value;
          if (!Number.isInteger(T)) return N.empty();
          const R = c.value;
          let P = !1;
          return N.create({ next: () => {
            if (!P) {
              for (let q = R.next(0); !q.done; q = R.next(0)) if (T-- === 1) return P = !0, q;
              P = !0;
            }
            return H;
          } });
        }
        return x.fa() ? c : N.empty();
      }
      const u = c.value;
      let h = null, g = 0, b = null;
      return N.create({ next: (x) => {
        let C = !1;
        for (; (!h || !h.done) && (h || (h = u.next(C ? 0 : x), C = !0), !h.done); ) {
          b || (b = he(this.l, Fr(i, g, h.value, c), s));
          var T = b.first();
          T = T === null ? !1 : I(T.type, 2) ? T.value === g + 1 : b.fa(), b = null;
          const R = h.value;
          if (h = null, g++, T) return j(R);
        }
        return h;
      } });
    }
    D() {
      return this.s.D();
    }
  };
  function f0(i, s, c) {
    if (c = [c], I(i.type, 62)) if (s === "*") c.push(...i.h.map((u) => u()));
    else if (I(s.type, 5)) {
      const u = s.value;
      if (i.h.length < u || 0 >= u) throw Error("FOAY0001: Array index out of bounds");
      c.push(i.h[u - 1]());
    } else throw Error("XPTY0004: The key specifier is not an integer.");
    else if (I(i.type, 61)) s === "*" ? c.push(...i.h.map((u) => u.value())) : (i = i.h.find((u) => qo(u.key, s))) && c.push(i.value());
    else throw Error("XPTY0004: The provided context item is not a map or an array.");
    return Gn(c);
  }
  function m0(i, s, c, u, h) {
    return s === "*" ? f0(i, s, c) : (s = he(s, u, h), s = st(s)().N((g) => g.reduce((b, x) => f0(i, x, b), new Be())), Gn([c, s]));
  }
  var YT = class extends Ae {
    constructor(i, s) {
      super(i.o, [i].concat(s === "*" ? [] : [s]), { B: i.B, R: i.ia, subtree: i.subtree }), this.l = i, this.s = s;
    }
    h(i, s) {
      return he(this.l, i, s).N((c) => c.reduce((u, h) => m0(h, this.s, u, i, s), new Be()));
    }
    D() {
      return this.l.D();
    }
  }, QT = class extends Ae {
    constructor(i, s) {
      super(new Fe({ external: 1 }), i === "*" ? [] : [i], { B: !1 }, !1, s), this.l = i;
    }
    h(i, s) {
      return m0(i.M, this.l, new Be(), i, s);
    }
  }, ZT = class extends Ae {
    constructor(i, s, c, u) {
      const h = s.map((g) => g.fb);
      s = s.map((g) => g.name), super(h.reduce((g, b) => g.add(b.o), c.o), h.concat(c), { B: !1 }, !1, u), this.s = i, this.A = s, this.L = h, this.P = c, this.l = null;
    }
    h(i, s) {
      let c = i;
      const u = this.l.map((x, C) => {
        const T = he(this.L[C], c, s).O();
        return c = ci(i, { [x]: () => N.create(T) }), T;
      });
      if (u.some((x) => x.length === 0)) return this.s === "every" ? N.aa() : N.T();
      const h = Array(u.length).fill(0);
      h[0] = -1;
      for (var g = !0; g; ) {
        g = !1;
        for (let x = 0, C = h.length; x < C; ++x) {
          var b = u[x];
          if (++h[x] > b.length - 1) h[x] = 0;
          else {
            for (g = /* @__PURE__ */ Object.create(null), b = 0; b < h.length; b++) {
              const T = u[b][h[b]];
              g[this.l[b]] = () => N.m(T);
            }
            if (g = ci(i, g), g = he(this.P, g, s), g.fa() && this.s === "some") return N.aa();
            if (!g.fa() && this.s === "every") return N.T();
            g = !0;
            break;
          }
        }
      }
      return this.s === "every" ? N.aa() : N.T();
    }
    v(i) {
      this.l = [];
      for (let c = 0, u = this.A.length; c < u; ++c) {
        this.L[c].v(i), ts(i);
        var s = this.A[c];
        const h = s.prefix ? i.$(s.prefix) : null;
        s = fr(i, h, s.localName), this.l[c] = s;
      }
      this.P.v(i);
      for (let c = 0, u = this.A.length; c < u; ++c) ns(i);
    }
  }, Ac = class extends Ae {
    constructor(i) {
      super(i, [], { B: !1 });
    }
    h(i) {
      return this.l(i.M) ? N.aa() : N.T();
    }
  }, cs = class extends Ac {
    constructor(i) {
      super(new Fe({ nodeType: 1 })), this.s = i;
    }
    l(i) {
      return I(i.type, 53) ? (i = i.value.node.nodeType, this.s === 3 && i === 4 ? !0 : this.s === i) : !1;
    }
    D() {
      return `type-${this.s}`;
    }
  }, Yi = class extends Ac {
    constructor(i, s = { kind: null }) {
      const c = i.prefix, u = i.namespaceURI;
      i = i.localName;
      const h = {};
      i !== "*" && (h.nodeName = 1), h.nodeType = 1, super(new Fe(h)), this.s = i, this.L = u, this.A = c, this.P = s.kind;
    }
    l(i) {
      const s = I(i.type, 54), c = I(i.type, 47);
      return !s && !c ? !1 : (i = i.value, this.P !== null && (this.P === 1 && !s || this.P === 2 && !c) ? !1 : this.A === null && this.L !== "" && this.s === "*" ? !0 : this.A === "*" ? this.s === "*" ? !0 : this.s === i.node.localName : this.s !== "*" && this.s !== i.node.localName ? !1 : (i.node.namespaceURI || null) === ((this.A === "" ? s ? this.L : null : this.L) || null));
    }
    D() {
      return this.s === "*" ? this.P === null ? "type-1-or-type-2" : `type-${this.P}` : `name-${this.s}`;
    }
    v(i) {
      if (this.L === null && this.A !== "*" && (this.L = i.$(this.A || "") || null, !this.L && this.A)) throw Error(`XPST0081: The prefix ${this.A} could not be resolved.`);
    }
  }, eN = class extends Ac {
    constructor(i) {
      super(new Fe({ nodeName: 1 })), this.s = i;
    }
    l(i) {
      return I(i.type, 57) && i.value.node.target === this.s;
    }
    D() {
      return "type-7";
    }
  }, Ma = class extends Ac {
    constructor(i) {
      super(new Fe({})), this.s = i;
    }
    l(i) {
      return I(i.type, ft(this.s.prefix ? this.s.prefix + ":" + this.s.localName : this.s.localName));
    }
  }, tN = class extends Ae {
    constructor(i, s, c) {
      super(new Fe({}), [], { B: !1, R: "unsorted" }), this.A = c, this.s = s, this.L = i, this.l = null;
    }
    h(i, s) {
      if (!i.ra[this.l]) {
        if (this.P) return this.P(i, s);
        throw Error("XQDY0054: The variable " + this.A + " is declared but not in scope.");
      }
      return i.ra[this.l]();
    }
    v(i) {
      if (this.s === null && this.L && (this.s = i.$(this.L)), this.l = i.eb(this.s || "", this.A), !this.l) throw Error("XPST0008, The variable " + this.A + " is not in scope.");
      (i = i.Ea[this.l]) && (this.P = i);
    }
  }, nN = class extends Wi {
    constructor(i, s) {
      super(new Fe({}), [i, s], { B: !1, W: !1, R: "unsorted", subtree: !1 }, s), this.A = i;
    }
    L(i, s, c, u) {
      let h = null, g = null;
      return u({ next: () => {
        for (; ; ) {
          if (!g) {
            var b = s.next(0);
            if (b.done) return H;
            h = b.value, g = he(this.A, h, c);
          }
          b = g.fa();
          const x = h;
          if (g = h = null, b) return j(x);
        }
      } });
    }
  }, Qi = class {
    constructor(i) {
      this.type = i;
    }
  }, g0 = class extends Qi {
    constructor(i) {
      super("delete"), this.target = i;
    }
    h(i) {
      return { type: this.type, target: Pt(this.target, i, !1) };
    }
  }, Oa = class extends Qi {
    constructor(i, s, c) {
      super(c), this.target = i, this.content = s;
    }
    h(i) {
      return { type: this.type, target: Pt(this.target, i, !1), content: this.content.map((s) => Pt(s, i, !0)) };
    }
  }, y0 = class extends Oa {
    constructor(i, s) {
      super(i, s, "insertAfter");
    }
  }, us = class extends Qi {
    constructor(i, s) {
      super("insertAttributes"), this.target = i, this.content = s;
    }
    h(i) {
      return { type: this.type, target: Pt(this.target, i, !1), content: this.content.map((s) => Pt(s, i, !0)) };
    }
  }, w0 = class extends Oa {
    constructor(i, s) {
      super(i, s, "insertBefore");
    }
  }, b0 = class extends Oa {
    constructor(i, s) {
      super(i, s, "insertIntoAsFirst");
    }
  }, v0 = class extends Oa {
    constructor(i, s) {
      super(i, s, "insertIntoAsLast");
    }
  }, x0 = class extends Oa {
    constructor(i, s) {
      super(i, s, "insertInto");
    }
  }, k0 = class extends Qi {
    constructor(i, s) {
      super("rename"), this.target = i, this.o = s.za ? s : new _t(s.prefix, s.namespaceURI, s.localName);
    }
    h(i) {
      return { type: this.type, target: Pt(this.target, i, !1), newName: { prefix: this.o.prefix, namespaceURI: this.o.namespaceURI, localName: this.o.localName } };
    }
  }, A0 = class extends Qi {
    constructor(i, s) {
      super("replaceElementContent"), this.target = i, this.text = s;
    }
    h(i) {
      return { type: this.type, target: Pt(this.target, i, !1), text: this.text ? Pt(this.text, i, !0) : null };
    }
  }, C0 = class extends Qi {
    constructor(i, s) {
      super("replaceNode"), this.target = i, this.o = s;
    }
    h(i) {
      return { type: this.type, target: Pt(this.target, i, !1), replacement: this.o.map((s) => Pt(s, i, !0)) };
    }
  }, S0 = class extends Qi {
    constructor(i, s) {
      super("replaceValue"), this.target = i, this.o = s;
    }
    h(i) {
      return { type: this.type, target: Pt(this.target, i, !1), "string-value": this.o };
    }
  }, rN = (i, s) => new C0(i, s), iN = class extends Wo {
    constructor(i) {
      super(new Fe({}), [i], { B: !1, R: "unsorted" }), this.l = i;
    }
    s(i, s) {
      const c = pr(this.l)(i, s), u = s.h;
      let h, g;
      return { next: () => {
        if (!h) {
          const b = c.next(0);
          if (b.value.J.some((x) => !I(x.type, 53))) throw Error("XUTY0007: The target of a delete expression must be a sequence of zero or more nodes.");
          h = b.value.J, g = b.value.da;
        }
        return h = h.filter((b) => Ie(u, b.value)), j({ da: zn(h.map((b) => new g0(b.value)), g), J: [] });
      } };
    }
  };
  function E0(i, s, c, u, h, g) {
    const b = s.h;
    return i.reduce(function x(C, T) {
      return I(T.type, 62) ? (T.h.forEach((R) => R().O().forEach((P) => x(C, P))), C) : (C.push(T), C);
    }, []).forEach((x, C, T) => {
      if (I(x.type, 47)) {
        if (h) throw g(x.value, b);
        c.push(x.value.node);
      } else if (I(x.type, 46) || I(x.type, 53) && x.value.node.nodeType === 3) {
        const R = I(x.type, 46) ? He(Pr(x, s).first(), 1).value : Et(b, x.value);
        C !== 0 && I(T[C - 1].type, 46) && I(x.type, 46) ? (u.push({ data: " " + R, Ra: !0, nodeType: 3 }), h = !0) : R && (u.push({ data: "" + R, Ra: !0, nodeType: 3 }), h = !0);
      } else if (I(
        x.type,
        55
      )) {
        const R = [];
        sr(b, x.value).forEach((P) => R.push(_e(P))), h = E0(R, s, c, u, h, g);
      } else if (I(x.type, 53)) u.push(x.value.node), h = !0;
      else
        throw I(x.type, 60) ? xg(x.type) : Error(`Atomizing ${x.type} is not implemented.`);
    }), h;
  }
  function hp(i, s, c) {
    const u = [], h = [];
    let g = !1;
    return i.forEach((b) => {
      g = E0(b, s, u, h, g, c);
    }), { attributes: u, Xa: h };
  }
  function oN(i, s, c, u, h) {
    const g = [];
    switch (i) {
      case 4:
        u.length && g.push(new us(s, u)), h.length && g.push(new b0(s, h));
        break;
      case 5:
        u.length && g.push(new us(s, u)), h.length && g.push(new v0(s, h));
        break;
      case 3:
        u.length && g.push(new us(s, u)), h.length && g.push(new x0(s, h));
        break;
      case 2:
        u.length && g.push(new us(c, u)), h.length && g.push(new w0(s, h));
        break;
      case 1:
        u.length && g.push(new us(c, u)), h.length && g.push(new y0(s, h));
    }
    return g;
  }
  var sN = class extends Wo {
    constructor(i, s, c) {
      super(new Fe({}), [i, c], { B: !1, R: "unsorted" }), this.L = i, this.l = s, this.A = c;
    }
    s(i, s) {
      const c = pr(this.L)(i, s), u = pr(this.A)(i, s), h = s.h;
      let g, b, x, C, T, R;
      return { next: () => {
        if (!g) {
          var P = c.next(0);
          const q = hp([P.value.J], s, wE);
          g = q.attributes.map((_) => ({ node: _, G: null })), b = q.Xa.map((_) => ({ node: _, G: null })), x = P.value.da;
        }
        if (!C) {
          if (P = u.next(0), P.value.J.length === 0) throw cc();
          if (3 <= this.l) {
            if (P.value.J.length !== 1 || !I(P.value.J[0].type, 54) && !I(P.value.J[0].type, 55)) throw cy();
          } else {
            if (P.value.J.length !== 1 || !(I(P.value.J[0].type, 54) || I(P.value.J[0].type, 56) || I(P.value.J[0].type, 58) || I(P.value.J[0].type, 57))) throw uy();
            if (R = Ie(h, P.value.J[0].value, null), R === null) throw Error(`XUDY0029: The target ${P.value.J[0].value.outerHTML} for inserting a node before or after must have a parent.`);
          }
          C = P.value.J[0], T = P.value.da;
        }
        if (g.length) {
          if (3 <= this.l) {
            if (!I(C.type, 54)) throw Error("XUTY0022: An insert expression specifies the insertion of an attribute node into a document node.");
          } else if (R.node.nodeType !== 1) throw Error("XUDY0030: An insert expression specifies the insertion of an attribute node before or after a child of a document node.");
          g.reduce((q, _) => {
            const ie = _.node.prefix || "";
            var me = _.node.prefix || "";
            const Ce = _.node.namespaceURI, $e = me ? C.value.node.lookupNamespaceURI(me) : null;
            if ($e && $e !== Ce) throw ac(Ce);
            if ((me = q[me]) && Ce !== me) throw lc(Ce);
            return q[ie] = _.node.namespaceURI, q;
          }, {});
        }
        return j({ J: [], da: zn(oN(this.l, C.value, R || null, g, b), x, T) });
      } };
    }
  };
  const Cc = () => Nn("Casting not supported from given type to a single xs:string or xs:untypedAtomic or any of its derived types."), T0 = /([A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])/, aN = new RegExp(`${T0.source}${new RegExp(`(${T0.source}|[-.0-9·̀-ͯ‿⁀])`).source}*`, "g"), fp = (i) => (i = i.match(aN)) ? i.length === 1 : !1;
  function N0(i, s) {
    return at(s, i).X({ m: (c) => {
      if (c = c.first(), I(c.type, 1) || I(c.type, 19)) {
        if (!fp(c.value)) throw Error(`XQDY0041: The value "${c.value}" of a name expressions cannot be converted to a NCName.`);
        return N.m(c);
      }
      throw Cc();
    }, default: () => {
      throw Cc();
    } }).value;
  }
  function Sc(i, s, c) {
    return at(c, s).X({ m: (u) => {
      if (u = u.first(), I(u.type, 23)) return N.m(u);
      if (I(u.type, 1) || I(u.type, 19)) {
        let h, g;
        if (u = u.value.split(":"), u.length === 1 ? u = u[0] : (h = u[0], g = i.$(h), u = u[1]), !fp(u) || h && !fp(h)) throw jy(h ? `${h}:${u}` : u);
        if (h && !g) throw jy(`${h}:${u}`);
        return N.m({ type: 23, value: new _t(h, g, u) });
      }
      throw Cc();
    }, default: () => {
      throw Cc();
    } }).value;
  }
  var lN = class extends Wo {
    constructor(i, s) {
      super(new Fe({}), [i, s], { B: !1, R: "unsorted" }), this.A = i, this.L = s, this.l = void 0;
    }
    s(i, s) {
      const c = pr(this.A)(i, s), u = pr(this.L)(i, s);
      return { next: () => {
        const h = c.next(0);
        var g = h.value.J;
        if (g.length === 0) throw cc();
        if (g.length !== 1 || !I(g[0].type, 54) && !I(g[0].type, 47) && !I(g[0].type, 57)) throw dy();
        g = g[0];
        const b = u.next(0);
        e: {
          var x = this.l, C = N.create(b.value.J);
          switch (g.type) {
            case 54:
              if (x = Sc(x, s, C).next(0).value.value, (C = g.value.node.lookupNamespaceURI(x.prefix)) && C !== x.namespaceURI) throw ac(x.namespaceURI);
              break e;
            case 47:
              if (x = Sc(x, s, C).next(0).value.value, x.namespaceURI && (C = g.value.node.lookupNamespaceURI(x.prefix)) && C !== x.namespaceURI) throw ac(x.namespaceURI);
              break e;
            case 57:
              x = N0(s, C).next(0).value.value, x = new _t("", null, x);
              break e;
          }
          x = void 0;
        }
        return j({ J: [], da: zn([new k0(g.value, x)], h.value.da, b.value.da) });
      } };
    }
    v(i) {
      this.l = fc(i), super.v(i);
    }
  };
  function cN(i, s, c) {
    let u, h, g;
    return { next: () => {
      if (!u) {
        var b = c.next(0), x = hp([b.value.J], i, lc);
        u = { attributes: x.attributes.map((C) => ({ node: C, G: null })), Xa: x.Xa.map((C) => ({ node: C, G: null })) }, h = b.value.da;
      }
      if (x = s.next(0), x.value.J.length === 0) throw cc();
      if (x.value.J.length !== 1 || !(I(x.value.J[0].type, 54) || I(x.value.J[0].type, 47) || I(x.value.J[0].type, 56) || I(x.value.J[0].type, 58) || I(x.value.J[0].type, 57))) throw sc();
      if (g = Ie(i.h, x.value.J[0].value, null), g === null) throw Error(`XUDY0009: The target ${x.value.J[0].value.outerHTML} for replacing a node must have a parent.`);
      if (b = x.value.J[0], x = x.value.da, I(b.type, 47)) {
        if (u.Xa.length) throw Error("XUTY0011: When replacing an attribute the new value must be zero or more attribute nodes.");
        u.attributes.reduce((C, T) => {
          const R = T.node.prefix || "";
          T = T.node.namespaceURI;
          var P = g.node.lookupNamespaceURI(R);
          if (P && P !== T) throw ac(T);
          if ((P = C[R]) && T !== P) throw lc(T);
          return C[R] = T, C;
        }, {});
      } else if (u.attributes.length) throw Error("XUTY0010: When replacing an an element, text, comment, or processing instruction node the new value must be a single node.");
      return j({ J: [], da: zn([rN(b.value, [].concat(u.attributes, u.Xa))], h, x) });
    } };
  }
  function uN(i, s, c) {
    let u, h, g, b, x = !1;
    return { next: () => {
      if (x) return H;
      if (!g) {
        var C = c.next(0);
        const T = at(N.create(C.value.J), i).map((R) => He(R, 1)).O().map((R) => R.value).join(" ");
        g = T.length === 0 ? null : { node: i.Ja.createTextNode(T), G: null }, b = C.value.da;
      }
      if (!u) {
        if (C = s.next(0), C.value.J.length === 0) throw cc();
        if (C.value.J.length !== 1 || !(I(C.value.J[0].type, 54) || I(C.value.J[0].type, 47) || I(C.value.J[0].type, 56) || I(C.value.J[0].type, 58) || I(C.value.J[0].type, 57))) throw sc();
        u = C.value.J[0], h = C.value.da;
      }
      if (I(
        u.type,
        54
      )) return x = !0, j({ J: [], da: zn([new A0(u.value, g)], b, h) });
      if (I(u.type, 47) || I(u.type, 56) || I(u.type, 58) || I(u.type, 57)) {
        if (C = g ? Et(i.h, g) : "", I(u.type, 58) && (C.includes("--") || C.endsWith("-"))) throw Error(`XQDY0072: The content "${C}" for a comment node contains two adjacent hyphens or ends with a hyphen.`);
        if (I(u.type, 57) && C.includes("?>")) throw Error(`XQDY0026: The content "${C}" for a processing instruction node contains "?>".`);
        return x = !0, j({ J: [], da: zn([new S0(u.value, C)], b, h) });
      }
    } };
  }
  var dN = class extends Wo {
    constructor(i, s, c) {
      super(new Fe({}), [s, c], { B: !1, R: "unsorted" }), this.L = i, this.l = s, this.A = c;
    }
    s(i, s) {
      const c = pr(this.l)(i, s);
      return i = pr(this.A)(i, s), this.L ? uN(s, c, i) : cN(s, c, i);
    }
  };
  function B0(i) {
    switch (i.type) {
      case "delete":
        return new g0({ node: i.target, G: null });
      case "insertAfter":
        return new y0({ node: i.target, G: null }, i.content.map((s) => ({ node: s, G: null })));
      case "insertBefore":
        return new w0({ node: i.target, G: null }, i.content.map((s) => ({ node: s, G: null })));
      case "insertInto":
        return new x0({ node: i.target, G: null }, i.content.map((s) => ({ node: s, G: null })));
      case "insertIntoAsFirst":
        return new b0({ node: i.target, G: null }, i.content.map((s) => ({ node: s, G: null })));
      case "insertIntoAsLast":
        return new v0({
          node: i.target,
          G: null
        }, i.content.map((s) => ({ node: s, G: null })));
      case "insertAttributes":
        return new us({ node: i.target, G: null }, i.content.map((s) => ({ node: s, G: null })));
      case "rename":
        return new k0({ node: i.target, G: null }, i.newName);
      case "replaceNode":
        return new C0({ node: i.target, G: null }, i.replacement.map((s) => ({ node: s, G: null })));
      case "replaceValue":
        return new S0({ node: i.target, G: null }, i["string-value"]);
      case "replaceElementContent":
        return new A0({ node: i.target, G: null }, i.text ? { node: i.text, G: null } : null);
      default:
        throw Error(`Unexpected type "${i.type}" when parsing a transferable pending update.`);
    }
  }
  function I0(i, s, c) {
    if (s.find((h) => mt(h, i))) return !0;
    const u = Ie(c, i);
    return u ? I0(u, s, c) : !1;
  }
  var pN = class extends Wo {
    constructor(i, s, c) {
      super(new Fe({}), i.reduce((u, h) => (u.push(h.fb), u), [s, c]), { B: !1, R: "unsorted" }), this.l = i, this.L = s, this.A = c, this.I = null;
    }
    h(i, s) {
      return i = this.s(i, s), Yo(i, () => {
      });
    }
    s(i, s) {
      const c = s.h, u = s.Ja, h = s.Ma, g = [];
      let b, x, C;
      const T = [], R = [];
      return { next: () => {
        if (T.length !== this.l.length) for (var P = T.length; P < this.l.length; P++) {
          const _ = this.l[P];
          var q = g[P];
          if (q || (g[P] = q = pr(_.fb)(i, s)), q = q.next(0), q.value.J.length !== 1 || !I(q.value.J[0].type, 53)) throw Error("XUTY0013: The source expression of a copy modify expression must return a single node.");
          const ie = _e(pc(q.value.J[0].value, s));
          T.push(ie.value), R.push(q.value.da), i = ci(i, { [_.fc]: () => N.m(ie) });
        }
        return C || (b || (b = pr(this.L)(i, s)), C = b.next(0).value.da), C.forEach((_) => {
          if (_.target && !I0(_.target, T, c)) throw Error(`XUDY0014: The target ${_.target.node.outerHTML} must be a node created by the copy clause.`);
          if (_.type === "put") throw Error("XUDY0037: The modify expression of a copy modify expression can not contain a fn:put.");
        }), P = C.map((_) => (_ = _.h(s), B0(_))), by(P, c, u, h), x || (x = pr(this.A)(i, s)), P = x.next(0), j({
          J: P.value.J,
          da: zn(P.value.da, ...R)
        });
      } };
    }
    v(i) {
      ts(i), this.l.forEach((s) => s.fc = fr(i, s.Jb.namespaceURI, s.Jb.localName)), super.v(i), ns(i), this.I = this.l.some((s) => s.fb.I) || this.A.I;
    }
  };
  function M0(i, s) {
    return { node: { nodeType: 2, Ra: !0, nodeName: i.za(), namespaceURI: i.namespaceURI, prefix: i.prefix, localName: i.localName, name: i.za(), value: s }, G: null };
  }
  var O0 = class extends Ae {
    constructor(i, s) {
      let c = s.nb || [];
      c = c.concat(i.Na || []), super(new Fe({}), c, { B: !1, R: "unsorted" }), i.Na ? this.s = i.Na : this.name = new _t(i.prefix, i.namespaceURI, i.localName), this.l = s, this.A = void 0;
    }
    h(i, s) {
      let c, u, h, g = !1;
      return N.create({ next: () => {
        if (g) return H;
        if (!u) {
          if (this.s) {
            if (!c) {
              var b = this.s.h(i, s);
              c = Sc(this.A, s, b);
            }
            u = c.next(0).value.value;
          } else u = this.name;
          if (u && (u.prefix === "xmlns" || u.prefix === "" && u.localName === "xmlns" || u.namespaceURI === "http://www.w3.org/2000/xmlns/" || u.prefix === "xml" && u.namespaceURI !== "http://www.w3.org/XML/1998/namespace" || u.prefix !== "" && u.prefix !== "xml" && u.namespaceURI === "http://www.w3.org/XML/1998/namespace"))
            throw Ba(u);
        }
        return this.l.nb ? (b = this.l.nb, h || (h = Gn(b.map((x) => at(x.h(i, s), s).N((C) => N.m(M(C.map((T) => T.value).join(" "), 1))))).N((x) => N.m(_e(M0(u, x.map((C) => C.value).join(""))))).value), h.next(0)) : (g = !0, j(_e(M0(u, this.l.value))));
      } });
    }
    v(i) {
      if (this.A = fc(i), this.name && this.name.prefix && !this.name.namespaceURI) {
        const s = i.$(this.name.prefix);
        if (s === void 0 && this.name.prefix) throw kg(this.name.prefix);
        this.name.namespaceURI = s || null;
      }
      super.v(i);
    }
  }, hN = class extends Ae {
    constructor(i) {
      super(i ? i.o : new Fe({}), i ? [i] : [], { B: !1, R: "unsorted" }), this.l = i;
    }
    h(i, s) {
      const c = { data: "", Ra: !0, nodeType: 8 }, u = { node: c, G: null };
      return this.l ? (i = he(this.l, i, s), at(i, s).N((h) => {
        if (h = h.map((g) => He(g, 1).value).join(" "), h.indexOf("-->") !== -1) throw Error('XQDY0072: The contents of the data of a comment may not include "-->"');
        return c.data = h, N.m(_e(u));
      })) : N.m(_e(u));
    }
  }, D0 = class extends Ae {
    constructor(i, s, c, u) {
      super(new Fe({}), u.concat(s).concat(i.Na || []), { B: !1, R: "unsorted" }), i.Na ? this.s = i.Na : this.l = new _t(i.prefix, i.namespaceURI, i.localName), this.P = c.reduce((h, g) => {
        if (g.prefix in h) throw Error(`XQST0071: The namespace declaration with the prefix ${g.prefix} has already been declared on the constructed element.`);
        return h[g.prefix || ""] = g.uri, h;
      }, {}), this.L = s, this.ma = u, this.A = void 0;
    }
    h(i, s) {
      let c = !1, u, h, g = !1, b, x, C, T = !1;
      return N.create({ next: () => {
        if (T) return H;
        if (c || (u || (u = Gn(this.L.map((ie) => he(ie, i, s)))), h = u.O(), c = !0), !g) {
          b || (b = this.ma.map((ie) => he(ie, i, s)));
          for (var R = [], P = 0; P < b.length; P++) {
            var q = b[P].O();
            R.push(q);
          }
          x = R, g = !0;
        }
        if (this.s && (C || (R = this.s.h(i, s), C = Sc(this.A, s, R)), this.l = C.next(0).value.value), this.l.prefix === "xmlns" || this.l.namespaceURI === "http://www.w3.org/2000/xmlns/" || this.l.prefix === "xml" && this.l.namespaceURI !== "http://www.w3.org/XML/1998/namespace" || this.l.prefix && this.l.prefix !== "xml" && this.l.namespaceURI === "http://www.w3.org/XML/1998/namespace") throw Error(`XQDY0096: The node name "${this.l.za()}" is invalid for a computed element constructor.`);
        const _ = { nodeType: 1, Ra: !0, attributes: [], childNodes: [], nodeName: this.l.za(), namespaceURI: this.l.namespaceURI, prefix: this.l.prefix, localName: this.l.localName };
        for (R = { node: _, G: null }, h.forEach((ie) => {
          _.attributes.push(ie.value.node);
        }), P = hp(x, s, $E), P.attributes.forEach((ie) => {
          if (_.attributes.find((me) => me.namespaceURI === ie.namespaceURI && me.localName === ie.localName)) throw Error(`XQDY0025: The attribute ${ie.name} does not have an unique name in the constructed element.`);
          _.attributes.push(ie);
        }), P.Xa.forEach((ie) => {
          _.childNodes.push(ie);
        }), P = 0; P < _.childNodes.length; P++) {
          if (q = _.childNodes[P], !zt(q) || q.nodeType !== 3) continue;
          const ie = _.childNodes[P - 1];
          ie && zt(ie) && ie.nodeType === 3 && (ie.data += q.data, _.childNodes.splice(P, 1), P--);
        }
        return T = !0, j(_e(R));
      } });
    }
    v(i) {
      if (ts(i), Object.keys(this.P).forEach((s) => Ji(i, s, this.P[s])), this.Fa.forEach((s) => s.v(i)), this.L.reduce((s, c) => {
        if (c.name) {
          if (c = `Q{${c.name.namespaceURI === null ? i.$(c.name.prefix) : c.name.namespaceURI}}${c.name.localName}`, s.includes(c)) throw Error(`XQST0040: The attribute ${c} does not have an unique name in the constructed element.`);
          s.push(c);
        }
        return s;
      }, []), this.l && this.l.namespaceURI === null) {
        const s = i.$(this.l.prefix);
        if (s === void 0 && this.l.prefix) throw kg(this.l.prefix);
        this.l.namespaceURI = s;
      }
      this.A = fc(i), ns(i);
    }
  };
  function R0(i) {
    if (/^xml$/i.test(i)) throw Error(`XQDY0064: The target of a created PI may not be "${i}"`);
  }
  function F0(i, s) {
    return { node: { data: s, Ra: !0, nodeName: i, nodeType: 7, target: i }, G: null };
  }
  var fN = class extends Ae {
    constructor(i, s) {
      const c = i.xb ? [i.xb].concat(s) : [s];
      super(c.reduce((u, h) => u.add(h.o), new Fe({})), c, { B: !1, R: "unsorted" }), this.l = i, this.s = s;
    }
    h(i, s) {
      const c = he(this.s, i, s);
      return at(c, s).N((u) => {
        const h = u.map((b) => He(b, 1).value).join(" ");
        if (h.indexOf("?>") !== -1) throw Error('XQDY0026: The contents of the data of a processing instruction may not include "?>"');
        if (this.l.Fb !== null) return u = this.l.Fb, R0(u), N.m(_e(F0(u, h)));
        u = he(this.l.xb, i, s);
        const g = N0(s, u);
        return N.create({ next: () => {
          var b = g.next(0);
          return b.done ? b : (b = b.value.value, R0(b), j(_e(F0(b, h))));
        } });
      });
    }
  }, mN = class extends Ae {
    constructor(i) {
      super(i ? i.o : new Fe({}), i ? [i] : [], { B: !1, R: "unsorted" }), this.l = i;
    }
    h(i, s) {
      return this.l ? (i = he(this.l, i, s), at(i, s).N((c) => c.length === 0 ? N.empty() : (c = { node: { data: c.map((u) => He(u, 1).value).join(" "), Ra: !0, nodeType: 3 }, G: null }, N.m(_e(c))))) : N.empty();
    }
  }, gN = class extends Qo {
    constructor(i, s, c, u) {
      super(new Fe({}), [i, ...s.map((h) => h.pb), c].concat(...s.map((h) => h.Ib.map((g) => g.Hb))), { B: !1, W: !1, R: "unsorted", subtree: !1 }, u), this.L = i, this.l = s.length, this.P = s.map((h) => h.Ib);
    }
    A(i, s, c) {
      return c[0](i).N((u) => {
        for (let h = 0; h < this.l; h++) if (this.P[h].some((g) => {
          switch (g.ec) {
            case "?":
              if (1 < u.length) return !1;
              break;
            case "*":
              break;
            case "+":
              if (1 > u.length) return !1;
              break;
            default:
              if (u.length !== 1) return !1;
          }
          const b = N.create(u);
          return u.every((x, C) => (x = Fr(i, C, x, b), he(g.Hb, x, s).fa()));
        })) return c[h + 1](i);
        return c[this.l + 1](i);
      });
    }
    v(i) {
      if (super.v(i), this.L.I) throw jr();
    }
  }, yN = class extends Qo {
    constructor(i, s, c, u) {
      super(new Fe({}), [i, c, ...s.map((h) => h.pb)].concat(...s.map((h) => h.Gb.map((g) => g))), { B: !1, W: !1, R: "unsorted", subtree: !1 }, u), this.L = i, this.l = s.length, this.P = s.map((h) => h.Gb);
    }
    A(i, s, c) {
      const u = ls(c[0](i), s), [, h, ...g] = c;
      return u.X({ multiple: () => {
        throw Error("XPTY0004: The operand for a switch expression should result in zero or one item");
      }, default: () => {
        const b = u.first(), x = !b;
        for (let T = 0; T < this.l; T++) {
          var C = this.P[T].map((R) => he(R, i, s));
          for (const R of C) if (C = ls(R, s), C.F()) {
            if (x) return g[T](i);
          } else {
            if (!C.oa()) throw Error("XPTY0004: The operand for a switch case should result in zero or one item");
            if (!x && (C = C.first(), Yd(i, s, null, b, C).next(0).value)) return g[T](i);
          }
        }
        return h(i);
      } });
    }
    v(i) {
      if (super.v(i), this.L.I) throw jr();
    }
  }, wN = { Z: !1, sa: !1 }, bN = { Z: !0, sa: !1 }, vN = { Z: !0, sa: !0 };
  function Me(i) {
    return i.Z ? i.sa ? vN : bN : wN;
  }
  function re(i, s) {
    switch (i[0]) {
      case "andOp":
        var c = le(i, "type");
        return new kT($0("andOp", i, Me(s)), c);
      case "orOp":
        return c = le(i, "type"), new AT($0("orOp", i, Me(s)), c);
      case "unaryPlusOp":
        return c = F(F(i, "operand"), "*"), i = le(i, "type"), new a0("+", re(c, s), i);
      case "unaryMinusOp":
        return c = F(F(i, "operand"), "*"), i = le(i, "type"), new a0("-", re(c, s), i);
      case "addOp":
      case "subtractOp":
      case "multiplyOp":
      case "divOp":
      case "idivOp":
      case "modOp":
        var u = i[0], h = re(oe(i, ["firstOperand", "*"]), Me(s));
        s = re(oe(i, ["secondOperand", "*"]), Me(s));
        const g = le(i, "type"), b = le(oe(i, ["firstOperand", "*"]), "type"), x = le(oe(i, ["secondOperand", "*"]), "type");
        return b && x && le(i, "type") && (c = zy(u, b.type, x.type)), new GE(u, h, s, g, c);
      case "sequenceExpr":
        return MN(i, s);
      case "unionOp":
        return c = le(i, "type"), new zT([re(oe(i, ["firstOperand", "*"]), Me(s)), re(oe(i, ["secondOperand", "*"]), Me(s))], c);
      case "exceptOp":
      case "intersectOp":
        return c = le(i, "type"), new UT(i[0], re(oe(i, ["firstOperand", "*"]), Me(s)), re(oe(i, ["secondOperand", "*"]), Me(s)), c);
      case "stringConcatenateOp":
        return DN(i, s);
      case "rangeSequenceExpr":
        return RN(
          i,
          s
        );
      case "equalOp":
      case "notEqualOp":
      case "lessThanOrEqualOp":
      case "lessThanOp":
      case "greaterThanOrEqualOp":
      case "greaterThanOp":
        return mp("generalCompare", i, s);
      case "eqOp":
      case "neOp":
      case "ltOp":
      case "leOp":
      case "gtOp":
      case "geOp":
        return mp("valueCompare", i, s);
      case "isOp":
      case "nodeBeforeOp":
      case "nodeAfterOp":
        return mp("nodeCompare", i, s);
      case "pathExpr":
        return BN(i, s);
      case "contextItemExpr":
        return new XT(le(i, "type"));
      case "functionCallExpr":
        return SN(i, s);
      case "inlineFunctionExpr":
        return NN(i, s);
      case "arrowExpr":
        return EN(i, s);
      case "dynamicFunctionInvocationExpr":
        return TN(i, s);
      case "namedFunctionRef":
        return s = F(i, "functionName"), c = le(i, "type"), i = Se(oe(i, ["integerConstantExpr", "value"])), new Ia(ze(s), parseInt(i, 10), c);
      case "integerConstantExpr":
        return new as(Se(F(i, "value")), { type: 5, g: 3 });
      case "stringConstantExpr":
        return new as(Se(F(i, "value")), { type: 1, g: 3 });
      case "decimalConstantExpr":
        return new as(Se(F(i, "value")), { type: 4, g: 3 });
      case "doubleConstantExpr":
        return new as(Se(F(i, "value")), { type: 3, g: 3 });
      case "varRef":
        const { prefix: C, namespaceURI: T, localName: R } = ze(F(i, "name"));
        return new tN(C, T, R);
      case "flworExpr":
        return CN(i, s);
      case "quantifiedExpr":
        return IN(i, s);
      case "ifThenElseExpr":
        return c = le(i, "type"), u = F(i, "ifClause") || ae(i, "x:stackTrace")[0], h = F(i, "thenClause") || ae(i, "x:stackTrace")[1], i = F(i, "elseClause") || ae(i, "x:stackTrace")[2], new mT(re(u, Me(s)), re(h, s), re(i, s), c);
      case "instanceOfExpr":
        return c = re(oe(i, ["argExpr", "*"]), s), u = oe(i, ["sequenceType", "*"]), h = oe(i, ["sequenceType", "occurrenceIndicator"]), i = le(i, "type"), new _T(c, re(u, Me(s)), h ? Se(h) : "", i);
      case "castExpr":
        return s = re(F(F(i, "argExpr"), "*"), Me(s)), c = F(i, "singleType"), i = ze(F(c, "atomicType")), c = F(c, "optional") !== null, new GT(s, i, c);
      case "castableExpr":
        return s = re(F(F(i, "argExpr"), "*"), Me(s)), c = F(i, "singleType"), i = ze(F(c, "atomicType")), c = F(c, "optional") !== null, new HT(s, i, c);
      case "simpleMapExpr":
        return ON(i, s);
      case "mapConstructor":
        return kN(i, s);
      case "arrayConstructor":
        return xN(i, s);
      case "unaryLookup":
        return c = le(i, "type"), new QT(j0(i, s), c);
      case "typeswitchExpr":
        return UN(
          i,
          s
        );
      case "switchExpr":
        return LN(i, s);
      case "elementConstructor":
        return FN(i, s);
      case "attributeConstructor":
        return PN(i, s);
      case "computedAttributeConstructor":
        return (c = F(i, "tagName")) ? c = ze(c) : (c = F(i, "tagNameExpr"), c = { Na: re(F(c, "*"), Me(s)) }), s = re(F(F(i, "valueExpr"), "*"), Me(s)), new O0(c, { nb: [s] });
      case "computedCommentConstructor":
        if (!s.Z) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
        return s = (i = F(i, "argExpr")) ? re(F(i, "*"), Me(s)) : null, new hN(s);
      case "computedTextConstructor":
        if (!s.Z) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
        return s = (i = F(i, "argExpr")) ? re(F(i, "*"), Me(s)) : null, new mN(s);
      case "computedElementConstructor":
        return $N(i, s);
      case "computedPIConstructor":
        if (!s.Z) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
        return c = F(i, "piTargetExpr"), u = F(i, "piTarget"), h = F(i, "piValueExpr"), i = le(i, "type"), new fN({ xb: c ? re(F(c, "*"), Me(s)) : null, Fb: u ? Se(u) : null }, h ? re(F(h, "*"), Me(s)) : new dp([], i));
      case "CDataSection":
        return new as(Se(i), { type: 1, g: 3 });
      case "deleteExpr":
        return s = re(
          oe(i, ["targetExpr", "*"]),
          s
        ), new iN(s);
      case "insertExpr":
        switch (c = re(oe(i, ["sourceExpr", "*"]), s), h = ae(i, "*")[1], h[0]) {
          case "insertAfter":
            u = 1;
            break;
          case "insertBefore":
            u = 2;
            break;
          case "insertInto":
            u = (u = F(h, "*")) ? u[0] === "insertAsFirst" ? 4 : 5 : 3;
        }
        return s = re(oe(i, ["targetExpr", "*"]), s), new sN(c, u, s);
      case "renameExpr":
        return c = re(oe(i, ["targetExpr", "*"]), s), s = re(oe(i, ["newNameExpr", "*"]), s), new lN(c, s);
      case "replaceExpr":
        return c = !!F(i, "replaceValue"), u = re(oe(i, ["targetExpr", "*"]), s), s = re(oe(i, ["replacementExpr", "*"]), s), new dN(c, u, s);
      case "transformExpr":
        return jN(
          i,
          s
        );
      case "x:stackTrace":
        for (c = i, i = c[2]; i[0] === "x:stackTrace"; ) c = i, i = i[2];
        return c = c[1], new gT(c, i[0], re(i, s), c.Wa);
      case "ifClause":
      case "thenClause":
      case "elseClause":
        return re(F(i, "*"), s);
      default:
        return P0(i);
    }
  }
  function P0(i) {
    switch (i[0]) {
      case "nameTest":
        return new Yi(ze(i));
      case "piTest":
        return (i = F(i, "piTarget")) ? new eN(Se(i)) : new cs(7);
      case "commentTest":
        return new cs(8);
      case "textTest":
        return new cs(3);
      case "documentTest":
        return new cs(9);
      case "attributeTest":
        var s = (i = F(i, "attributeName")) && F(i, "star");
        return !i || s ? new cs(2) : new Yi(ze(F(i, "QName")), { kind: 2 });
      case "elementTest":
        return s = (i = F(i, "elementName")) && F(i, "star"), !i || s ? new cs(1) : new Yi(ze(F(i, "QName")), { kind: 1 });
      case "anyKindTest":
        return new Ma({
          prefix: "",
          namespaceURI: null,
          localName: "node()"
        });
      case "anyMapTest":
        return new Ma({ prefix: "", namespaceURI: null, localName: "map(*)" });
      case "anyArrayTest":
        return new Ma({ prefix: "", namespaceURI: null, localName: "array(*)" });
      case "Wildcard":
        return F(i, "star") ? (s = F(i, "uri")) ? i = new Yi({ localName: "*", namespaceURI: Se(s), prefix: "" }) : (s = F(i, "NCName"), i = F(i, "*")[0] === "star" ? new Yi({ localName: Se(s), namespaceURI: null, prefix: "*" }) : new Yi({ localName: "*", namespaceURI: null, prefix: Se(s) })) : i = new Yi({
          localName: "*",
          namespaceURI: null,
          prefix: "*"
        }), i;
      case "atomicType":
        return new Ma(ze(i));
      case "anyItemType":
        return new Ma({ prefix: "", namespaceURI: null, localName: "item()" });
      default:
        throw Error("No selector counterpart for: " + i[0] + ".");
    }
  }
  function xN(i, s) {
    const c = le(i, "type");
    i = F(i, "*");
    const u = ae(i, "arrayElem").map((h) => re(F(h, "*"), Me(s)));
    switch (i[0]) {
      case "curlyArray":
        return new ZE(u, c);
      case "squareArray":
        return new eT(u, c);
      default:
        throw Error("Unrecognized arrayType: " + i[0]);
    }
  }
  function kN(i, s) {
    const c = le(i, "type");
    return new vT(ae(i, "mapConstructorEntry").map((u) => ({ key: re(oe(u, ["mapKeyExpr", "*"]), Me(s)), value: re(oe(u, ["mapValueExpr", "*"]), Me(s)) })), c);
  }
  function $0(i, s, c) {
    function u(g) {
      const b = F(F(g, "firstOperand"), "*");
      g = F(F(g, "secondOperand"), "*"), b[0] === i ? u(b) : h.push(re(b, c)), g[0] === i ? u(g) : h.push(re(g, c));
    }
    const h = [];
    return u(s), h;
  }
  function j0(i, s) {
    switch (i = F(i, "*"), i[0]) {
      case "NCName":
        return new as(Se(i), { type: 1, g: 3 });
      case "star":
        return "*";
      default:
        return re(i, Me(s));
    }
  }
  function mp(i, s, c) {
    var u = oe(s, ["firstOperand", "*"]);
    const h = oe(s, ["secondOperand", "*"]);
    switch (u = re(u, Me(c)), c = re(h, Me(c)), i) {
      case "valueCompare":
        return new OT(s[0], u, c);
      case "nodeCompare":
        return new jT(s[0], u, c);
      case "generalCompare":
        return new FT(s[0], u, c);
    }
  }
  function AN(i, s, c) {
    return i = ae(i, "*"), new VT(i.filter((u) => u[0] !== "stable").map((u) => {
      var h = F(u, "orderModifier"), g = h ? F(h, "orderingKind") : null;
      return h = h ? F(h, "emptyOrderingMode") : null, g = g ? Se(g) === "ascending" : !0, h = h ? Se(h) === "empty least" : !0, { ba: re(oe(u, ["orderByExpr", "*"]), s), Bb: g, cc: h };
    }), c);
  }
  function CN(i, s) {
    var c = ae(i, "*");
    if (i = F(c[c.length - 1], "*"), c = c.slice(0, -1), 1 < c.length && !s.Z) throw Error("XPST0003: Use of XQuery FLWOR expressions in XPath is no allowed");
    return c.reduceRight((u, h) => {
      switch (h[0]) {
        case "forClause":
          h = ae(h, "*");
          for (var g = h.length - 1; 0 <= g; --g) {
            var b = h[g], x = oe(b, ["forExpr", "*"]);
            const C = F(b, "positionalVariableBinding");
            u = new yT(ze(oe(b, ["typedVariableBinding", "varName"])), re(x, Me(s)), C ? ze(C) : null, u);
          }
          return u;
        case "letClause":
          for (h = ae(h, "*"), g = h.length - 1; 0 <= g; --g) b = h[g], x = oe(
            b,
            ["letExpr", "*"]
          ), u = new bT(ze(oe(b, ["typedVariableBinding", "varName"])), re(x, Me(s)), u);
          return u;
        case "whereClause":
          for (h = ae(h, "*"), g = h.length - 1; 0 <= g; --g) u = new nN(re(h[g], s), u);
          return u;
        case "windowClause":
          throw Error(`Not implemented: ${h[0]} is not implemented yet.`);
        case "groupByClause":
          throw Error(`Not implemented: ${h[0]} is not implemented yet.`);
        case "orderByClause":
          return AN(h, s, u);
        case "countClause":
          throw Error(`Not implemented: ${h[0]} is not implemented yet.`);
        default:
          throw Error(`Not implemented: ${h[0]} is not supported in a flwor expression`);
      }
    }, re(i, s));
  }
  function SN(i, s) {
    const c = F(i, "functionName"), u = ae(F(i, "arguments"), "*");
    return i = le(i, "type"), new Ta(new Ia(ze(c), u.length, i), u.map((h) => h[0] === "argumentPlaceholder" ? null : re(h, s)), i);
  }
  function EN(i, s) {
    const c = le(i, "type");
    var u = oe(i, ["argExpr", "*"]);
    i = ae(i, "*").slice(1), u = [re(u, s)];
    for (let g = 0; g < i.length; g++) if (i[g][0] !== "arguments") {
      if (i[g + 1][0] === "arguments") {
        var h = ae(i[g + 1], "*");
        u = u.concat(h.map((b) => b[0] === "argumentPlaceholder" ? null : re(b, s)));
      }
      h = i[g][0] === "EQName" ? new Ia(ze(i[g]), u.length, c) : re(i[g], Me(s)), u = [new Ta(h, u, c)];
    }
    return u[0];
  }
  function TN(i, s) {
    const c = oe(i, ["functionItem", "*"]), u = le(i, "type");
    i = F(i, "arguments");
    let h = [];
    return i && (h = ae(i, "*").map((g) => g[0] === "argumentPlaceholder" ? null : re(g, s))), new Ta(re(c, s), h, u);
  }
  function NN(i, s) {
    const c = ae(F(i, "paramList"), "*"), u = oe(i, ["functionBody", "*"]), h = le(i, "type");
    return new wT(c.map((g) => ({ name: ze(F(g, "varName")), type: mc(g) })), mc(i), u ? re(u, s) : new dp([], h));
  }
  function BN(i, s) {
    const c = le(i, "type");
    var u = ae(i, "stepExpr");
    let h = !1;
    var g = u.map((b) => {
      var x = F(b, "xpathAxis");
      let C;
      var T = ae(b, "*");
      const R = [];
      let P = null, q = !1;
      for (const _ of T) switch (_[0]) {
        case "lookup":
          R.push(["lookup", j0(_, s)]);
          break;
        case "predicate":
        case "predicates":
          for (const ie of ae(_, "*")) {
            if (T = re(ie, Me(s)), !q) {
              const me = T.D();
              me === null ? q = !0 : P = vn(P, me);
            }
            R.push(["predicate", T]);
          }
      }
      if (x) switch (h = !0, b = F(b, "attributeTest anyElementTest piTest documentTest elementTest commentTest namespaceTest anyKindTest textTest anyFunctionTest typedFunctionTest schemaAttributeTest atomicType anyItemType parenthesizedItemType typedMapTest typedArrayTest nameTest Wildcard".split(" ")), b = P0(b), Se(x)) {
        case "ancestor":
          C = new Qy(b, { Qa: !1 });
          break;
        case "ancestor-or-self":
          C = new Qy(b, { Qa: !0 });
          break;
        case "attribute":
          C = new nT(b, P);
          break;
        case "child":
          C = new rT(b, P);
          break;
        case "descendant":
          C = new e0(b, { Qa: !1 });
          break;
        case "descendant-or-self":
          C = new e0(b, { Qa: !0 });
          break;
        case "parent":
          C = new cT(b, P);
          break;
        case "following-sibling":
          C = new lT(b, P);
          break;
        case "preceding-sibling":
          C = new hT(b, P);
          break;
        case "following":
          C = new sT(b);
          break;
        case "preceding":
          C = new dT(b);
          break;
        case "self":
          C = new fT(b, P);
      }
      else x = oe(
        b,
        ["filterExpr", "*"]
      ), C = re(x, Me(s));
      for (const _ of R) switch (_[0]) {
        case "lookup":
          C = new YT(C, _[1]);
          break;
        case "predicate":
          C = new WT(C, _[1]);
      }
      return C.type = c, C;
    });
    return i = F(i, "rootExpr"), u = h || i !== null || 1 < u.length, !u && g.length === 1 || !i && g.length === 1 && g[0].ia === "sorted" ? g[0] : i && g.length === 0 ? new h0(null) : (g = new KT(g, u), i ? new h0(g) : g);
  }
  function IN(i, s) {
    const c = le(i, "type"), u = Se(F(i, "quantifier")), h = oe(i, ["predicateExpr", "*"]);
    return i = ae(i, "quantifiedExprInClause").map((g) => {
      const b = ze(oe(g, ["typedVariableBinding", "varName"]));
      return g = oe(g, ["sourceExpr", "*"]), { name: b, fb: re(g, Me(s)) };
    }), new ZT(u, i, re(h, Me(s)), c);
  }
  function MN(i, s) {
    var c = ae(i, "*").map((u) => re(u, s));
    return c.length === 1 ? c[0] : (c = le(i, "type"), new dp(ae(i, "*").map((u) => re(u, s)), c));
  }
  function ON(i, s) {
    const c = le(i, "type");
    return ae(i, "*").reduce((u, h) => u === null ? re(h, Me(s)) : new LT(u, re(h, Me(s)), c), null);
  }
  function DN(i, s) {
    const c = le(i, "type");
    return i = [oe(i, ["firstOperand", "*"]), oe(i, ["secondOperand", "*"])], new Ta(new Ia({ localName: "concat", namespaceURI: "http://www.w3.org/2005/xpath-functions", prefix: "" }, i.length, c), i.map((u) => re(u, Me(s))), c);
  }
  function RN(i, s) {
    const c = le(i, "type");
    i = [F(F(i, "startExpr"), "*"), F(F(i, "endExpr"), "*")];
    const u = new Ia({ localName: "to", namespaceURI: "http://fontoxpath/operators", prefix: "" }, i.length, c);
    return new Ta(u, i.map((h) => re(h, Me(s))), c);
  }
  function FN(i, s) {
    if (!s.Z) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
    const c = ze(F(i, "tagName"));
    var u = F(i, "attributeList");
    const h = u ? ae(u, "attributeConstructor").map((g) => re(g, Me(s))) : [];
    return u = u ? ae(u, "namespaceDeclaration").map((g) => {
      const b = F(g, "prefix");
      return { prefix: b ? Se(b) : "", uri: Se(F(g, "uri")) };
    }) : [], i = (i = F(i, "elementContent")) ? ae(i, "*").map((g) => re(g, Me(s))) : [], new D0(c, h, u, i);
  }
  function PN(i, s) {
    if (!s.Z) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
    const c = ze(F(i, "attributeName"));
    var u = F(i, "attributeValue");
    return u = u ? Se(u) : null, i = (i = F(i, "attributeValueExpr")) ? ae(i, "*").map((h) => re(h, Me(s))) : null, new O0(c, { value: u, nb: i });
  }
  function $N(i, s) {
    var c = F(i, "tagName");
    return c ? c = ze(c) : (c = F(i, "tagNameExpr"), c = { Na: re(F(c, "*"), Me(s)) }), i = (i = F(i, "contentExpr")) ? ae(i, "*").map((u) => re(u, Me(s))) : [], new D0(c, [], [], i);
  }
  function jN(i, s) {
    const c = ae(F(i, "transformCopies"), "transformCopy").map((h) => {
      const g = ze(F(F(h, "varRef"), "name"));
      return { fb: re(F(F(h, "copySource"), "*"), s), Jb: new _t(g.prefix, g.namespaceURI, g.localName) };
    }), u = re(F(F(i, "modifyExpr"), "*"), s);
    return i = re(F(F(i, "returnExpr"), "*"), s), new pN(c, u, i);
  }
  function UN(i, s) {
    if (!s.Z) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
    const c = le(i, "type"), u = re(F(F(i, "argExpr"), "*"), s), h = ae(i, "typeswitchExprCaseClause").map((g) => {
      const b = ae(g, "sequenceTypeUnion").length === 0 ? [F(g, "sequenceType")] : ae(F(g, "sequenceTypeUnion"), "sequenceType");
      return { pb: re(oe(g, ["resultExpr", "*"]), s), Ib: b.map((x) => {
        const C = F(x, "occurrenceIndicator");
        return { ec: C ? Se(C) : "", Hb: re(F(x, "*"), s) };
      }) };
    });
    return i = re(oe(i, ["typeswitchExprDefaultClause", "resultExpr", "*"]), s), new gN(u, h, i, c);
  }
  function LN(i, s) {
    if (!s.Z) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
    const c = le(i, "type"), u = re(F(F(i, "argExpr"), "*"), s), h = ae(i, "switchExprCaseClause").map((g) => {
      const b = ae(g, "switchCaseExpr");
      return { pb: re(oe(g, ["resultExpr", "*"]), s), Gb: b.map((x) => re(F(x, "*"), s)) };
    });
    return i = re(oe(i, ["switchExprDefaultClause", "resultExpr", "*"]), s), new yN(u, h, i, c);
  }
  function gp(i, s) {
    return re(i, s);
  }
  const Ec = /* @__PURE__ */ new Map();
  class HN {
    constructor(s, c, u, h, g, b) {
      this.v = s, this.D = c, this.h = u, this.kb = h, this.o = g, this.l = b;
    }
  }
  function GN(i, s, c, u, h, g, b, x) {
    return i = Ec.get(i), i ? (s = i[s + (g ? "_DEBUG" : "")], s && (s = s.find((C) => C.o === b && C.v.every((T) => c(T.prefix) === T.namespaceURI) && C.D.every((T) => u[T.name] !== void 0) && C.kb.every((T) => h[T.prefix] === T.namespaceURI) && C.l.every((T) => {
      const R = x(T.dc, T.arity);
      return R && R.namespaceURI === T.Db.namespaceURI && R.localName === T.Db.localName;
    }))) ? { ba: s.h, hc: !1 } : null) : null;
  }
  function U0(i, s, c, u, h, g, b) {
    let x = Ec.get(i);
    x || (x = /* @__PURE__ */ Object.create(null), Ec.set(i, x)), i = s + (g ? "_DEBUG" : ""), (s = x[i]) || (s = x[i] = []), s.push(new HN(Object.values(c.h), Object.values(c.o), h, Object.keys(u).map((C) => ({ namespaceURI: u[C], prefix: C })), b, c.D));
  }
  function Tc(i) {
    var s = new si();
    if (i.namespaceURI !== "http://www.w3.org/2005/XQueryX" && i.namespaceURI !== "http://www.w3.org/2005/XQueryX" && i.namespaceURI !== "http://fontoxml.com/fontoxpath" && i.namespaceURI !== "http://www.w3.org/2007/xquery-update-10") throw Nn("The XML structure passed as an XQueryX program was not valid XQueryX");
    const c = [i.localName === "stackTrace" ? "x:stackTrace" : i.localName], u = s.getAllAttributes(i);
    u && 0 < u.length && c.push(Array.from(u).reduce((h, g) => (g.localName !== "comment" && g.localName !== "start" && g.localName !== "end" || i.localName !== "stackTrace" ? g.localName === "type" ? h[g.localName] = or(g.value) : h[g.localName] = g.value : h[g.localName] = JSON.parse(g.value), h), {})), s = s.getChildNodes(i);
    for (const h of s) switch (h.nodeType) {
      case 1:
        c.push(Tc(h));
        break;
      case 3:
        c.push(h.data);
    }
    return c;
  }
  const Da = /* @__PURE__ */ Object.create(null);
  var L0 = (i, s) => {
    let c = Da[i];
    c || (c = Da[i] = { Ia: [], Ta: [], pa: null, source: s.source });
    const u = c.pa || (() => {
    });
    c.Ia = c.Ia.concat(s.Ia), c.Ta = c.Ta.concat(s.Ta), c.pa = (h) => {
      u(h), s.pa && s.pa(h);
    };
  }, yp = (i, s) => {
    const c = Da[s];
    if (!c) throw Error(`XQST0051: No modules found with the namespace uri ${s}`);
    c.Ia.forEach((u) => {
      u.cb && ap(i, s, u.localName, u.arity, u);
    }), c.Ta.forEach((u) => {
      fr(i, s, u.localName), Hy(i, s, u.localName, (h, g) => he(u.ba, h, g));
    });
  }, Ra = () => {
    Object.keys(Da).forEach((i) => {
      if (i = Da[i], i.pa) try {
        i.pa(i);
      } catch (s) {
        i.pa = null, dn(
          i.source,
          s
        );
      }
      i.pa = null;
    });
  };
  function wp(i) {
    return i.replace(/(\x0D\x0A)|(\x0D(?!\x0A))/g, `
`);
  }
  var w = e;
  function bp(i, s) {
    return (c, u) => s.has(u) ? s.get(u) : (c = i(c, u), s.set(u, c), c);
  }
  function ye(i, s) {
    return (0, w.delimited)(s, i, s);
  }
  function V(i, s) {
    return i.reverse().reduce((c, u) => (0, w.preceded)(u, c), s);
  }
  function bt(i, s, c, u) {
    return (0, w.then)((0, w.then)(i, s, (h, g) => [h, g]), c, ([h, g], b) => u(h, g, b));
  }
  function vp(i, s, c, u, h) {
    return (0, w.then)((0, w.then)((0, w.then)(i, s, (g, b) => [g, b]), c, ([g, b], x) => [g, b, x]), u, ([g, b, x], C) => h(g, b, x, C));
  }
  function _N(i, s, c, u, h, g) {
    return (0, w.then)((0, w.then)((0, w.then)((0, w.then)(i, s, (b, x) => [b, x]), c, ([b, x], C) => [b, x, C]), u, ([b, x, C], T) => [b, x, C, T]), h, ([b, x, C, T], R) => g(b, x, C, T, R));
  }
  function pi(i) {
    return (0, w.map)(i, (s) => [s]);
  }
  function Pe(i, s) {
    return (0, w.map)((0, w.or)(i), () => s);
  }
  function vt(i) {
    return (s, c) => (s = i.exec(s.substring(c))) && s.index === 0 ? (0, w.okWithValue)(c + s[0].length, s[0]) : (0, w.error)(c, [i.source], !1);
  }
  var H0 = (0, w.or)([(0, w.token)(" "), (0, w.token)("	"), (0, w.token)("\r"), (0, w.token)(`
`)]), G0 = (0, w.token)("(:"), _0 = (0, w.token)(":)"), zN = (0, w.token)("(#"), z0 = (0, w.token)("#)"), lt = (0, w.token)("("), nt = (0, w.token)(")"), q0 = (0, w.token)("["), V0 = (0, w.token)("]"), hi = (0, w.token)("{"), fi = (0, w.token)("}"), qN = (0, w.token)("{{"), VN = (0, w.token)("}}"), Nc = (0, w.token)("'"), XN = (0, w.token)("''"), Bc = (0, w.token)('"'), JN = (0, w.token)('""'), KN = (0, w.token)("<![CDATA["), X0 = (0, w.token)("]]>"), WN = (0, w.token)("/>"), YN = (0, w.token)("</"), QN = (0, w.token)("<!--"), ZN = (0, w.token)("-->"), eB = (0, w.token)("<?"), J0 = (0, w.token)("?>"), tB = (0, w.token)("&#x"), nB = (0, w.token)("&#"), rB = (0, w.token)(":*"), iB = (0, w.token)("*:"), Zi = (0, w.token)(":="), oB = (0, w.token)("&"), Fa = (0, w.token)(":"), eo = (0, w.token)(";"), gr = (0, w.token)("*"), sB = (0, w.token)("@"), yr = (0, w.token)("$"), aB = (0, w.token)("#"), K0 = (0, w.token)("%"), Pa = (0, w.token)("?"), mi = (0, w.token)("="), lB = (0, w.followed)((0, w.token)("!"), (0, w.not)((0, w.peek)(mi), [])), W0 = (0, w.followed)((0, w.token)("|"), (0, w.not)(
    (0, w.peek)((0, w.token)("|")),
    []
  )), cB = (0, w.token)("||"), uB = (0, w.token)("!="), Y0 = (0, w.token)("<"), dB = (0, w.token)("<<"), pB = (0, w.token)("<="), xp = (0, w.token)(">"), hB = (0, w.token)(">>"), fB = (0, w.token)(">="), Tt = (0, w.token)(","), ds = (0, w.token)("."), mB = (0, w.token)(".."), Ic = (0, w.token)("+"), ps = (0, w.token)("-"), Mc = (0, w.token)("/"), gB = (0, w.token)("//"), yB = (0, w.token)("=>"), wB = (0, w.token)("e"), bB = (0, w.token)("E");
  (0, w.token)("l"), (0, w.token)("L"), (0, w.token)("m"), (0, w.token)("M");
  var vB = (0, w.token)("Q");
  (0, w.token)("x"), (0, w.token)("X");
  var qn = (0, w.token)("as"), xB = (0, w.token)("cast"), kB = (0, w.token)("castable"), AB = (0, w.token)("treat"), CB = (0, w.token)("instance"), Q0 = (0, w.token)("of"), $a = (0, w.token)("node"), Z0 = (0, w.token)("nodes"), SB = (0, w.token)("delete"), EB = (0, w.token)("value"), hs = (0, w.token)("function"), Oc = (0, w.token)("map"), to = (0, w.token)("element"), ja = (0, w.token)("attribute"), ew = (0, w.token)("schema-element"), TB = (0, w.token)("intersect"), NB = (0, w.token)("except"), BB = (0, w.token)("union"), IB = (0, w.token)("to"), MB = (0, w.token)("is"), OB = (0, w.token)("or"), DB = (0, w.token)("and"), RB = (0, w.token)("div"), FB = (0, w.token)("idiv"), PB = (0, w.token)("mod"), $B = (0, w.token)("eq"), jB = (0, w.token)("ne"), tw = (0, w.token)("lt"), UB = (0, w.token)("le"), nw = (0, w.token)("gt"), LB = (0, w.token)("ge"), HB = (0, w.token)("amp"), GB = (0, w.token)("quot"), _B = (0, w.token)("apos"), rw = (0, w.token)("if"), zB = (0, w.token)("then"), qB = (0, w.token)("else"), VB = (0, w.token)("allowing"), kp = (0, w.token)("empty"), Ap = (0, w.token)("at"), iw = (0, w.token)("in"), XB = (0, w.token)("for"), JB = (0, w.token)("let"), KB = (0, w.token)("where"), Cp = (0, w.token)("collation"), WB = (0, w.token)("group"), Sp = (0, w.token)("by"), Ep = (0, w.token)("order"), YB = (0, w.token)("stable"), fs = (0, w.token)("return"), Dc = (0, w.token)("array"), QB = (0, w.token)("document"), no = (0, w.token)("namespace"), ow = (0, w.token)("text"), sw = (0, w.token)("comment"), aw = (0, w.token)("processing-instruction"), ZB = (0, w.token)("lax"), eI = (0, w.token)("strict"), tI = (0, w.token)("validate"), nI = (0, w.token)("type"), xn = (0, w.token)("declare"), ro = (0, w.token)("default"), rI = (0, w.token)("boundary-space"), lw = (0, w.token)("strip"), Tp = (0, w.token)("preserve"), iI = (0, w.token)("no-preserve"), oI = (0, w.token)("inherit"), sI = (0, w.token)("no-inherit"), cw = (0, w.token)("greatest"), uw = (0, w.token)("least"), aI = (0, w.token)("copy-namespaces"), dw = (0, w.token)("decimal-format"), pw = (0, w.token)("case"), hw = (0, w.token)("typeswitch"), lI = (0, w.token)("some"), cI = (0, w.token)("every"), uI = (0, w.token)("satisfies"), dI = (0, w.token)("replace"), pI = (0, w.token)("with"), hI = (0, w.token)("copy"), fI = (0, w.token)("modify"), mI = (0, w.token)("first"), gI = (0, w.token)("last"), yI = (0, w.token)("before"), wI = (0, w.token)("after"), bI = (0, w.token)("into"), vI = (0, w.token)("insert"), xI = (0, w.token)("rename"), fw = (0, w.token)("switch"), kI = (0, w.token)("variable"), Np = (0, w.token)("external"), AI = (0, w.token)("updating"), mw = (0, w.token)("import"), CI = (0, w.token)("schema"), gw = (0, w.token)("module"), SI = (0, w.token)("base-uri"), EI = (0, w.token)("construction"), TI = (0, w.token)("ordering"), NI = (0, w.token)("ordered"), BI = (0, w.token)("unordered"), II = (0, w.token)("option"), MI = (0, w.token)("context"), yw = (0, w.token)("item"), OI = (0, w.token)("xquery"), DI = (0, w.token)("version"), ww = (0, w.token)("encoding"), RI = (0, w.token)("document-node"), FI = (0, w.token)("namespace-node"), PI = (0, w.token)("schema-attribute"), $I = (0, w.token)("ascending"), jI = (0, w.token)("descending"), UI = (0, w.token)("empty-sequence"), LI = (0, w.token)("child::"), HI = (0, w.token)("descendant::"), GI = (0, w.token)("attribute::"), _I = (0, w.token)("self::"), zI = (0, w.token)("descendant-or-self::"), qI = (0, w.token)("following-sibling::"), VI = (0, w.token)("following::"), XI = (0, w.token)("parent::"), JI = (0, w.token)("ancestor::"), KI = (0, w.token)("preceding-sibling::"), WI = (0, w.token)("preceding::"), YI = (0, w.token)("ancestor-or-self::"), QI = (0, w.token)("decimal-separator"), ZI = (0, w.token)("grouping-separator"), eM = (0, w.token)("infinity"), tM = (0, w.token)("minus-sign"), nM = (0, w.token)("NaN"), rM = (0, w.token)("per-mille"), iM = (0, w.token)("zero-digit"), oM = (0, w.token)("digit"), sM = (0, w.token)("pattern-separator"), aM = (0, w.token)("exponent-separator"), lM = (0, w.token)("schema-attribute("), cM = (0, w.token)("document-node("), uM = (0, w.token)("processing-instruction("), dM = (0, w.token)("processing-instruction()"), pM = (0, w.token)("comment()"), hM = (0, w.token)("text()"), fM = (0, w.token)("namespace-node()"), mM = (0, w.token)("node()"), gM = (0, w.token)("item()"), yM = (0, w.token)("empty-sequence()");
  (0, w.token)("`");
  var wM = (0, w.token)("``["), bw = (0, w.token)("]``"), vw = (0, w.token)("`{"), xw = (0, w.token)("}`"), kw = /* @__PURE__ */ new Map(), Aw = /* @__PURE__ */ new Map(), wr = (0, w.or)([vt(/[\t\n\r -\uD7FF\uE000\uFFFD]/), vt(/[\uD800-\uDBFF][\uDC00-\uDFFF]/)]), bM = (0, w.preceded)((0, w.peek)((0, w.not)((0, w.or)([G0, _0]), ['comment contents cannot contain "(:" or ":)"'])), wr), Cw = (0, w.map)((0, w.delimited)(G0, (0, w.star)((0, w.or)([bM, function(i, s) {
    return Cw(i, s);
  }])), _0, !0), (i) => i.join("")), Bp = (0, w.or)([H0, Cw]), Rc = (0, w.map)((0, w.plus)(H0), (i) => i.join("")), $ = bp((0, w.map)((0, w.star)(Bp), (i) => i.join("")), kw), W = bp((0, w.map)((0, w.plus)(Bp), (i) => i.join("")), Aw);
  const Ip = (0, w.or)([vt(/[A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/), (0, w.then)(vt(/[\uD800-\uDB7F]/), vt(/[\uDC00-\uDFFF]/), (i, s) => i + s)]), Sw = (0, w.or)([Ip, vt(/[\-\.0-9\xB7\u0300-\u036F\u203F\u2040]/)]);
  var en = (0, w.then)(Ip, (0, w.star)(Sw), (i, s) => i + s.join("")), vM = (0, w.map)(en, (i) => ["prefix", i]);
  const xM = (0, w.or)([Ip, Fa]), kM = (0, w.or)([Sw, Fa]);
  (0, w.then)(xM, (0, w.star)(kM), (i, s) => i + s.join(""));
  const AM = (0, w.map)(en, (i) => [{ prefix: "", URI: null }, i]), CM = (0, w.then)(en, (0, w.preceded)(Fa, en), (i, s) => [{ prefix: i, URI: null }, s]);
  var Fc = (0, w.or)([CM, AM]), Ew = (0, w.followed)(V([vB, $, hi], (0, w.map)((0, w.star)(vt(/[^{}]/)), (i) => i.join("").replace(/\s+/g, " ").trim())), fi);
  const SM = (0, w.then)(Ew, en, (i, s) => [i, s]);
  var qe = (0, w.or)([(0, w.map)(SM, (i) => [{ prefix: null, URI: i[0] }, i[1]]), Fc]), Tw = (0, w.or)([(0, w.map)(qe, (i) => ["QName", ...i]), (0, w.map)(gr, () => ["star"])]), Mp = (0, w.map)((0, w.preceded)(yr, qe), (i) => ["varRef", ["name", ...i]]), Nt = (0, w.peek)((0, w.or)([lt, Bc, Nc, Bp])), EM = (0, w.map)((0, w.or)([LI, HI, GI, _I, zI, qI, VI]), (i) => i.substring(0, i.length - 2)), TM = (0, w.map)((0, w.or)([XI, JI, KI, WI, YI]), (i) => i.substring(0, i.length - 2)), Op = bt(oB, (0, w.or)([tw, nw, HB, GB, _B]), eo, (i, s, c) => i + s + c), Dp = (0, w.or)([bt(tB, vt(/[0-9a-fA-F]+/), eo, (i, s, c) => i + s + c), bt(nB, vt(/[0-9]+/), eo, (i, s, c) => i + s + c)]), Rp = Pe([JN], '"'), Fp = Pe([XN], "'"), NM = pi(Pe([pM], "commentTest")), BM = pi(Pe([hM], "textTest")), IM = pi(Pe([fM], "namespaceTest")), MM = pi(Pe([mM], "anyKindTest"));
  const io = vt(/[0-9]+/), OM = (0, w.then)((0, w.or)([(0, w.then)(ds, io, (i, s) => i + s), (0, w.then)(io, (0, w.optional)((0, w.preceded)(ds, vt(/[0-9]*/))), (i, s) => i + (s !== null ? "." + s : ""))]), bt((0, w.or)([wB, bB]), (0, w.optional)((0, w.or)([Ic, ps])), io, (i, s, c) => i + (s || "") + c), (i, s) => ["doubleConstantExpr", ["value", i + s]]), DM = (0, w.or)([(0, w.map)((0, w.preceded)(ds, io), (i) => ["decimalConstantExpr", ["value", "." + i]]), (0, w.then)((0, w.followed)(io, ds), (0, w.optional)(io), (i, s) => ["decimalConstantExpr", ["value", i + "." + (s !== null ? s : "")]])]);
  var Pp = (0, w.map)(io, (i) => ["integerConstantExpr", ["value", i]]), RM = (0, w.followed)((0, w.or)([OM, DM, Pp]), (0, w.peek)((0, w.not)(vt(/[a-zA-Z]/), ["no alphabetical characters after numeric literal"]))), FM = (0, w.map)((0, w.followed)(ds, (0, w.peek)((0, w.not)(ds, ["context item should not be followed by another ."]))), () => ["contextItemExpr"]), Nw = (0, w.or)([Dc, ja, sw, RI, to, UI, hs, rw, yw, Oc, FI, $a, aw, PI, ew, fw, ow, hw]), PM = pi(Pe([Pa], "argumentPlaceholder")), $M = (0, w.or)([Pa, gr, Ic]), jM = (0, w.preceded)((0, w.peek)((0, w.not)(
    vt(/[{}<&]/),
    ["elementContentChar cannot be {, }, <, or &"]
  )), wr), UM = (0, w.map)((0, w.delimited)(KN, (0, w.star)((0, w.preceded)((0, w.peek)((0, w.not)(X0, ['CDataSection content may not contain "]]>"'])), wr)), X0, !0), (i) => ["CDataSection", i.join("")]), LM = (0, w.preceded)((0, w.peek)((0, w.not)(vt(/["{}<&]/), ['quotAttrValueContentChar cannot be ", {, }, <, or &'])), wr), HM = (0, w.preceded)((0, w.peek)((0, w.not)(vt(/['{}<&]/), ["aposAttrValueContentChar cannot be ', {, }, <, or &"])), wr), GM = (0, w.map)((0, w.star)((0, w.or)([(0, w.preceded)((0, w.peek)((0, w.not)(
    ps,
    []
  )), wr), (0, w.map)(V([ps, (0, w.peek)((0, w.not)(ps, []))], wr), (i) => "-" + i)])), (i) => i.join("")), _M = (0, w.map)((0, w.delimited)(QN, GM, ZN, !0), (i) => ["computedCommentConstructor", ["argExpr", ["stringConstantExpr", ["value", i]]]]);
  const zM = (0, w.filter)(en, (i) => i.toLowerCase() !== "xml", ['A processing instruction target cannot be "xml"']), qM = (0, w.map)((0, w.star)((0, w.preceded)((0, w.peek)((0, w.not)(J0, [])), wr)), (i) => i.join(""));
  var VM = (0, w.then)((0, w.preceded)(eB, (0, w.cut)(zM)), (0, w.cut)((0, w.followed)((0, w.optional)((0, w.preceded)(Rc, qM)), J0)), (i, s) => ["computedPIConstructor", ["piTarget", i], ["piValueExpr", ["stringConstantExpr", ["value", s]]]]), $p = (0, w.map)(gB, () => ["stepExpr", ["xpathAxis", "descendant-or-self"], ["anyKindTest"]]), XM = (0, w.or)([ZB, eI]), JM = (0, w.map)((0, w.star)((0, w.followed)(wr, (0, w.peek)((0, w.not)(z0, ["Pragma contents should not contain '#)'"])))), (i) => i.join("")), KM = (0, w.map)((0, w.followed)((0, w.or)([
    $B,
    jB,
    tw,
    UB,
    nw,
    LB
  ]), Nt), (i) => i + "Op"), WM = (0, w.or)([(0, w.followed)(Pe([MB], "isOp"), Nt), Pe([dB], "nodeBeforeOp"), Pe([hB], "nodeAfterOp")]), YM = (0, w.or)([Pe([mi], "equalOp"), Pe([uB], "notEqualOp"), Pe([pB], "lessThanOrEqualOp"), Pe([Y0], "lessThanOp"), Pe([fB], "greaterThanOrEqualOp"), Pe([xp], "greaterThanOp")]), QM = (0, w.map)(AI, () => ["annotation", ["annotationName", "updating"]]);
  const ZM = (0, w.or)([Tp, iI]), eO = (0, w.or)([oI, sI]);
  var tO = (0, w.or)([QI, ZI, eM, tM, nM, K0, rM, iM, oM, sM, aM]), nO = (0, w.map)(V([xn, W, rI, W], (0, w.or)([Tp, lw])), (i) => ["boundarySpaceDecl", i]), rO = (0, w.map)(V([xn, W, EI, W], (0, w.or)([Tp, lw])), (i) => ["constructionDecl", i]), iO = (0, w.map)(V([xn, W, TI, W], (0, w.or)([NI, BI])), (i) => ["orderingModeDecl", i]), oO = (0, w.map)(V([xn, W, ro, W, Ep, W, kp, W], (0, w.or)([cw, uw])), (i) => ["emptyOrderDecl", i]), sO = (0, w.then)(V([xn, W, aI, W], ZM), V([$, Tt, $], eO), (i, s) => ["copyNamespacesDecl", ["preserveMode", i], ["inheritMode", s]]);
  function jp(i) {
    switch (i[0]) {
      case "constantExpr":
      case "varRef":
      case "contextItemExpr":
      case "functionCallExpr":
      case "sequenceExpr":
      case "elementConstructor":
      case "computedElementConstructor":
      case "computedAttributeConstructor":
      case "computedDocumentConstructor":
      case "computedTextConstructor":
      case "computedCommentConstructor":
      case "computedNamespaceConstructor":
      case "computedPIConstructor":
      case "orderedExpr":
      case "unorderedExpr":
      case "namedFunctionRef":
      case "inlineFunctionExpr":
      case "dynamicFunctionInvocationExpr":
      case "mapConstructor":
      case "arrayConstructor":
      case "stringConstructor":
      case "unaryLookup":
        return i;
    }
    return [
      "sequenceExpr",
      i
    ];
  }
  function Bw(i) {
    if (!(1 <= i && 55295 >= i || 57344 <= i && 65533 >= i || 65536 <= i && 1114111 >= i)) throw Error("XQST0090: The character reference " + i + " (" + i.toString(16) + ") does not reference a valid codePoint.");
  }
  function Pc(i) {
    return i.replace(/(&[^;]+);/g, (s) => {
      if (/^&#x/.test(s)) return s = parseInt(s.slice(3, -1), 16), Bw(s), String.fromCodePoint(s);
      if (/^&#/.test(s)) return s = parseInt(s.slice(2, -1), 10), Bw(s), String.fromCodePoint(s);
      switch (s) {
        case "&lt;":
          return "<";
        case "&gt;":
          return ">";
        case "&amp;":
          return "&";
        case "&quot;":
          return '"';
        case "&apos;":
          return "'";
      }
      throw Error('XPST0003: Unknown character reference: "' + s + '"');
    });
  }
  function Iw(i, s, c) {
    if (!i.length) return [];
    let u = [i[0]];
    for (let h = 1; h < i.length; ++h) {
      const g = u[u.length - 1];
      typeof g == "string" && typeof i[h] == "string" ? u[u.length - 1] = g + i[h] : u.push(i[h]);
    }
    if (typeof u[0] == "string" && u.length === 0) return [];
    if (u = u.reduce((h, g, b) => {
      if (typeof g != "string") h.push(g);
      else if (c && /^\s*$/.test(g)) {
        const x = u[b + 1];
        (x && x[0] === "CDataSection" || (b = u[b - 1]) && b[0] === "CDataSection") && h.push(Pc(g));
      } else h.push(Pc(g));
      return h;
    }, []), !u.length) return u;
    if (1 < u.length || s) for (i = 0; i < u.length; i++) typeof u[i] == "string" && (u[i] = ["stringConstantExpr", ["value", u[i]]]);
    return u;
  }
  function Mw(i) {
    return i[0].prefix ? i[0].prefix + ":" + i[1] : i[1];
  }
  var Ow = (0, w.then)(qe, (0, w.optional)(Pa), (i, s) => s !== null ? ["singleType", ["atomicType", ...i], ["optional"]] : ["singleType", ["atomicType", ...i]]), Dw = (0, w.map)(qe, (i) => ["atomicType", ...i]);
  const Rw = /* @__PURE__ */ new Map();
  function $c(i) {
    function s(E, D) {
      return D.reduce((J, Ee) => [Ee[0], ["firstOperand", J], ["secondOperand", Ee[1]]], E);
    }
    function c(E, D, J) {
      return (0, w.then)(E, (0, w.star)((0, w.then)(ye(D, $), (0, w.cut)(E), (Ee, je) => [Ee, je])), J);
    }
    function u(E, D, J = "firstOperand", Ee = "secondOperand") {
      return (0, w.then)(E, (0, w.optional)((0, w.then)(ye(D, $), (0, w.cut)(E), (je, rn) => [je, rn])), (je, rn) => rn === null ? je : [rn[0], [J, je], [Ee, rn[1]]]);
    }
    function h(E) {
      return i.mb ? (D, J) => {
        if (D = E(D, J), !D.success) return D;
        const Ee = T.has(J) ? T.get(J) : { offset: J, line: -1, ha: -1 }, je = T.has(D.offset) ? T.get(D.offset) : { offset: D.offset, line: -1, ha: -1 };
        return T.set(J, Ee), T.set(D.offset, je), J = D.value.Wa, (0, w.okWithValue)(D.offset, ["x:stackTrace", Object.assign({ start: Ee, end: je }, J ? { Wa: J } : {}), D.value]);
      } : E;
    }
    function g(E, D) {
      return fb(E, D);
    }
    function b(E, D) {
      return oh(E, D);
    }
    function x(E, D) {
      return h((0, w.or)([oR, dR, vR, lR, L2, yR, pR, wR, hR, mR, P2]))(E, D);
    }
    function C(E, D) {
      return c(x, Tt, (J, Ee) => Ee.length === 0 ? J : ["sequenceExpr", J, ...Ee.map((je) => je[1])])(E, D);
    }
    const T = /* @__PURE__ */ new Map(), R = (0, w.preceded)(q0, (0, w.followed)(ye(
      C,
      $
    ), V0)), P = (0, w.map)(i.Za ? (0, w.or)([ye((0, w.star)((0, w.or)([Op, Dp, Rp, vt(/[^"&]/)])), Bc), ye((0, w.star)((0, w.or)([Op, Dp, Fp, vt(/[^'&]/)])), Nc)]) : (0, w.or)([ye((0, w.star)((0, w.or)([Rp, vt(/[^"]/)])), Bc), ye((0, w.star)((0, w.or)([Fp, vt(/[^']/)])), Nc)]), (E) => E.join("")), q = (0, w.or)([(0, w.map)(V([to, $], (0, w.delimited)((0, w.followed)(lt, $), (0, w.then)(Tw, V([$, Tt, $], qe), (E, D) => [["elementName", E], ["typeName", ...D]]), (0, w.preceded)($, nt))), ([E, D]) => ["elementTest", E, D]), (0, w.map)(V([to, $], (0, w.delimited)(lt, Tw, nt)), (E) => [
      "elementTest",
      ["elementName", E]
    ]), (0, w.map)(V([to, $], (0, w.delimited)(lt, $, nt)), () => ["elementTest"])]), _ = (0, w.or)([(0, w.map)(qe, (E) => ["QName", ...E]), (0, w.map)(gr, () => ["star"])]), ie = (0, w.or)([(0, w.map)(V([ja, $], (0, w.delimited)((0, w.followed)(lt, $), (0, w.then)(_, V([$, Tt, $], qe), (E, D) => [["attributeName", E], ["typeName", ...D]]), (0, w.preceded)($, nt))), ([E, D]) => ["attributeTest", E, D]), (0, w.map)(V([ja, $], (0, w.delimited)(lt, _, nt)), (E) => ["attributeTest", ["attributeName", E]]), (0, w.map)(V([ja, $], (0, w.delimited)(lt, $, nt)), () => ["attributeTest"])]), me = (0, w.map)(V([ew, $, lt], (0, w.followed)(qe, nt)), (E) => ["schemaElementTest", ...E]), Ce = (0, w.map)((0, w.delimited)(lM, ye(qe, $), nt), (E) => ["schemaAttributeTest", ...E]), $e = (0, w.map)((0, w.preceded)(cM, (0, w.followed)(ye((0, w.optional)((0, w.or)([q, me])), $), nt)), (E) => ["documentTest", ...E ? [E] : []]), nn = (0, w.or)([(0, w.map)((0, w.preceded)(uM, (0, w.followed)(ye((0, w.or)([en, P]), $), nt)), (E) => ["piTest", ["piTarget", E]]), pi(Pe([dM], "piTest"))]), yi = (0, w.or)([$e, q, ie, me, Ce, nn, NM, BM, IM, MM]), so = (0, w.or)([(0, w.map)((0, w.preceded)(iB, en), (E) => ["Wildcard", ["star"], ["NCName", E]]), pi(Pe([gr], "Wildcard")), (0, w.map)((0, w.followed)(Ew, gr), (E) => ["Wildcard", ["uri", E], ["star"]]), (0, w.map)((0, w.followed)(en, rB), (E) => ["Wildcard", ["NCName", E], ["star"]])]), Ha = (0, w.or)([so, (0, w.map)(qe, (E) => ["nameTest", ...E])]), ao = (0, w.or)([yi, Ha]), mD = (0, w.then)((0, w.optional)(sB), ao, (E, D) => E !== null || D[0] === "attributeTest" || D[0] === "schemaAttributeTest" ? ["stepExpr", ["xpathAxis", "attribute"], D] : ["stepExpr", ["xpathAxis", "child"], D]), gD = (0, w.or)([(0, w.then)(EM, ao, (E, D) => [
      "stepExpr",
      ["xpathAxis", E],
      D
    ]), mD]), yD = (0, w.map)(mB, () => ["stepExpr", ["xpathAxis", "parent"], ["anyKindTest"]]), wD = (0, w.or)([(0, w.then)(TM, ao, (E, D) => ["stepExpr", ["xpathAxis", E], D]), yD]), bD = (0, w.map)((0, w.star)((0, w.preceded)($, R)), (E) => 0 < E.length ? ["predicates", ...E] : void 0), vD = (0, w.then)((0, w.or)([wD, gD]), bD, (E, D) => D === void 0 ? E : E.concat([D])), th = (0, w.or)([RM, (0, w.map)(P, (E) => ["stringConstantExpr", ["value", i.Za ? Pc(E) : E]])]), nh = (0, w.or)([(0, w.delimited)(lt, ye(C, $), nt), (0, w.map)((0, w.delimited)(lt, $, nt), () => ["sequenceExpr"])]), pb = (0, w.or)([x, PM]), Hc = (0, w.map)((0, w.delimited)(lt, ye((0, w.optional)((0, w.then)(pb, (0, w.star)((0, w.preceded)(ye(Tt, $), pb)), (E, D) => [E, ...D])), $), nt), (E) => E !== null ? E : []), xD = (0, w.preceded)((0, w.not)(bt(Nw, $, lt, () => {
    }), ["cannot use reserved keyword for function names"]), h((0, w.then)(qe, (0, w.preceded)($, Hc), (E, D) => {
      D = ["functionCallExpr", ["functionName", ...E], D !== null ? ["arguments", ...D] : ["arguments"]];
      const J = E[0].prefix, Ee = E[0].URI;
      return E = E[1], D.Wa = J ? `${J}:${E}` : Ee ? `Q{${Ee}}${E}` : E, D;
    }))), kD = (0, w.then)(
      qe,
      (0, w.preceded)(aB, Pp),
      (E, D) => ["namedFunctionRef", ["functionName", ...E], D]
    ), Vn = (0, w.delimited)(hi, ye((0, w.optional)(C), $), fi), hb = (0, w.map)(Vn, (E) => E || ["sequenceExpr"]), br = (0, w.or)([(0, w.map)(yM, () => [["voidSequenceType"]]), (0, w.then)(g, (0, w.optional)((0, w.preceded)($, $M)), (E, D) => [E, ...D !== null ? [["occurrenceIndicator", D]] : []])]), rh = (0, w.then)(V([K0, $], qe), (0, w.optional)((0, w.followed)((0, w.then)(V([lt, $], th), (0, w.star)(V([Tt, $], th)), (E, D) => E.concat(D)), nt)), (E, D) => [
      "annotation",
      ["annotationName", ...E],
      ...D ? ["arguments", D] : []
    ]), AD = (0, w.map)(V([hs, $, lt, $, gr, $], nt), () => ["anyFunctionTest"]), CD = (0, w.then)(V([hs, $, lt, $], (0, w.optional)(c(br, Tt, (E, D) => E.concat.apply(E, D.map((J) => J[1]))))), V([$, nt, W, qn, W], br), (E, D) => ["typedFunctionTest", ["paramTypeList", ["sequenceType", ...E || []]], ["sequenceType", ...D]]), SD = (0, w.then)((0, w.star)(rh), (0, w.or)([AD, CD]), (E, D) => [D[0], ...E, ...D.slice(1)]), ED = (0, w.map)(V([Oc, $, lt, $, gr, $], nt), () => ["anyMapTest"]), TD = (0, w.then)(V([Oc, $, lt, $], Dw), V([$, Tt], (0, w.followed)(
      ye(br, $),
      nt
    )), (E, D) => ["typedMapTest", E, ["sequenceType", ...D]]), ND = (0, w.or)([ED, TD]), BD = (0, w.map)(V([Dc, $, lt, $, gr, $], nt), () => ["anyArrayTest"]), ID = (0, w.map)(V([Dc, $, lt], (0, w.followed)(ye(br, $), nt)), (E) => ["typedArrayTest", ["sequenceType", ...E]]), MD = (0, w.or)([BD, ID]), OD = (0, w.map)((0, w.delimited)(lt, ye(g, $), nt), (E) => ["parenthesizedItemType", E]), fb = (0, w.or)([yi, pi(Pe([gM], "anyItemType")), SD, ND, MD, Dw, OD]), ks = (0, w.map)(V([qn, W], br), (E) => ["typeDeclaration", ...E]), DD = (0, w.then)((0, w.preceded)(yr, qe), (0, w.optional)((0, w.preceded)(
      W,
      ks
    )), (E, D) => ["param", ["varName", ...E], ...D ? [D] : []]), mb = c(DD, Tt, (E, D) => [E, ...D.map((J) => J[1])]), RD = vp((0, w.star)(rh), V([$, hs, $, lt, $], (0, w.optional)(mb)), V([$, nt, $], (0, w.optional)((0, w.map)(V([qn, $], (0, w.followed)(br, $)), (E) => ["typeDeclaration", ...E]))), hb, (E, D, J, Ee) => ["inlineFunctionExpr", ...E, ["paramList", ...D || []], ...J ? [J] : [], ["functionBody", Ee]]), FD = (0, w.or)([kD, RD]), PD = (0, w.map)(x, (E) => ["mapKeyExpr", E]), $D = (0, w.map)(x, (E) => ["mapValueExpr", E]), jD = (0, w.then)(PD, (0, w.preceded)(ye(Fa, $), $D), (E, D) => [
      "mapConstructorEntry",
      E,
      D
    ]), UD = (0, w.preceded)(Oc, (0, w.delimited)(ye(hi, $), (0, w.map)((0, w.optional)(c(jD, ye(Tt, $), (E, D) => [E, ...D.map((J) => J[1])])), (E) => E ? ["mapConstructor", ...E] : ["mapConstructor"]), (0, w.preceded)($, fi))), LD = (0, w.map)((0, w.delimited)(q0, ye((0, w.optional)(c(x, Tt, (E, D) => [E, ...D.map((J) => J[1])].map((J) => ["arrayElem", J]))), $), V0), (E) => ["squareArray", ...E !== null ? E : []]), HD = (0, w.map)((0, w.preceded)(Dc, (0, w.preceded)($, Vn)), (E) => ["curlyArray", ...E !== null ? [["arrayElem", E]] : []]), GD = (0, w.map)((0, w.or)([LD, HD]), (E) => [
      "arrayConstructor",
      E
    ]), gb = (0, w.map)((0, w.star)((0, w.preceded)((0, w.peek)((0, w.not)((0, w.or)([vw, xw, bw]), ["String constructors can not contain interpolation characters"])), wr)), (E) => ["stringConstructorChars", E.join("")]), _D = (0, w.map)((0, w.delimited)(vw, C, xw, !0), (E) => ["stringConstructorInterpolation", E]), zD = (0, w.then)(gb, (0, w.star)((0, w.then)(_D, gb, (E, D) => [E, D])), (E, D) => {
      E = [E];
      for (const [J, Ee] of D) E.push(J, Ee);
      return E;
    }), qD = (0, w.map)((0, w.delimited)(wM, zD, bw, !0), (E) => ["stringConstructor", ...E]), yb = (0, w.or)([en, Pp, nh, gr]), VD = (0, w.map)((0, w.preceded)(Pa, (0, w.preceded)($, yb)), (E) => E === "*" ? ["unaryLookup", ["star"]] : typeof E == "string" ? ["unaryLookup", ["NCName", E]] : ["unaryLookup", E]), ih = (0, w.or)([Op, Dp, Pe([qN], "{"), Pe([VN], "}"), (0, w.map)(Vn, (E) => E || ["sequenceExpr"])]), XD = (0, w.or)([UM, function(E, D) {
      return wb(E, D);
    }, ih, jM]), JD = (0, w.or)([(0, w.map)(LM, (E) => E.replace(/[\x20\x0D\x0A\x09]/g, " ")), ih]), KD = (0, w.or)([(0, w.map)(HM, (E) => E.replace(/[\x20\x0D\x0A\x09]/g, " ")), ih]), WD = (0, w.map)((0, w.or)([ye((0, w.star)((0, w.or)([Rp, JD])), Bc), ye((0, w.star)((0, w.or)([
      Fp,
      KD
    ])), Nc)]), (E) => Iw(E, !1, !1)), YD = (0, w.then)(Fc, (0, w.preceded)(ye(mi, (0, w.optional)(Rc)), WD), (E, D) => {
      if (E[0].prefix === "" && E[1] === "xmlns") {
        if (D.length && typeof D[0] != "string") throw Error("XQST0022: A namespace declaration may not contain enclosed expressions");
        return ["namespaceDeclaration", D.length ? ["uri", D[0]] : ["uri"]];
      }
      if (E[0].prefix === "xmlns") {
        if (D.length && typeof D[0] != "string") throw Error("XQST0022: The namespace declaration for 'xmlns:" + E[1] + "' may not contain enclosed expressions");
        return [
          "namespaceDeclaration",
          ["prefix", E[1]],
          D.length ? ["uri", D[0]] : ["uri"]
        ];
      }
      return ["attributeConstructor", ["attributeName"].concat(E), D.length === 0 ? ["attributeValue"] : D.length === 1 && typeof D[0] == "string" ? ["attributeValue", D[0]] : ["attributeValueExpr"].concat(D)];
    }), QD = (0, w.map)((0, w.star)((0, w.preceded)(Rc, (0, w.optional)(YD))), (E) => E.filter(Boolean)), ZD = bt((0, w.preceded)(Y0, Fc), QD, (0, w.or)([(0, w.map)(WN, () => null), (0, w.then)((0, w.preceded)(xp, (0, w.star)(XD)), V([$, YN], (0, w.followed)(Fc, (0, w.then)((0, w.optional)(Rc), xp, () => null))), (E, D) => [Iw(E, !0, !0), D])]), (E, D, J) => {
      var Ee = J;
      if (J && J.length) {
        Ee = Mw(E);
        const je = Mw(J[1]);
        if (Ee !== je) throw Error('XQST0118: The start and the end tag of an element constructor must be equal. "' + Ee + '" does not match "' + je + '"');
        Ee = J[0];
      }
      return ["elementConstructor", ["tagName", ...E], ...D.length ? [["attributeList", ...D]] : [], ...Ee && Ee.length ? [["elementContent", ...Ee]] : []];
    }), wb = (0, w.or)([ZD, _M, VM]), e2 = (0, w.map)(V([QB, $], Vn), (E) => ["computedDocumentConstructor", ...E ? [["argExpr", E]] : []]), t2 = (0, w.map)(Vn, (E) => E ? [[
      "contentExpr",
      E
    ]] : []), n2 = (0, w.then)(V([to, $], (0, w.or)([(0, w.map)(qe, (E) => ["tagName", ...E]), (0, w.map)((0, w.delimited)(hi, ye(C, $), fi), (E) => ["tagNameExpr", E])])), (0, w.preceded)($, t2), (E, D) => ["computedElementConstructor", E, ...D]), r2 = (0, w.then)((0, w.preceded)(ja, (0, w.or)([(0, w.map)(V([Nt, $], qe), (E) => ["tagName", ...E]), (0, w.map)((0, w.preceded)($, (0, w.delimited)(hi, ye(C, $), fi)), (E) => ["tagNameExpr", E])])), (0, w.preceded)($, Vn), (E, D) => ["computedAttributeConstructor", E, ["valueExpr", D || ["sequenceExpr"]]]), i2 = (0, w.map)(Vn, (E) => E ? [[
      "prefixExpr",
      E
    ]] : []), o2 = (0, w.map)(Vn, (E) => E ? [["URIExpr", E]] : []), s2 = (0, w.then)(V([no, $], (0, w.or)([vM, i2])), (0, w.preceded)($, o2), (E, D) => ["computedNamespaceConstructor", ...E, ...D]), a2 = (0, w.map)(V([ow, $], Vn), (E) => ["computedTextConstructor", ...E ? [["argExpr", E]] : []]), l2 = (0, w.map)(V([sw, $], Vn), (E) => ["computedCommentConstructor", ...E ? [["argExpr", E]] : []]), c2 = V([aw, $], (0, w.then)((0, w.or)([(0, w.map)(en, (E) => ["piTarget", E]), (0, w.map)((0, w.delimited)(hi, ye(C, $), fi), (E) => ["piTargetExpr", E])]), (0, w.preceded)($, Vn), (E, D) => [
      "computedPIConstructor",
      E,
      ...D ? [["piValueExpr", D]] : []
    ])), u2 = (0, w.or)([e2, n2, r2, s2, a2, l2, c2]), d2 = (0, w.or)([wb, u2]), bb = (0, w.or)([th, Mp, nh, FM, xD, d2, FD, UD, GD, qD, VD]), vb = (0, w.map)(V([Pa, $], yb), (E) => E === "*" ? ["lookup", ["star"]] : typeof E == "string" ? ["lookup", ["NCName", E]] : ["lookup", E]), p2 = (0, w.then)((0, w.map)(bb, (E) => jp(E)), (0, w.star)((0, w.or)([(0, w.map)((0, w.preceded)($, R), (E) => ["predicate", E]), (0, w.map)((0, w.preceded)($, Hc), (E) => ["argumentList", E]), (0, w.preceded)($, vb)])), (E, D) => {
      function J() {
        Cb && rn.length === 1 ? Cs.push([
          "predicate",
          rn[0]
        ]) : rn.length !== 0 && Cs.push(["predicates", ...rn]), rn.length = 0;
      }
      function Ee(lo) {
        J(), Cs.length !== 0 ? (je[0][0] === "sequenceExpr" && 2 < je[0].length && (je = [["sequenceExpr", ...je]]), je = [["filterExpr", ...je], ...Cs], Cs.length = 0) : lo && (je = [["filterExpr", ...je]]);
      }
      let je = [E];
      const rn = [], Cs = [];
      let Cb = !1;
      for (const lo of D) switch (lo[0]) {
        case "predicate":
          rn.push(lo[1]);
          break;
        case "lookup":
          Cb = !0, J(), Cs.push(lo);
          break;
        case "argumentList":
          Ee(!1), 1 < je.length && (je = [["sequenceExpr", ["pathExpr", ["stepExpr", ...je]]]]), je = [[
            "dynamicFunctionInvocationExpr",
            ["functionItem", ...je],
            ...lo[1].length ? [["arguments", ...lo[1]]] : []
          ]];
          break;
        default:
          throw Error("unreachable");
      }
      return Ee(!0), je;
    }), As = (0, w.or)([(0, w.map)(p2, (E) => ["stepExpr", ...E]), vD]), h2 = (0, w.followed)(bb, (0, w.peek)((0, w.not)((0, w.preceded)($, (0, w.or)([R, Hc, vb])), ["primary expression not followed by predicate, argumentList, or lookup"]))), f2 = (0, w.or)([
      bt(As, (0, w.preceded)($, $p), (0, w.preceded)($, b), (E, D, J) => ["pathExpr", E, D, ...J]),
      (0, w.then)(As, (0, w.preceded)(ye(Mc, $), b), (E, D) => ["pathExpr", E, ...D]),
      h2,
      (0, w.map)(As, (E) => ["pathExpr", E])
    ]), oh = (0, w.or)([bt(As, (0, w.preceded)($, $p), (0, w.preceded)($, b), (E, D, J) => [E, D, ...J]), (0, w.then)(As, (0, w.preceded)(ye(Mc, $), b), (E, D) => [E, ...D]), (0, w.map)(As, (E) => [E])]), m2 = (0, w.or)([(0, w.map)(V([Mc, $], oh), (E) => ["pathExpr", ["rootExpr"], ...E]), (0, w.then)($p, (0, w.preceded)($, oh), (E, D) => ["pathExpr", ["rootExpr"], E, ...D]), (0, w.map)(
      (0, w.followed)(Mc, (0, w.not)((0, w.preceded)($, i.Za ? vt(/[*<a-zA-Z]/) : vt(/[*a-zA-Z]/)), ["Single rootExpr cannot be by followed by something that can be interpreted as a relative path"])),
      () => ["pathExpr", ["rootExpr"]]
    )]), g2 = bp((0, w.or)([f2, m2]), Rw), y2 = (0, w.preceded)(tI, (0, w.then)((0, w.optional)((0, w.or)([(0, w.map)((0, w.preceded)($, XM), (E) => ["validationMode", E]), (0, w.map)(V([$, nI, $], qe), (E) => ["type", ...E])])), (0, w.delimited)((0, w.preceded)($, hi), ye(C, $), fi), (E, D) => ["validateExpr", ...E ? [E] : [], ["argExpr", D]])), w2 = (0, w.delimited)(zN, (0, w.then)((0, w.preceded)($, qe), (0, w.optional)((0, w.preceded)(W, JM)), (E, D) => D ? ["pragma", ["pragmaName", E], ["pragmaContents", D]] : ["pragma", ["pragmaName", E]]), (0, w.preceded)(
      $,
      z0
    )), b2 = (0, w.map)((0, w.followed)((0, w.plus)(w2), (0, w.preceded)($, (0, w.delimited)(hi, ye((0, w.optional)(C), $), fi))), (E) => ["extensionExpr", ...E]), v2 = h(c(g2, lB, (E, D) => D.length === 0 ? E : ["simpleMapExpr", E[0] === "pathExpr" ? E : ["pathExpr", ["stepExpr", ["filterExpr", jp(E)]]]].concat(D.map((J) => (J = J[1], J[0] === "pathExpr" ? J : ["pathExpr", ["stepExpr", ["filterExpr", jp(J)]]]))))), x2 = (0, w.or)([y2, b2, v2]), xb = (0, w.or)([(0, w.then)((0, w.or)([Pe([ps], "unaryMinusOp"), Pe([Ic], "unaryPlusOp")]), (0, w.preceded)($, function(E, D) {
      return xb(
        E,
        D
      );
    }), (E, D) => [E, ["operand", D]]), x2]), k2 = (0, w.or)([(0, w.map)(qe, (E) => ["EQName", ...E]), Mp, nh]), A2 = (0, w.then)(xb, (0, w.star)(V([$, yB, $], (0, w.then)(k2, (0, w.preceded)($, Hc), (E, D) => [E, D]))), (E, D) => D.reduce((J, Ee) => ["arrowExpr", ["argExpr", J], Ee[0], ["arguments", ...Ee[1]]], E)), C2 = (0, w.then)(A2, (0, w.optional)(V([$, xB, W, qn, Nt, $], Ow)), (E, D) => D !== null ? ["castExpr", ["argExpr", E], D] : E), S2 = (0, w.then)(C2, (0, w.optional)(V([$, kB, W, qn, Nt, $], Ow)), (E, D) => D !== null ? ["castableExpr", ["argExpr", E], D] : E), E2 = (0, w.then)(S2, (0, w.optional)(V([
      $,
      AB,
      W,
      qn,
      Nt,
      $
    ], br)), (E, D) => D !== null ? ["treatExpr", ["argExpr", E], ["sequenceType", ...D]] : E), T2 = (0, w.then)(E2, (0, w.optional)(V([$, CB, W, Q0, Nt, $], br)), (E, D) => D !== null ? ["instanceOfExpr", ["argExpr", E], ["sequenceType", ...D]] : E), N2 = c(T2, (0, w.followed)((0, w.or)([Pe([TB], "intersectOp"), Pe([NB], "exceptOp")]), Nt), s), B2 = c(N2, (0, w.or)([Pe([W0], "unionOp"), (0, w.followed)(Pe([BB], "unionOp"), Nt)]), s), I2 = c(B2, (0, w.or)([Pe([gr], "multiplyOp"), (0, w.followed)(Pe([RB], "divOp"), Nt), (0, w.followed)(Pe([FB], "idivOp"), Nt), (0, w.followed)(Pe(
      [PB],
      "modOp"
    ), Nt)]), s), M2 = c(I2, (0, w.or)([Pe([ps], "subtractOp"), Pe([Ic], "addOp")]), s), O2 = u(M2, (0, w.followed)(Pe([IB], "rangeSequenceExpr"), Nt), "startExpr", "endExpr"), D2 = c(O2, Pe([cB], "stringConcatenateOp"), s), R2 = u(D2, (0, w.or)([KM, WM, YM])), F2 = c(R2, (0, w.followed)(Pe([DB], "andOp"), Nt), s), P2 = c(F2, (0, w.followed)(Pe([OB], "orOp"), Nt), s), $2 = h((0, w.map)(C, (E) => ["ifClause", E])), j2 = h((0, w.map)(x, (E) => ["thenClause", E])), U2 = h((0, w.map)(x, (E) => ["elseClause", E])), L2 = (0, w.then)((0, w.then)(V([rw, $, lt, $], $2), V(
      [$, nt, $, zB, Nt, $],
      j2
    ), (E, D) => [E, D]), V([$, qB, Nt, $], U2), (E, D) => ["ifThenElseExpr", E[0], E[1], D]), H2 = (0, w.delimited)(VB, W, kp), G2 = (0, w.map)(V([Ap, W, yr], qe), (E) => ["positionalVariableBinding", ...E]), _2 = _N((0, w.preceded)(yr, (0, w.cut)(qe)), (0, w.cut)((0, w.preceded)($, (0, w.optional)(ks))), (0, w.cut)((0, w.preceded)($, (0, w.optional)(H2))), (0, w.cut)((0, w.preceded)($, (0, w.optional)(G2))), (0, w.cut)((0, w.preceded)(ye(iw, $), x)), (E, D, J, Ee, je) => ["forClauseItem", ["typedVariableBinding", ["varName", ...E, ...D ? [D] : []]], ...J ? [["allowingEmpty"]] : [], ...Ee ? [Ee] : [], ["forExpr", je]]), z2 = V([XB, W], c(_2, Tt, (E, D) => ["forClause", E, ...D.map((J) => J[1])])), q2 = bt((0, w.preceded)(yr, qe), (0, w.preceded)($, (0, w.optional)(ks)), (0, w.preceded)(ye(Zi, $), x), (E, D, J) => ["letClauseItem", ["typedVariableBinding", ["varName", ...E], ...D ? [D] : []], ["letExpr", J]]), V2 = (0, w.map)(V([JB, $], c(q2, Tt, (E, D) => [E, ...D.map((J) => J[1])])), (E) => ["letClause", ...E]), kb = (0, w.or)([z2, V2]), X2 = (0, w.map)(V([KB, Nt, $], x), (E) => ["whereClause", E]), J2 = (0, w.map)((0, w.preceded)(yr, qe), (E) => ["varName", ...E]), K2 = (0, w.then)((0, w.preceded)($, (0, w.optional)(ks)), (0, w.preceded)(ye(Zi, $), x), (E, D) => ["groupVarInitialize", ...E ? [["typeDeclaration", ...E]] : [], ["varValue", D]]), W2 = bt(J2, (0, w.optional)(K2), (0, w.optional)((0, w.map)((0, w.preceded)(ye(Cp, $), P), (E) => ["collation", E])), (E, D, J) => ["groupingSpec", E, ...D ? [D] : [], ...J ? [J] : []]), Y2 = c(W2, Tt, (E, D) => [E, ...D.map((J) => J[1])]), Q2 = (0, w.map)(V([WB, W, Sp, $], Y2), (E) => ["groupByClause", ...E]), Z2 = bt((0, w.optional)((0, w.or)([$I, jI])), (0, w.optional)(V([$, kp, $], (0, w.or)([cw, uw].map((E) => (0, w.map)(E, (D) => "empty " + D))))), (0, w.preceded)($, (0, w.optional)(V([Cp, $], P))), (E, D, J) => E || D || J ? ["orderModifier", ...E ? [["orderingKind", E]] : [], ...D ? [["emptyOrderingMode", D]] : [], ...J ? [["collation", J]] : []] : null), eR = (0, w.then)(x, (0, w.preceded)($, Z2), (E, D) => ["orderBySpec", ["orderByExpr", E], ...D ? [D] : []]), tR = c(eR, Tt, (E, D) => [E, ...D.map((J) => J[1])]), nR = (0, w.then)((0, w.or)([(0, w.map)(V([Ep, W], Sp), () => !1), (0, w.map)(V([YB, W, Ep, W], Sp), () => !0)]), (0, w.preceded)($, tR), (E, D) => ["orderByClause", ...E ? [["stable"]] : [], ...D]), rR = (0, w.or)([kb, X2, Q2, nR]), iR = (0, w.map)(V([fs, $], x), (E) => ["returnClause", E]), oR = bt(kb, (0, w.cut)((0, w.star)((0, w.preceded)($, rR))), (0, w.cut)((0, w.preceded)($, iR)), (E, D, J) => ["flworExpr", E, ...D, J]), sR = c(br, W0, (E, D) => D.length === 0 ? ["sequenceType", ...E] : ["sequenceTypeUnion", ["sequenceType", ...E], ...D.map((J) => ["sequenceType", ...J[1]])]), aR = bt(V([pw, $], (0, w.optional)((0, w.preceded)(yr, (0, w.followed)((0, w.followed)(qe, W), qn)))), (0, w.preceded)($, sR), V([W, fs, W], x), (E, D, J) => ["typeswitchExprCaseClause"].concat(E ? [["variableBinding", ...E]] : [], [D], [["resultExpr", J]])), lR = vp((0, w.preceded)(hw, ye((0, w.delimited)(lt, ye(C, $), nt), $)), (0, w.plus)((0, w.followed)(aR, $)), V([ro, W], (0, w.optional)((0, w.preceded)(yr, (0, w.followed)(qe, W)))), V([fs, W], x), (E, D, J, Ee) => ["typeswitchExpr", ["argExpr", E], ...D, ["typeswitchExprDefaultClause", ...J || [], ["resultExpr", Ee]]]), cR = bt((0, w.preceded)(yr, qe), (0, w.optional)((0, w.preceded)(W, ks)), (0, w.preceded)(ye(iw, W), x), (E, D, J) => ["quantifiedExprInClause", [
      "typedVariableBinding",
      ["varName", ...E],
      ...D ? [D] : []
    ], ["sourceExpr", J]]), uR = c(cR, Tt, (E, D) => [E, ...D.map((J) => J[1])]), dR = bt((0, w.or)([lI, cI]), (0, w.preceded)(W, uR), (0, w.preceded)(ye(uI, $), x), (E, D, J) => ["quantifiedExpr", ["quantifier", E], ...D, ["predicateExpr", J]]), pR = (0, w.map)(V([SB, W, (0, w.or)([Z0, $a]), W], x), (E) => ["deleteExpr", ["targetExpr", E]]), hR = bt(V([dI, W], (0, w.optional)(V([EB, W, Q0], W))), V([$a, W], x), (0, w.preceded)(ye(pI, W), x), (E, D, J) => E ? ["replaceExpr", ["replaceValue"], ["targetExpr", D], ["replacementExpr", J]] : ["replaceExpr", ["targetExpr", D], [
      "replacementExpr",
      J
    ]]), fR = (0, w.then)(Mp, (0, w.preceded)(ye(Zi, $), x), (E, D) => ["transformCopy", E, ["copySource", D]]), mR = bt(V([hI, W], c(fR, Tt, (E, D) => [E, ...D.map((J) => J[1])])), V([$, fI, W], x), (0, w.preceded)(ye(fs, W), x), (E, D, J) => ["transformExpr", ["transformCopies", ...E], ["modifyExpr", D], ["returnExpr", J]]), gR = (0, w.or)([
      (0, w.followed)((0, w.map)((0, w.optional)((0, w.followed)(V([qn, W], (0, w.or)([(0, w.map)(mI, () => ["insertAsFirst"]), (0, w.map)(gI, () => ["insertAsLast"])])), W)), (E) => E ? ["insertInto", E] : ["insertInto"]), bI),
      (0, w.map)(wI, () => ["insertAfter"]),
      (0, w.map)(yI, () => ["insertBefore"])
    ]), yR = bt(V([vI, W, (0, w.or)([Z0, $a]), W], x), (0, w.preceded)(W, gR), (0, w.preceded)(W, x), (E, D, J) => ["insertExpr", ["sourceExpr", E], D, ["targetExpr", J]]), wR = (0, w.then)(V([xI, W, $a, $], x), V([W, qn, W], x), (E, D) => ["renameExpr", ["targetExpr", E], ["newNameExpr", D]]), bR = (0, w.then)((0, w.plus)((0, w.then)((0, w.map)(V([pw, W], (0, w.cut)(x)), (E) => ["switchCaseExpr", E]), (0, w.cut)(W), (E) => E)), (0, w.cut)(V([fs, W], (0, w.cut)(x))), (E, D) => ["switchExprCaseClause", ...E, ["resultExpr", D]]), vR = bt(V(
      [fw, $, lt],
      (0, w.cut)(C)
    ), (0, w.cut)(V([$, nt, (0, w.cut)($)], (0, w.plus)((0, w.followed)(bR, $)))), (0, w.cut)(V([ro, W, fs, W], x)), (E, D, J) => ["switchExpr", ["argExpr", E], ...D, ["switchExprDefaultClause", ["resultExpr", J]]]), xR = (0, w.map)(C, (E) => ["queryBody", E]), kR = V([xn, W, no, W], (0, w.cut)((0, w.then)(en, (0, w.preceded)(ye(mi, $), P), (E, D) => ["namespaceDecl", ["prefix", E], ["uri", D]]))), AR = (0, w.then)(V([kI, W, yr, $], (0, w.then)(qe, (0, w.optional)((0, w.preceded)($, ks)), (E, D) => [E, D])), (0, w.cut)((0, w.or)([(0, w.map)(V([$, Zi, $], x), (E) => [
      "varValue",
      E
    ]), (0, w.map)(V([W, Np], (0, w.optional)(V([$, Zi, $], x))), (E) => ["external", ...E ? [["varValue", E]] : []])])), ([E, D], J) => ["varDecl", ["varName", ...E], ...D !== null ? [D] : [], J]), CR = vp(
      V([hs, W, (0, w.cut)((0, w.peek)((0, w.not)((0, w.followed)(Nw, (0, w.not)(Fa, [""])), ["Cannot use reserved function name"])))], qe),
      (0, w.cut)(V([$, lt, $], (0, w.optional)(mb))),
      (0, w.cut)(V([$, nt], (0, w.optional)(V([W, qn, W], br)))),
      (0, w.cut)((0, w.preceded)($, (0, w.or)([(0, w.map)(hb, (E) => ["functionBody", E]), (0, w.map)(Np, () => ["externalDefinition"])]))),
      (E, D, J, Ee) => ["functionDecl", ["functionName", ...E], ["paramList", ...D || []], ...J ? [["typeDeclaration", ...J]] : [], Ee]
    ), SR = V([xn, W], (0, w.then)((0, w.star)((0, w.followed)((0, w.or)([rh, QM]), W)), (0, w.or)([AR, CR]), (E, D) => [D[0], ...E, ...D.slice(1)])), ER = (0, w.then)(V([xn, W, ro, W], (0, w.or)([to, hs])), V([W, no, W], P), (E, D) => ["defaultNamespaceDecl", ["defaultNamespaceCategory", E], ["uri", D]]), TR = (0, w.or)([(0, w.map)((0, w.followed)(V([no, W], en), (0, w.preceded)($, mi)), (E) => ["namespacePrefix", E]), (0, w.map)(
      V([ro, W, to, W], no),
      () => ["defaultElementNamespace"]
    )]), NR = V([mw, W, CI], bt((0, w.optional)((0, w.preceded)(W, TR)), (0, w.preceded)($, P), (0, w.optional)((0, w.then)(V([W, Ap, W], P), (0, w.star)(V([$, Tt, $], P)), (E, D) => [E, ...D])), (E, D, J) => ["schemaImport", ...E ? [E] : [], ["targetNamespace", D], ...J ? [J] : []])), BR = V([mw, W, gw], bt((0, w.optional)((0, w.followed)(V([W, no, W], en), (0, w.preceded)($, mi))), (0, w.preceded)($, P), (0, w.optional)((0, w.then)(V([W, Ap, W], P), (0, w.star)(V([$, Tt, $], P)), (E, D) => [E, ...D])), (E, D) => ["moduleImport", [
      "namespacePrefix",
      E
    ], ["targetNamespace", D]])), IR = (0, w.or)([NR, BR]), MR = (0, w.map)(V([xn, W, ro, W, Cp, W], P), (E) => ["defaultCollationDecl", E]), OR = (0, w.map)(V([xn, W, SI, W], P), (E) => ["baseUriDecl", E]), DR = (0, w.then)(V([xn, W], (0, w.or)([(0, w.map)(V([dw, W], qe), (E) => ["decimalFormatName", ...E]), (0, w.map)(V([ro, W], dw), () => null)])), (0, w.star)((0, w.then)((0, w.preceded)(W, tO), (0, w.preceded)(ye(mi, W), P), (E, D) => ["decimalFormatParam", ["decimalFormatParamName", E], ["decimalFormatParamValue", D]])), (E, D) => ["decimalFormatDecl", ...E ? [E] : [], ...D]), RR = (0, w.or)([nO, MR, OR, rO, iO, oO, sO, DR]), FR = (0, w.then)(V([xn, W, II, W], qe), (0, w.preceded)(W, P), (E, D) => ["optionDecl", ["optionName", E], ["optionContents", D]]), PR = (0, w.then)(V([xn, W, MI, W, yw], (0, w.optional)(V([W, qn], fb))), (0, w.or)([(0, w.map)((0, w.preceded)(ye(Zi, $), x), (E) => ["varValue", E]), (0, w.map)(V([W, Np], (0, w.optional)((0, w.preceded)(ye(Zi, $), x))), () => ["external"])]), (E, D) => ["contextItemDecl", ...E ? [["contextItemType", E]] : [], D]), Ab = (0, w.then)(
      (0, w.star)((0, w.followed)((0, w.or)([ER, RR, kR, IR]), (0, w.cut)(ye(eo, $)))),
      (0, w.star)((0, w.followed)((0, w.or)([PR, SR, FR]), (0, w.cut)(ye(eo, $)))),
      (E, D) => E.length === 0 && D.length === 0 ? null : ["prolog", ...E, ...D]
    ), $R = V([gw, W, no, W], (0, w.then)((0, w.followed)(en, ye(mi, $)), (0, w.followed)(P, ye(eo, $)), (E, D) => ["moduleDecl", ["prefix", E], ["uri", D]])), jR = (0, w.then)($R, (0, w.preceded)($, Ab), (E, D) => ["libraryModule", E, ...D ? [D] : []]), UR = (0, w.then)(Ab, (0, w.preceded)($, xR), (E, D) => ["mainModule", ...E ? [E] : [], D]), LR = (0, w.map)(V([OI, $], (0, w.followed)((0, w.or)([(0, w.then)((0, w.preceded)(ww, W), P, (E) => [
      "encoding",
      E
    ]), (0, w.then)(V([DI, W], P), (0, w.optional)(V([W, ww, W], P)), (E, D) => [["version", E], ...D ? [["encoding", D]] : []])]), (0, w.preceded)($, eo))), (E) => ["versionDecl", ...E]), HR = (0, w.then)((0, w.optional)(ye(LR, $)), (0, w.or)([jR, UR]), (E, D) => ["module", ...E ? [E] : [], D]), GR = (0, w.complete)(ye(HR, $));
    return (E, D) => {
      T.clear(), D = GR(E, D);
      let J = 1, Ee = 1;
      for (let je = 0; je < E.length + 1; je++) {
        if (T.has(je)) {
          const rn = T.get(je);
          rn.line = Ee, rn.ha = J;
        }
        E[je] === `
` ? (Ee++, J = 1) : J++;
      }
      return D;
    };
  }
  const aO = $c({ mb: !1, Za: !1 }), lO = $c({ mb: !0, Za: !1 }), cO = $c({ mb: !1, Za: !0 }), uO = $c({ mb: !0, Za: !0 });
  function Ua(i, s) {
    var c = !!s.Z;
    if (s = !!s.debug, kw.clear(), Aw.clear(), Rw.clear(), c = c ? s ? uO(i, 0) : cO(i, 0) : s ? lO(i, 0) : aO(i, 0), c.success === !0) return c.value;
    throw i = i.substring(0, c.offset).split(`
`), s = i[i.length - 1].length + 1, new vc({ start: { offset: c.offset, line: i.length, ha: s }, end: { offset: c.offset + 1, line: i.length, ha: s + 1 } }, "", "", Error(`XPST0003: Failed to parse script. Expected ${[...new Set(c.expected)]}`));
  }
  const Fw = "http://www.w3.org/XML/1998/namespace http://www.w3.org/2001/XMLSchema http://www.w3.org/2001/XMLSchema-instance http://www.w3.org/2005/xpath-functions http://www.w3.org/2005/xpath-functions/math http://www.w3.org/2012/xquery http://www.w3.org/2005/xpath-functions/array http://www.w3.org/2005/xpath-functions/map".split(" ");
  function dO(i, s, c, u, h) {
    var g = F(i, "functionName"), b = le(g, "prefix") || "";
    let x = le(g, "URI");
    const C = Se(g);
    if (x === null && (x = b === "" ? s.v === null ? "http://www.w3.org/2005/xpath-functions" : s.v : s.$(b), !x && b)) throw Uy(b);
    if (Fw.includes(x)) throw Fy();
    if (b = ae(i, "annotation").map((_) => F(_, "annotationName")), g = b.every((_) => !le(_, "URI") && Se(_) !== "private"), b = b.some((_) => !le(_, "URI") && Se(_) === "updating"), !x) throw op();
    const T = mc(i), R = ae(F(i, "paramList"), "param"), P = R.map((_) => F(_, "varName")), q = R.map((_) => mc(_));
    if (i = F(i, "functionBody")) {
      if (s.va(
        x,
        C,
        q.length
      )) throw Py(x, C);
      if (!h) return;
      const _ = gp(i[1], { sa: !1, Z: !0 }), ie = new Ki(s), me = P.map((Ce) => {
        let $e = le(Ce, "URI");
        const nn = le(Ce, "prefix");
        return Ce = Se(Ce), nn && $e === null && ($e = s.$(nn || "")), fr(ie, $e, Ce);
      });
      h = b ? { j: q, arity: P.length, callFunction: (Ce, $e, nn, ...yi) => (Ce = ci(Fr(Ce, -1, null, N.empty()), me.reduce((so, Ha, ao) => (so[Ha] = st(yi[ao]), so), /* @__PURE__ */ Object.create(null))), _.s(Ce, $e)), wb: !1, I: !0, cb: g, localName: C, namespaceURI: x, i: T } : { j: q, arity: P.length, callFunction: (Ce, $e, nn, ...yi) => (Ce = ci(Fr(Ce, -1, null, N.empty()), me.reduce((so, Ha, ao) => (so[Ha] = st(yi[ao]), so), /* @__PURE__ */ Object.create(null))), he(_, Ce, $e)), wb: !1, I: !1, cb: g, localName: C, namespaceURI: x, i: T }, c.push({ ba: _, Eb: ie }), u.push({ arity: P.length, ba: _, Ab: h, localName: C, namespaceURI: x, cb: g });
    } else {
      if (b) throw Error("Updating external function declarations are not supported");
      h = { j: q, arity: P.length, callFunction: (_, ie, me, ...Ce) => {
        const $e = me.va(x, C, P.length, !0);
        if (!$e) throw Error(`XPST0017: Function Q{${x}}${C} with arity of ${P.length} not registered. ${rp(C)}`);
        if ($e.i.type !== T.type || $e.j.some((nn, yi) => nn.type !== q[yi].type)) throw Error("External function declaration types do not match actual function");
        return $e.callFunction(_, ie, me, ...Ce);
      }, wb: !0, I: !1, localName: C, namespaceURI: x, cb: g, i: T };
    }
    ap(s, x, C, P.length, h);
  }
  function Up(i, s, c, u) {
    const h = [], g = [];
    ae(i, "*").forEach((R) => {
      switch (R[0]) {
        case "moduleImport":
        case "namespaceDecl":
        case "defaultNamespaceDecl":
        case "functionDecl":
        case "varDecl":
          break;
        default:
          throw Error("Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules");
      }
    });
    const b = /* @__PURE__ */ new Set();
    ae(i, "moduleImport").forEach((R) => {
      const P = Se(F(R, "namespacePrefix"));
      if (R = Se(F(R, "targetNamespace")), b.has(R)) throw Error(`XQST0047: The namespace "${R}" is imported more than once.`);
      b.add(R), Ji(s, P, R);
    }), ae(i, "namespaceDecl").forEach((R) => {
      const P = Se(F(R, "prefix"));
      if (R = Se(F(R, "uri")), P === "xml" || P === "xmlns" || R === "http://www.w3.org/XML/1998/namespace" || R === "http://www.w3.org/2000/xmlns/") throw sp();
      Ji(s, P, R);
    });
    let x = null, C = null;
    for (const R of ae(i, "defaultNamespaceDecl")) {
      const P = Se(F(R, "defaultNamespaceCategory")), q = Se(F(R, "uri"));
      if (!q) throw op();
      if (q === "http://www.w3.org/XML/1998/namespace" || q === "http://www.w3.org/2000/xmlns/") throw sp();
      if (P === "function") {
        if (x) throw $y();
        x = q;
      } else if (P === "element") {
        if (C) throw $y();
        C = q;
      }
    }
    x && (s.v = x), C && Ji(s, "", C), ae(i, "functionDecl").forEach((R) => {
      dO(R, s, h, g, c);
    });
    const T = [];
    return ae(i, "varDecl").forEach((R) => {
      const P = ze(F(R, "varName"));
      let q = P.namespaceURI;
      if (q === null && (q = s.$(P.prefix), !q && P.prefix)) throw Uy(P.prefix);
      if (Fw.includes(q)) throw Fy();
      var _ = F(R, "external");
      R = F(R, "varValue");
      let ie, me;
      if (_ !== null ? (_ = F(_, "varValue"), _ !== null && (ie = F(_, "*"))) : R !== null && (ie = F(R, "*")), T.some((Ce) => Ce.namespaceURI === q && Ce.localName === P.localName)) throw Error(`XQST0049: The variable ${q ? `Q{${q}}` : ""}${P.localName} has already been declared.`);
      if (fr(s, q || "", P.localName), c && (ie && (me = gp(ie, { sa: !1, Z: !0 })), ie && !jE(s, q || "", P.localName))) {
        let Ce = null;
        Hy(s, q, P.localName, ($e, nn) => (Ce || (Ce = st(he(me, $e, nn))), Ce())), h.push({ ba: me, Eb: new Ki(s) }), T.push({ ba: me, localName: P.localName, namespaceURI: q });
      }
    }), g.forEach((R) => {
      if (!R.Ab.I && R.ba.I) throw jr(`The function Q{${R.namespaceURI}}${R.localName} is updating but the %updating annotation is missing.`);
    }), {
      Ia: g.map((R) => R.Ab),
      Ta: T,
      source: u,
      pa: (R) => {
        b.forEach((P) => {
          yp(s, P);
        }), h.forEach(({ ba: P, Eb: q }) => {
          b.forEach((_) => {
            yp(q, _);
          }), R.Ia.forEach((_) => {
            q.va(_.namespaceURI, _.localName, _.arity, !0) || _.cb && ap(q, _.namespaceURI, _.localName, _.arity, _);
          }), R.Ta.forEach((_) => {
            q.eb(_.namespaceURI, _.localName) || fr(q, _.namespaceURI, _.localName);
          }), P.v(q);
        });
      }
    };
  }
  function pO(i, s, c, u, h, g, b) {
    const x = s.Z ? "XQuery" : "XPath";
    return c = s.Ha ? null : GN(i, x, c, u, h, s.debug, g, b), c !== null ? { state: c.hc ? 1 : 2, ba: c.ba } : { state: 0, Zb: typeof i == "string" ? Ua(i, s) : Tc(i) };
  }
  function hO(i, s, c, u) {
    const h = F(i, "mainModule");
    if (!h) throw Error("Can not execute a library module.");
    const g = F(h, "prolog");
    if (g) {
      if (!s.Z) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
      Ra(), u = Up(g, c, !0, u), u.pa(u);
    }
    return ke(i, new bc(c)), i = oe(h, ["queryBody", "*"]), re(i, s);
  }
  function Pw(i, s, c, u, h, g, b) {
    const x = new hc(c, u, g, b), C = new Ki(x);
    switch (0 < Object.keys(h).length && Ra(), Object.keys(h).forEach((T) => {
      const R = h[T];
      yp(C, R), Ji(C, T, R);
    }), typeof i == "string" && (i = wp(i)), c = pO(i, s, c, u, h, g, b), c.state) {
      case 2:
        return { ga: C, ba: c.ba };
      case 1:
        return c.ba.v(C), U0(i, s.Z ? "XQuery" : "XPath", x, h, c.ba, s.debug, g), { ga: C, ba: c.ba };
      case 0:
        return c = hO(c.Zb, s, C, i), c.v(C), s.Ha || U0(i, s.Z ? "XQuery" : "XPath", x, h, c, s.debug, g), { ga: C, ba: c };
    }
  }
  function fO(i) {
    if (I(i.type, 1)) return i.value;
    if (I(i.type, 54)) return i.value.node;
    throw Nn(`Unable to convert selector argument of type ${se[i.type]} to either an ${se[1]} or an ${se[54]} representing an XQueryX program while calling 'fontoxpath:evaluate'`);
  }
  function mO(i, s, c, u) {
    i = i.first();
    const h = s.first().h.reduce((g, b) => (g[b.key.value] = st(b.value()), g), /* @__PURE__ */ Object.create(null));
    s = h["."] ? h["."]() : N.empty(), delete h["."], i = fO(i);
    try {
      const { ba: g, ga: b } = Pw(i, { sa: !1, Z: !0, debug: u.debug, Ha: u.Ha }, (T) => c.$(T), Object.keys(h).reduce((T, R) => (T[R] = R, T), {}), {}, "http://www.w3.org/2005/xpath-functions", (T, R) => c.Sa(T, R)), x = !s.F(), C = new Vo({ M: x ? s.first() : null, Aa: x ? 0 : -1, ta: s, ra: Object.keys(h).reduce((T, R) => (T[b.eb(null, R)] = h[R], T), /* @__PURE__ */ Object.create(null)) });
      return { ic: g.h(C, u).value, ac: i };
    } catch (g) {
      dn(i, g);
    }
  }
  function Lp(i, s, c) {
    if (s.node.nodeType !== 1 && s.node.nodeType !== 9) return [];
    const u = sr(i, s).reduce((h, g) => {
      for (const b of Lp(i, g, c)) h.push(b);
      return h;
    }, []);
    return c(s) && u.unshift(s), u;
  }
  const $w = (i, s, c, u, h) => {
    if (i = h.first(), !i) throw _n("The context is absent, it needs to be present to use id function.");
    if (!I(i.type, 53)) throw Nn("The context item is not a node, it needs to be node to use id function.");
    const g = s.h, b = u.O().reduce((x, C) => (C.value.split(/\s+/).forEach((T) => {
      x[T] = !0;
    }), x), /* @__PURE__ */ Object.create(null));
    for (s = i.value; s.node.nodeType !== 9; ) if (s = Ie(g, s), s === null) throw Error("FODC0001: the root node of the target node is not a document node.");
    return s = Lp(g, s, (x) => x.node.nodeType !== 1 || (x = Bd(g, x, "id"), !x || !b[x]) ? !1 : (b[x] = !1, !0)), N.create(s.map((x) => _e(x)));
  }, jw = (i, s, c, u, h) => {
    if (i = h.first(), !i) throw _n("The context is absent, it needs to be present to use idref function.");
    if (!I(i.type, 53)) throw Nn("The context item is not a node, it needs to be node to use idref function.");
    const g = s.h, b = u.O().reduce((x, C) => (x[C.value] = !0, x), /* @__PURE__ */ Object.create(null));
    for (s = i.value; s.node.nodeType !== 9; ) if (s = Ie(g, s), s === null) throw Error("FODC0001: the root node of the context node is not a document node.");
    return s = Lp(g, s, (x) => x.node.nodeType !== 1 ? !1 : (x = Bd(g, x, "idref")) ? x.split(/\s+/).some((C) => b[C]) : !1), N.create(s.map((x) => _e(x)));
  };
  function Hp(i) {
    switch (typeof i) {
      case "object":
        return Array.isArray(i) ? N.m(new qt(i.map((s) => st(Hp(s))))) : i === null ? N.empty() : N.m(new Dr(Object.keys(i).map((s) => ({ key: M(s, 1), value: st(Hp(i[s])) }))));
      case "number":
        return N.m(M(i, 3));
      case "string":
        return N.m(M(i, 1));
      case "boolean":
        return i ? N.aa() : N.T();
      default:
        throw Error("Unexpected type in JSON parse");
    }
  }
  const Uw = (i, s, c, u, h) => {
    const g = N.m(M("duplicates", 1));
    i = Md(i, s, c, h, g);
    const b = i.F() ? "use-first" : i.first().value;
    return u.N((x) => N.m(new Dr(x.reduce((C, T) => (T.h.forEach((R) => {
      const P = C.findIndex((q) => qo(q.key, R.key));
      if (0 <= P) switch (b) {
        case "reject":
          throw Error("FOJS0003: Duplicate encountered when merging maps.");
        case "use-last":
          C.splice(P, 1, R);
          return;
        case "combine":
          C.splice(P, 1, { key: R.key, value: st(N.create(C[P].value().O().concat(R.value().O()))) });
          return;
        default:
          return;
      }
      C.push(R);
    }), C), []))));
  };
  function Gp(i, s, c) {
    let u = 1;
    const h = i.value;
    i = i.Pa(!0);
    let g = null;
    const b = Math.max(s - 1, 0);
    return i !== -1 && (g = Math.max(0, (c === null ? i : Math.max(0, Math.min(i, c + (s - 1)))) - b)), N.create({ next: (x) => {
      for (; u < s; ) h.next(x), u++;
      return c !== null && u >= s + c ? H : (x = h.next(x), u++, x);
    } }, g);
  }
  function _p(i) {
    return i.map((s) => I(s.type, 19) ? He(s, 3) : s);
  }
  function Lw(i) {
    if (i = _p(i), i.some((s) => Number.isNaN(s.value))) return [M(NaN, 3)];
    if (i = kc(i), !i) throw Error("FORG0006: Incompatible types to be converted to a common type");
    return i;
  }
  const Hw = (i, s, c, u, h, g) => Oe([h, g], ([b, x]) => {
    if (b.value === 1 / 0) return N.empty();
    if (b.value === -1 / 0) return x && x.value === 1 / 0 ? N.empty() : u;
    if (x) {
      if (isNaN(x.value)) return N.empty();
      x.value === 1 / 0 && (x = null);
    }
    return isNaN(b.value) ? N.empty() : Gp(u, Math.round(b.value), x ? Math.round(x.value) : null);
  }), Gw = (i, s, c, u, h) => {
    if (u.F()) return h;
    if (i = _p(u.O()), i = kc(i), !i) throw Error("FORG0006: Incompatible types to be converted to a common type");
    if (!i.every((g) => I(g.type, 2))) throw Error("FORG0006: items passed to fn:sum are not all numeric.");
    return s = i.reduce((g, b) => g + b.value, 0), i.every((g) => I(g.type, 5)) ? N.m(M(s, 5)) : i.every((g) => I(g.type, 3)) ? N.m(M(s, 3)) : i.every((g) => I(g.type, 4)) ? N.m(M(s, 4)) : N.m(M(s, 6));
  };
  var gO = [].concat(BE, [{ namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "boolean", j: [{ type: 59, g: 2 }], i: { type: 0, g: 3 }, callFunction: (i, s, c, u) => u.fa() ? N.aa() : N.T() }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "true", j: [], i: { type: 0, g: 3 }, callFunction: () => N.aa() }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "not", j: [{ type: 59, g: 2 }], i: { type: 0, g: 3 }, callFunction: (i, s, c, u) => u.fa() === !1 ? N.aa() : N.T() }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "false",
    j: [],
    i: { type: 0, g: 3 },
    callFunction: () => N.T()
  }], [{ namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "last", j: [], i: { type: 5, g: 3 }, callFunction: (i) => {
    if (i.M === null) throw _n("The fn:last() function depends on dynamic context, which is absent.");
    let s = !1;
    return N.create({ next: () => {
      if (s) return H;
      const c = i.ta.Pa();
      return s = !0, j(M(c, 5));
    } }, 1);
  } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "position", j: [], i: { type: 5, g: 3 }, callFunction: (i) => {
    if (i.M === null) throw _n("The fn:position() function depends on dynamic context, which is absent.");
    return N.m(M(i.Aa + 1, 5));
  } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "current-dateTime", j: [], i: { type: 10, g: 3 }, callFunction: (i) => N.m(M(Pd(i), 10)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "current-date", j: [], i: { type: 7, g: 3 }, callFunction: (i) => N.m(M(Ln(Pd(i), 7), 7)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "current-time", j: [], i: { type: 8, g: 3 }, callFunction: (i) => N.m(M(Ln(Pd(i), 8), 8)) }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "implicit-timezone",
    j: [],
    i: { type: 17, g: 3 },
    callFunction: (i) => N.m(M(Hn(i), 17))
  }], IE, ME, RE, [{ namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "years-from-duration", j: [{ type: 18, g: 0 }], i: { type: 5, g: 0 }, callFunction: (i, s, c, u) => u.F() ? u : N.m(M(u.first().value.bb(), 5)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "months-from-duration", j: [{ type: 18, g: 0 }], i: { type: 5, g: 0 }, callFunction: (i, s, c, u) => u.F() ? u : N.m(M(u.first().value.ab(), 5)) }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "days-from-duration",
    j: [{ type: 18, g: 0 }],
    i: { type: 5, g: 0 },
    callFunction: (i, s, c, u) => u.F() ? u : N.m(M(u.first().value.$a(), 5))
  }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "hours-from-duration", j: [{ type: 18, g: 0 }], i: { type: 5, g: 0 }, callFunction: (i, s, c, u) => u.F() ? u : N.m(M(u.first().value.getHours(), 5)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "minutes-from-duration", j: [{ type: 18, g: 0 }], i: { type: 5, g: 0 }, callFunction: (i, s, c, u) => u.F() ? u : N.m(M(u.first().value.getMinutes(), 5)) }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "seconds-from-duration",
    j: [{ type: 18, g: 0 }],
    i: { type: 4, g: 0 },
    callFunction: (i, s, c, u) => u.F() ? u : N.m(M(u.first().value.getSeconds(), 4))
  }], FE, [{ namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "id", j: [{ type: 1, g: 2 }, { type: 53, g: 3 }], i: { type: 54, g: 2 }, callFunction: $w }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "id", j: [{ type: 1, g: 2 }], i: { type: 54, g: 2 }, callFunction(i, s, c, u) {
    return $w(i, s, c, u, N.m(i.M));
  } }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    localName: "idref",
    j: [{ type: 1, g: 2 }, { type: 53, g: 3 }],
    i: { type: 53, g: 2 },
    callFunction: jw
  }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "idref", j: [{ type: 1, g: 2 }], i: { type: 53, g: 2 }, callFunction(i, s, c, u) {
    return jw(i, s, c, u, N.m(i.M));
  } }], [{ namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "parse-json", j: [{ type: 1, g: 3 }], i: { type: 59, g: 0 }, callFunction: (i, s, c, u) => {
    let h;
    try {
      h = JSON.parse(u.first().value);
    } catch {
      throw Error("FOJS0001: parsed JSON string contains illegal JSON.");
    }
    return Hp(h);
  } }], [{
    namespaceURI: "http://www.w3.org/2005/xpath-functions/map",
    localName: "contains",
    j: [{ type: 61, g: 3 }, { type: 46, g: 3 }],
    i: { type: 0, g: 3 },
    callFunction: (i, s, c, u, h) => Oe([u, h], ([g, b]) => g.h.some((x) => qo(x.key, b)) ? N.aa() : N.T())
  }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "entry", j: [{ type: 46, g: 3 }, { type: 59, g: 2 }], i: { type: 61, g: 3 }, callFunction: (i, s, c, u, h) => u.map((g) => new Dr([{ key: g, value: st(h) }])) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "for-each", j: [{ type: 61, g: 3 }, { type: 59, g: 2 }], i: { type: 59, g: 2 }, callFunction: (i, s, c, u, h) => Oe([
    u,
    h
  ], ([g, b]) => Gn(g.h.map((x) => b.value.call(void 0, i, s, c, N.m(x.key), x.value())))) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "get", j: [{ type: 61, g: 3 }, { type: 46, g: 3 }], i: { type: 59, g: 2 }, callFunction: Md }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "keys", j: [{ type: 61, g: 3 }], i: { type: 46, g: 2 }, callFunction: (i, s, c, u) => Oe([u], ([h]) => N.create(h.h.map((g) => g.key))) }, {
    namespaceURI: "http://www.w3.org/2005/xpath-functions/map",
    localName: "merge",
    j: [{ type: 61, g: 2 }, { type: 61, g: 3 }],
    i: { type: 61, g: 3 },
    callFunction: Uw
  }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "merge", j: [{ type: 61, g: 2 }], i: { type: 61, g: 3 }, callFunction(i, s, c, u) {
    return Uw(i, s, c, u, N.m(new Dr([{ key: M("duplicates", 1), value: () => N.m(M("use-first", 1)) }])));
  } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "put", j: [{ type: 61, g: 3 }, { type: 46, g: 3 }, { type: 59, g: 2 }], i: { type: 61, g: 3 }, callFunction: (i, s, c, u, h, g) => Oe([u, h], ([b, x]) => {
    b = b.h.concat();
    const C = b.findIndex((T) => qo(T.key, x));
    return 0 <= C ? b.splice(
      C,
      1,
      { key: x, value: st(g) }
    ) : b.push({ key: x, value: st(g) }), N.m(new Dr(b));
  }) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "remove", j: [{ type: 61, g: 3 }, { type: 46, g: 2 }], i: { type: 61, g: 3 }, callFunction: (i, s, c, u, h) => Oe([u], ([g]) => {
    const b = g.h.concat();
    return h.N((x) => (x.forEach((C) => {
      const T = b.findIndex((R) => qo(R.key, C));
      0 <= T && b.splice(T, 1);
    }), N.m(new Dr(b))));
  }) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "size", j: [{ type: 61, g: 3 }], i: { type: 5, g: 3 }, callFunction: (i, s, c, u) => u.map((h) => M(h.h.length, 5)) }], [{ namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "pi", j: [], i: { type: 3, g: 3 }, callFunction: () => N.m(M(Math.PI, 3)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "exp", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: (i, s, c, u) => u.map((h) => M(Math.pow(Math.E, h.value), 3)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "exp10", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: (i, s, c, u) => u.map((h) => M(
    Math.pow(10, h.value),
    3
  )) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "log", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: (i, s, c, u) => u.map((h) => M(Math.log(h.value), 3)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "log10", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: (i, s, c, u) => u.map((h) => M(Math.log10(h.value), 3)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "pow", j: [{ type: 3, g: 0 }, { type: 2, g: 3 }], i: { type: 3, g: 0 }, callFunction: (i, s, c, u, h) => h.N(([g]) => u.map((b) => Math.abs(b.value) !== 1 || Number.isFinite(g.value) ? M(Math.pow(b.value, g.value), 3) : M(1, 3))) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "sqrt", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: (i, s, c, u) => u.map((h) => M(Math.sqrt(h.value), 3)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "sin", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: (i, s, c, u) => u.map((h) => M(Math.sin(h.value), 3)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "cos", j: [{
    type: 3,
    g: 0
  }], i: { type: 3, g: 0 }, callFunction: (i, s, c, u) => u.map((h) => M(Math.cos(h.value), 3)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "tan", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: (i, s, c, u) => u.map((h) => M(Math.tan(h.value), 3)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "asin", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: (i, s, c, u) => u.map((h) => M(Math.asin(h.value), 3)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "acos", j: [{
    type: 3,
    g: 0
  }], i: { type: 3, g: 0 }, callFunction: (i, s, c, u) => u.map((h) => M(Math.acos(h.value), 3)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "atan", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: (i, s, c, u) => u.map((h) => M(Math.atan(h.value), 3)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "atan2", j: [{ type: 3, g: 0 }, { type: 3, g: 3 }], i: { type: 3, g: 0 }, callFunction: (i, s, c, u, h) => h.N(([g]) => u.map((b) => M(Math.atan2(b.value, g.value), 3))) }], dE, lE, [{
    namespaceURI: "http://fontoxpath/operators",
    localName: "to",
    j: [{ type: 5, g: 0 }, { type: 5, g: 0 }],
    i: { type: 5, g: 2 },
    callFunction: (i, s, c, u, h) => {
      if (i = u.first(), h = h.first(), i === null || h === null) return N.empty();
      let g = i.value;
      return h = h.value, g > h ? N.empty() : N.create({ next: () => j(M(g++, 5)) }, h - g + 1);
    }
  }], [{ namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "QName", j: [{ type: 1, g: 0 }, { type: 1, g: 3 }], i: { type: 23, g: 3 }, callFunction: (i, s, c, u, h) => Oe([u, h], ([g, b]) => {
    if (b = b.value, !nc(b, 23)) throw Error("FOCA0002: The provided QName is invalid.");
    if (g = g && g.value || null, g === null && b.includes(":")) throw Error("FOCA0002: The URI of a QName may not be empty if a prefix is provided.");
    if (u.F()) return N.m(M(new _t("", null, b), 23));
    if (!b.includes(":")) return N.m(M(new _t("", g, b), 23));
    const [x, C] = b.split(":");
    return N.m(M(new _t(x, g, C), 23));
  }) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "prefix-from-QName", j: [{ type: 23, g: 0 }], i: { type: 24, g: 0 }, callFunction: (i, s, c, u) => Oe([u], ([h]) => h === null ? N.empty() : (h = h.value, h.prefix ? N.m(M(h.prefix, 24)) : N.empty())) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "local-name-from-QName", j: [{ type: 23, g: 0 }], i: { type: 24, g: 0 }, callFunction: (i, s, c, u) => u.map((h) => M(h.value.localName, 24)) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "namespace-uri-from-QName", j: [{ type: 23, g: 0 }], i: { type: 20, g: 0 }, callFunction: (i, s, c, u) => u.map((h) => M(h.value.namespaceURI || "", 20)) }], [{
    j: [{ type: 59, g: 2 }],
    callFunction: (i, s, c, u) => u.X({ empty: () => N.aa(), multiple: () => N.T(), m: () => N.T() }),
    localName: "empty",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: { type: 0, g: 3 }
  }, { j: [{ type: 59, g: 2 }], callFunction: (i, s, c, u) => u.X({ empty: () => N.T(), multiple: () => N.aa(), m: () => N.aa() }), localName: "exists", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 0, g: 3 } }, { j: [{ type: 59, g: 2 }], callFunction: (i, s, c, u) => Gp(u, 1, 1), localName: "head", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 0 } }, {
    j: [{ type: 59, g: 2 }],
    callFunction: (i, s, c, u) => Gp(u, 2, null),
    localName: "tail",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: { type: 59, g: 2 }
  }, { j: [{ type: 59, g: 2 }, { type: 5, g: 3 }, { type: 59, g: 2 }], callFunction: (i, s, c, u, h, g) => u.F() ? g : g.F() ? u : (i = u.O(), h = h.first().value - 1, 0 > h ? h = 0 : h > i.length && (h = i.length), s = i.slice(h), N.create(i.slice(0, h).concat(g.O(), s))), localName: "insert-before", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 } }, {
    j: [{ type: 59, g: 2 }, { type: 5, g: 3 }],
    callFunction: (i, s, c, u, h) => (i = h.first().value, u = u.O(), !u.length || 1 > i || i > u.length || u.splice(i - 1, 1), N.create(u)),
    localName: "remove",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: { type: 59, g: 2 }
  }, { j: [{ type: 59, g: 2 }], callFunction: (i, s, c, u) => u.N((h) => N.create(h.reverse())), localName: "reverse", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 } }, { j: [{ type: 59, g: 2 }, { type: 3, g: 3 }], callFunction: (i, s, c, u, h) => Hw(i, s, c, u, h, N.empty()), localName: "subsequence", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 } }, {
    j: [{ type: 59, g: 2 }, { type: 3, g: 3 }, { type: 3, g: 3 }],
    callFunction: Hw,
    localName: "subsequence",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: { type: 59, g: 2 }
  }, { j: [{ type: 59, g: 2 }], callFunction: (i, s, c, u) => u, localName: "unordered", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 } }, { j: [{ type: 46, g: 2 }], callFunction: (i, s, c, u) => {
    const h = at(u, s).O();
    return N.create(h).filter((g, b) => h.slice(0, b).every((x) => !Ea(g, x)));
  }, localName: "distinct-values", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 2 } }, { j: [{ type: 46, g: 2 }, { type: 1, g: 3 }], callFunction() {
    throw Error("FOCH0002: No collations are supported");
  }, localName: "distinct-values", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 2 } }, { j: [{ type: 46, g: 2 }, { type: 46, g: 3 }], callFunction: (i, s, c, u, h) => h.N(([g]) => at(u, s).map((b, x) => xc("eqOp", b.type, g.type)(b, g, i) ? M(x + 1, 5) : M(-1, 5)).filter((b) => b.value !== -1)), localName: "index-of", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 5, g: 2 } }, {
    j: [{ type: 46, g: 2 }, { type: 46, g: 3 }, { type: 1, g: 3 }],
    callFunction() {
      throw Error("FOCH0002: No collations are supported");
    },
    localName: "index-of",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: { type: 5, g: 2 }
  }, { j: [{ type: 59, g: 2 }, { type: 59, g: 2 }], callFunction: (i, s, c, u, h) => {
    let g = !1;
    const b = ui(i, s, c, u, h);
    return N.create({ next: () => {
      if (g) return H;
      const x = b.next(0);
      return x.done ? x : (g = !0, j(M(x.value, 0)));
    } });
  }, localName: "deep-equal", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 0, g: 3 } }, {
    j: [{ type: 59, g: 2 }, { type: 59, g: 2 }, { type: 1, g: 3 }],
    callFunction() {
      throw Error("FOCH0002: No collations are supported");
    },
    localName: "deep-equal",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: { type: 0, g: 3 }
  }, { j: [{ type: 59, g: 2 }], callFunction: (i, s, c, u) => {
    let h = !1;
    return N.create({ next: () => {
      if (h) return H;
      const g = u.Pa();
      return h = !0, j(M(g, 5));
    } });
  }, localName: "count", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 5, g: 3 } }, { j: [{ type: 46, g: 2 }], callFunction: (i, s, c, u) => {
    if (u.F()) return u;
    if (i = _p(u.O()), i = kc(i), !i) throw Error("FORG0006: Incompatible types to be converted to a common type");
    if (!i.every((h) => I(h.type, 2))) throw Error("FORG0006: items passed to fn:avg are not all numeric.");
    return s = i.reduce((h, g) => h + g.value, 0) / i.length, i.every((h) => I(h.type, 5) || I(h.type, 3)) ? N.m(M(s, 3)) : i.every((h) => I(h.type, 4)) ? N.m(M(s, 4)) : N.m(M(s, 6));
  }, localName: "avg", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 0 } }, { j: [{ type: 46, g: 2 }], callFunction: (i, s, c, u) => u.F() ? u : (i = Lw(u.O()), N.m(i.reduce((h, g) => h.value < g.value ? g : h))), localName: "max", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 0 } }, { j: [{ type: 46, g: 2 }, { type: 1, g: 3 }], callFunction() {
    throw Error("FOCH0002: No collations are supported");
  }, localName: "max", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 0 } }, { j: [{ type: 46, g: 2 }], callFunction: (i, s, c, u) => u.F() ? u : (i = Lw(u.O()), N.m(i.reduce((h, g) => h.value > g.value ? g : h))), localName: "min", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 0 } }, { j: [{ type: 46, g: 2 }, { type: 1, g: 3 }], callFunction() {
    throw Error("FOCH0002: No collations are supported");
  }, localName: "min", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 0 } }, { j: [{
    type: 46,
    g: 2
  }], callFunction: (i, s, c, u) => Gw(i, s, c, u, N.m(M(0, 5))), localName: "sum", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 3 } }, { j: [{ type: 46, g: 2 }, { type: 46, g: 0 }], callFunction: Gw, localName: "sum", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 0 } }, {
    j: [{ type: 59, g: 2 }],
    callFunction: (i, s, c, u) => {
      if (!u.F() && !u.oa()) throw Error("FORG0003: The argument passed to fn:zero-or-one contained more than one item.");
      return u;
    },
    localName: "zero-or-one",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: { type: 59, g: 0 }
  }, { j: [{ type: 59, g: 2 }], callFunction: (i, s, c, u) => {
    if (u.F()) throw Error("FORG0004: The argument passed to fn:one-or-more was empty.");
    return u;
  }, localName: "one-or-more", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 1 } }, { j: [{ type: 59, g: 2 }], callFunction: (i, s, c, u) => {
    if (!u.oa()) throw Error("FORG0005: The argument passed to fn:exactly-one is empty or contained more than one item.");
    return u;
  }, localName: "exactly-one", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: {
    type: 59,
    g: 3
  } }, {
    j: [{ type: 59, g: 2 }, { type: 60, g: 3 }],
    callFunction: (i, s, c, u, h) => {
      if (u.F()) return u;
      const g = h.first(), b = g.o;
      if (b.length !== 1) throw Error("XPTY0004: signature of function passed to fn:filter is incompatible.");
      return u.filter((x) => {
        if (x = cr(b[0], N.m(x), s, "fn:filter", !1), x = g.value.call(void 0, i, s, c, x), !x.oa() || !I(x.first().type, 0)) throw Error("XPTY0004: signature of function passed to fn:filter is incompatible.");
        return x.first().value;
      });
    },
    localName: "filter",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: { type: 59, g: 2 }
  }, {
    j: [{ type: 59, g: 2 }, { type: 60, g: 3 }],
    callFunction: (i, s, c, u, h) => {
      if (u.F()) return u;
      const g = h.first(), b = g.o;
      if (b.length !== 1) throw Error("XPTY0004: signature of function passed to fn:for-each is incompatible.");
      const x = u.value;
      let C;
      return N.create({ next: (T) => {
        for (; ; ) {
          if (!C) {
            var R = x.next(0);
            if (R.done) return R;
            R = cr(b[0], N.m(R.value), s, "fn:for-each", !1), C = g.value.call(void 0, i, s, c, R).value;
          }
          if (R = C.next(T), !R.done) return R;
          C = null;
        }
      } });
    },
    localName: "for-each",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: { type: 59, g: 2 }
  }, { j: [{ type: 59, g: 2 }, { type: 59, g: 2 }, { type: 60, g: 3 }], callFunction: (i, s, c, u, h, g) => {
    if (u.F()) return u;
    const b = g.first(), x = b.o;
    if (x.length !== 2) throw Error("XPTY0004: signature of function passed to fn:fold-left is incompatible.");
    return u.N((C) => C.reduce((T, R) => (T = cr(x[0], T, s, "fn:fold-left", !1), R = cr(x[1], N.m(R), s, "fn:fold-left", !1), b.value.call(void 0, i, s, c, T, R)), h));
  }, localName: "fold-left", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 } }, { j: [{ type: 59, g: 2 }, {
    type: 59,
    g: 2
  }, { type: 60, g: 3 }], callFunction: (i, s, c, u, h, g) => {
    if (u.F()) return u;
    const b = g.first(), x = b.o;
    if (x.length !== 2) throw Error("XPTY0004: signature of function passed to fn:fold-right is incompatible.");
    return u.N((C) => C.reduceRight((T, R) => (T = cr(x[0], T, s, "fn:fold-right", !1), R = cr(x[1], N.m(R), s, "fn:fold-right", !1), b.value.call(void 0, i, s, c, R, T)), h));
  }, localName: "fold-right", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 } }, { j: [{ type: 59, g: 2 }], callFunction: (i, s, c, u) => {
    if (!s.Ua) throw Error("serialize() called but no xmlSerializer set in execution parameters.");
    if (i = u.O(), !i.every((h) => I(h.type, 53))) throw Error("Expected argument to fn:serialize to resolve to a sequence of Nodes.");
    return N.m(M(i.map((h) => s.Ua.serializeToString(Pt(h.value, s, !1))).join(""), 1));
  }, localName: "serialize", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 } }], cE, [{
    j: [{ type: 59, g: 3 }, { type: 61, g: 3 }],
    callFunction: (i, s, c, u, h) => {
      let g, b;
      return N.create({ next: () => {
        g || ({ ic: g, ac: b } = mO(u, h, c, s));
        try {
          return g.next(0);
        } catch (x) {
          dn(b, x);
        }
      } });
    },
    localName: "evaluate",
    namespaceURI: "http://fontoxml.com/fontoxpath",
    i: { type: 59, g: 2 }
  }, { j: [], callFunction: () => N.m(M(t, 1)), localName: "version", namespaceURI: "http://fontoxml.com/fontoxpath", i: { type: 1, g: 3 } }], [{
    j: [{ type: 23, g: 3 }, { type: 5, g: 3 }],
    callFunction: (i, s, c, u, h) => Oe([u, h], ([g, b]) => {
      const x = c.va(g.value.namespaceURI, g.value.localName, b.value);
      return x === null ? N.empty() : (g = new oi({ j: x.j, arity: b.value, localName: g.value.localName, namespaceURI: g.value.namespaceURI, i: x.i, value: x.callFunction }), N.m(g));
    }),
    localName: "function-lookup",
    namespaceURI: "http://www.w3.org/2005/xpath-functions",
    i: { g: 0, type: 60 }
  }, { j: [{ type: 60, g: 3 }], callFunction: (i, s, c, u) => Oe([u], ([h]) => h.Ya() ? N.empty() : N.m(M(new _t("", h.l, h.D), 23))), localName: "function-name", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 23, g: 0 } }, { j: [{ type: 60, g: 3 }], callFunction: (i, s, c, u) => Oe([u], ([h]) => N.m(M(h.v, 5))), localName: "function-arity", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 5, g: 3 } }]);
  class _w {
    constructor(s) {
      this.h = s;
    }
    createAttributeNS(s, c) {
      return this.h.createAttributeNS(s, c);
    }
    createCDATASection(s) {
      return this.h.createCDATASection(s);
    }
    createComment(s) {
      return this.h.createComment(s);
    }
    createDocument() {
      return this.h.createDocument();
    }
    createElementNS(s, c) {
      return this.h.createElementNS(s, c);
    }
    createProcessingInstruction(s, c) {
      return this.h.createProcessingInstruction(s, c);
    }
    createTextNode(s) {
      return this.h.createTextNode(s);
    }
  }
  var zp = Symbol("IS_XPATH_VALUE_SYMBOL");
  function yO(i) {
    return (s, c) => (s = wg(new Kl(c === null ? new si() : c), s, or(i)), { [zp]: !0, zb: s });
  }
  gO.forEach((i) => {
    Ry(i.namespaceURI, i.localName, i.j, i.i, i.callFunction);
  });
  function zw(i) {
    return i && typeof i == "object" && "lookupNamespaceURI" in i ? (s) => i.lookupNamespaceURI(s || null) : () => null;
  }
  function qp(i) {
    return ({ prefix: s, localName: c }) => s ? null : { namespaceURI: i, localName: c };
  }
  function Vp(i, s, c, u, h, g) {
    u == null && (u = u || {});
    const b = h ? { jb: h.logger || { trace: console.log.bind(console) }, Ma: h.documentWriter, kb: h.moduleImports, Cb: h.namespaceResolver, bc: h.functionNameResolver, Ja: h.nodesFactory, Ua: h.xmlSerializer } : { jb: { trace: console.log.bind(console) }, kb: {}, Cb: null, Ja: null, Ma: null, Ua: null }, x = new Kl(c === null ? new si() : c);
    c = b.kb || /* @__PURE__ */ Object.create(null);
    var C = h.defaultFunctionNamespaceURI === void 0 ? "http://www.w3.org/2005/xpath-functions" : h.defaultFunctionNamespaceURI;
    const T = Pw(
      i,
      g,
      b.Cb || zw(s),
      u,
      c,
      C,
      b.bc || qp(C)
    );
    i = s ? Zl(x, s) : N.empty(), s = !b.Ja && g.Z ? new my(s) : new _w(b.Ja), c = b.Ma ? new pg(b.Ma) : Nd, C = b.Ua;
    const R = Object.keys(u).reduce((_, ie) => {
      const me = u[ie];
      return _[`Q{}${ie}[0]`] = me && typeof me == "object" && zp in me ? () => N.create(me.zb) : () => Zl(x, u[ie]), _;
    }, /* @__PURE__ */ Object.create(null));
    let P;
    for (const _ of Object.keys(T.ga.Ea)) R[_] || (R[_] = () => (0, T.ga.Ea[_])(P, q));
    P = new Vo({ M: i.first(), Aa: 0, ta: i, ra: R });
    const q = new vg(g.debug, g.Ha, x, s, c, h.currentContext, /* @__PURE__ */ new Map(), b.jb, C);
    return { tb: P, ub: q, ba: T.ba };
  }
  function Xp(i, s) {
    const c = {};
    let u = 0, h = !1, g = null;
    return { next: () => {
      if (h) return H;
      for (; u < i.h.length; ) {
        const x = i.h[u].key.value;
        if (!g) {
          const C = i.h[u];
          var b = C.value().X({ default: (T) => T, multiple: () => {
            throw Error(`Serialization error: The value of an entry in a map is expected to be a single item or an empty sequence. Use arrays when putting multiple values in a map. The value of the key ${C.key.value} holds multiple items`);
          } }).first();
          if (b === null) {
            c[x] = null, u++;
            continue;
          }
          g = oo(b, s);
        }
        b = g.next(0), g = null, c[x] = b.value, u++;
      }
      return h = !0, j(c);
    } };
  }
  function Jp(i, s) {
    const c = [];
    let u = 0, h = !1, g = null;
    return { next: () => {
      if (h) return H;
      for (; u < i.h.length; ) {
        if (!g) {
          var b = i.h[u]().X({ default: (x) => x, multiple: () => {
            throw Error("Serialization error: The value of an entry in an array is expected to be a single item or an empty sequence. Use nested arrays when putting multiple values in an array.");
          } }).first();
          if (b === null) {
            c[u++] = null;
            continue;
          }
          g = oo(b, s);
        }
        b = g.next(0), g = null, c[u++] = b.value;
      }
      return h = !0, j(c);
    } };
  }
  function oo(i, s) {
    if (I(i.type, 61)) return Xp(i, s);
    if (I(i.type, 62)) return Jp(i, s);
    if (I(i.type, 23)) {
      const c = i.value;
      return { next: () => j(`Q{${c.namespaceURI || ""}}${c.localName}`) };
    }
    switch (i.type) {
      case 7:
      case 8:
      case 9:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
        const c = i.value;
        return { next: () => j(va(c)) };
      case 47:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 58:
        const u = i.value;
        return { next: () => j(Pt(u, s, !1)) };
      default:
        return { next: () => j(i.value) };
    }
  }
  var ct = { ANY: 0, NUMBER: 1, STRING: 2, BOOLEAN: 3, NODES: 7, FIRST_NODE: 9, STRINGS: 10, MAP: 11, ARRAY: 12, NUMBERS: 13, ALL_RESULTS: 14, ASYNC_ITERATOR: 99 };
  ct[ct.ANY] = "ANY", ct[ct.NUMBER] = "NUMBER", ct[ct.STRING] = "STRING", ct[ct.BOOLEAN] = "BOOLEAN", ct[ct.NODES] = "NODES", ct[ct.FIRST_NODE] = "FIRST_NODE", ct[ct.STRINGS] = "STRINGS", ct[ct.MAP] = "MAP", ct[ct.ARRAY] = "ARRAY", ct[ct.NUMBERS] = "NUMBERS", ct[ct.ALL_RESULTS] = "ALL_RESULTS", ct[ct.ASYNC_ITERATOR] = "ASYNC_ITERATOR";
  function qw(i, s, c, u) {
    switch (c) {
      case 3:
        return s.fa();
      case 2:
        return s = at(s, u).O(), s.length ? s.map((C) => He(C, 1).value).join(" ") : "";
      case 10:
        return s = at(s, u).O(), s.length ? s.map((C) => C.value + "") : [];
      case 1:
        return s = s.first(), s !== null && I(s.type, 2) ? s.value : NaN;
      case 9:
        if (s = s.first(), s === null) return null;
        if (!I(s.type, 53)) throw Error("Expected XPath " + hr(i) + " to resolve to Node. Got " + se[s.type]);
        return Pt(s.value, u, !1);
      case 7:
        if (s = s.O(), !s.every((C) => I(C.type, 53))) throw Error("Expected XPath " + hr(i) + " to resolve to a sequence of Nodes.");
        return s.map((C) => Pt(C.value, u, !1));
      case 11:
        if (s = s.O(), s.length !== 1) throw Error("Expected XPath " + hr(i) + " to resolve to a single map.");
        if (s = s[0], !I(s.type, 61)) throw Error("Expected XPath " + hr(i) + " to resolve to a map");
        return Xp(s, u).next(0).value;
      case 12:
        if (s = s.O(), s.length !== 1) throw Error("Expected XPath " + hr(i) + " to resolve to a single array.");
        if (s = s[0], !I(s.type, 62)) throw Error("Expected XPath " + hr(i) + " to resolve to an array");
        return Jp(s, u).next(0).value;
      case 13:
        return s.O().map((C) => {
          if (!I(
            C.type,
            2
          )) throw Error("Expected XPath " + hr(i) + " to resolve to numbers");
          return C.value;
        });
      case 99:
        const h = s.value;
        let g = null, b = !1;
        const x = () => {
          for (; !b; ) {
            if (!g) {
              var C = h.next(0);
              if (C.done) {
                b = !0;
                break;
              }
              g = oo(C.value, u);
            }
            return C = g.next(0), g = null, C;
          }
          return Promise.resolve({ done: !0, value: null });
        };
        return "asyncIterator" in Symbol ? { [Symbol.asyncIterator]() {
          return this;
        }, next: () => new Promise((C) => C(x())).catch((C) => {
          dn(i, C);
        }) } : { next: () => new Promise((C) => C(x())) };
      case 14:
        return s.O().map((C) => oo(C, u).next(0).value);
      default:
        return s = s.O(), s.every((C) => I(C.type, 53) && !I(C.type, 47)) ? (s = s.map((C) => Pt(C.value, u, !1)), s.length === 1 ? s[0] : s) : s.length === 1 ? (s = s[0], I(s.type, 62) ? Jp(s, u).next(0).value : I(s.type, 61) ? Xp(s, u).next(0).value : Pr(s, u).first().value) : at(N.create(s), u).O().map((C) => C.value);
    }
  }
  let jc = !1, gi = null;
  var wO = { getPerformanceSummary() {
    const i = gi.getEntriesByType("measure").filter((s) => s.name.startsWith("XPath: "));
    return Array.from(i.reduce((s, c) => {
      var u = c.name.substring(7);
      return s.has(u) ? (u = s.get(u), u.times += 1, u.totalDuration += c.duration) : s.set(u, { xpath: u, times: 1, totalDuration: c.duration, average: 0 }), s;
    }, /* @__PURE__ */ new Map()).values()).map((s) => (s.average = s.totalDuration / s.times, s)).sort((s, c) => c.totalDuration - s.totalDuration);
  }, setPerformanceImplementation(i) {
    gi = i;
  }, startProfiling() {
    if (gi === null) throw Error("Performance API object must be set using `profiler.setPerformanceImplementation` before starting to profile");
    gi.clearMarks(), gi.clearMeasures(), jc = !0;
  }, stopProfiling() {
    jc = !1;
  } };
  let ms = 0;
  var bO = { XPATH_3_1_LANGUAGE: "XPath3.1", XQUERY_3_1_LANGUAGE: "XQuery3.1", XQUERY_UPDATE_3_1_LANGUAGE: "XQueryUpdate3.1" };
  const ut = (i, s, c, u, h, g) => {
    if (h = h || 0, !i || typeof i != "string" && !("nodeType" in i)) throw new TypeError("Failed to execute 'evaluateXPath': xpathExpression must be a string or an element depicting an XQueryX DOM tree.");
    g = g || {};
    let b, x;
    try {
      const T = Vp(i, s, c || null, u || {}, g, { sa: g.language === "XQueryUpdate3.1", Z: g.language === "XQuery3.1" || g.language === "XQueryUpdate3.1", debug: !!g.debug, Ha: !!g.disableCache });
      var C = T.tb;
      b = T.ub, x = T.ba;
    } catch (T) {
      dn(i, T);
    }
    if (x.I) throw Error("XUST0001: Updating expressions should be evaluated as updating expressions");
    if (h === 3 && s && typeof s == "object" && "nodeType" in s && (c = x.D(), s = Or(s), c !== null && !s.includes(c))) return !1;
    try {
      s = i, jc && (typeof s != "string" && (s = hr(s)), gi.mark(`${s}${ms === 0 ? "" : "@" + ms}`), ms++);
      const T = he(x, C, b), R = qw(i, T, h, b);
      return h = i, jc && (typeof h != "string" && (h = hr(h)), ms--, C = `${h}${ms === 0 ? "" : "@" + ms}`, gi.measure(`XPath: ${h}`, C), gi.clearMarks(C)), R;
    } catch (T) {
      dn(i, T);
    }
  };
  Object.assign(ut, { jc: 14, ANY_TYPE: 0, Lb: 12, Mb: 99, BOOLEAN_TYPE: 3, Ob: 9, Rb: 11, Tb: 7, Ub: 13, NUMBER_TYPE: 1, Vb: 10, STRING_TYPE: 2, kc: "XPath3.1", lc: "XQuery3.1", Yb: "XQueryUpdate3.1" }), Object.assign(ut, { ALL_RESULTS_TYPE: 14, ANY_TYPE: 0, ARRAY_TYPE: 12, ASYNC_ITERATOR_TYPE: 99, BOOLEAN_TYPE: 3, FIRST_NODE_TYPE: 9, MAP_TYPE: 11, NODES_TYPE: 7, NUMBERS_TYPE: 13, NUMBER_TYPE: 1, STRINGS_TYPE: 10, STRING_TYPE: 2, XPATH_3_1_LANGUAGE: "XPath3.1", XQUERY_3_1_LANGUAGE: "XQuery3.1", XQUERY_UPDATE_3_1_LANGUAGE: "XQueryUpdate3.1" });
  function Vw(i, s, c, u, h) {
    return ut(i, s, c, u, ut.Mb, h);
  }
  function Xw(i, s, c, u) {
    return { pendingUpdateList: i.da.map((h) => h.h(u)), xdmValue: qw(s, N.create(i.J), c, u) };
  }
  async function vO(i, s, c, u, h) {
    h = h || {}, Ra();
    let g, b;
    try {
      const T = Vp(i, s, c || null, u || {}, h || {}, { sa: !0, Z: !0, debug: !!h.debug, Ha: !!h.disableCache });
      var x = T.tb;
      g = T.ub, b = T.ba;
    } catch (T) {
      dn(i, T);
    }
    if (!b.I) {
      for (x = [], i = Vw(i, s, c, u, Object.assign(Object.assign({}, h), { language: "XQueryUpdate3.1" })), s = await i.next(); !s.done; s = await i.next()) x.push(s.value);
      return Promise.resolve({ pendingUpdateList: [], xdmValue: x });
    }
    let C;
    try {
      C = b.s(x, g).next(0);
    } catch (T) {
      dn(i, T);
    }
    return Xw(C.value, i, h.returnType, g);
  }
  function xO(i, s, c, u, h) {
    h = h || {}, Ra();
    let g, b, x;
    try {
      const T = Vp(i, s, c || null, u || {}, h || {}, { sa: !0, Z: !0, debug: !!h.debug, Ha: !!h.disableCache });
      g = T.tb, b = T.ub, x = T.ba;
    } catch (T) {
      dn(i, T);
    }
    if (!x.I) return { pendingUpdateList: [], xdmValue: ut(i, s, c, u, h.i, Object.assign(Object.assign({}, h), { language: ut.Yb })) };
    let C;
    try {
      C = x.s(g, b).next(0);
    } catch (T) {
      dn(i, T);
    }
    return Xw(C.value, i, h.returnType, b);
  }
  function kO(i, s, c, u, h) {
    return ut(i, s, c, u, ut.Lb, h);
  }
  function AO(i, s, c, u, h) {
    return ut(i, s, c, u, ut.BOOLEAN_TYPE, h);
  }
  function CO(i, s, c, u, h) {
    return ut(i, s, c, u, ut.Ob, h);
  }
  function SO(i, s, c, u, h) {
    return ut(i, s, c, u, ut.Rb, h);
  }
  function EO(i, s, c, u, h) {
    return ut(i, s, c, u, ut.Tb, h);
  }
  function TO(i, s, c, u, h) {
    return ut(i, s, c, u, ut.NUMBER_TYPE, h);
  }
  function NO(i, s, c, u, h) {
    return ut(i, s, c, u, ut.Ub, h);
  }
  function BO(i, s, c, u, h) {
    return ut(i, s, c, u, ut.STRING_TYPE, h);
  }
  function IO(i, s, c, u, h) {
    return ut(i, s, c, u, ut.Vb, h);
  }
  function MO(i, s, c, u) {
    s = new Kl(s || new si()), u = u ? new pg(u) : Nd, c = c ? c = new _w(c) : null, i = i.map(B0), by(i, s, c, u);
  }
  function be(i, s, c) {
    return { code: i, ua: s, H: c, isAstAccepted: !0 };
  }
  function De(i) {
    return { isAstAccepted: !1, reason: i };
  }
  function de(i, s) {
    return i.isAstAccepted ? s(i) : i;
  }
  function Kp(i, s) {
    return i.isAstAccepted ? s(i) : [i, null];
  }
  function Ur(i, s, c) {
    return de(i, (u) => {
      switch (u.ua.type) {
        case 0:
          return u;
        case 1:
          return de(tn(c, u, "nodes"), (h) => de(tn(c, s, "contextItem"), (g) => be(`(function () {
							const { done, value } = ${h.code}(${g.code}).next();
							return done ? null : value;
						})()`, { type: 0 }, [...h.H, ...g.H])));
        default:
          throw Error(`invalid generated code type to convert to value: ${u.ua.type}`);
      }
    });
  }
  function gs(i, s, c, u) {
    return i = Ur(i, c, u), s && s.type === 0 && s.g === 3 ? i : de(i, (h) => be(`!!${h.code}`, { type: 0 }, h.H));
  }
  function La(i, s, c) {
    return s ? i.isAstAccepted && i.ua.type !== 0 ? De("Atomization only implemented for single value") : I(s.type, 1) ? i : I(s.type, 47) ? de(tn(c, i, "attr"), (u) => be(`(${u.code} ? domFacade.getData(${u.code}) : null)`, { type: 0 }, u.H)) : De("Atomization only implemented for string and attribute") : De("Can not atomize value if type was not annotated");
  }
  function Jw(i, s, c, u) {
    return i = Ur(i, c, u), u = La(i, s, u), Vi(s) ? de(u, (h) => be(`${h.code} ?? ''`, { type: 0 }, h.H)) : u;
  }
  function Wp(i, s, c) {
    return de(tn(c, i, "node"), (u) => u.ua.type === 1 ? u : s && !I(s.type, 53) ? De("Can not evaluate to node if expression does not result in nodes") : be(`(function () {
				if (${u.code} !== null && !${u.code}.nodeType) {
					throw new Error('XPDY0050: The result of the expression was not a node');
				}
				return ${u.code};
			})()`, { type: 0 }, u.H));
  }
  function OO(i, s, c, u) {
    return de(i, (h) => {
      switch (h.ua.type) {
        case 1:
          return de(tn(u, h, "nodes"), (g) => de(tn(u, c, "contextItem"), (b) => be(`Array.from(${g.code}(${b.code}))`, { type: 0 }, [...g.H, ...b.H])));
        case 0:
          return de(tn(u, Wp(h, s, u), "node"), (g) => be(`(${g.code} === null ? [] : [${g.code}])`, { type: 0 }, g.H));
        default:
          return De("Unsupported code type to evaluate to nodes");
      }
    });
  }
  function ys(i, s) {
    return de(i, (c) => de(s, (u) => {
      if (c.ua.type !== 0 || u.ua.type !== 0) throw Error("can only use emitAnd with value expressions");
      return be(`${c.code} && ${u.code}`, { type: 0 }, [...c.H, ...u.H]);
    }));
  }
  function ws(i, s, c, u) {
    return (i = oe(i, [s, "*"])) ? u.h(i, c, u) : [De(`${s} expression not found`), null];
  }
  const Yp = { equalOp: "eqOp", notEqualOp: "neOp", lessThanOrEqualOp: "leOp", lessThanOp: "ltOp", greaterThanOrEqualOp: "geOp", greaterThanOp: "gtOp" }, DO = { eqOp: "eqOp", neOp: "neOp", leOp: "geOp", ltOp: "gtOp", geOp: "leOp", gtOp: "ltOp" };
  function Kw(i, s, c, u) {
    const h = le(oe(i, ["firstOperand", "*"]), "type"), g = le(oe(i, ["secondOperand", "*"]), "type");
    if (!h || !g) return De("Can not generate code for value compare without both types");
    var b = [47, 1];
    if (!b.includes(h.type) || !b.includes(g.type)) return De(`Unsupported types in compare: [${se[h.type]}, ${se[g.type]}]`);
    if (b = /* @__PURE__ */ new Map([["eqOp", "==="], ["neOp", "!=="]]), !b.has(s)) return De(s + " not yet implemented");
    const x = b.get(s);
    return [s] = ws(i, "firstOperand", c, u), s = Ur(s, c, u), s = La(s, h, u), de(
      tn(u, s, "first"),
      (C) => {
        var [T] = ws(i, "secondOperand", c, u);
        return T = Ur(T, c, u), T = La(T, g, u), de(tn(u, T, "second"), (R) => {
          const P = [];
          return Vi(h) && P.push(`${C.code} === null`), Vi(g) && P.push(`${R.code} === null`), be(`(${P.length ? `${P.join(" || ")} ? null : ` : ""}${C.code} ${x} ${R.code})`, { type: 0 }, [...C.H, ...R.H]);
        });
      }
    );
  }
  function Ww(i, s, c, u, h, g) {
    var b = le(oe(i, [s, "*"]), "type");
    const x = le(oe(i, [c, "*"]), "type");
    if (!b || !x) return De("Can not generate code for general compare without both types");
    var C = [47, 1];
    if (!C.includes(b.type) || !C.includes(x.type)) return De(`Unsupported types in compare: [${se[b.type]}, ${se[x.type]}]`);
    if (C = /* @__PURE__ */ new Map([["eqOp", "==="], ["neOp", "!=="]]), !C.has(u)) return De(u + " not yet implemented");
    const T = C.get(u);
    return [s] = ws(i, s, h, g), s = Ur(s, h, g), b = La(s, b, g), de(tn(g, b, "single"), (R) => {
      const [P] = ws(i, c, h, g);
      return de(tn(g, P, "multiple"), (q) => {
        if (q.ua.type !== 1) return De("can only generate general compare for a single value and a generator");
        const _ = Lc(g, Uc(g, "n")), ie = La(_, x, g);
        return de(h, (me) => de(ie, (Ce) => be(`(function () {
									for (const ${_.code} of ${q.code}(${me.code})) {
										${Ce.H.join(`
`)}
										if (${Ce.code} ${T} ${R.code}) {
											return true;
										}
									}
									return false;
								})()`, { type: 0 }, [...R.H, ..._.H, ...me.H, ...q.H])));
      });
    });
  }
  function bs(i) {
    return JSON.stringify(i).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  const RO = { "false#0": HO, "local-name#0": eb, "local-name#1": eb, "name#0": Zw, "name#1": Zw, "not#1": LO, "true#0": GO }, FO = { "http://fontoxml.com/fontoxpath": ["version#0"], "": ["root#1", "path#1"] };
  function PO(i, s, c, u) {
    const [h] = u.h(i, c, u);
    if (i = le(i, "type"), !s || s.g === 2 || s.g === 1) return De("Not supported: sequence arguments with multiple items");
    if (I(s.type, 53)) return s = Ur(h, c, u), Wp(s, i, u);
    switch (s.type) {
      case 59:
        return Ur(h, c, u);
      case 0:
        return gs(h, i, c, u);
      case 1:
        return Jw(h, i, c, u);
    }
    return De(`Argument types not supported: ${i ? se[i.type] : "unknown"} -> ${se[s.type]}`);
  }
  function Yw(i, s, c, u) {
    if (i.length !== s.length || s.some((C) => C === 4)) return De("Not supported: variadic function or mismatch in argument count");
    if (i.length === 0) return be("", { type: 0 }, []);
    const [h, ...g] = i, [b, ...x] = s;
    return i = tn(u, PO(h, b, c, u), "arg"), g.length === 0 ? i : de(i, (C) => {
      const T = Yw(g, x, c, u);
      return de(T, (R) => be(`${C.code}, ${R.code}`, { type: 0 }, [...C.H, ...R.H]));
    });
  }
  function $O(i, s) {
    return de(i, (c) => !s || s.g === 2 || s.g === 1 || ![0, 1].includes(s.type) && !I(s.type, 53) ? De(`Function return type ${se[s.type]} not supported`) : c);
  }
  function jO(i, s, c) {
    const { localName: u, namespaceURI: h } = ze(F(i, "functionName")), g = ae(F(i, "arguments"), "*");
    var b = g.length;
    const x = `${u}#${b}`, C = h === c.D;
    if (C) {
      const T = RO[x];
      if (T !== void 0) return T(i, s, c);
    }
    return (i = FO[C ? "" : h]) && !i.includes(x) ? De(`Not supported: built-in function not on allow list: ${x}`) : (b = ip(h, u, b), b ? b.I ? De("Not supported: updating functions") : (s = Yw(g, b.j, s, c), s = de(s, (T) => be(
      `runtimeLib.callFunction(domFacade, ${bs(h)}, ${bs(u)}, [${T.code}], options)`,
      { type: 0 },
      T.H
    )), $O(s, b.i)) : De(`Unknown function / arity: ${x}`));
  }
  function UO(i, s) {
    return de(tn(s, i, "contextItem"), (c) => be(c.code, { type: 0 }, [...c.H, `if (${c.code} === undefined || ${c.code} === null) {
					throw errXPDY0002('The function which was called depends on dynamic context, which is absent.');
				}`]));
  }
  function Qw(i, s, c, u) {
    if ((i = oe(i, ["arguments", "*"])) && i[0] !== "contextItemExpr") {
      const h = le(i, "type");
      if (!h || !I(h.type, 53)) return De("name function only implemented if arg is a node");
      [i] = c.h(i, s, c);
    } else i = UO(s, c);
    return s = Ur(i, s, c), de(tn(c, s, "arg"), (h) => be(`(${h.code} ? ${u(h.code)} : '')`, { type: 0 }, h.H));
  }
  function Zw(i, s, c) {
    return Qw(i, s, c, (u) => `(((${u}.prefix || '').length !== 0 ? ${u}.prefix + ':' : '')
		+ (${u}.localName || ${u}.target || ''))`);
  }
  function eb(i, s, c) {
    return Qw(i, s, c, (u) => `(${u}.localName || ${u}.target || '')`);
  }
  function LO(i, s, c) {
    var u = oe(i, ["arguments", "*"]);
    return i = le(u, "type"), [u] = c.h(u, s, c), s = gs(u, i, s, c), de(s, (h) => be(`!${h.code}`, { type: 0 }, h.H));
  }
  function HO() {
    return be("false", { type: 0 }, []);
  }
  function GO() {
    return be("true", { type: 0 }, []);
  }
  function tb(i, s, c, u) {
    const [h, g] = ws(i, "firstOperand", c, u);
    var b = le(oe(i, ["firstOperand", "*"]), "type");
    b = gs(h, b, c, u);
    const [x, C] = ws(i, "secondOperand", c, u);
    b = de(b, (R) => {
      var P = le(oe(i, ["secondOperand", "*"]), "type");
      return P = gs(x, P, c, u), de(P, (q) => be(`(${R.code} ${s} ${q.code})`, { type: 0 }, [...R.H, ...q.H]));
    });
    const T = s === "&&" ? vn(g, C) : g === C ? g : null;
    return [b, T];
  }
  function nb(i, s, c) {
    return de(i, (u) => de(s, (h) => de(c, (g) => be(`for (${u.code}) {
						${h.H.join(`
`)}
						if (!(${h.code})) {
							continue;
						}
						${g.H.join(`
`)}
						${g.code}
					}`, { type: 2 }, u.H))));
  }
  function _O(i, s, c, u, h) {
    const g = s ? `, "${s}"` : "";
    return s = de(u, (b) => de(h, (x) => be(`let ${b.code} = domFacade.getFirstChild(${x.code}${g});
							${b.code};
							${b.code} = domFacade.getNextSibling(${b.code}${g})`, { type: 2 }, [...b.H, ...x.H]))), nb(s, i, c);
  }
  function zO(i, s, c, u, h) {
    const g = vn(s, "type-2"), b = de(h, (x) => be(`(${x.code} && ${x.code}.nodeType === /*ELEMENT_NODE*/ 1 ? domFacade.getAllAttributes(${x.code}${g ? `, "${g}"` : ""}) : [])`, { type: 0 }, x.H));
    return s = de(u, (x) => de(b, (C) => be(`const ${x.code} of ${C.code}`, { type: 2 }, [...x.H, ...C.H]))), nb(s, i, c);
  }
  function qO(i, s, c, u, h) {
    const g = s ? `, "${s}"` : "";
    return s = de(h, (b) => be(`domFacade.getParentNode(${b.code}${g})`, { type: 0 }, b.H)), rb(u, s, i, c);
  }
  function rb(i, s, c, u) {
    const h = ys(i, c);
    return de(i, (g) => de(s, (b) => de(h, (x) => de(u, (C) => be(`const ${g.code} = ${b.code};
						${x.H.join(`
`)}
						if (${x.code}) {
							${C.H.join(`
`)}
							${C.code}
						}`, { type: 2 }, [...g.H, ...b.H])))));
  }
  function VO(i, s, c, u, h, g) {
    switch (i = Se(i), i) {
      case "attribute":
        return [zO(s, c, u, h, g), "type-1"];
      case "child":
        return [_O(s, c, u, h, g), null];
      case "parent":
        return [qO(s, c, u, h, g), null];
      case "self":
        return [rb(h, g, s, u), c];
      default:
        return [De(`Unsupported: the ${i} axis`), null];
    }
  }
  const vs = { Wb: "textTest", Nb: "elementTest", Sb: "nameTest", Xb: "Wildcard", Kb: "anyKindTest" };
  var ib = Object.values(vs);
  function XO(i) {
    return [de(i, (s) => be(`(${s.code}.nodeType === /*TEXT_NODE*/ 3 ||
				${s.code}.nodeType === /* CDATA_SECTION_NODE */ 4)`, { type: 0 }, [])), "type-3"];
  }
  function JO(i, s) {
    if (i.namespaceURI === null && i.prefix !== "*") {
      if (s = s.$(i.prefix || "") || null, !s && i.prefix) throw Error(`XPST0081: The prefix ${i.prefix} could not be resolved.`);
      i.namespaceURI = s;
    }
  }
  function xs(i, s, c, u) {
    JO(i, u);
    const h = i.prefix, g = i.namespaceURI, b = i.localName;
    return Kp(c, (x) => {
      var C = s ? be(`${x.code}.nodeType
						&& (${x.code}.nodeType === /*ELEMENT_NODE*/ 1
						|| ${x.code}.nodeType === /*ATTRIBUTE_NODE*/ 2)`, { type: 0 }, []) : be(`${x.code}.nodeType
						&& ${x.code}.nodeType === /*ELEMENT_NODE*/ 1`, { type: 0 }, []);
      if (h === "*") return b === "*" ? [C, s ? "type-1-or-type-2" : "type-1"] : [ys(C, be(`${x.code}.localName === ${bs(b)}`, { type: 0 }, [])), `name-${b}`];
      C = b === "*" ? C : ys(C, be(`${x.code}.localName === ${bs(b)}`, { type: 0 }, []));
      var T = be(bs(g), { type: 0 }, []);
      return T = h === "" && s ? de(T, (R) => be(`${x.code}.nodeType === /*ELEMENT_NODE*/ 1 ? ${R.code} : null`, { type: 0 }, R.H)) : T, T = de(T, (R) => be(`(${x.code}.namespaceURI || null) === ((${R.code}) || null)`, { type: 0 }, R.H)), [ys(C, T), `name-${b}`];
    });
  }
  function KO(i, s, c) {
    const u = (i = F(i, "elementName")) && F(i, "star");
    return i === null || u ? [de(s, (h) => be(`${h.code}.nodeType === /*ELEMENT_NODE*/ 1`, { type: 0 }, [])), "type-1"] : (i = ze(F(i, "QName")), xs(i, !1, s, c));
  }
  function WO(i) {
    return [de(i, (s) => be(`!!${s.code}.nodeType`, { type: 0 }, [])), null];
  }
  function ob(i, s, c, u) {
    var h = i[0];
    switch (h) {
      case vs.Nb:
        return KO(i, c, u);
      case vs.Wb:
        return XO(c);
      case vs.Sb:
        return xs(ze(i), s, c, u);
      case vs.Xb:
        return F(i, "star") ? (h = F(i, "uri"), h !== null ? i = xs({ localName: "*", namespaceURI: Se(h), prefix: "" }, s, c, u) : (h = F(i, "NCName"), i = F(i, "*")[0] === "star" ? xs({ localName: Se(h), namespaceURI: null, prefix: "*" }, s, c, u) : xs({ localName: "*", namespaceURI: null, prefix: Se(h) }, s, c, u))) : i = xs({ localName: "*", namespaceURI: null, prefix: "*" }, s, c, u), i;
      case vs.Kb:
        return WO(c);
      default:
        return [
          De(`Test not implemented: '${h}`),
          null
        ];
    }
  }
  function sb(i, s, c) {
    const [u, h] = c.h(i, s, c);
    return [gs(u, le(i, "type"), s, c), h];
  }
  function ab(i, s, c) {
    i = i ? ae(i, "*") : [];
    const [u, h] = i.reduce(([g, b], x) => {
      if (!g) return sb(x, s, c);
      let C = b;
      return Kp(g, (T) => {
        const [R, P] = sb(x, s, c);
        return C = vn(b, P), [de(R, (q) => be(`${T.code} && ${q.code}`, { type: 0 }, [...T.H, ...q.H])), C];
      });
    }, [null, null]);
    return [u ? de(u, (g) => be(`(function () {
							${g.H.join(`
`)}
							return ${g.code};
						})()`, { type: 0 }, [])) : null, h];
  }
  function Qp(i, s, c, u) {
    if (i.length === 0) return [de(c, (_) => be(`yield ${_.code};`, { type: 2 }, _.H)), null];
    const [h, ...g] = i;
    if (0 < ae(h, "lookup").length) return [De("Unsupported: lookups"), null];
    const b = Lc(u, Uc(u, "contextItem"));
    i = F(h, "predicates");
    const [x, C] = ab(i, b, u);
    if (i = F(h, "xpathAxis")) {
      var T = F(h, ib);
      if (!T) return [De("Unsupported test in step"), null];
      var R = Se(i);
      s = R === "attribute" || R === "self" && s;
      const [_, ie] = ob(T, s, b, u);
      return T = x === null ? _ : ys(_, x), R = vn(ie, C), [s] = Qp(g, s, b, u), VO(i, T, R, s, b, c);
    }
    if (i = oe(h, ["filterExpr", "*"]), !i) return [De("Unsupported: unknown step type"), null];
    const [P, q] = u.h(i, c, u);
    return [de(P, (_) => {
      const ie = g.length === 0 ? be("", { type: 2 }, []) : be(`if (${b.code} !== null && !${b.code}.nodeType) {
									throw new Error('XPTY0019: The result of E1 in a path expression E1/E2 should evaluate to a sequence of nodes.');
								}`, { type: 2 }, []), [me] = Qp(g, !0, b, u), Ce = x === null ? me : de(x, ($e) => de(me, (nn) => be(`if (${$e.code}) {
									${nn.H.join(`
`)}
									${nn.code}
								}`, { type: 2 }, $e.H)));
      return de(Ce, ($e) => {
        switch (_.ua.type) {
          case 1:
            return de(c, (nn) => be(`for (const ${b.code} of ${_.code}(${nn.code})) {
									${$e.H.join(`
`)}
									${$e.code}
								}`, { type: 2 }, [...b.H, ..._.H, ...ie.H]));
          case 0:
            return be(`const ${b.code} = ${_.code};
							${ie.code}
							if (${b.code} !== null) {
								${$e.H.join(`
`)}
								${$e.code}
							}`, { type: 2 }, [...b.H, ..._.H, ...ie.H]);
          default:
            return De("Unsupported generated code type for filterExpr");
        }
      });
    }), q];
  }
  function YO(i) {
    return de(i, (s) => be(`(function () {
				let n = ${s.code};
				while (n.nodeType !== /*DOCUMENT_NODE*/9) {
					n = domFacade.getParentNode(n);
					if (n === null) {
						throw new Error('XPDY0050: the root node of the context node is not a document node.');
					}
				}
				return n;
			})()`, { type: 0 }, s.H));
  }
  function QO(i, s, c) {
    return Kp(s, (u) => {
      if (0 < ae(i, "lookup").length) return [De("Unsupported: lookups"), null];
      var h = F(i, "predicates");
      const [g, b] = ab(h, u, c);
      if (h = F(i, ib), !h) return [De("Unsupported test in step"), null];
      const [x, C] = ob(h, !0, u, c);
      h = g === null ? x : ys(x, g);
      const T = vn(C, b);
      return [de(h, (R) => be(`((${R.code}) ? ${u.code} : null)`, { type: 0 }, [...u.H, ...R.H])), T];
    });
  }
  function ZO(i, s, c) {
    const u = ae(i, "stepExpr");
    if (u.length === 1) {
      const x = F(u[0], "xpathAxis");
      if (x && Se(x) === "self") return QO(u[0], s, c);
    }
    const h = Lc(c, Uc(c, "contextItem"));
    s = (i = F(i, "rootExpr")) ? tn(c, YO(h), "root") : h;
    const [g, b] = Qp(u, !i, s, c);
    return [de(g, (x) => be(`(function* (${h.code}) {
			${x.H.join(`
`)}
			${x.code}
		})`, { type: 1 }, [])), b];
  }
  function eD(i, s, c) {
    const u = i[0];
    switch (u) {
      case "contextItemExpr":
        return [s, null];
      case "pathExpr":
        return ZO(i, s, c);
      case "andOp":
        return tb(i, "&&", s, c);
      case "orOp":
        return tb(i, "||", s, c);
      case "stringConstantExpr":
        return i = F(i, "value")[1] || "", i = bs(i), [be(i, { type: 0 }, []), null];
      case "equalOp":
      case "notEqualOp":
      case "lessThanOrEqualOp":
      case "lessThanOp":
      case "greaterThanOrEqualOp":
      case "greaterThanOp":
      case "eqOp":
      case "neOp":
      case "ltOp":
      case "leOp":
      case "gtOp":
      case "geOp":
      case "isOp":
      case "nodeBeforeOp":
      case "nodeAfterOp":
        e: switch (u) {
          case "eqOp":
          case "neOp":
          case "ltOp":
          case "leOp":
          case "gtOp":
          case "geOp":
          case "isOp":
            i = Kw(i, u, s, c);
            break e;
          case "equalOp":
          case "notEqualOp":
          case "lessThanOrEqualOp":
          case "lessThanOp":
          case "greaterThanOrEqualOp":
          case "greaterThanOp":
            const h = le(oe(i, ["firstOperand", "*"]), "type"), g = le(oe(i, ["secondOperand", "*"]), "type");
            i = h && g ? h.g === 3 && g.g === 3 ? Kw(i, Yp[u], s, c) : h.g === 3 ? Ww(i, "firstOperand", "secondOperand", Yp[u], s, c) : g.g === 3 ? Ww(i, "secondOperand", "firstOperand", DO[Yp[u]], s, c) : De("General comparison for sequences is not implemented") : De("types of compare are not known");
            break e;
          default:
            i = De(`Unsupported compare type: ${u}`);
        }
        return [
          i,
          null
        ];
      case "functionCallExpr":
        return [jO(i, s, c), null];
      default:
        return [De(`Unsupported: the base expression '${u}'.`), null];
    }
  }
  function tn(i, s, c) {
    return de(s, (u) => {
      var h = i.o.get(u);
      return h || (h = Uc(i, c), h = be(h, u.ua, [...u.H, `const ${h} = ${u.code};`]), i.o.set(u, h), i.o.set(h, h)), h;
    });
  }
  function Uc(i, s = "v") {
    const c = i.v.get(s) || 0;
    return i.v.set(s, c + 1), `${s}${c}`;
  }
  function Lc(i, s) {
    return s = be(s, { type: 0 }, []), i.o.set(s, s), s;
  }
  var tD = class {
    constructor(i, s) {
      this.o = /* @__PURE__ */ new Map(), this.v = /* @__PURE__ */ new Map(), this.$ = i, this.D = s, this.h = eD;
    }
  };
  function lb(i) {
    const s = ae(i, "*");
    if (i[0] === "pathExpr") return !0;
    for (const c of s) if (lb(c)) return !0;
    return !1;
  }
  function nD(i, s, c) {
    if (c = c || {}, s = s || 0, typeof i == "string") {
      i = wp(i);
      var u = { Z: c.language === "XQuery3.1" || c.language === "XQueryUpdate3.1", debug: !1 };
      try {
        var h = Ua(i, u);
      } catch (b) {
        dn(i, b);
      }
    } else h = Tc(i);
    if (i = F(h, "mainModule"), !i) return De("Unsupported: XQuery Library modules are not supported.");
    if (F(i, "prolog")) return De("Unsupported: XQuery Prologs are not supported.");
    if (u = c.defaultFunctionNamespaceURI === void 0 ? "http://www.w3.org/2005/xpath-functions" : c.defaultFunctionNamespaceURI, i = new tD(c.namespaceResolver || zw(null), u), c = new bc(new Ki(new hc(i.$, {}, u, c.functionNameResolver || qp("http://www.w3.org/2005/xpath-functions")))), ke(h, c), c = F(h, "mainModule")) if (F(c, "prolog")) i = De("Unsupported: XQuery.");
    else {
      var g = oe(c, ["queryBody", "*"]);
      c = Lc(i, "contextItem"), [u] = i.h(g, c, i);
      e: switch (g = le(g, "type"), s) {
        case 9:
          s = Ur(u, c, i), i = Wp(s, g, i);
          break e;
        case 7:
          i = OO(u, g, c, i);
          break e;
        case 3:
          i = gs(u, g, c, i);
          break e;
        case 2:
          i = Jw(u, g, c, i);
          break e;
        default:
          i = De(`Unsupported: the return type '${s}'.`);
      }
      i.isAstAccepted && (i = `
		${i.H.join(`
`)}
		return ${i.code};`, s = `
	return (contextItem, domFacade, runtimeLib, options) => {
		const {
			errXPDY0002,
		} = runtimeLib;`, lb(h) && (s += `
		if (!contextItem) {
			throw errXPDY0002("Context is needed to evaluate the given path expression.");
		}

		if (!contextItem.nodeType) {
			throw new Error("Context item must be subtype of node().");
		}
		`), i = { code: s + (i + `}
//# sourceURL=generated.js`), isAstAccepted: !0 });
    }
    else i = De("Unsupported: Can not execute a library module.");
    return i;
  }
  class rD extends Error {
    constructor(s, c, u) {
      var h = s.stack;
      h && (h.includes(s.message) && (h = h.substr(h.indexOf(s.message) + s.message.length).trim()), h = h.split(`
`), h.splice(10), h = h.map((g) => g.startsWith("    ") || g.startsWith("	") ? g : `    ${g}`), h = h.join(`
`)), super(`Custom XPath function Q{${u}}${c} raised:
${s.message}
${h}`);
    }
  }
  function cb(i, s, c) {
    return s.g === 0 ? i.F() ? null : oo(i.first(), c).next(0).value : s.g === 2 || s.g === 1 ? i.O().map((u) => {
      if (I(u.type, 47)) throw Error("Cannot pass attribute nodes to custom functions");
      return oo(u, c).next(0).value;
    }) : oo(i.first(), c).next(0).value;
  }
  function iD(i) {
    if (typeof i == "object") return i;
    if (i = i.split(":"), i.length !== 2) throw Error("Do not register custom functions in the default function namespace");
    const [s, c] = i;
    if (i = Na[s], !i) {
      if (i = `generated_namespace_uri_${s}`, Na[s]) throw Error("Prefix already registered: Do not register the same prefix twice.");
      Na[s] = i;
    }
    return { localName: c, namespaceURI: i };
  }
  function oD(i, s, c, u) {
    const { namespaceURI: h, localName: g } = iD(i);
    if (!h) throw op();
    const b = s.map((C) => or(C)), x = or(c);
    Ry(h, g, b, x, function(C, T, R) {
      var P = Array.from(arguments);
      P.splice(0, 3), P = P.map((ie, me) => cb(ie, b[me], T));
      const q = { currentContext: T.o, domFacade: T.h.h };
      let _;
      try {
        _ = u.apply(void 0, [q, ...P]);
      } catch (ie) {
        throw new rD(ie, g, h);
      }
      return _ && typeof _ == "object" && Object.getOwnPropertySymbols(_).includes(zp) ? N.create(_.zb) : Zl(T.h, _, x);
    });
  }
  var sD = { callFunction(i, s, c, u, h) {
    const g = ip(s, c, u.length);
    if (!g) throw Error("function not found for codegen function call");
    s = new Vo({ M: null, Aa: 0, ta: N.empty(), ra: {} });
    const b = new Kl(i);
    return i = new vg(!1, !1, b, null, null, h ? h.currentContext : null, null), u = g.callFunction(s, i, null, ...u.map((x, C) => Zl(b, x, g.j[C]))), cb(u, { g: 0 }, i);
  }, errXPDY0002: _n }, aD = (i, s, c, u) => (c = c || new si(), i()(s ?? null, c, sD, u));
  const ub = { "http://www.w3.org/2005/XQueryX": "xqx", "http://www.w3.org/2007/xquery-update-10": "xquf", "http://fontoxml.com/fontoxpath": "x" };
  function lD(i, s) {
    switch (i) {
      case "copySource":
      case "insertAfter":
      case "insertAsFirst":
      case "insertAsLast":
      case "insertBefore":
      case "insertInto":
      case "modifyExpr":
      case "newNameExpr":
      case "replacementExpr":
      case "replaceValue":
      case "returnExpr":
      case "sourceExpr":
      case "targetExpr":
      case "transformCopies":
      case "transformCopy":
        return { localName: i, lb: s || "http://www.w3.org/2005/XQueryX" };
      case "deleteExpr":
      case "insertExpr":
      case "renameExpr":
      case "replaceExpr":
      case "transformExpr":
        return { localName: i, lb: "http://www.w3.org/2007/xquery-update-10" };
      case "x:stackTrace":
        return { localName: "stackTrace", lb: "http://fontoxml.com/fontoxpath" };
      default:
        return { localName: i, lb: "http://www.w3.org/2005/XQueryX" };
    }
  }
  function db(i, s, c, u, h) {
    if (typeof c == "string") return c.length === 0 ? null : s.createTextNode(c);
    if (!Array.isArray(c)) throw new TypeError("JsonML element should be an array or string");
    var g = lD(c[0], u);
    u = g.localName, g = g.lb;
    const b = s.createElementNS(g, ub[g] + ":" + u), x = c[1];
    var C = 1;
    if (typeof x == "object" && !Array.isArray(x)) {
      if (x !== null) for (var T of Object.keys(x)) C = x[T], C !== null && (T === "type" ? C !== void 0 && i.setAttributeNS(b, g, "fontoxpath:" + T, kt(C)) : (T !== "start" && T !== "end" && T !== "comment" || u !== "stackTrace" || (C = JSON.stringify(C)), h && T === "prefix" && C === "" || i.setAttributeNS(b, g, ub[g] + ":" + T, C)));
      C = 2;
    }
    for (let R = C, P = c.length; R < P; ++R) T = db(i, s, c[R], g, h), T !== null && i.insertBefore(b, T, null);
    return b;
  }
  function cD(i, s, c, u = Nd) {
    i = wp(i);
    let h;
    try {
      h = Ua(i, { Z: s.language === "XQuery3.1" || s.language === "XQueryUpdate3.1", debug: s.debug });
    } catch (C) {
      dn(i, C);
    }
    var g = new hc(s.namespaceResolver || (() => null), {}, s.defaultFunctionNamespaceURI === void 0 ? "http://www.w3.org/2005/xpath-functions" : s.defaultFunctionNamespaceURI, s.functionNameResolver || (() => null));
    g = new Ki(g);
    var b = F(h, ["mainModule", "libraryModule"]), x = F(b, "moduleDecl");
    if (x) {
      const C = Se(F(x, "prefix"));
      x = Se(F(x, "uri")), Ji(g, C, x);
    }
    return (b = F(b, "prolog")) && Up(b, g, !1, i), s.annotateAst !== !1 && Ky(h, new bc(g)), g = new si(), s = db(u, c, h, null, s.mc === !1), u.insertBefore(s, c.createComment(i), g.getFirstChild(s)), s;
  }
  function uD(i) {
    return Promise.resolve(i);
  }
  function dD(i, s = { debug: !1 }) {
    try {
      var c = Ua(i, { Z: !0, debug: s.debug });
    } catch (g) {
      dn(i, g);
    }
    if (Ky(c, new bc()), s = F(c, "libraryModule"), !s) throw Error("XQuery module must be declared in a library module.");
    c = F(s, "moduleDecl");
    var u = F(c, "uri");
    const h = Se(u);
    if (c = F(c, "prefix"), u = Se(c), c = new Ki(new hc(() => null, /* @__PURE__ */ Object.create(null), "http://www.w3.org/2005/xpath-functions", qp("http://www.w3.org/2005/xpath-functions"))), Ji(c, u, h), s = F(s, "prolog"), s !== null) {
      let g;
      try {
        g = Up(s, c, !0, i);
      } catch (b) {
        dn(i, b);
      }
      g.Ia.forEach(({ namespaceURI: b }) => {
        if (h !== b) throw Error("XQST0048: Functions and variables declared in a module must reside in the module target namespace.");
      }), L0(h, g);
    } else L0(h, { Ia: [], Ta: [], pa: null, source: i });
    return h;
  }
  const Zp = /* @__PURE__ */ new Map();
  function eh(i) {
    var s;
    e: {
      if (s = Ec.get(i)) {
        for (const c of Object.keys(s)) if (s[c] && s[c].length) {
          s = s[c][0].h;
          break e;
        }
      }
      s = null;
    }
    if (s) return s;
    if (Zp.has(i)) return Zp.get(i);
    if (s = typeof i == "string" ? Ua(i, { Z: !1 }) : Tc(i), s = oe(s, ["mainModule", "queryBody", "*"]), s === null) throw Error("Library modules do not have a specificity");
    return s = gp(s, { sa: !1, Z: !1 }), Zp.set(i, s), s;
  }
  function pD(i) {
    return eh(i).D();
  }
  function hD(i, s) {
    return dc(eh(i).o, eh(s).o);
  }
  var fD = new si();
  return typeof r < "u" && (r.compareSpecificity = hD, r.compileXPathToJavaScript = nD, r.domFacade = fD, r.evaluateXPath = ut, r.evaluateXPathToArray = kO, r.evaluateXPathToAsyncIterator = Vw, r.evaluateXPathToBoolean = AO, r.evaluateXPathToFirstNode = CO, r.evaluateXPathToMap = SO, r.evaluateXPathToNodes = EO, r.evaluateXPathToNumber = TO, r.evaluateXPathToNumbers = NO, r.evaluateXPathToString = BO, r.evaluateXPathToStrings = IO, r.evaluateUpdatingExpression = vO, r.evaluateUpdatingExpressionSync = xO, r.executeJavaScriptCompiledXPath = aD, r.executePendingUpdateList = MO, r.getBucketForSelector = pD, r.getBucketsForNode = Or, r.precompileXPath = uD, r.registerXQueryModule = dD, r.registerCustomXPathFunction = oD, r.parseScript = cD, r.profiler = wO, r.createTypedValueFactory = yO, r.finalizeModuleRegistration = Ra, r.Language = bO, r.ReturnType = ct), r;
}).call(typeof window > "u" ? void 0 : window, N_, tz);
We.compareSpecificity;
We.compileXPathToJavaScript;
We.createTypedValueFactory;
We.domFacade;
We.evaluateUpdatingExpression;
We.evaluateUpdatingExpressionSync;
const ag = We.evaluateXPath;
We.evaluateXPathToArray;
We.evaluateXPathToAsyncIterator;
We.evaluateXPathToBoolean;
const nz = We.evaluateXPathToFirstNode;
We.evaluateXPathToMap;
const bS = We.evaluateXPathToNodes;
We.evaluateXPathToNumber;
We.evaluateXPathToNumbers;
We.evaluateXPathToString;
We.evaluateXPathToStrings;
We.executeJavaScriptCompiledXPath;
We.executePendingUpdateList;
We.finalizeModuleRegistration;
We.getBucketForSelector;
We.getBucketsForNode;
We.Language;
We.parseScript;
We.precompileXPath;
We.profiler;
We.registerCustomXPathFunction;
const rz = We.registerXQueryModule;
We.ReturnType;
const iz = `xquery version '3.1';

module namespace jt = 'http://jinntec.de/jinntap';

declare namespace tei = 'http://www.tei-c.org/ns/1.0';

declare function jt:new-document () {
    <TEI xmlns="http://www.tei-c.org/ns/1.0">
        <teiHeader>
            <fileDesc>
                <titleStmt><title>Untitled Document</title></titleStmt>
                <publicationStmt><p>Information about publication or distribution</p></publicationStmt>
                <sourceDesc><p>Information about the source</p></sourceDesc>
            </fileDesc>
        </teiHeader>
        <text><body><div><p /></div></body></text>
        <standOff><listAnnotation /></standOff>
    </TEI>
};

declare function jt:import ($doc as node()) {
    let $xml := if (not($doc//tei:body)) then
        $doc//tei:text/node()
    else
        $doc//tei:body/node()
    return (
            jt:import($xml, false()),
            <tei-listAnnotation>
                { jt:import($doc//tei:standOff/tei:listAnnotation/tei:note, true()), jt:import($xml//tei:note, true()) }
            </tei-listAnnotation>
        )
};

declare %private function jt:transform-to-same-node ($node as node(), $importNotes as xs:boolean) as node()* {
    element {'tei-' || local-name($node)} {
        $node/@* except $node/@xml:id,
        if ($node/@xml:id) then
            attribute id { $node/@xml:id }
        else (
        ),
        jt:import($node/node(), $importNotes)
    }
};

declare function jt:import ($nodes as node()*, $importNotes as xs:boolean) {
    for $node in $nodes
    return typeswitch ($node)
            case element(tei:listAnnotation) return
                ()
            case element(tei:note) return
                if ($importNotes) then
                    <tei-note
                        n="{$node/@n}"
                        target="{
                            if ($node/@target) then
                                $node/@target
                            else (
                                '#' || generate-id($node)
                            )
                        }"
                        type="note"
                    >{ jt:import($node/node(), false()) }</tei-note>
                else
                    <tei-anchor
                        id="{
                            if ($node/@xml:id) then
                                $node/@xml:id
                            else
                                generate-id($node)
                        }" />
            case element(tei:cell) return
                (: If there is a pb element directly after the row, fold it into the first cell in the row :)
                let $preceding-pb := $node/../preceding-sibling::*[1][self::tei:pb]
                return if (empty($preceding-pb)) then (
                        jt:transform-to-same-node($node, $importNotes)
                    ) else (
                        <tei-cell>
                            { $node/@*, $preceding-pb, jt:import($node/node(), $importNotes) }
                        </tei-cell>
                    )
            case element(tei:pb) return
                if ($node/parent::tei:table) then (
                    (: Remove the pb element, it's folded into the row :)
                ) else (
                    jt:transform-to-same-node($node, $importNotes)
                )
            case element() return
                jt:transform-to-same-node($node, $importNotes)

            default return
                $node
};

declare function jt:export ($nodes as node()*, $input as document-node(), $meta as map(*)) {
    for $node in $nodes
    return typeswitch ($node)
            case document-node() return
                jt:export($node/node(), $input, $meta)
            case element(tei:TEI) return
                element {node-name($node)} {
                    $node/@*,
                    jt:export($node/tei:teiHeader, $input, $meta),
                    jt:export($node/tei:text, $input, $meta),
                    if (not($node/tei:standOff)) then
                        <standOff xmlns="http://www.tei-c.org/ns/1.0">{ $input//tei:listAnnotation }</standOff>
                    else (
                    ),
                    jt:export($node/tei:standOff, $input, $meta)
                }
            case element(tei:standOff) return
                element {node-name($node)} {
                    $node/@*, $node/* except $node/tei:listAnnotation, $input//tei:listAnnotation
                }
            case element(tei:body) return
                element {node-name($node)} {
                    $node/@*,
                    let $contents := $input/tei:body/node() except $input/tei:body/tei:listAnnotation
                    return jt:export($contents, $input, $meta)
                }
            case element(tei:title) return
                element {node-name($node)} {
                    $node/@*,
                    if ($node/ancestor::tei:titleStmt and map:contains($meta, 'title')) then
                        $meta?title
                    else
                        jt:export($node/node(), $input, $meta)
                }
            case element(tei:cell) return
                element {node-name($node)} {
                    (: Filter out rowspan and colspan. They are added while the TEI table is an HTML table :)
                    $node/@* except $node/(@colspan, @rowspan), jt:export($node/node(), $input, $meta)
                }
            case element() return
                element {node-name($node)} { $node/@*, jt:export($node/node(), $input, $meta) }

            default return
                $node
};
`;
rz(iz);
function Gf(n) {
  const e = typeof n == "string" ? rS(n) : n;
  if (!e) return "";
  const t = bS(
    `
            import module namespace jt="http://jinntec.de/jinntap";

            jt:import(.)
        `,
    e,
    null,
    null,
    {
      language: ag.XQUERY_3_1_LANGUAGE,
      // we want to create HTML, not XML nodes
      nodesFactory: document
    }
  ), r = [];
  return t.forEach((o) => {
    r.push(o.outerHTML);
  }), {
    content: r.join(""),
    doc: e
  };
}
function ok(n, e, t = {}) {
  if (!e) return n;
  const r = rS(`<body xmlns="http://www.tei-c.org/ns/1.0">${n}</body>`), o = bS(
    `
            import module namespace jt="http://jinntec.de/jinntap";

            jt:export($document, ., $meta)
        `,
    r,
    null,
    {
      document: e,
      meta: t
    },
    {
      language: ag.XQUERY_3_1_LANGUAGE
    }
  ), a = new XMLSerializer();
  return o.map((l) => a.serializeToString(l)).join("");
}
function sk() {
  const n = new DOMParser().parseFromString('<TEI xmlns="http://www.tei-c.org/ns/1.0"></TEI>', "application/xml"), e = nz(
    `
            import module namespace jt="http://jinntec.de/jinntap";

            jt:new-document()
        `,
    null,
    null,
    null,
    {
      language: ag.XQUERY_3_1_LANGUAGE,
      nodesFactory: n,
      debug: !0
    }
  );
  return Gf(e);
}
var Ps = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function oz(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var vS = {}, $o = {}, lg = {};
Object.defineProperty(lg, "__esModule", { value: !0 });
lg.default = [
  "abashed",
  "abbreviated",
  "abdominal",
  "abiding",
  "abject",
  "ablaze",
  "able",
  "able-bodied",
  "abnormal",
  "abominable",
  "aboriginal",
  "above",
  "abrasive",
  "abreast",
  "abrupt",
  "absent",
  "absolute",
  "absorbed",
  "absorbing",
  "abstract",
  "abundant",
  "academic",
  "accelerated",
  "accelerating",
  "acceptable",
  "accepted",
  "accessible",
  "accidental",
  "accompanying",
  "accomplished",
  "accountable",
  "accumulated",
  "accurate",
  "accursed",
  "accused",
  "accustomed",
  "aching",
  "acknowledged",
  "acoustic",
  "acquired",
  "acquisitive",
  "acrid",
  "acrimonious",
  "across-the-board",
  "acting",
  "active",
  "actual",
  "acute",
  "adamant",
  "adaptable",
  "adaptive",
  "added",
  "addictive",
  "additional",
  "additive",
  "adept",
  "adequate",
  "adhesive",
  "adjacent",
  "adjoining",
  "adjustable",
  "administrative",
  "admirable",
  "admiring",
  "admitting",
  "adolescent",
  "adopted",
  "adorable",
  "adoring",
  "adrenal",
  "adrift",
  "adroit",
  "adult",
  "advanced",
  "advancing",
  "advantageous",
  "adventurous",
  "adverse",
  "advisable",
  "advisory",
  "aesthetic",
  "affable",
  "affected",
  "affectionate",
  "affiliated",
  "affirmative",
  "afflicted",
  "affluent",
  "affordable",
  "afire",
  "afloat",
  "afraid",
  "aft",
  "after",
  "afterward",
  "aged",
  "ageless",
  "aggravated",
  "aggregate",
  "aghast",
  "agile",
  "aging",
  "agitated",
  "agonized",
  "agonizing",
  "agrarian",
  "agreeable",
  "agreed",
  "agricultural",
  "ailing",
  "aimless",
  "air-conditioned",
  "air-conditioning",
  "airborne",
  "airless",
  "airtight",
  "airy",
  "ajar",
  "akin",
  "alarmed",
  "alarming",
  "alert",
  "alien",
  "alienated",
  "alike",
  "alive",
  "all-american",
  "all-important",
  "all-night",
  "all-out",
  "all-powerful",
  "all-purpose",
  "all-time",
  "all-white",
  "alleged",
  "allegorical",
  "allergic",
  "allied",
  "allowable",
  "alluring",
  "almighty",
  "alone",
  "aloof",
  "alright",
  "altered",
  "alternate",
  "alternating",
  "alternative",
  "amateur",
  "amateurish",
  "amazed",
  "amazing",
  "amber",
  "ambiguous",
  "ambitious",
  "ambivalent",
  "amenable",
  "amiable",
  "amorous",
  "amorphous",
  "ample",
  "amused",
  "amusing",
  "anachronistic",
  "anal",
  "analogous",
  "analytic",
  "analytical",
  "anarchic",
  "anatomical",
  "ancestral",
  "ancient",
  "anemic",
  "anesthetic",
  "angelic",
  "angry",
  "anguished",
  "angular",
  "animated",
  "announced",
  "annoying",
  "annual",
  "anonymous",
  "answering",
  "antagonistic",
  "anterior",
  "anthropological",
  "anti",
  "anti-american",
  "anti-inflation",
  "anti-soviet",
  "anticipated",
  "antinuclear",
  "antiquated",
  "antique",
  "antiseptic",
  "antitank",
  "anxious",
  "apathetic",
  "apocalyptic",
  "apolitical",
  "appalled",
  "appalling",
  "apparent",
  "appealing",
  "appellate",
  "applicable",
  "applied",
  "appointed",
  "appreciable",
  "appreciative",
  "apprehensive",
  "approaching",
  "appropriate",
  "approved",
  "approximate",
  "apt",
  "aquatic",
  "arbitrary",
  "arcane",
  "arch",
  "archaeological",
  "archaic",
  "arched",
  "archetypal",
  "architectural",
  "arctic",
  "ardent",
  "arduous",
  "arid",
  "aristocratic",
  "armed",
  "armored",
  "arms-control",
  "aromatic",
  "arresting",
  "arterial",
  "artful",
  "articulate",
  "articulated",
  "artificial",
  "artistic",
  "ascending",
  "ascetic",
  "ascorbic",
  "ashamed",
  "ashen",
  "askew",
  "asleep",
  "aspiring",
  "assembled",
  "assertive",
  "assigned",
  "assistant",
  "associate",
  "associated",
  "assorted",
  "assumed",
  "assured",
  "astonished",
  "astonishing",
  "astounded",
  "astounding",
  "astronomical",
  "astute",
  "athletic",
  "atmospheric",
  "atomic",
  "atrocious",
  "attached",
  "attacking",
  "attainable",
  "attempted",
  "attendant",
  "attentive",
  "attracting",
  "attractive",
  "attributable",
  "auburn",
  "audacious",
  "audible",
  "audio",
  "auditory",
  "august",
  "auspicious",
  "austere",
  "authentic",
  "authoritarian",
  "authoritative",
  "authorized",
  "autobiographical",
  "autocratic",
  "automated",
  "automatic",
  "automotive",
  "autonomous",
  "autumnal",
  "auxiliary",
  "available",
  "avant-garde",
  "avenging",
  "average",
  "averse",
  "avid",
  "avowed",
  "awake",
  "aware",
  "awash",
  "away",
  "awed",
  "awesome",
  "back",
  "backhand",
  "backstage",
  "backward",
  "bacterial",
  "baffled",
  "baffling",
  "baggy",
  "baked",
  "balanced",
  "bald",
  "balding",
  "baleful",
  "ballistic",
  "balmy",
  "banal",
  "bankrupt",
  "banned",
  "barbarous",
  "barbed",
  "bare",
  "barefoot",
  "barefooted",
  "barred",
  "barren",
  "basic",
  "bass",
  "bathing",
  "battered",
  "beaded",
  "beaming",
  "bearable",
  "bearded",
  "beastly",
  "beautiful",
  "bedraggled",
  "beefy",
  "befuddled",
  "beguiling",
  "behavioral",
  "behind-the-scenes",
  "beige",
  "belated",
  "beleaguered",
  "believable",
  "belligerent",
  "beloved",
  "bemused",
  "beneficent",
  "beneficial",
  "benign",
  "bent",
  "bereaved",
  "bereft",
  "bespectacled",
  "best-known",
  "best-selling",
  "bestselling",
  "bewildered",
  "bewildering",
  "big",
  "big-city",
  "big-time",
  "bilateral",
  "bilingual",
  "binary",
  "binding",
  "biochemical",
  "biographical",
  "biological",
  "bipartisan",
  "biting",
  "bitter",
  "bittersweet",
  "bizarre",
  "black",
  "black-and-white",
  "black-haired",
  "blackened",
  "bland",
  "blank",
  "blasted",
  "blatant",
  "blazing",
  "bleached",
  "bleak",
  "bleary",
  "bleeding",
  "blessed",
  "blind",
  "blinding",
  "blinking",
  "blissful",
  "blistering",
  "bloated",
  "blocking",
  "blond",
  "blonde",
  "bloodied",
  "bloodshot",
  "bloodstained",
  "bloody",
  "blooming",
  "blue",
  "blue-and-white",
  "blue-black",
  "blue-chip",
  "blue-collar",
  "blue-eyed",
  "blue-gray",
  "blue-green",
  "bluish",
  "blunt",
  "blurred",
  "bodily",
  "bogus",
  "boiled",
  "boiling",
  "boisterous",
  "bold",
  "bony",
  "booming",
  "bored",
  "boring",
  "born",
  "born-again",
  "borrowed",
  "botanical",
  "bottled",
  "bottom",
  "bottomless",
  "bouncing",
  "bound",
  "boundless",
  "bountiful",
  "bourgeois",
  "bowed",
  "box-office",
  "boyish",
  "bracing",
  "braided",
  "branching",
  "brand-new",
  "brash",
  "brassy",
  "brave",
  "brawny",
  "brazen",
  "breathless",
  "breathtaking",
  "breezy",
  "bridal",
  "brief",
  "bright",
  "bright-eyed",
  "brilliant",
  "brisk",
  "brittle",
  "broad",
  "broad-shouldered",
  "broke",
  "broken",
  "bronchial",
  "brooding",
  "brotherly",
  "brown",
  "brownish",
  "bruised",
  "brusque",
  "brutal",
  "bubbling",
  "bubbly",
  "budding",
  "budgetary",
  "bulbous",
  "bulging",
  "bulky",
  "bulletproof",
  "bumper",
  "bumpy",
  "buoyant",
  "burdensome",
  "bureaucratic",
  "burgeoning",
  "buried",
  "burly",
  "burned",
  "burned-out",
  "burning",
  "burnished",
  "burnt",
  "bushy",
  "businesslike",
  "busing",
  "busted",
  "bustling",
  "busy",
  "button-down",
  "buxom",
  "buzzing",
  "bygone",
  "caged",
  "calculated",
  "called",
  "callous",
  "calm",
  "cancerous",
  "candid",
  "canned",
  "canny",
  "cantankerous",
  "capable",
  "capital",
  "capitalist",
  "capitalistic",
  "capricious",
  "captive",
  "cardboard",
  "cardiac",
  "cardinal",
  "cardiovascular",
  "carefree",
  "careful",
  "careless",
  "caring",
  "carnival",
  "carpeted",
  "carved",
  "cast",
  "cast-iron",
  "casual",
  "catastrophic",
  "causal",
  "caustic",
  "cautionary",
  "cautious",
  "cavernous",
  "ceaseless",
  "celebrated",
  "celestial",
  "cellular",
  "centennial",
  "central",
  "centralized",
  "centre-fire",
  "centrifugal",
  "centrist",
  "ceramic",
  "cerebral",
  "ceremonial",
  "certain",
  "certified",
  "challenging",
  "change-minimizing",
  "changed",
  "changing",
  "chaotic",
  "characteristic",
  "charged",
  "charging",
  "charismatic",
  "charitable",
  "charming",
  "charred",
  "chartered",
  "chaste",
  "chastened",
  "cheap",
  "checked",
  "checkered",
  "cheerful",
  "cheering",
  "cheery",
  "chemical",
  "cherished",
  "chief",
  "childlike",
  "chilled",
  "chilling",
  "chilly",
  "chipped",
  "chopped",
  "choppy",
  "choral",
  "chosen",
  "chronic",
  "chronological",
  "chunky",
  "cinematic",
  "circular",
  "circulating",
  "circulatory",
  "circumstantial",
  "citywide",
  "civic",
  "civil",
  "civilian",
  "civilized",
  "clammy",
  "clandestine",
  "classic",
  "classical",
  "classified",
  "classy",
  "clean",
  "clean-cut",
  "clear",
  "clear-cut",
  "cleared",
  "clearing",
  "clenched",
  "clerical",
  "clever",
  "climactic",
  "climatic",
  "clinging",
  "clinical",
  "clipped",
  "close",
  "closed",
  "closed-circuit",
  "closing",
  "cloudless",
  "cloudy",
  "clumsy",
  "cluttered",
  "coarse",
  "coastal",
  "cobbled",
  "coded",
  "coed",
  "coercive",
  "cognitive",
  "coherent",
  "cohesive",
  "coiled",
  "coincidental",
  "cold",
  "cold-blooded",
  "collaborative",
  "collapsing",
  "collected",
  "collective",
  "collegiate",
  "colonial",
  "colored",
  "colorful",
  "colorless",
  "colossal",
  "coloured",
  "comatose",
  "combative",
  "combined",
  "comely",
  "comfortable",
  "comforting",
  "comic",
  "comical",
  "coming",
  "commanding",
  "commendable",
  "commensurate",
  "commercial",
  "committed",
  "common",
  "commonplace",
  "communal",
  "compact",
  "comparable",
  "comparative",
  "compassionate",
  "compatible",
  "compelling",
  "compensatory",
  "competent",
  "competing",
  "competitive",
  "complacent",
  "complementary",
  "complete",
  "completed",
  "complex",
  "compliant",
  "complicated",
  "complimentary",
  "composite",
  "compositional",
  "comprehensible",
  "comprehensive",
  "compressed",
  "compulsory",
  "computerized",
  "concave",
  "concealed",
  "conceivable",
  "concentrated",
  "concentric",
  "conceptual",
  "concerned",
  "concerted",
  "conciliatory",
  "concise",
  "concluding",
  "conclusive",
  "concomitant",
  "concrete",
  "concurrent",
  "condemned",
  "condescending",
  "conditional",
  "conditioned",
  "conducive",
  "confident",
  "confidential",
  "confined",
  "confirmed",
  "conflicting",
  "confused",
  "confusing",
  "congenial",
  "congenital",
  "congested",
  "congressional",
  "conic",
  "conical",
  "connected",
  "connecting",
  "connective",
  "conquered",
  "conquering",
  "conscientious",
  "conscious",
  "consecutive",
  "consequent",
  "conservation",
  "conservative",
  "considerable",
  "considerate",
  "consistent",
  "consoling",
  "conspicuous",
  "conspiratorial",
  "constant",
  "constitutional",
  "constructive",
  "consular",
  "consulting",
  "consuming",
  "consummate",
  "contagious",
  "contaminated",
  "contemplative",
  "contemporary",
  "contemptible",
  "contemptuous",
  "contending",
  "content",
  "contented",
  "contentious",
  "contested",
  "continental",
  "contingent",
  "continual",
  "continued",
  "continuing",
  "continuous",
  "contraceptive",
  "contracting",
  "contractual",
  "contradictory",
  "contrary",
  "contrasting",
  "contributing",
  "contrite",
  "contrived",
  "controlled",
  "controlling",
  "controversial",
  "convenient",
  "conventional",
  "conversational",
  "converted",
  "convertible",
  "convicted",
  "convinced",
  "convincing",
  "convulsive",
  "cooked",
  "cool",
  "cooling",
  "cooperative",
  "coordinated",
  "copious",
  "cordial",
  "corned",
  "corny",
  "coronary",
  "corporate",
  "correct",
  "correctional",
  "corrective",
  "corresponding",
  "corrosive",
  "corrugated",
  "cosmetic",
  "cosmic",
  "cosmopolitan",
  "costly",
  "counterfeit",
  "counterproductive",
  "countless",
  "courageous",
  "court-ordered",
  "courteous",
  "courtly",
  "covered",
  "covert",
  "coveted",
  "coy",
  "cozy",
  "cracked",
  "cracking",
  "crackling",
  "crafty",
  "craggy",
  "cramped",
  "cranky",
  "crashing",
  "crass",
  "crawling",
  "crazed",
  "crazy",
  "creaking",
  "cream-colored",
  "creamy",
  "creased",
  "created",
  "creative",
  "credible",
  "creeping",
  "crimson",
  "crippled",
  "crisp",
  "critical",
  "cross-country",
  "cross-legged",
  "crossed",
  "crowded",
  "crucial",
  "crumbling",
  "crummy",
  "crumpled",
  "crushed",
  "crushing",
  "crusty",
  "cryptic",
  "crystalline",
  "cubic",
  "culinary",
  "cultivated",
  "cultural",
  "cultured",
  "cumbersome",
  "cumulative",
  "cunning",
  "cupped",
  "curious",
  "curled",
  "curly",
  "current",
  "cursory",
  "curt",
  "curtained",
  "curved",
  "curving",
  "customary",
  "cut-rate",
  "cute",
  "cutting",
  "cyclical",
  "cylindrical",
  "daily",
  "dainty",
  "damaged",
  "damn",
  "damned",
  "damp",
  "dangerous",
  "dank",
  "dapper",
  "daring",
  "dark",
  "dark-blue",
  "dark-eyed",
  "dark-haired",
  "darkened",
  "darkening",
  "darling",
  "darting",
  "dashing",
  "dated",
  "daunting",
  "day-care",
  "day-to-day",
  "dazed",
  "dazzling",
  "deaf",
  "deafening",
  "dear",
  "deathly",
  "debatable",
  "debilitating",
  "decadent",
  "decaying",
  "deceased",
  "decent",
  "decentralized",
  "decided",
  "decision-making",
  "decisive",
  "declared",
  "declining",
  "decorated",
  "decorative",
  "decorous",
  "decreased",
  "decreasing",
  "decrepit",
  "dedicated",
  "deductible",
  "deep",
  "deep-seated",
  "deepening",
  "defeated",
  "defenseless",
  "defensible",
  "defensive",
  "deferential",
  "deferred",
  "defiant",
  "deficient",
  "definite",
  "definitive",
  "deformed",
  "deft",
  "defunct",
  "degenerate",
  "degenerative",
  "dejected",
  "delayed",
  "delectable",
  "deliberate",
  "delicate",
  "delicious",
  "delighted",
  "delightful",
  "delinquent",
  "delirious",
  "demanding",
  "demeaning",
  "demented",
  "democratic",
  "demographic",
  "demonic",
  "demure",
  "dense",
  "dental",
  "departed",
  "departing",
  "departmental",
  "dependable",
  "dependent",
  "depleted",
  "deplorable",
  "deposed",
  "depressed",
  "derelict",
  "derisive",
  "descending",
  "descriptive",
  "deserted",
  "deserving",
  "designated",
  "desirable",
  "desired",
  "desolate",
  "despairing",
  "desperate",
  "despicable",
  "despised",
  "despondent",
  "destitute",
  "destructive",
  "desultory",
  "detached",
  "detailed",
  "detectable",
  "deteriorating",
  "determined",
  "determining",
  "detrimental",
  "devastating",
  "developed",
  "developing",
  "developmental",
  "deviant",
  "devious",
  "devoid",
  "devoted",
  "devout",
  "diagnostic",
  "diagonal",
  "dialectical",
  "dictatorial",
  "dietary",
  "different",
  "differential",
  "differing",
  "diffident",
  "diffuse",
  "digestive",
  "digging",
  "digital",
  "dignified",
  "dilapidated",
  "diligent",
  "dim",
  "diminished",
  "diminishing",
  "diminutive",
  "dingy",
  "diplomatic",
  "dire",
  "direct",
  "disabled",
  "disappearing",
  "disappointing",
  "disapproving",
  "disastrous",
  "discarded",
  "discernible",
  "discerning",
  "disciplinary",
  "disciplined",
  "disconcerting",
  "discontented",
  "discordant",
  "discouraging",
  "discredited",
  "discreet",
  "discrete",
  "discretionary",
  "discriminatory",
  "disembodied",
  "disenchanted",
  "disguised",
  "disjointed",
  "dismayed",
  "disorderly",
  "disorganized",
  "disoriented",
  "disparate",
  "displaced",
  "displeased",
  "disposable",
  "disproportionate",
  "disputed",
  "disquieting",
  "disreputable",
  "disruptive",
  "dissenting",
  "dissident",
  "dissimilar",
  "distant",
  "distinct",
  "distinctive",
  "distinguishable",
  "distinguished",
  "distinguishing",
  "distorted",
  "distraught",
  "distressed",
  "distressing",
  "disturbed",
  "disturbing",
  "divergent",
  "diverse",
  "diversified",
  "divided",
  "dividing",
  "divine",
  "diving",
  "divisional",
  "divisive",
  "dizzy",
  "dizzying",
  "do-it-yourself",
  "docile",
  "doctoral",
  "doctrinaire",
  "doctrinal",
  "dogged",
  "dogmatic",
  "domed",
  "domestic",
  "doomed",
  "door-to-door",
  "dormant",
  "double",
  "double-action",
  "double-breasted",
  "double-digit",
  "doubtful",
  "dour",
  "down",
  "down-to-earth",
  "downcast",
  "downhill",
  "downright",
  "downtown",
  "downward",
  "drab",
  "drained",
  "dramatic",
  "drastic",
  "dreaded",
  "dreamlike",
  "dreamy",
  "dreary",
  "dried",
  "driven",
  "driving",
  "droll",
  "drooping",
  "drowning",
  "drowsy",
  "drugged",
  "drunken",
  "dry",
  "dual",
  "dubious",
  "due",
  "dull",
  "duplicate",
  "durable",
  "dusky",
  "dusty",
  "dutiful",
  "dwindling",
  "dyed",
  "dying",
  "dynamic",
  "dynastic",
  "eager",
  "early",
  "early-morning",
  "earned",
  "earnest",
  "earthen",
  "earthly",
  "earthy",
  "eastern",
  "easy",
  "easygoing",
  "ebullient",
  "eccentric",
  "ecclesiastical",
  "echoing",
  "eclectic",
  "ecological",
  "economic",
  "economical",
  "ecstatic",
  "ecumenical",
  "edgy",
  "edible",
  "editorial",
  "educated",
  "educational",
  "eerie",
  "effective",
  "efficient",
  "effortless",
  "egalitarian",
  "eight-hour",
  "eight-year",
  "eighteenth-century",
  "elaborate",
  "elastic",
  "elated",
  "elderly",
  "elected",
  "elective",
  "electoral",
  "electric",
  "electrical",
  "electromagnetic",
  "electronic",
  "electrostatic",
  "elegant",
  "elemental",
  "elementary",
  "elevated",
  "eligible",
  "elitist",
  "elongated",
  "eloquent",
  "elusive",
  "embarrassed",
  "embarrassing",
  "embattled",
  "emblematic",
  "embroidered",
  "embryonic",
  "emerging",
  "emeritus",
  "eminent",
  "emotional",
  "emphatic",
  "empirical",
  "empty",
  "empty-handed",
  "enchanted",
  "enchanting",
  "enclosed",
  "encouraging",
  "endangered",
  "endearing",
  "endemic",
  "endless",
  "enduring",
  "energetic",
  "enforced",
  "engaged",
  "engaging",
  "engraved",
  "enhanced",
  "enigmatic",
  "enjoyable",
  "enlarged",
  "enlightened",
  "enormous",
  "enraged",
  "enriched",
  "ensconced",
  "ensuing",
  "enterprising",
  "entertaining",
  "enthusiastic",
  "enticing",
  "entire",
  "entrenched",
  "entrepreneurial",
  "enviable",
  "envious",
  "environmental",
  "ephemeral",
  "epic",
  "equal",
  "equatorial",
  "equestrian",
  "equitable",
  "equivalent",
  "eroding",
  "errant",
  "erratic",
  "erroneous",
  "ersatz",
  "erstwhile",
  "escalating",
  "escaping",
  "esoteric",
  "essential",
  "established",
  "esteemed",
  "esthetic",
  "estimated",
  "estranged",
  "eternal",
  "ethereal",
  "ethical",
  "eucalyptus",
  "euphoric",
  "evangelical",
  "evasive",
  "even",
  "eventual",
  "ever-increasing",
  "ever-present",
  "everlasting",
  "everyday",
  "evident",
  "evocative",
  "evolutionary",
  "exact",
  "exacting",
  "exaggerated",
  "exalted",
  "excellent",
  "exceptional",
  "excess",
  "excessive",
  "excited",
  "exciting",
  "exclusive",
  "excruciating",
  "executive",
  "exemplary",
  "exempt",
  "exhausted",
  "exhausting",
  "exhaustive",
  "exhilarated",
  "exhilarating",
  "exiled",
  "existential",
  "existing",
  "exorbitant",
  "exotic",
  "expanded",
  "expanding",
  "expansive",
  "expectant",
  "expected",
  "expedient",
  "expendable",
  "expensive",
  "experienced",
  "experimental",
  "expert",
  "explanatory",
  "explicit",
  "exploratory",
  "explosive",
  "exposed",
  "express",
  "expressed",
  "expressionless",
  "expressive",
  "exquisite",
  "extant",
  "extended",
  "extensive",
  "exterior",
  "external",
  "extinct",
  "extra",
  "extracurricular",
  "extraneous",
  "extraordinary",
  "extravagant",
  "extreme",
  "extremist",
  "extrinsic",
  "exuberant",
  "exultant",
  "fabled",
  "fabulous",
  "face-to-face",
  "faceless",
  "facial",
  "facile",
  "factional",
  "factual",
  "faded",
  "fading",
  "failed",
  "failing",
  "faint",
  "fair",
  "faithful",
  "fallen",
  "falling",
  "fallow",
  "false",
  "faltering",
  "famed",
  "familial",
  "familiar",
  "famished",
  "famous",
  "fanatical",
  "fanciful",
  "fancy",
  "fantastic",
  "far-flung",
  "far-off",
  "far-reaching",
  "farcical",
  "farfetched",
  "fascinated",
  "fascinating",
  "fascist",
  "fashionable",
  "fast",
  "fast-food",
  "fast-growing",
  "fast-moving",
  "fastidious",
  "fatal",
  "fated",
  "fateful",
  "fatherly",
  "fatty",
  "fatuous",
  "faulty",
  "favorable",
  "favored",
  "favorite",
  "favourable",
  "favourite",
  "feal",
  "fearful",
  "fearless",
  "fearsome",
  "feasible",
  "feathered",
  "feathery",
  "featureless",
  "federal",
  "feeble",
  "feeding",
  "feisty",
  "fellow",
  "feminine",
  "ferocious",
  "fervent",
  "festive",
  "fetal",
  "fetid",
  "feudal",
  "feverish",
  "fickle",
  "fictional",
  "fictitious",
  "fierce",
  "fiery",
  "figurative",
  "filmy",
  "final",
  "financial",
  "fine",
  "finished",
  "finishing",
  "finite",
  "firm",
  "first-aid",
  "first-class",
  "first-quarter",
  "first-rate",
  "first-time",
  "first-year",
  "firsthand",
  "fiscal",
  "fishy",
  "fit",
  "fitful",
  "fitting",
  "five-day",
  "five-minute",
  "five-year",
  "fixed",
  "flabbergasted",
  "flabby",
  "flagrant",
  "flailing",
  "flaky",
  "flamboyant",
  "flaming",
  "flash",
  "flashing",
  "flashy",
  "flat",
  "flattened",
  "flattered",
  "flattering",
  "flawless",
  "fledgling",
  "fleeing",
  "fleeting",
  "fleshy",
  "flexible",
  "flickering",
  "flimsy",
  "flipping",
  "floating",
  "floppy",
  "floral",
  "florid",
  "flourishing",
  "flowered",
  "flowering",
  "flowery",
  "flowing",
  "fluent",
  "fluffy",
  "fluorescent",
  "flushed",
  "flustered",
  "fluted",
  "fluttering",
  "flying",
  "foaming",
  "focal",
  "foggy",
  "folded",
  "folding",
  "follow-up",
  "following",
  "fond",
  "foolhardy",
  "foolish",
  "forbidding",
  "forced",
  "forceful",
  "foregoing",
  "foreign",
  "foreign-policy",
  "forensic",
  "foreseeable",
  "forested",
  "forged",
  "forgiving",
  "forgotten",
  "forlorn",
  "formal",
  "formative",
  "formidable",
  "formless",
  "forthcoming",
  "forthright",
  "fortified",
  "fortuitous",
  "fortunate",
  "forward",
  "foster",
  "foul",
  "founding",
  "four-day",
  "four-hour",
  "four-year",
  "fourth-quarter",
  "fractured",
  "fragmentary",
  "fragmented",
  "fragrant",
  "frail",
  "framed",
  "frank",
  "frantic",
  "fraternal",
  "fraudulent",
  "fraught",
  "frayed",
  "freak",
  "freckled",
  "free",
  "free-lance",
  "freezing",
  "french",
  "frenetic",
  "frenzied",
  "frequent",
  "fresh",
  "freshwater",
  "fretful",
  "friendly",
  "frightened",
  "frightening",
  "frightful",
  "frigid",
  "fringed",
  "frivolous",
  "front",
  "front-line",
  "front-page",
  "frontal",
  "frosted",
  "frosty",
  "frozen",
  "fruitful",
  "fruitless",
  "frustrated",
  "frustrating",
  "full",
  "full-blown",
  "full-fledged",
  "full-length",
  "full-page",
  "full-scale",
  "full-size",
  "full-time",
  "fun",
  "functional",
  "functioning",
  "fund-raising",
  "fundamental",
  "fundamentalist",
  "funded",
  "funky",
  "funny",
  "furious",
  "furnished",
  "furry",
  "furtive",
  "fussy",
  "futile",
  "future",
  "futuristic",
  "fuzzy",
  "galactic",
  "gallant",
  "galloping",
  "galvanized",
  "gaping",
  "garbled",
  "gargantuan",
  "garish",
  "garrulous",
  "gaseous",
  "gastrointestinal",
  "gathered",
  "gaudy",
  "gaunt",
  "gebling",
  "general",
  "generalized",
  "generating",
  "generative",
  "generic",
  "generous",
  "genetic",
  "genital",
  "genteel",
  "gentle",
  "gentlemanly",
  "genuine",
  "geographic",
  "geographical",
  "geological",
  "geometric",
  "geopolitical",
  "ghastly",
  "ghostly",
  "giant",
  "gibberish",
  "giddy",
  "gifted",
  "gigantic",
  "gilded",
  "ginger",
  "girlish",
  "given",
  "glacial",
  "glad",
  "glamorous",
  "glaring",
  "glassy",
  "glazed",
  "gleaming",
  "gleeful",
  "glib",
  "glistening",
  "glittering",
  "global",
  "gloomy",
  "glorious",
  "glossy",
  "gloved",
  "glowing",
  "glum",
  "gnarled",
  "goddam",
  "goddamn",
  "goddamned",
  "going",
  "gold",
  "golden",
  "good",
  "good-by",
  "good-looking",
  "good-natured",
  "good-sized",
  "goodly",
  "gorgeous",
  "gory",
  "governing",
  "governmental",
  "graceful",
  "gracious",
  "gradual",
  "grainy",
  "grammatical",
  "grand",
  "grandiose",
  "graphic",
  "grassy",
  "grateful",
  "gratifying",
  "grating",
  "gratuitous",
  "grave",
  "gravitational",
  "gray",
  "gray-haired",
  "graying",
  "grayish",
  "grazing",
  "greasy",
  "great",
  "greedy",
  "green",
  "greenish",
  "gregarious",
  "grey",
  "grieving",
  "grievous",
  "grilled",
  "grim",
  "grimy",
  "grinding",
  "grinning",
  "gripping",
  "grisly",
  "gritty",
  "grizzled",
  "grizzly",
  "groggy",
  "grotesque",
  "ground",
  "ground-floor",
  "growing",
  "grown-up",
  "grubby",
  "grudging",
  "grueling",
  "gruesome",
  "gruff",
  "guaranteed",
  "guarded",
  "gubernatorial",
  "guided",
  "guiding",
  "gullible",
  "guttural",
  "habitual",
  "haggard",
  "hairless",
  "hairy",
  "half-empty",
  "halfway",
  "hallowed",
  "halting",
  "hand-held",
  "hand-to-hand",
  "handicapped",
  "handmade",
  "handsome",
  "handwritten",
  "handy",
  "hanging",
  "haphazard",
  "hapless",
  "happy",
  "hard",
  "hard-boiled",
  "hard-core",
  "hard-line",
  "hard-nosed",
  "hard-pressed",
  "hard-working",
  "hardened",
  "hardworking",
  "hardy",
  "harmless",
  "harmonious",
  "harried",
  "harrowing",
  "harsh",
  "hashish",
  "hasty",
  "hated",
  "hateful",
  "haughty",
  "haunted",
  "haunting",
  "hawkish",
  "hazardous",
  "hazel",
  "hazy",
  "head",
  "headlong",
  "heady",
  "healing",
  "healthful",
  "healthy",
  "heart-shaped",
  "heartbreaking",
  "heartening",
  "heartfelt",
  "heartless",
  "hearty",
  "heated",
  "heathen",
  "heavenly",
  "heavy",
  "heavy-duty",
  "hectic",
  "heedless",
  "hefty",
  "heightened",
  "helmeted",
  "helpful",
  "hereditary",
  "heretical",
  "heroic",
  "hesitant",
  "heterogeneous",
  "hidden",
  "hierarchical",
  "high",
  "high-ceilinged",
  "high-fiber",
  "high-heeled",
  "high-level",
  "high-pitched",
  "high-powered",
  "high-pressure",
  "high-priced",
  "high-quality",
  "high-ranking",
  "high-rise",
  "high-risk",
  "high-school",
  "high-speed",
  "high-tech",
  "high-technology",
  "hilarious",
  "hilly",
  "hind",
  "hired",
  "historic",
  "historical",
  "hit-and-run",
  "hoarse",
  "holding",
  "hollow",
  "holy",
  "homeless",
  "homemade",
  "homesick",
  "honest",
  "honorable",
  "honorary",
  "honored",
  "hooded",
  "hopeful",
  "hopeless",
  "horizontal",
  "hormonal",
  "horn-rimmed",
  "horrendous",
  "horrible",
  "horrid",
  "horrified",
  "horse-drawn",
  "hospitable",
  "hot",
  "hour-long",
  "hourly",
  "howling",
  "huge",
  "hulking",
  "human",
  "humane",
  "humanistic",
  "humanitarian",
  "humble",
  "humid",
  "humiliating",
  "humorless",
  "humorous",
  "hunched",
  "hungry",
  "hunted",
  "hurried",
  "hurt",
  "hurtful",
  "hushed",
  "husky",
  "hybrid",
  "hydraulic",
  "hydroelectric",
  "hypnotic",
  "hypodermic",
  "hypothetical",
  "hysterical",
  "ice-cold",
  "iced",
  "icy",
  "ideal",
  "idealistic",
  "identical",
  "identifiable",
  "ideological",
  "idiosyncratic",
  "idiotic",
  "idle",
  "idyllic",
  "ignorant",
  "ill",
  "ill-advised",
  "ill-fated",
  "ill-fitting",
  "illegitimate",
  "illicit",
  "illiterate",
  "illogical",
  "illuminated",
  "illuminating",
  "illusory",
  "illustrated",
  "illustrious",
  "imaginable",
  "imaginary",
  "imaginative",
  "imagined",
  "immaculate",
  "immediate",
  "immense",
  "imminent",
  "immobile",
  "immortal",
  "immune",
  "immutable",
  "impartial",
  "impassable",
  "impassioned",
  "impassive",
  "impatient",
  "impeccable",
  "impending",
  "impenetrable",
  "imperative",
  "imperceptible",
  "imperial",
  "imperialist",
  "imperious",
  "impersonal",
  "impertinent",
  "impervious",
  "impetuous",
  "implacable",
  "implausible",
  "implicit",
  "implied",
  "important",
  "imported",
  "imposing",
  "impossible",
  "impoverished",
  "impractical",
  "imprecise",
  "impressed",
  "impressive",
  "imprisoned",
  "improbable",
  "impromptu",
  "improper",
  "improved",
  "improving",
  "improvised",
  "impulsive",
  "impure",
  "in-depth",
  "in-house",
  "inaccessible",
  "inactive",
  "inane",
  "inanimate",
  "inarticulate",
  "inaudible",
  "incalculable",
  "incandescent",
  "incapable",
  "incendiary",
  "incessant",
  "incidental",
  "incipient",
  "incisive",
  "inclined",
  "inclusive",
  "incoherent",
  "income-tax",
  "incoming",
  "incomparable",
  "incompatible",
  "incompetent",
  "incomplete",
  "incomprehensible",
  "inconceivable",
  "inconclusive",
  "incongruous",
  "inconsequential",
  "inconsistent",
  "inconspicuous",
  "incorrect",
  "increased",
  "increasing",
  "incredible",
  "incredulous",
  "incremental",
  "incriminating",
  "incumbent",
  "incurable",
  "indebted",
  "indefatigable",
  "indefinite",
  "indelible",
  "independent",
  "indestructible",
  "indeterminate",
  "indicative",
  "indifferent",
  "indigenous",
  "indigent",
  "indignant",
  "indirect",
  "indiscriminate",
  "indispensable",
  "indistinct",
  "indistinguishable",
  "individual",
  "individualistic",
  "indomitable",
  "indoor",
  "indulgent",
  "industrial",
  "industrialized",
  "industrious",
  "ineffable",
  "ineffective",
  "ineffectual",
  "inept",
  "inert",
  "inescapable",
  "inevitable",
  "inexhaustible",
  "inexorable",
  "inexpensive",
  "inexperienced",
  "inexplicable",
  "infallible",
  "infamous",
  "infantile",
  "infatuated",
  "infected",
  "infectious",
  "infernal",
  "infinite",
  "infirm",
  "inflamed",
  "inflammatory",
  "inflated",
  "inflationary",
  "inflexible",
  "influential",
  "informal",
  "informative",
  "informed",
  "infrared",
  "infrequent",
  "ingenious",
  "ingratiating",
  "inherent",
  "inherited",
  "inhospitable",
  "inimical",
  "initial",
  "injured",
  "inlaid",
  "inland",
  "innate",
  "inner",
  "inner-city",
  "innermost",
  "innocent",
  "innocuous",
  "innovative",
  "innumerable",
  "inordinate",
  "inorganic",
  "inquisitive",
  "insane",
  "inscrutable",
  "insensitive",
  "inside",
  "insignificant",
  "insistent",
  "insoluble",
  "inspirational",
  "inspired",
  "inspiring",
  "instant",
  "instantaneous",
  "instinctive",
  "institutional",
  "institutionalized",
  "instructional",
  "instructive",
  "instrumental",
  "insufferable",
  "insulated",
  "insurgent",
  "insurmountable",
  "intact",
  "intangible",
  "integral",
  "integrated",
  "intellectual",
  "intelligent",
  "intelligible",
  "intended",
  "intense",
  "intensified",
  "intensive",
  "intent",
  "intentional",
  "inter",
  "interchangeable",
  "intercontinental",
  "interdependent",
  "interested",
  "interesting",
  "interim",
  "interior",
  "interlocking",
  "intermediate",
  "intermediate-range",
  "interminable",
  "intermittent",
  "internal",
  "international",
  "interpersonal",
  "interrelated",
  "interstate",
  "interstellar",
  "intervening",
  "intimidating",
  "intolerable",
  "intolerant",
  "intractable",
  "intransigent",
  "intravenous",
  "intrepid",
  "intricate",
  "intriguing",
  "intrinsic",
  "introductory",
  "intrusive",
  "intuitive",
  "invading",
  "invalid",
  "invaluable",
  "inventive",
  "inverted",
  "investigative",
  "investing",
  "invigorating",
  "invincible",
  "invisible",
  "inviting",
  "involuntary",
  "involved",
  "invulnerable",
  "inward",
  "irate",
  "iridescent",
  "ironic",
  "irrational",
  "irregular",
  "irrelevant",
  "irreparable",
  "irreplaceable",
  "irrepressible",
  "irresistible",
  "irresponsible",
  "irreverent",
  "irreversible",
  "irrevocable",
  "irritable",
  "irritated",
  "irritating",
  "isolated",
  "issuing",
  "itinerant",
  "jaded",
  "jagged",
  "jaunty",
  "jerky",
  "jeweled",
  "jittery",
  "joint",
  "jolly",
  "journalistic",
  "jovial",
  "joyful",
  "joyous",
  "jubilant",
  "judicial",
  "judicious",
  "juicy",
  "jumbo",
  "jumping",
  "jumpy",
  "junior",
  "just",
  "justifiable",
  "justified",
  "keen",
  "khaki",
  "kind",
  "kindly",
  "kindred",
  "kinetic",
  "kinky",
  "knitted",
  "knotted",
  "knowing",
  "knowledgeable",
  "known",
  "kosher",
  "labored",
  "laborious",
  "laconic",
  "lacy",
  "lame",
  "land-based",
  "landed",
  "landless",
  "languid",
  "lanky",
  "large",
  "large-scale",
  "lascivious",
  "last-minute",
  "lasting",
  "late",
  "late-night",
  "latent",
  "lateral",
  "latter-day",
  "laughable",
  "laughing",
  "lavish",
  "law-abiding",
  "law-enforcement",
  "lawful",
  "lawless",
  "lax",
  "lay",
  "lazy",
  "leaded",
  "leaden",
  "leading",
  "leafless",
  "leafy",
  "leaky",
  "lean",
  "learned",
  "leathery",
  "leery",
  "left",
  "left-hand",
  "left-handed",
  "left-wing",
  "leftover",
  "legal",
  "legendary",
  "legislative",
  "legitimate",
  "leisurely",
  "lengthy",
  "lenient",
  "lesser",
  "lethal",
  "level",
  "leveraged",
  "lexical",
  "liable",
  "liberal",
  "liberated",
  "liberating",
  "licensed",
  "life-size",
  "lifeless",
  "lifelong",
  "light",
  "lighted",
  "lightweight",
  "likable",
  "like",
  "likely",
  "limited",
  "limiting",
  "limitless",
  "limp",
  "linear",
  "lined",
  "lingering",
  "linguistic",
  "linked",
  "liquid",
  "listed",
  "listening",
  "listless",
  "literal",
  "literary",
  "literate",
  "lithe",
  "little",
  "little-known",
  "liturgical",
  "live",
  "lively",
  "livid",
  "living",
  "living-room",
  "loaded",
  "loathsome",
  "local",
  "locked",
  "lofty",
  "logical",
  "logistical",
  "lone",
  "lonely",
  "lonesome",
  "long",
  "long-awaited",
  "long-distance",
  "long-haired",
  "long-legged",
  "long-lost",
  "long-range",
  "long-running",
  "long-standing",
  "long-term",
  "long-time",
  "longstanding",
  "longterm",
  "longtime",
  "looking",
  "looming",
  "loose",
  "lopsided",
  "lordly",
  "losing",
  "loud",
  "lousy",
  "lovable",
  "loved",
  "lovely",
  "loving",
  "low",
  "low-cost",
  "low-income",
  "low-key",
  "low-level",
  "lower-class",
  "lowered",
  "lowly",
  "loyal",
  "lucid",
  "lucky",
  "lucrative",
  "ludicrous",
  "lukewarm",
  "lumbering",
  "luminous",
  "lunar",
  "lunatic",
  "lurid",
  "lurking",
  "luscious",
  "lush",
  "luxuriant",
  "luxurious",
  "luxury",
  "lyric",
  "lyrical",
  "macabre",
  "machine-gun",
  "macho",
  "mad",
  "magic",
  "magical",
  "magnetic",
  "magnificent",
  "maiden",
  "maimed",
  "main",
  "mainstream",
  "majestic",
  "major",
  "makeshift",
  "malevolent",
  "malignant",
  "mammoth",
  "man-made",
  "manageable",
  "managerial",
  "managing",
  "mandatory",
  "maniacal",
  "manic",
  "manicured",
  "manifest",
  "manifold",
  "manipulative",
  "manly",
  "manned",
  "manual",
  "manufactured",
  "marching",
  "marginal",
  "marine",
  "maritime",
  "marked",
  "marketable",
  "maroon",
  "married",
  "marshy",
  "martial",
  "marvellous",
  "marvelous",
  "masculine",
  "mashed",
  "masked",
  "mass",
  "mass-produced",
  "massed",
  "massive",
  "masterful",
  "masterly",
  "matched",
  "matching",
  "material",
  "materialistic",
  "maternal",
  "mathematical",
  "mating",
  "matter-of-fact",
  "mature",
  "maudlin",
  "mauve",
  "maximum",
  "mayoral",
  "meager",
  "meaningful",
  "meaningless",
  "measurable",
  "measured",
  "measuring",
  "meaty",
  "mechanical",
  "mechanized",
  "median",
  "medical",
  "medicinal",
  "medieval",
  "mediocre",
  "meditative",
  "medium",
  "medium-size",
  "medium-sized",
  "meek",
  "melancholy",
  "mellow",
  "melodic",
  "melodramatic",
  "melted",
  "memorable",
  "menacing",
  "menial",
  "mental",
  "mercantile",
  "merciful",
  "merciless",
  "mercurial",
  "mere",
  "merry",
  "messy",
  "metabolic",
  "metallic",
  "metaphoric",
  "metaphorical",
  "metaphysical",
  "methodical",
  "methodological",
  "meticulous",
  "metric",
  "metropolitan",
  "microscopic",
  "middle",
  "middle-aged",
  "middle-class",
  "middle-income",
  "midwestern",
  "mighty",
  "migratory",
  "mild",
  "mild-mannered",
  "militant",
  "military",
  "military-industrial",
  "milky",
  "million-dollar",
  "mindful",
  "mindless",
  "mingled",
  "miniature",
  "minimal",
  "minimum",
  "ministerial",
  "mint",
  "minuscule",
  "minute",
  "miraculous",
  "mirrored",
  "miscellaneous",
  "mischievous",
  "misguided",
  "misleading",
  "misplaced",
  "missed",
  "misshapen",
  "missing",
  "mistaken",
  "misty",
  "mixed",
  "mobile",
  "mock",
  "mocking",
  "moderate",
  "modern",
  "modern-day",
  "modernist",
  "modest",
  "modified",
  "moist",
  "molecular",
  "molten",
  "momentary",
  "momentous",
  "monastic",
  "monetary",
  "monogrammed",
  "monolithic",
  "monotonous",
  "monstrous",
  "monthly",
  "monumental",
  "moody",
  "moonlit",
  "moot",
  "moral",
  "morbid",
  "morose",
  "mortal",
  "mossy",
  "motionless",
  "motivated",
  "motley",
  "mottled",
  "mountainous",
  "mounted",
  "mounting",
  "mournful",
  "movable",
  "moving",
  "muddled",
  "muddy",
  "muffled",
  "multicolored",
  "multilateral",
  "multinational",
  "multiple",
  "mundane",
  "municipal",
  "murdered",
  "murderous",
  "murky",
  "muscular",
  "mushy",
  "musical",
  "musty",
  "mute",
  "muted",
  "mutilated",
  "mutual",
  "mysterious",
  "mystic",
  "mystical",
  "mystified",
  "mythic",
  "mythical",
  "mythological",
  "nagging",
  "naive",
  "named",
  "nameless",
  "narrative",
  "narrow",
  "nasal",
  "national",
  "nationalist",
  "nationalistic",
  "nationalized",
  "nationwide",
  "native",
  "natural",
  "naturalistic",
  "nauseous",
  "nautical",
  "naval",
  "near",
  "nearby",
  "neat",
  "nebulous",
  "necessary",
  "needful",
  "needless",
  "needy",
  "negative",
  "negligent",
  "negligible",
  "negotiable",
  "negotiated",
  "neighboring",
  "nervous",
  "neural",
  "neurological",
  "neurotic",
  "neutral",
  "never-ending",
  "new",
  "new-found",
  "newborn",
  "newfound",
  "newsworthy",
  "next-door",
  "nice",
  "nightly",
  "nightmarish",
  "nimble",
  "nineteenth-century",
  "no-fault",
  "no-nonsense",
  "noble",
  "nocturnal",
  "noisy",
  "nomadic",
  "nominal",
  "non-communist",
  "nonaligned",
  "nondescript",
  "nonexistent",
  "nonpartisan",
  "nonpolitical",
  "nonprofit",
  "nonstop",
  "normal",
  "normative",
  "northeastern",
  "northern",
  "northwestern",
  "nostalgic",
  "notable",
  "noted",
  "noteworthy",
  "noticeable",
  "notorious",
  "novel",
  "noxious",
  "nuclear",
  "numb",
  "numbered",
  "numerical",
  "numerous",
  "nursing",
  "nutritional",
  "nutritious",
  "nuts",
  "nutty",
  "obedient",
  "obese",
  "objectionable",
  "objective",
  "obligatory",
  "obliging",
  "oblique",
  "oblivious",
  "obnoxious",
  "obscure",
  "observable",
  "observant",
  "observed",
  "obsessive",
  "obsolete",
  "obstinate",
  "obvious",
  "occasional",
  "occupational",
  "occupied",
  "octagonal",
  "odd",
  "odious",
  "off",
  "off-duty",
  "offbeat",
  "offending",
  "offhand",
  "official",
  "offshore",
  "oil-producing",
  "oil-rich",
  "oily",
  "old",
  "old-fashioned",
  "old-line",
  "old-time",
  "olive",
  "ominous",
  "omnipotent",
  "omnipresent",
  "oncoming",
  "one-day",
  "one-man",
  "one-party",
  "one-room",
  "one-sided",
  "one-story",
  "one-time",
  "one-way",
  "one-year",
  "onerous",
  "onetime",
  "ongoing",
  "only",
  "onstage",
  "opaque",
  "open",
  "open-air",
  "open-ended",
  "opened",
  "operatic",
  "operational",
  "operative",
  "opposing",
  "opposite",
  "oppressed",
  "optical",
  "optimal",
  "optimistic",
  "optimum",
  "optional",
  "opulent",
  "orange",
  "orbital",
  "orchestral",
  "ordered",
  "orderly",
  "ordinary",
  "organic",
  "organizational",
  "organized",
  "organizing",
  "oriental",
  "original",
  "ornamental",
  "ornate",
  "orphaned",
  "orthodox",
  "orthopedic",
  "ostensible",
  "ostentatious",
  "other",
  "out-of-town",
  "outdated",
  "outdoor",
  "outer",
  "outgoing",
  "outlandish",
  "outlawed",
  "outlying",
  "outmoded",
  "outraged",
  "outrageous",
  "outright",
  "outside",
  "outspoken",
  "outstanding",
  "outstretched",
  "outward",
  "oval",
  "over-all",
  "over-the-counter",
  "overall",
  "overcast",
  "overcome",
  "overcrowded",
  "overdue",
  "overgrown",
  "overhanging",
  "overhead",
  "overheated",
  "overjoyed",
  "overlapping",
  "overnight",
  "overpowering",
  "overriding",
  "overseas",
  "oversized",
  "overstuffed",
  "overt",
  "overturned",
  "overweight",
  "overwhelming",
  "overworked",
  "packaged",
  "packed",
  "padded",
  "paid",
  "pained",
  "painful",
  "painless",
  "painstaking",
  "painted",
  "palatable",
  "palatial",
  "pale",
  "pallid",
  "palpable",
  "paltry",
  "panicky",
  "papal",
  "paradoxical",
  "parallel",
  "paralyzed",
  "paramilitary",
  "paramount",
  "paranoid",
  "parasitic",
  "parched",
  "parental",
  "parked",
  "parliamentary",
  "parochial",
  "part-time",
  "partial",
  "participating",
  "participatory",
  "particular",
  "partisan",
  "passable",
  "passing",
  "passionate",
  "passive",
  "past",
  "pastel",
  "pastoral",
  "paternal",
  "patient",
  "patriarchal",
  "patriotic",
  "patterned",
  "paved",
  "payable",
  "paying",
  "peace-keeping",
  "peaceable",
  "peaceful",
  "pearly",
  "peculiar",
  "pedagogical",
  "penal",
  "pending",
  "penetrating",
  "penniless",
  "pensive",
  "pent-up",
  "perceived",
  "perceptible",
  "perceptive",
  "perceptual",
  "peremptory",
  "perennial",
  "perfect",
  "perfumed",
  "perfunctory",
  "periodic",
  "peripheral",
  "permanent",
  "permissible",
  "permissive",
  "pernicious",
  "perpetual",
  "perplexed",
  "perplexing",
  "persistent",
  "personal",
  "persuasive",
  "pert",
  "pertinent",
  "pervasive",
  "pessimistic",
  "petite",
  "petrified",
  "petty",
  "petulant",
  "phantom",
  "pharmaceutical",
  "phenomenal",
  "philosophic",
  "philosophical",
  "phonetic",
  "phony",
  "photographic",
  "physical",
  "physiological",
  "pictorial",
  "picturesque",
  "piercing",
  "pinched",
  "pink",
  "pinkish",
  "pioneering",
  "pious",
  "pissed",
  "pitched",
  "pitiful",
  "pitiless",
  "pivotal",
  "placid",
  "plain",
  "plaintive",
  "planetary",
  "planned",
  "planted",
  "plausible",
  "playful",
  "playing",
  "pleasant",
  "pleased",
  "pleasing",
  "pleasurable",
  "pleated",
  "plentiful",
  "pliable",
  "plump",
  "plush",
  "poetic",
  "poignant",
  "pointed",
  "pointless",
  "poisonous",
  "polar",
  "polished",
  "polite",
  "political",
  "polluted",
  "pompous",
  "ponderous",
  "poorly",
  "popular",
  "populist",
  "populous",
  "porous",
  "portable",
  "portentous",
  "portly",
  "posh",
  "positive",
  "possible",
  "post-world",
  "postal",
  "postwar",
  "potent",
  "potential",
  "potted",
  "pouring",
  "powdered",
  "powerful",
  "powerless",
  "practicable",
  "practical",
  "practiced",
  "practicing",
  "pragmatic",
  "precarious",
  "preceding",
  "precious",
  "precipitous",
  "precise",
  "precocious",
  "predatory",
  "predictable",
  "predicted",
  "predominant",
  "preferable",
  "preferential",
  "preferred",
  "prehistoric",
  "prejudiced",
  "preliminary",
  "premier",
  "premium",
  "prenatal",
  "preoccupied",
  "prep",
  "preparatory",
  "prepared",
  "preposterous",
  "prescribed",
  "present",
  "present-day",
  "presentable",
  "preserving",
  "presidential",
  "presiding",
  "pressing",
  "prestigious",
  "presumed",
  "presumptuous",
  "pretentious",
  "pretrial",
  "pretty",
  "prevailing",
  "prevalent",
  "preventive",
  "previous",
  "prewar",
  "priceless",
  "prickly",
  "priestly",
  "prim",
  "primal",
  "primary",
  "prime",
  "primeval",
  "primitive",
  "primordial",
  "princely",
  "principal",
  "printed",
  "prior",
  "pristine",
  "private",
  "privileged",
  "privy",
  "prized",
  "pro",
  "probable",
  "probing",
  "procedural",
  "processed",
  "prodigious",
  "producing",
  "productive",
  "profane",
  "professional",
  "proficient",
  "profitable",
  "profound",
  "progressive",
  "projected",
  "projecting",
  "projective",
  "proletarian",
  "prolific",
  "prolonged",
  "prominent",
  "promiscuous",
  "promised",
  "promising",
  "promotional",
  "prompt",
  "prone",
  "pronounced",
  "proper",
  "prophetic",
  "proportional",
  "proportionate",
  "proposed",
  "proprietary",
  "prosaic",
  "prospective",
  "prosperous",
  "prostrate",
  "protected",
  "protectionist",
  "protective",
  "protracted",
  "protruding",
  "proud",
  "proven",
  "proverbial",
  "provincial",
  "provisional",
  "provocative",
  "prudent",
  "psychedelic",
  "psychic",
  "psychological",
  "pubic",
  "public",
  "public-relations",
  "publicized",
  "published",
  "pudgy",
  "puffing",
  "puffy",
  "pulmonary",
  "pungent",
  "punishable",
  "punishing",
  "punitive",
  "pure",
  "puritanical",
  "purple",
  "purplish",
  "purported",
  "purposeful",
  "pushy",
  "putative",
  "puzzled",
  "puzzling",
  "quaint",
  "qualified",
  "qualifying",
  "qualitative",
  "quantitative",
  "quarterly",
  "queasy",
  "queer",
  "questioning",
  "quick",
  "quiet",
  "quilted",
  "quintessential",
  "quirky",
  "quivering",
  "quixotic",
  "quizzical",
  "rabid",
  "racial",
  "racing",
  "radiant",
  "radical",
  "radioactive",
  "ragged",
  "raging",
  "rainy",
  "raised",
  "rambling",
  "rampant",
  "ramshackle",
  "rancid",
  "random",
  "rapacious",
  "rapid",
  "rapt",
  "rare",
  "rash",
  "rasping",
  "rational",
  "raucous",
  "ravaged",
  "ravenous",
  "raw",
  "reactionary",
  "readable",
  "ready",
  "ready-made",
  "real",
  "real-estate",
  "real-life",
  "realistic",
  "rear",
  "rear-view",
  "rearing",
  "reasonable",
  "reasoned",
  "reassuring",
  "recalcitrant",
  "receding",
  "received",
  "receiving",
  "recent",
  "receptive",
  "reciprocal",
  "reckless",
  "recognizable",
  "recognized",
  "recommended",
  "recorded",
  "recreational",
  "rectangular",
  "recurrent",
  "recurring",
  "red",
  "red-faced",
  "red-haired",
  "red-hot",
  "reddish",
  "reduced",
  "redundant",
  "refined",
  "reflected",
  "reflective",
  "reflex",
  "reformed",
  "reformist",
  "refreshing",
  "regal",
  "regimental",
  "regional",
  "registered",
  "regressive",
  "regular",
  "regulated",
  "regulatory",
  "reigning",
  "related",
  "relative",
  "relaxed",
  "relaxing",
  "released",
  "relentless",
  "relevant",
  "reliable",
  "relieved",
  "religious",
  "reluctant",
  "remaining",
  "remarkable",
  "remedial",
  "remembered",
  "reminiscent",
  "remote",
  "renewed",
  "renowned",
  "rented",
  "repeated",
  "repeating",
  "repetitious",
  "repetitive",
  "replete",
  "reported",
  "reprehensible",
  "representative",
  "repressed",
  "repressive",
  "reproductive",
  "republican",
  "repugnant",
  "reputable",
  "reputed",
  "required",
  "requisite",
  "resentful",
  "reserve",
  "reserved",
  "resident",
  "residential",
  "residual",
  "resigned",
  "resilient",
  "resistant",
  "resolute",
  "resonant",
  "resounding",
  "resourceful",
  "respectable",
  "respected",
  "respectful",
  "respective",
  "respiratory",
  "resplendent",
  "responsible",
  "responsive",
  "restful",
  "restive",
  "restless",
  "restored",
  "restoring",
  "restrained",
  "restraining",
  "restricted",
  "restrictive",
  "resultant",
  "resulting",
  "retail",
  "retaliatory",
  "reticent",
  "retired",
  "retiring",
  "retreating",
  "retroactive",
  "retrospective",
  "returning",
  "revealing",
  "revered",
  "reverent",
  "reverse",
  "revised",
  "revived",
  "revolting",
  "revolutionary",
  "revolving",
  "rewarding",
  "rhetorical",
  "rheumatic",
  "rheumatoid",
  "rhythmic",
  "ribbed",
  "rich",
  "rickety",
  "rife",
  "right",
  "right-hand",
  "right-wing",
  "righteous",
  "rightful",
  "rigid",
  "rigorous",
  "riotous",
  "ripe",
  "ripped",
  "rippling",
  "rising",
  "risky",
  "ritual",
  "rival",
  "roaring",
  "roast",
  "roasted",
  "roasting",
  "robust",
  "rock-and-roll",
  "rocking",
  "rocky",
  "rolled",
  "rolling",
  "romantic",
  "rosy",
  "rotating",
  "rotting",
  "rough",
  "round",
  "round-trip",
  "rounded",
  "rousing",
  "routine",
  "roving",
  "rowdy",
  "royal",
  "rubber",
  "rubbery",
  "ruddy",
  "rudimentary",
  "rueful",
  "ruffled",
  "rugged",
  "ruined",
  "ruinous",
  "ruling",
  "rumpled",
  "run-down",
  "runaway",
  "running",
  "rural",
  "rushing",
  "rusted",
  "rustic",
  "rusty",
  "ruthless",
  "rutted",
  "sacred",
  "sacrificial",
  "sacrosanct",
  "sad",
  "safe",
  "said",
  "saintly",
  "salaried",
  "salient",
  "sallow",
  "salted",
  "salty",
  "salutary",
  "sandy",
  "sane",
  "sanguine",
  "sanitary",
  "sardonic",
  "satiric",
  "satirical",
  "satisfactory",
  "satisfied",
  "satisfying",
  "saturated",
  "saucy",
  "savage",
  "savvy",
  "scaly",
  "scant",
  "scanty",
  "scarce",
  "scared",
  "scarlet",
  "scarred",
  "scary",
  "scathing",
  "scattered",
  "scenic",
  "scented",
  "scheduled",
  "scholarly",
  "scholastic",
  "science-fiction",
  "scientific",
  "scorched",
  "scornful",
  "scrambled",
  "scraping",
  "scrawny",
  "screaming",
  "scriptural",
  "scruffy",
  "scrupulous",
  "sealed",
  "searching",
  "searing",
  "seasonal",
  "seasoned",
  "seated",
  "secluded",
  "second-class",
  "second-floor",
  "second-hand",
  "second-rate",
  "secondary",
  "secondhand",
  "secret",
  "secretarial",
  "secretive",
  "sectarian",
  "sectional",
  "secular",
  "secure",
  "sedate",
  "sedentary",
  "seedy",
  "seeming",
  "segregated",
  "seismic",
  "select",
  "selected",
  "selective",
  "self-appointed",
  "self-assured",
  "self-centered",
  "self-confident",
  "self-conscious",
  "self-contained",
  "self-effacing",
  "self-evident",
  "self-fulfilling",
  "self-help",
  "self-imposed",
  "self-indulgent",
  "self-made",
  "self-proclaimed",
  "self-righteous",
  "self-satisfied",
  "self-serving",
  "self-styled",
  "self-sufficient",
  "self-supporting",
  "selfless",
  "semantic",
  "semifinal",
  "senatorial",
  "senior",
  "sensational",
  "senseless",
  "sensible",
  "sensitive",
  "sensory",
  "sensuous",
  "sentencing",
  "sentimental",
  "separate",
  "separated",
  "separatist",
  "serene",
  "serial",
  "serious",
  "settled",
  "seven-year",
  "seventeenth-century",
  "severe",
  "severed",
  "shabby",
  "shaded",
  "shadowed",
  "shadowy",
  "shady",
  "shaggy",
  "shaken",
  "shaky",
  "shallow",
  "shaped",
  "shapeless",
  "shapely",
  "shared",
  "sharp",
  "sharpened",
  "shattered",
  "shattering",
  "shaven",
  "shaving",
  "sheepish",
  "sheer",
  "sheltered",
  "shifting",
  "shimmering",
  "shining",
  "shiny",
  "shocked",
  "shocking",
  "shoddy",
  "short",
  "short-lived",
  "short-range",
  "short-sleeved",
  "short-term",
  "shortsighted",
  "shouting",
  "showy",
  "shredded",
  "shrewd",
  "shrill",
  "shrinking",
  "shrunken",
  "shuddering",
  "shut",
  "shuttered",
  "shy",
  "sick",
  "sidelong",
  "signed",
  "significant",
  "silent",
  "silken",
  "silky",
  "silly",
  "silver",
  "silver-haired",
  "silvery",
  "similar",
  "simmering",
  "simple",
  "simplified",
  "simplistic",
  "simulated",
  "simultaneous",
  "sincere",
  "sinewy",
  "sinful",
  "single",
  "singular",
  "sinister",
  "sinuous",
  "six-day",
  "six-foot",
  "six-month",
  "six-year",
  "sizable",
  "sizzling",
  "skeletal",
  "skeptical",
  "sketchy",
  "skilled",
  "skillful",
  "skimpy",
  "skinny",
  "skittish",
  "slack",
  "slain",
  "slanted",
  "slatted",
  "sleazy",
  "sled",
  "sleek",
  "sleeping",
  "sleepless",
  "sleepy",
  "sleeveless",
  "slender",
  "sliced",
  "slick",
  "sliding",
  "slight",
  "slim",
  "slimy",
  "slippery",
  "sloping",
  "sloppy",
  "slow",
  "slow-moving",
  "sluggish",
  "sly",
  "small",
  "small-scale",
  "small-time",
  "small-town",
  "smart",
  "smashed",
  "smashing",
  "smiling",
  "smoked",
  "smokeless",
  "smoking",
  "smoky",
  "smoldering",
  "smooth",
  "smug",
  "snap",
  "snappy",
  "snarling",
  "sneaky",
  "snow-covered",
  "snowy",
  "snug",
  "so-called",
  "soaked",
  "soaring",
  "sober",
  "sobering",
  "socalled",
  "sociable",
  "social",
  "socialist",
  "societal",
  "socioeconomic",
  "sociological",
  "sodden",
  "soft",
  "soft-spoken",
  "soggy",
  "soiled",
  "solar",
  "sole",
  "solemn",
  "solicitous",
  "solid",
  "solitary",
  "soluble",
  "somber",
  "sometime",
  "sonic",
  "soothing",
  "sooty",
  "sophisticated",
  "sordid",
  "sore",
  "sorrowful",
  "sorry",
  "sortal",
  "sound",
  "soundless",
  "sour",
  "southeastern",
  "southern",
  "southwestern",
  "sovereign",
  "soybean",
  "spacious",
  "spare",
  "sparkling",
  "sparse",
  "spatial",
  "speaking",
  "special",
  "special-interest",
  "specialized",
  "specific",
  "specified",
  "speckled",
  "spectacular",
  "spectral",
  "speculative",
  "speechless",
  "speeding",
  "speedy",
  "spellbound",
  "spent",
  "spherical",
  "spicy",
  "spiky",
  "spilled",
  "spinal",
  "spindly",
  "spinning",
  "spiral",
  "spirited",
  "spiritual",
  "spiteful",
  "splendid",
  "splintered",
  "split",
  "spoiled",
  "spoken",
  "spongy",
  "sponsored",
  "spontaneous",
  "spooky",
  "sporadic",
  "sporting",
  "sporty",
  "spotless",
  "spotted",
  "spotty",
  "sprawling",
  "spreading",
  "springy",
  "spurious",
  "square",
  "squat",
  "squeaky",
  "stable",
  "stacked",
  "staggering",
  "staid",
  "stained",
  "stained-glass",
  "stainless",
  "stale",
  "stalled",
  "stalwart",
  "stamped",
  "stand-up",
  "standard",
  "standardized",
  "standby",
  "starched",
  "stark",
  "starry",
  "startled",
  "startling",
  "starved",
  "starving",
  "state-owned",
  "state-run",
  "stated",
  "stately",
  "statewide",
  "static",
  "stationary",
  "statistical",
  "statutory",
  "staunch",
  "steadfast",
  "steady",
  "steamed",
  "steaming",
  "steamy",
  "steely",
  "steep",
  "stellar",
  "step-by-step",
  "stepped-up",
  "stereotyped",
  "sticking",
  "sticky",
  "stiff",
  "still",
  "stimulating",
  "stinging",
  "stingy",
  "stinking",
  "stirring",
  "stocky",
  "stolen",
  "stolid",
  "stoned",
  "stony",
  "stopped",
  "stored",
  "stormy",
  "stout",
  "straight",
  "straight-backed",
  "straightforward",
  "strained",
  "stranded",
  "strange",
  "strangled",
  "strapping",
  "strategic",
  "stray",
  "streamlined",
  "strenuous",
  "stressful",
  "stricken",
  "strict",
  "strident",
  "striking",
  "stringent",
  "stringy",
  "striped",
  "strong",
  "strong-willed",
  "structural",
  "structured",
  "struggling",
  "stubby",
  "stuck",
  "studied",
  "studious",
  "stuffed",
  "stuffy",
  "stunned",
  "stunning",
  "stunted",
  "sturdy",
  "stylish",
  "stylistic",
  "stylized",
  "suave",
  "subatomic",
  "subconscious",
  "subdued",
  "subjective",
  "sublime",
  "subliminal",
  "submerged",
  "subordinate",
  "subsequent",
  "subservient",
  "subsidiary",
  "subsidized",
  "substandard",
  "substantial",
  "substantive",
  "substitute",
  "subterranean",
  "subtle",
  "suburban",
  "subversive",
  "succeeding",
  "successful",
  "successive",
  "sudden",
  "suffering",
  "sufficient",
  "suffocating",
  "suggested",
  "suggestive",
  "suicidal",
  "suitable",
  "sullen",
  "sultry",
  "sumptuous",
  "sundry",
  "sunken",
  "sunlit",
  "sunny",
  "super",
  "superb",
  "superficial",
  "superfluous",
  "superhuman",
  "superior",
  "supernatural",
  "supersonic",
  "superstitious",
  "supervisory",
  "supple",
  "supplemental",
  "supplementary",
  "supporting",
  "supportive",
  "supposed",
  "suppressed",
  "supreme",
  "sure",
  "surface-to-air",
  "surgical",
  "surging",
  "surly",
  "surplus",
  "surprised",
  "surprising",
  "surreal",
  "surrounding",
  "surviving",
  "susceptible",
  "suspect",
  "suspected",
  "suspended",
  "suspicious",
  "sustained",
  "swarthy",
  "swaying",
  "sweating",
  "sweeping",
  "sweet",
  "swell",
  "swelling",
  "swift",
  "swinging",
  "swirling",
  "switching",
  "swollen",
  "sworn",
  "symbolic",
  "symmetrical",
  "sympathetic",
  "symptomatic",
  "syndicated",
  "synonymous",
  "syntactic",
  "synthetic",
  "systematic",
  "systemic",
  "tacit",
  "tacky",
  "tactful",
  "tactical",
  "tailored",
  "talented",
  "talkative",
  "tall",
  "tame",
  "tan",
  "tangible",
  "tangled",
  "tanned",
  "tantalizing",
  "tantamount",
  "taped",
  "tart",
  "tasteful",
  "tasteless",
  "tasty",
  "tattered",
  "taut",
  "tawny",
  "tax-exempt",
  "tax-free",
  "taxable",
  "taxing",
  "tearful",
  "teasing",
  "technical",
  "technological",
  "tedious",
  "teeming",
  "teen-age",
  "teenage",
  "telescopic",
  "televised",
  "telling",
  "temperate",
  "temporal",
  "temporary",
  "tempting",
  "ten-year",
  "tenacious",
  "tender",
  "tense",
  "tentative",
  "tenuous",
  "tepid",
  "terminal",
  "terraced",
  "terrestrial",
  "terrible",
  "terrific",
  "terrifying",
  "territorial",
  "terrorist",
  "terse",
  "textured",
  "thankful",
  "thatched",
  "theatrical",
  "thematic",
  "then",
  "theological",
  "theoretical",
  "therapeutic",
  "thermal",
  "thermonuclear",
  "thick",
  "thin",
  "third-floor",
  "thirsty",
  "thorny",
  "thorough",
  "thoughtful",
  "thoughtless",
  "threadbare",
  "threatened",
  "three-day",
  "three-dimensional",
  "three-hour",
  "three-month",
  "three-piece",
  "three-story",
  "three-way",
  "three-week",
  "three-year",
  "thrilled",
  "thrilling",
  "thriving",
  "throaty",
  "throbbing",
  "through",
  "thunderous",
  "thyroid",
  "tidal",
  "tidy",
  "tight",
  "tight-lipped",
  "tiled",
  "time-consuming",
  "time-honored",
  "timeless",
  "timely",
  "timid",
  "tinkling",
  "tinny",
  "tinted",
  "tiny",
  "tional",
  "tired",
  "tireless",
  "tiresome",
  "tiring",
  "tive",
  "token",
  "tolerable",
  "tolerant",
  "toothless",
  "top",
  "top-level",
  "top-secret",
  "topical",
  "topless",
  "tormented",
  "torn",
  "tortuous",
  "tortured",
  "total",
  "touching",
  "touchy",
  "tough",
  "towering",
  "traceable",
  "tracking",
  "traditional",
  "trailing",
  "trained",
  "trampled",
  "tranquil",
  "transatlantic",
  "transcendent",
  "transcendental",
  "transient",
  "transitional",
  "transitory",
  "translucent",
  "transparent",
  "trapped",
  "traumatic",
  "traveling",
  "treacherous",
  "treasured",
  "tree-lined",
  "trembling",
  "tremendous",
  "tremulous",
  "trendy",
  "triangular",
  "tribal",
  "tricky",
  "tried",
  "trifling",
  "trim",
  "triple",
  "trite",
  "triumphal",
  "triumphant",
  "trivial",
  "tropical",
  "troubled",
  "troublesome",
  "troubling",
  "trucking",
  "true",
  "trusted",
  "trusting",
  "trustworthy",
  "truthful",
  "trying",
  "tufted",
  "tumbling",
  "tumultuous",
  "turbulent",
  "turn-of-the-century",
  "turning",
  "turquoise",
  "tutoring",
  "twelve-year-old",
  "twentieth-century",
  "twin",
  "twisting",
  "two-bit",
  "two-day",
  "two-dimensional",
  "two-hour",
  "two-man",
  "two-month",
  "two-room",
  "two-story",
  "two-way",
  "two-week",
  "two-year",
  "typed",
  "typical",
  "tyrannical",
  "ubiquitous",
  "ultimate",
  "ultraviolet",
  "umbilical",
  "unabashed",
  "unable",
  "unaccountable",
  "unaccustomed",
  "unadorned",
  "unaffected",
  "unanimous",
  "unannounced",
  "unanswered",
  "unanticipated",
  "unarmed",
  "unassuming",
  "unattended",
  "unauthorized",
  "unavailable",
  "unavoidable",
  "unaware",
  "unbalanced",
  "unbearable",
  "unbelievable",
  "unborn",
  "unbridled",
  "unbroken",
  "uncanny",
  "uncertain",
  "unchallenged",
  "unchanged",
  "unchanging",
  "uncharacteristic",
  "unchecked",
  "unclean",
  "unclear",
  "uncomfortable",
  "uncommon",
  "uncomplicated",
  "uncomprehending",
  "uncompromising",
  "unconcerned",
  "unconditional",
  "unconscionable",
  "unconscious",
  "unconstitutional",
  "uncontrollable",
  "unconventional",
  "unconvinced",
  "unconvincing",
  "uncritical",
  "uncut",
  "undecided",
  "undefeated",
  "undefined",
  "undeniable",
  "undercover",
  "underdeveloped",
  "underground",
  "underlying",
  "understandable",
  "underwater",
  "undetected",
  "undeveloped",
  "undifferentiated",
  "undisciplined",
  "undisclosed",
  "undiscovered",
  "undisputed",
  "undistinguished",
  "undisturbed",
  "undue",
  "undulating",
  "unearned",
  "unearthly",
  "uneasy",
  "uneducated",
  "unencumbered",
  "unending",
  "unequal",
  "unequivocal",
  "unethical",
  "uneven",
  "uneventful",
  "unexpected",
  "unexplained",
  "unfair",
  "unfamiliar",
  "unfashionable",
  "unfathomable",
  "unfavorable",
  "unfettered",
  "unfinished",
  "unfit",
  "unfocused",
  "unforeseen",
  "unforgettable",
  "unfortunate",
  "unfounded",
  "unfriendly",
  "unfulfilled",
  "ungainly",
  "unguarded",
  "unharmed",
  "unheard",
  "unhurried",
  "unidentified",
  "unified",
  "uniform",
  "uniformed",
  "unifying",
  "unilateral",
  "unimaginable",
  "unimpressed",
  "uninformed",
  "uninhabited",
  "uninhibited",
  "unintelligible",
  "unintended",
  "uninterested",
  "uninteresting",
  "uninterrupted",
  "unionized",
  "unique",
  "unitary",
  "united",
  "universal",
  "unjust",
  "unjustified",
  "unkempt",
  "unknown",
  "unlike",
  "unlikely",
  "unlimited",
  "unlit",
  "unmanageable",
  "unmanned",
  "unmarked",
  "unmatched",
  "unmistakable",
  "unmoved",
  "unmoving",
  "unnamed",
  "unnatural",
  "unnoticed",
  "unobserved",
  "unobtrusive",
  "unoccupied",
  "unofficial",
  "unopened",
  "unorthodox",
  "unpaid",
  "unpainted",
  "unparalleled",
  "unperturbed",
  "unpopular",
  "unprecedented",
  "unpredictable",
  "unprepared",
  "unpretentious",
  "unproductive",
  "unprofitable",
  "unprotected",
  "unpublished",
  "unqualified",
  "unquestioned",
  "unreadable",
  "unreal",
  "unrealistic",
  "unreasonable",
  "unrecognizable",
  "unrecognized",
  "unrelated",
  "unrelenting",
  "unreliable",
  "unresolved",
  "unresponsive",
  "unrestricted",
  "unruffled",
  "unruly",
  "unsafe",
  "unsatisfactory",
  "unsatisfied",
  "unsavory",
  "unscathed",
  "unscrupulous",
  "unseemly",
  "unseen",
  "unsettled",
  "unsettling",
  "unskilled",
  "unsmiling",
  "unsold",
  "unsolved",
  "unsophisticated",
  "unsound",
  "unspecified",
  "unspoiled",
  "unspoken",
  "unstable",
  "unsteady",
  "unsuitable",
  "unsupported",
  "unsure",
  "unsuspecting",
  "untapped",
  "untenable",
  "untested",
  "unthinkable",
  "unthinking",
  "untidy",
  "untimely",
  "untold",
  "untouchable",
  "untouched",
  "untoward",
  "untrained",
  "untreated",
  "untroubled",
  "untrue",
  "unused",
  "unusual",
  "unwanted",
  "unwarranted",
  "unwary",
  "unwashed",
  "unwavering",
  "unwelcome",
  "unwieldy",
  "unwise",
  "unwitting",
  "unwrapped",
  "unwritten",
  "unyielding",
  "up-to-date",
  "upbeat",
  "upcoming",
  "updated",
  "uphill",
  "upper",
  "upper-class",
  "upper-middle-class",
  "uppermost",
  "upright",
  "uprooted",
  "upsetting",
  "upstate",
  "uptight",
  "uptown",
  "upturned",
  "upward",
  "urban",
  "urbane",
  "urgent",
  "usable",
  "used",
  "useful",
  "useless",
  "usual",
  "utilitarian",
  "utmost",
  "utopian",
  "utter",
  "vacant",
  "vague",
  "vain",
  "valiant",
  "valid",
  "valuable",
  "valued",
  "vanished",
  "vanishing",
  "vanquished",
  "variable",
  "varied",
  "various",
  "varying",
  "vascular",
  "vast",
  "vaudeville",
  "vaulted",
  "vaunted",
  "vegetarian",
  "vehement",
  "veiled",
  "velvety",
  "venerable",
  "venereal",
  "venomous",
  "verbal",
  "verifiable",
  "veritable",
  "versatile",
  "vertical",
  "very",
  "vested",
  "veteran",
  "veterinary",
  "viable",
  "vibrant",
  "vice",
  "vice-presidential",
  "vicious",
  "victorious",
  "vigilant",
  "vigorous",
  "vile",
  "vindictive",
  "violet",
  "viral",
  "virile",
  "virtual",
  "virtuous",
  "virulent",
  "visible",
  "visionary",
  "visiting",
  "visual",
  "vital",
  "vivacious",
  "vivid",
  "vocal",
  "vocational",
  "volatile",
  "volcanic",
  "voluble",
  "voluminous",
  "voluntary",
  "voracious",
  "vulnerable",
  "wage-price",
  "waiting",
  "walled",
  "wan",
  "wandering",
  "waning",
  "wanted",
  "wanting",
  "wanton",
  "warlike",
  "warm",
  "warped",
  "warring",
  "wary",
  "washed",
  "wasted",
  "wasteful",
  "watchful",
  "waterproof",
  "watery",
  "waving",
  "wavy",
  "waxed",
  "wayward",
  "weakening",
  "wealthy",
  "weary",
  "weathered",
  "wee",
  "weekly",
  "weeping",
  "weightless",
  "weighty",
  "weird",
  "welcome",
  "welcoming",
  "well",
  "well-defined",
  "well-dressed",
  "well-educated",
  "well-established",
  "well-heeled",
  "well-intentioned",
  "well-known",
  "well-meaning",
  "well-organized",
  "well-placed",
  "well-publicized",
  "well-to-do",
  "well-trained",
  "well-worn",
  "western",
  "whimsical",
  "whipped",
  "whirling",
  "whispered",
  "white",
  "white-collar",
  "white-haired",
  "whitewashed",
  "whitish",
  "whole",
  "wholesale",
  "wholesome",
  "wicked",
  "wide",
  "wide-eyed",
  "wide-open",
  "wide-ranging",
  "widening",
  "widespread",
  "widowed",
  "wild",
  "wild-eyed",
  "willful",
  "willing",
  "wily",
  "winding",
  "windy",
  "winged",
  "winning",
  "winsome",
  "wintry",
  "wiry",
  "wise",
  "wishful",
  "wispy",
  "wistful",
  "withered",
  "withering",
  "withholding",
  "witty",
  "wobbly",
  "wonderful",
  "wondrous",
  "wont",
  "wooded",
  "wooden",
  "woody",
  "woolen",
  "woolly",
  "wordless",
  "workable",
  "working",
  "working-class",
  "world-class",
  "world-wide",
  "worldly",
  "worldwide",
  "worn",
  "worn-out",
  "worrisome",
  "worrying",
  "worsening",
  "worthless",
  "worthwhile",
  "worthy",
  "wounded",
  "woven",
  "wrecked",
  "wretched",
  "wrinkled",
  "written",
  "wrought",
  "wrought-iron",
  "wry",
  "yawning",
  "year-end",
  "year-old",
  "year-round",
  "yearly",
  "yellow",
  "yellowed",
  "yellowing",
  "yellowish",
  "yielding",
  "young",
  "youthful",
  "zealous"
];
var cg = {};
Object.defineProperty(cg, "__esModule", { value: !0 });
cg.default = [
  "abatement",
  "abbey",
  "abbot",
  "abbreviation",
  "abdication",
  "abdomen",
  "abductor",
  "ability",
  "abode",
  "abolition",
  "abolitionist",
  "about-face",
  "abrasion",
  "absolutism",
  "absolutist",
  "absorber",
  "absorption",
  "abstention",
  "abstract",
  "abstraction",
  "absurdist",
  "absurdity",
  "abundance",
  "abutment",
  "abyss",
  "acacia",
  "academic",
  "academician",
  "academy",
  "acceleration",
  "accelerator",
  "accent",
  "acceptance",
  "accession",
  "accessory",
  "acclaim",
  "acclamation",
  "accolade",
  "accommodation",
  "accompaniment",
  "accompanist",
  "accomplice",
  "accomplishment",
  "accord",
  "accordion",
  "account",
  "accountant",
  "accounting",
  "accreditation",
  "accretion",
  "accumulation",
  "accuracy",
  "accuser",
  "ace",
  "acetate",
  "achievement",
  "acknowledgement",
  "acolyte",
  "acorn",
  "acquaintance",
  "acquaintanceship",
  "acquisition",
  "acquit",
  "acquittal",
  "acreage",
  "acrobat",
  "acronym",
  "acrylic",
  "act",
  "action",
  "activist",
  "activity",
  "actor",
  "actuality",
  "actualization",
  "actuary",
  "acuity",
  "ad",
  "ad-lib",
  "adage",
  "adaptation",
  "adapter",
  "adder",
  "addition",
  "address",
  "adequacy",
  "adherent",
  "adhesive",
  "adjective",
  "adjournment",
  "adjudication",
  "adjunct",
  "adjuster",
  "adjustment",
  "adjutant",
  "administration",
  "administrator",
  "admiral",
  "admiration",
  "admirer",
  "admission",
  "admixture",
  "admonition",
  "adobe",
  "adolescent",
  "adornment",
  "adulation",
  "adult",
  "advance",
  "advancement",
  "advantage",
  "adventure",
  "adventurer",
  "adverb",
  "adversity",
  "advertisement",
  "advertiser",
  "advisement",
  "adviser",
  "advisor",
  "advocate",
  "aerial",
  "aerie",
  "aeroplane",
  "aerosol",
  "aesthete",
  "affect",
  "affection",
  "affidavit",
  "affiliate",
  "affiliation",
  "affinity",
  "affirmation",
  "affront",
  "afterburner",
  "aftermath",
  "afterthought",
  "agate",
  "agency",
  "agenda",
  "agent",
  "agglomeration",
  "aggrandizement",
  "aggregate",
  "aggregation",
  "agitation",
  "agitator",
  "agreement",
  "agribusiness",
  "agronomist",
  "aide",
  "air",
  "air-conditioner",
  "airfield",
  "airfoil",
  "airframe",
  "airing",
  "airlift",
  "airline",
  "airliner",
  "airlock",
  "airman",
  "airplane",
  "airport",
  "airship",
  "airstrip",
  "airway",
  "aisle",
  "alarm",
  "alarmist",
  "albatross",
  "album",
  "alchemist",
  "alcove",
  "alder",
  "alderman",
  "ale",
  "alert",
  "algorithm",
  "alibi",
  "alien",
  "alignment",
  "alkali",
  "allegiance",
  "allegory",
  "alleviation",
  "alley",
  "alleyway",
  "alliance",
  "alligator",
  "alliteration",
  "allocation",
  "allotment",
  "allowance",
  "alloy",
  "allure",
  "allusion",
  "ally",
  "almanac",
  "almond",
  "alpha",
  "alphabet",
  "also-ran",
  "altar",
  "altarpiece",
  "alteration",
  "altercation",
  "alternation",
  "alternative",
  "altitude",
  "alto",
  "ama",
  "amalgam",
  "amalgamation",
  "amateur",
  "ambassador",
  "ambassadorship",
  "amber",
  "ambiguity",
  "ambition",
  "ambivalence",
  "ambulance",
  "amelioration",
  "amendment",
  "amenity",
  "amethyst",
  "amity",
  "ammunition",
  "amnesty",
  "amoeba",
  "amount",
  "amour",
  "amphetamine",
  "amphitheater",
  "amphitheatre",
  "amplifier",
  "amplitude",
  "ampule",
  "amputee",
  "amulet",
  "amusement",
  "anachronism",
  "analgesic",
  "analog",
  "analogue",
  "analogy",
  "analysis",
  "analyst",
  "anarchist",
  "anatomist",
  "anatomy",
  "ance",
  "ancestor",
  "ancestry",
  "anchor",
  "anchorage",
  "anchorman",
  "anchovy",
  "ancient",
  "android",
  "anecdote",
  "anemia",
  "anesthesiologist",
  "anesthetic",
  "anesthetist",
  "aneurysm",
  "angel",
  "angiogram",
  "angle",
  "angler",
  "angora",
  "animal",
  "animation",
  "ankle",
  "annex",
  "annexation",
  "anniversary",
  "announcement",
  "announcer",
  "annoyance",
  "annual",
  "annuity",
  "annulment",
  "anode",
  "anonymity",
  "answer",
  "ant",
  "antagonist",
  "antechamber",
  "antelope",
  "antenna",
  "anteroom",
  "anthem",
  "anthill",
  "anthology",
  "anthropoid",
  "anthropologist",
  "antibiotic",
  "antibody",
  "anticipation",
  "anticommunist",
  "antidote",
  "antigen",
  "antihero",
  "antiquarian",
  "antique",
  "antiquity",
  "antithesis",
  "antler",
  "anvil",
  "aorta",
  "apartment",
  "ape",
  "aperture",
  "apex",
  "aphasia",
  "aphorism",
  "aphrodisiac",
  "apologia",
  "apostle",
  "apothecary",
  "apparition",
  "appeal",
  "appearance",
  "appellation",
  "appendage",
  "appendectomy",
  "appendix",
  "appetite",
  "appetizer",
  "apple",
  "appliance",
  "applicant",
  "application",
  "appointee",
  "appointment",
  "apportionment",
  "appraisal",
  "appraiser",
  "appreciation",
  "apprehension",
  "apprentice",
  "apprenticeship",
  "approach",
  "appropriation",
  "approval",
  "approximation",
  "apricot",
  "apron",
  "aptitude",
  "aquarium",
  "aqueduct",
  "arbiter",
  "arbitration",
  "arbitrator",
  "arbor",
  "arcade",
  "arch",
  "archaeologist",
  "archangel",
  "archbishop",
  "archdiocese",
  "archeologist",
  "archer",
  "archetype",
  "archipelago",
  "architect",
  "archive",
  "archivist",
  "archway",
  "ardor",
  "arena",
  "argument",
  "argyle",
  "aria",
  "aristocracy",
  "aristocrat",
  "arithmetic",
  "ark",
  "arm",
  "armada",
  "armadillo",
  "armament",
  "armature",
  "armband",
  "armchair",
  "armful",
  "armload",
  "armoire",
  "armor",
  "armory",
  "army",
  "aroma",
  "arraignment",
  "arrangement",
  "arranger",
  "array",
  "arrival",
  "arrow",
  "arrowhead",
  "arse",
  "arsenal",
  "arson",
  "arsonist",
  "art",
  "artery",
  "artichoke",
  "article",
  "articulation",
  "artifact",
  "artifice",
  "artificiality",
  "artisan",
  "artist",
  "artiste",
  "artwork",
  "ascendant",
  "ascension",
  "ascent",
  "ascot",
  "ash",
  "ashtray",
  "asking",
  "aspect",
  "aspen",
  "aspirant",
  "aspiration",
  "assailant",
  "assay",
  "assemblage",
  "assembly",
  "assemblyman",
  "assent",
  "assertion",
  "assessment",
  "assessor",
  "asset",
  "assignation",
  "assignment",
  "assimilation",
  "assist",
  "assistant",
  "associate",
  "association",
  "assortment",
  "assumption",
  "assurance",
  "asterisk",
  "asteroid",
  "astonishment",
  "astrologer",
  "astronaut",
  "astronomer",
  "astrophysicist",
  "asylum",
  "asymmetry",
  "atelier",
  "atheist",
  "athlete",
  "ation",
  "atmosphere",
  "atoll",
  "atom",
  "atrium",
  "attachment",
  "attainment",
  "attempt",
  "attendant",
  "attention",
  "attic",
  "attitude",
  "attorney",
  "attraction",
  "attribute",
  "attribution",
  "attrition",
  "auction",
  "auctioneer",
  "audience",
  "audit",
  "audition",
  "auditor",
  "auditorium",
  "auger",
  "augury",
  "aura",
  "aureole",
  "austerity",
  "auteur",
  "author",
  "authority",
  "authorization",
  "autobiography",
  "autocracy",
  "autocrat",
  "autograph",
  "automaker",
  "automatic",
  "automaton",
  "automobile",
  "autopsy",
  "auxiliary",
  "availability",
  "avant-garde",
  "avatar",
  "avenger",
  "avenue",
  "aviary",
  "aviator",
  "avocation",
  "avowal",
  "awakening",
  "award",
  "awareness",
  "awl",
  "awning",
  "ax",
  "axe",
  "axiom",
  "axis",
  "axle",
  "ayatollah",
  "azure",
  "ba",
  "babble",
  "baby-sitter",
  "babysitter",
  "bachelor",
  "back-up",
  "backache",
  "backboard",
  "backbone",
  "backdoor",
  "backdrop",
  "backer",
  "backfield",
  "background",
  "backlog",
  "backpack",
  "backroom",
  "backseat",
  "backside",
  "backstop",
  "backup",
  "backwash",
  "backwater",
  "backyard",
  "bacon",
  "bacterium",
  "badge",
  "badger",
  "bag",
  "bagel",
  "baggage",
  "bagpipe",
  "bail",
  "bailiff",
  "bailiwick",
  "baiting",
  "baker",
  "bakery",
  "baking",
  "balance",
  "balcony",
  "bale",
  "ball",
  "ballad",
  "ballast",
  "ballcarrier",
  "ballerina",
  "ballet",
  "ballgame",
  "balloon",
  "ballot",
  "ballpark",
  "ballplayer",
  "ballpoint",
  "ballroom",
  "balm",
  "balustrade",
  "bamboo",
  "ban",
  "banality",
  "banana",
  "band",
  "bandage",
  "bandana",
  "bandanna",
  "banding",
  "bandit",
  "bandleader",
  "bandstand",
  "bang",
  "banister",
  "bank",
  "bankbook",
  "banker",
  "bankroll",
  "bankruptcy",
  "banner",
  "banning",
  "bannister",
  "banquet",
  "banquette",
  "banshee",
  "bantam",
  "bantamweight",
  "baptism",
  "bar",
  "barb",
  "barbecue",
  "barbell",
  "barber",
  "barbershop",
  "bard",
  "bargain",
  "bargaining",
  "barge",
  "baritone",
  "bark",
  "barkeep",
  "barker",
  "barmaid",
  "barman",
  "barn",
  "barnyard",
  "barometer",
  "baron",
  "baroness",
  "baronet",
  "barony",
  "barracuda",
  "barrage",
  "barrel",
  "barrette",
  "barricade",
  "barrier",
  "barrister",
  "barroom",
  "barrow",
  "barstool",
  "bartender",
  "barter",
  "bas-relief",
  "basalt",
  "baseball",
  "baseboard",
  "baseline",
  "baseman",
  "basement",
  "bash",
  "basilica",
  "basilisk",
  "basin",
  "basis",
  "basket",
  "basketball",
  "bassinet",
  "bassist",
  "bastion",
  "bat",
  "batch",
  "bath",
  "bathhouse",
  "bathrobe",
  "bathroom",
  "bathtub",
  "battalion",
  "battering",
  "battery",
  "battle",
  "battlefield",
  "battlefront",
  "battleground",
  "battlement",
  "battleship",
  "bauble",
  "bayonet",
  "bazaar",
  "beach",
  "beachhead",
  "beacon",
  "bead",
  "beagle",
  "beak",
  "beaker",
  "beam",
  "beamer",
  "bean",
  "bear",
  "beard",
  "bearer",
  "bearing",
  "bearskin",
  "beastie",
  "beater",
  "beating",
  "beau",
  "beautician",
  "beauty",
  "beaver",
  "beck",
  "bed",
  "bedchamber",
  "bedding",
  "bedpan",
  "bedpost",
  "bedroll",
  "bedroom",
  "bedsheet",
  "bedside",
  "bedspread",
  "bedstead",
  "bee",
  "beech",
  "beef",
  "beefsteak",
  "beehive",
  "beep",
  "beeper",
  "beet",
  "beetle",
  "begat",
  "beginner",
  "beginning",
  "behavior",
  "behaviorist",
  "behaviour",
  "behemoth",
  "behind",
  "beholder",
  "being",
  "belch",
  "belfry",
  "belief",
  "believer",
  "bell",
  "belle",
  "bellhop",
  "bellow",
  "bellowing",
  "belly",
  "bellyache",
  "beloved",
  "belt",
  "bench",
  "benchmark",
  "bender",
  "bending",
  "benediction",
  "benefactor",
  "beneficiary",
  "benefit",
  "bequest",
  "ber",
  "bereavement",
  "beret",
  "berry",
  "berserker",
  "berth",
  "best-seller",
  "bestseller",
  "beta",
  "betrothal",
  "better",
  "betterment",
  "bettor",
  "bevel",
  "beverage",
  "bevy",
  "bib",
  "bicep",
  "bickering",
  "bicycle",
  "bid",
  "bidder",
  "bidet",
  "biennial",
  "bier",
  "biggie",
  "bike",
  "biker",
  "bilge",
  "bility",
  "bill",
  "billboard",
  "billiard",
  "billing",
  "billionaire",
  "billow",
  "billy",
  "bin",
  "binary",
  "bind",
  "binder",
  "binding",
  "binge",
  "bio",
  "biochemist",
  "biographer",
  "biography",
  "biologist",
  "biology",
  "biopsy",
  "biplane",
  "birch",
  "bird",
  "birdbath",
  "birdcage",
  "birder",
  "birdie",
  "birdsong",
  "birth",
  "birthday",
  "birthmark",
  "birthplace",
  "birthrate",
  "birthright",
  "biscuit",
  "bishop",
  "bit",
  "bivouac",
  "black",
  "blackberry",
  "blackbird",
  "blackboard",
  "blackguard",
  "blackjack",
  "blacklist",
  "blackness",
  "blackout",
  "blacksmith",
  "bladder",
  "blade",
  "blanc",
  "blank",
  "blanket",
  "blare",
  "blast",
  "blaster",
  "blastocyst",
  "blaze",
  "blazer",
  "ble",
  "bleach",
  "bleacher",
  "bleat",
  "blemish",
  "blend",
  "blender",
  "blessing",
  "blimp",
  "blind",
  "blink",
  "blinker",
  "blinking",
  "blip",
  "blister",
  "blizzard",
  "bloak",
  "blob",
  "block",
  "blockade",
  "blockage",
  "blockbuster",
  "blocker",
  "blockhouse",
  "bloke",
  "blond",
  "blonde",
  "blood",
  "bloodhound",
  "bloodletting",
  "bloodline",
  "bloodstream",
  "bloom",
  "blooper",
  "blossom",
  "blot",
  "blotch",
  "blotter",
  "blow-up",
  "blower",
  "blowgun",
  "blowing",
  "blowout",
  "blowpipe",
  "blowtorch",
  "blowup",
  "blubber",
  "bludgeon",
  "blue",
  "blueberry",
  "blueprint",
  "bluff",
  "blur",
  "blurb",
  "blush",
  "blusher",
  "bo",
  "boa",
  "boar",
  "board",
  "boarder",
  "boarding",
  "boardinghouse",
  "boardroom",
  "boardwalk",
  "boast",
  "boasting",
  "boat",
  "boater",
  "boathouse",
  "boatload",
  "boatman",
  "boatyard",
  "bobby",
  "bobcat",
  "bodice",
  "body",
  "bodyguard",
  "bog",
  "bogey",
  "boiler",
  "bolster",
  "bolt",
  "bomb",
  "bombard",
  "bombardment",
  "bomber",
  "bombing",
  "bombshell",
  "bon",
  "bonanza",
  "bond",
  "bonding",
  "bondsman",
  "bone",
  "bonfire",
  "bonnet",
  "book",
  "bookcase",
  "bookie",
  "booking",
  "bookkeeper",
  "booklet",
  "bookmaker",
  "bookseller",
  "bookshelf",
  "bookshop",
  "bookstore",
  "boom",
  "booming",
  "boomlet",
  "boon",
  "boondoggle",
  "boor",
  "boost",
  "booster",
  "boot",
  "booth",
  "bootlegger",
  "bootstrap",
  "booty",
  "booze",
  "border",
  "borderline",
  "bore",
  "borough",
  "borrower",
  "borrowing",
  "bosom",
  "boss",
  "botanist",
  "bottle",
  "bottleneck",
  "bottler",
  "bottling",
  "bottom",
  "bottomland",
  "boudoir",
  "bougainvillea",
  "bough",
  "bouillabaisse",
  "boulder",
  "boulevard",
  "bounce",
  "bouncer",
  "bound",
  "boundary",
  "bounty",
  "bouquet",
  "bourbon",
  "bourgeoisie",
  "bout",
  "boutique",
  "bow",
  "bowel",
  "bowhead",
  "bowl",
  "bowler",
  "bowsprit",
  "bowstring",
  "box",
  "boxcar",
  "boxer",
  "boxwood",
  "brace",
  "bracelet",
  "bracket",
  "braggart",
  "braid",
  "brain",
  "brainstorm",
  "brake",
  "brakeman",
  "bramble",
  "branch",
  "brand",
  "brandy",
  "brass",
  "brassiere",
  "brat",
  "brave",
  "bravery",
  "brawl",
  "brawler",
  "brawling",
  "brazier",
  "breach",
  "breadth",
  "breadwinner",
  "break",
  "break-up",
  "breakaway",
  "breakdown",
  "breaker",
  "breakfast",
  "breakfront",
  "breakin",
  "breaking",
  "breakout",
  "breakthrough",
  "breakup",
  "breakwater",
  "breath",
  "breather",
  "breathing",
  "breech",
  "breed",
  "breeder",
  "breeding",
  "breeze",
  "brew",
  "brewer",
  "brewery",
  "briar",
  "bribe",
  "brick",
  "bricklayer",
  "brickwork",
  "bride",
  "bridegroom",
  "bridge",
  "bridgehead",
  "bridle",
  "brief",
  "briefcase",
  "briefing",
  "brig",
  "brigade",
  "brigadier",
  "brigand",
  "brightness",
  "brilliance",
  "brim",
  "brioche",
  "brisket",
  "bristle",
  "broad",
  "broadcast",
  "broadcaster",
  "broadcasting",
  "broadcloth",
  "broadsheet",
  "broadside",
  "broadsword",
  "brocade",
  "brochure",
  "brogue",
  "broil",
  "broiler",
  "broker",
  "brokerage",
  "bromide",
  "bronc",
  "bronze",
  "brooch",
  "brood",
  "brook",
  "broom",
  "broomstick",
  "broth",
  "brouhaha",
  "brown",
  "brownstone",
  "bruise",
  "brunch",
  "brunette",
  "brush",
  "brushfire",
  "brushing",
  "brute",
  "bubble",
  "buccaneer",
  "buckboard",
  "bucket",
  "bucketful",
  "buckle",
  "buckskin",
  "bud",
  "buddy",
  "budget",
  "buff",
  "buffalo",
  "buffer",
  "buffet",
  "buffoon",
  "bug",
  "bugger",
  "bugging",
  "buggy",
  "bugle",
  "build-up",
  "builder",
  "building",
  "buildup",
  "bulb",
  "bulge",
  "bulkhead",
  "bull",
  "bulldog",
  "bulldozer",
  "bullet",
  "bulletin",
  "bullfight",
  "bullfighter",
  "bullfrog",
  "bullhorn",
  "bullock",
  "bully",
  "bulwark",
  "bum",
  "bumblebee",
  "bummer",
  "bump",
  "bumper",
  "bumpkin",
  "bun",
  "bunch",
  "bundle",
  "bungalow",
  "bunk",
  "bunker",
  "bunkhouse",
  "bunny",
  "bunt",
  "bunting",
  "buoy",
  "burden",
  "bureau",
  "bureaucracy",
  "bureaucrat",
  "burger",
  "burgher",
  "burglar",
  "burglary",
  "burial",
  "burlap",
  "burlesque",
  "burn",
  "burner",
  "burnout",
  "burp",
  "burrow",
  "burst",
  "bursting",
  "busboy",
  "bush",
  "bushel",
  "business",
  "businessman",
  "businesswoman",
  "busload",
  "bust",
  "buster",
  "bustle",
  "busybody",
  "butchery",
  "butler",
  "butt",
  "butte",
  "butterfly",
  "butternut",
  "buttock",
  "button",
  "buttonhole",
  "buttress",
  "buy",
  "buyer",
  "buying",
  "buyout",
  "buzzard",
  "buzzer",
  "by-election",
  "by-product",
  "bypass",
  "byproduct",
  "bystander",
  "byword",
  "cab",
  "cabal",
  "cabana",
  "cabaret",
  "cabbage",
  "cabbie",
  "cabby",
  "cabdriver",
  "cabin",
  "cabinet",
  "cabinetmaker",
  "cable",
  "caboose",
  "cache",
  "cachet",
  "cackle",
  "cacophony",
  "cad",
  "cadaver",
  "caddie",
  "caddy",
  "cadence",
  "cadet",
  "cadre",
  "caf",
  "cafe",
  "cafeteria",
  "caftan",
  "cage",
  "cairn",
  "cajole",
  "cake",
  "calabash",
  "calculation",
  "calculator",
  "caldron",
  "calendar",
  "calf",
  "calfskin",
  "caliber",
  "calibre",
  "calico",
  "caller",
  "calling",
  "calumny",
  "calyx",
  "cam",
  "camcorder",
  "camel",
  "cameo",
  "camera",
  "cameraman",
  "camisole",
  "camp",
  "campaign",
  "campaigner",
  "camper",
  "campfire",
  "campground",
  "campsite",
  "can",
  "canal",
  "canard",
  "canary",
  "cancellation",
  "cancer",
  "candelabra",
  "candidacy",
  "candidate",
  "candle",
  "candlestick",
  "candy",
  "cane",
  "canine",
  "canister",
  "cannery",
  "cannibal",
  "cannonball",
  "canoe",
  "canon",
  "canopy",
  "cant",
  "cantaloupe",
  "canteen",
  "canter",
  "cantina",
  "canton",
  "cantor",
  "canvass",
  "canyon",
  "cap",
  "capability",
  "capacity",
  "cape",
  "caper",
  "capital",
  "capitalist",
  "capitalization",
  "capitol",
  "capitulation",
  "capon",
  "caprice",
  "capstone",
  "capsule",
  "captain",
  "caption",
  "captive",
  "captivity",
  "captor",
  "capture",
  "car",
  "carafe",
  "caramel",
  "carapace",
  "carat",
  "caravan",
  "carbide",
  "carbine",
  "carbohydrate",
  "carbon",
  "carbonate",
  "carburetor",
  "carcass",
  "carcinogen",
  "card",
  "cardboard",
  "cardigan",
  "cardinal",
  "cardiologist",
  "career",
  "careerist",
  "carelessness",
  "caress",
  "caretaker",
  "cargo",
  "caricature",
  "carillon",
  "carload",
  "carnation",
  "carnival",
  "carnivore",
  "carol",
  "carotene",
  "carousel",
  "carpenter",
  "carpet",
  "carport",
  "carriage",
  "carrier",
  "carrot",
  "carryall",
  "carrying",
  "cart",
  "cartel",
  "carter",
  "cartilage",
  "carton",
  "cartoon",
  "cartoonist",
  "cartridge",
  "cartwheel",
  "carver",
  "carving",
  "cascade",
  "caseload",
  "casement",
  "cashier",
  "cashmere",
  "casing",
  "cask",
  "casket",
  "cassava",
  "casserole",
  "cassette",
  "cassock",
  "cast",
  "castaway",
  "caste",
  "casting",
  "castle",
  "castor",
  "casualty",
  "cat",
  "cataclysm",
  "catalog",
  "catalogue",
  "catalyst",
  "catamaran",
  "catapult",
  "cataract",
  "catch",
  "catcher",
  "catechism",
  "categorization",
  "category",
  "caterer",
  "caterpillar",
  "cathedral",
  "catheter",
  "cathode",
  "cathouse",
  "cation",
  "cattleman",
  "catwalk",
  "cauldron",
  "cauliflower",
  "causality",
  "causation",
  "cause",
  "causeway",
  "caution",
  "cavalcade",
  "cavalier",
  "cavalryman",
  "cave",
  "caveat",
  "caveman",
  "cavern",
  "cavity",
  "ce",
  "cease-fire",
  "cedar",
  "ceiling",
  "celebration",
  "celebrity",
  "cell",
  "cellar",
  "cellblock",
  "cellist",
  "cellmate",
  "cement",
  "cemetery",
  "censor",
  "censure",
  "centaur",
  "centenary",
  "center",
  "centerpiece",
  "centimeter",
  "centre",
  "centrifuge",
  "centurion",
  "cer",
  "ceramic",
  "cereal",
  "cerebrum",
  "ceremonial",
  "ceremony",
  "certainty",
  "certificate",
  "certification",
  "certitude",
  "cess",
  "cession",
  "cesspool",
  "chador",
  "chain",
  "chair",
  "chairman",
  "chairmanship",
  "chaise",
  "chalet",
  "chalice",
  "chalk",
  "chalkboard",
  "challenge",
  "challenger",
  "chamber",
  "chamberlain",
  "chambermaid",
  "chameleon",
  "champ",
  "champagne",
  "champion",
  "championship",
  "chance",
  "chancellery",
  "chancellor",
  "chancre",
  "chandelier",
  "change",
  "changeling",
  "changeover",
  "changer",
  "channel",
  "chant",
  "chanting",
  "chap",
  "chapel",
  "chaperone",
  "chaplain",
  "chapter",
  "char",
  "character",
  "characteristic",
  "characterization",
  "charcoal",
  "chard",
  "charge",
  "charger",
  "chariot",
  "charioteer",
  "charity",
  "charlatan",
  "charm",
  "charmer",
  "chart",
  "charter",
  "chartreuse",
  "chase",
  "chaser",
  "chasm",
  "chat",
  "chateau",
  "chattel",
  "chatter",
  "chatty",
  "chauffeur",
  "check",
  "checkbook",
  "checker",
  "checkerboard",
  "checklist",
  "checkout",
  "checkpoint",
  "checkup",
  "cheek",
  "cheekbone",
  "cheer",
  "cheering",
  "cheerleader",
  "cheeseburger",
  "cheesecake",
  "cheetah",
  "chef",
  "chemical",
  "chemise",
  "chemist",
  "chemistry",
  "chenille",
  "cheque",
  "cheroot",
  "cherry",
  "cherub",
  "chessboard",
  "chestnut",
  "chicanery",
  "chick",
  "chicken",
  "chief",
  "chieftain",
  "chiffon",
  "child",
  "childhood",
  "chile",
  "chili",
  "chill",
  "chillun",
  "chime",
  "chimera",
  "chimney",
  "chimp",
  "chimpanzee",
  "chin",
  "chine",
  "chip",
  "chipmunk",
  "chiropractor",
  "chisel",
  "chiton",
  "chloride",
  "chlorophyll",
  "chocolate",
  "choice",
  "choir",
  "choirboy",
  "choke",
  "choker",
  "cholera",
  "chop",
  "chopper",
  "chopping",
  "chord",
  "chore",
  "choreographer",
  "chowder",
  "chrissake",
  "christening",
  "chrome",
  "chromosome",
  "chronicle",
  "chronicler",
  "chronology",
  "chrysanthemum",
  "chuck",
  "chuckle",
  "chum",
  "chump",
  "chunk",
  "church",
  "churchman",
  "churchyard",
  "churn",
  "chute",
  "cider",
  "cigar",
  "cigaret",
  "cigarette",
  "cinch",
  "cinder",
  "cinema",
  "cinematographer",
  "cipher",
  "circel",
  "circle",
  "circlet",
  "circuit",
  "circular",
  "circulation",
  "circumference",
  "circumstance",
  "cistern",
  "citadel",
  "citation",
  "citizen",
  "citizenship",
  "citron",
  "city",
  "city-state",
  "cityscape",
  "civilian",
  "civilisation",
  "civility",
  "civilization",
  "claim",
  "claimant",
  "clam",
  "clamor",
  "clamp",
  "clampdown",
  "clan",
  "clang",
  "clank",
  "clanking",
  "clap",
  "clapboard",
  "clapper",
  "claque",
  "claret",
  "clarification",
  "clarinet",
  "clarinetist",
  "clarity",
  "clash",
  "clasp",
  "class",
  "classic",
  "classicist",
  "classification",
  "classmate",
  "classroom",
  "clatter",
  "clause",
  "clavicle",
  "claw",
  "clay",
  "claymore",
  "clean",
  "cleaner",
  "cleanser",
  "cleansing",
  "cleanup",
  "clearance",
  "clearing",
  "clearinghouse",
  "cleat",
  "cleaver",
  "cleft",
  "clemency",
  "clergyman",
  "cleric",
  "clerk",
  "clich",
  "cliche",
  "click",
  "clicking",
  "client",
  "clientele",
  "cliff",
  "cliffside",
  "climate",
  "climax",
  "climber",
  "clime",
  "clinch",
  "clinic",
  "clinician",
  "clink",
  "clip",
  "clipboard",
  "clipper",
  "clipping",
  "clique",
  "cloak",
  "cloakroom",
  "clock",
  "clod",
  "clog",
  "cloister",
  "clone",
  "close-up",
  "closet",
  "closeup",
  "closing",
  "closure",
  "clot",
  "cloth",
  "clothesline",
  "cloud",
  "clout",
  "clove",
  "clover",
  "clown",
  "club",
  "clubhouse",
  "clump",
  "cluster",
  "clustering",
  "clutch",
  "co-author",
  "co-chairman",
  "co-conspirator",
  "co-defendant",
  "co-director",
  "co-founder",
  "co-op",
  "co-operation",
  "co-ordination",
  "co-owner",
  "co-pilot",
  "co-star",
  "co-worker",
  "coach",
  "coachman",
  "coal",
  "coalition",
  "coast",
  "coaster",
  "coastline",
  "coat",
  "coating",
  "coauthor",
  "cob",
  "cobbler",
  "cobblestone",
  "cobra",
  "cobweb",
  "cochairman",
  "cockpit",
  "cockroach",
  "cocktail",
  "coconut",
  "cocoon",
  "coda",
  "code",
  "codger",
  "coding",
  "coed",
  "coefficient",
  "coenzyme",
  "coffee",
  "coffeehouse",
  "coffeepot",
  "coffin",
  "coffle",
  "cofounder",
  "cog",
  "cognac",
  "cognition",
  "cohabitation",
  "coherence",
  "cohesion",
  "cohort",
  "coif",
  "coiffure",
  "coil",
  "coin",
  "coinage",
  "coincidence",
  "coke",
  "col",
  "cola",
  "colander",
  "coliseum",
  "collaboration",
  "collaborator",
  "collage",
  "collapse",
  "collar",
  "collarbone",
  "collateral",
  "colleague",
  "collect",
  "collection",
  "collective",
  "collectivist",
  "collectivity",
  "collector",
  "colleen",
  "college",
  "collie",
  "collier",
  "collision",
  "cologne",
  "colon",
  "colonel",
  "colonist",
  "colonization",
  "colonnade",
  "colony",
  "color",
  "coloration",
  "coloring",
  "colour",
  "colouring",
  "colt",
  "column",
  "columnist",
  "com",
  "coma",
  "comb",
  "combination",
  "combustion",
  "comeback",
  "comedian",
  "comedienne",
  "comedy",
  "comer",
  "comet",
  "comfort",
  "comforter",
  "comic",
  "coming",
  "comma",
  "command",
  "commandant",
  "commander",
  "commander-in-chief",
  "commandment",
  "commando",
  "commemoration",
  "commencement",
  "commendation",
  "comment",
  "commentary",
  "commentator",
  "commercial",
  "commie",
  "commissar",
  "commission",
  "commissioner",
  "commitment",
  "committee",
  "committeeman",
  "commode",
  "commodity",
  "commodore",
  "commonality",
  "commoner",
  "commonplace",
  "commonwealth",
  "commotion",
  "commune",
  "communication",
  "communicator",
  "communion",
  "communique",
  "community",
  "commuter",
  "companion",
  "companionway",
  "company",
  "comparison",
  "compartment",
  "compass",
  "compatriot",
  "compendium",
  "compensation",
  "competence",
  "competency",
  "competition",
  "competitor",
  "compilation",
  "complacency",
  "complaint",
  "completion",
  "complex",
  "complexion",
  "complexity",
  "compliance",
  "complication",
  "compliment",
  "component",
  "composer",
  "composite",
  "composition",
  "compost",
  "compound",
  "comprehension",
  "compress",
  "compression",
  "compressor",
  "compromise",
  "comptroller",
  "compunction",
  "computation",
  "computer",
  "comrade",
  "concatenation",
  "concealment",
  "conceit",
  "concentrate",
  "concentration",
  "concept",
  "conception",
  "conceptualization",
  "concern",
  "concert",
  "concertina",
  "concession",
  "conch",
  "concierge",
  "conciliation",
  "conciliator",
  "conclave",
  "conclusion",
  "concoction",
  "concourse",
  "concubine",
  "concurrence",
  "concussion",
  "condemnation",
  "condensation",
  "condenser",
  "condition",
  "conditioner",
  "condolence",
  "condominium",
  "condor",
  "conduct",
  "conductor",
  "conduit",
  "cone",
  "confection",
  "confederate",
  "confederation",
  "conference",
  "confession",
  "confessional",
  "confessor",
  "confidant",
  "confidante",
  "configuration",
  "confinement",
  "confirmation",
  "confiscation",
  "conflagration",
  "conflict",
  "confluence",
  "conformation",
  "conformist",
  "confrontation",
  "confusion",
  "conga",
  "congestion",
  "conglomerate",
  "conglomeration",
  "congregation",
  "congress",
  "congressman",
  "conjecture",
  "conjunction",
  "conjurer",
  "connection",
  "connector",
  "connexion",
  "connoisseur",
  "connotation",
  "conqueror",
  "conquest",
  "conscience",
  "consciousness",
  "conscript",
  "conscription",
  "consent",
  "consequence",
  "conservation",
  "conservationist",
  "conservative",
  "conservator",
  "conservatory",
  "consideration",
  "consignment",
  "consistency",
  "consolation",
  "console",
  "consolidation",
  "consonant",
  "consort",
  "consortium",
  "conspiracy",
  "conspirator",
  "constable",
  "constancy",
  "constant",
  "constellation",
  "constituency",
  "constituent",
  "constitution",
  "constraint",
  "constriction",
  "constrictor",
  "construct",
  "construction",
  "constructionist",
  "constructivist",
  "consul",
  "consulate",
  "consultant",
  "consultation",
  "consumer",
  "consumption",
  "contact",
  "container",
  "contaminant",
  "contamination",
  "contemplation",
  "contemporary",
  "contempt",
  "contender",
  "content",
  "contention",
  "contentment",
  "contest",
  "contestant",
  "context",
  "continent",
  "contingency",
  "contingent",
  "continuance",
  "continuation",
  "continuity",
  "continuum",
  "contour",
  "contra",
  "contraband",
  "contraceptive",
  "contract",
  "contraction",
  "contractor",
  "contradiction",
  "contraption",
  "contrary",
  "contrast",
  "contravention",
  "contribution",
  "contributor",
  "contrivance",
  "control",
  "controller",
  "controversy",
  "conundrum",
  "convenience",
  "convent",
  "convention",
  "conventionalist",
  "convergence",
  "conversation",
  "conversationalist",
  "converse",
  "conversion",
  "convert",
  "converter",
  "convertible",
  "conveyance",
  "conveyor",
  "conviviality",
  "convocation",
  "convoy",
  "convulsion",
  "cook",
  "cookbook",
  "cooker",
  "cookie",
  "cookstove",
  "coolant",
  "cooler",
  "coolie",
  "coon",
  "coop",
  "cooperative",
  "coordination",
  "coordinator",
  "cop",
  "copier",
  "copper",
  "coproduction",
  "copse",
  "copter",
  "copulation",
  "copyright",
  "copywriter",
  "coral",
  "cord",
  "cordiality",
  "cordon",
  "corduroy",
  "core",
  "cork",
  "corkscrew",
  "corn",
  "corncob",
  "cornea",
  "corner",
  "cornerback",
  "cornerstone",
  "cornet",
  "cornfield",
  "cornice",
  "cornucopia",
  "corollary",
  "coronation",
  "coroner",
  "corporal",
  "corporation",
  "corpse",
  "corpsman",
  "corpus",
  "corral",
  "correction",
  "corrective",
  "correlation",
  "correspondence",
  "correspondent",
  "corridor",
  "corsage",
  "corsair",
  "corset",
  "cortex",
  "cosmology",
  "cosmopolitan",
  "costume",
  "cot",
  "coterie",
  "cottage",
  "cotton",
  "cottonwood",
  "couch",
  "cough",
  "council",
  "councilman",
  "councilor",
  "counsel",
  "counsellor",
  "counselor",
  "count",
  "countdown",
  "countenance",
  "counter",
  "counterattack",
  "counterfeit",
  "counterforce",
  "counterman",
  "counterpart",
  "counterpoint",
  "counterproposal",
  "counterrevolution",
  "countertop",
  "counterweight",
  "countess",
  "country",
  "countryman",
  "countryside",
  "county",
  "couple",
  "couplet",
  "coupling",
  "coupon",
  "courier",
  "course",
  "court",
  "court-martial",
  "courtesan",
  "courtesy",
  "courthouse",
  "courtier",
  "courtroom",
  "courtship",
  "courtyard",
  "cousin",
  "couturier",
  "cove",
  "coven",
  "covenant",
  "cover",
  "cover-up",
  "coverage",
  "coverall",
  "covering",
  "coverlet",
  "covey",
  "cowbell",
  "cowboy",
  "cowgirl",
  "cowhide",
  "cowl",
  "coyote",
  "crab",
  "crack",
  "crackdown",
  "cracker",
  "crackle",
  "crackling",
  "crackpot",
  "cradle",
  "craft",
  "craftsman",
  "cramp",
  "cranberry",
  "crane",
  "crank",
  "cranny",
  "crap",
  "crash",
  "crate",
  "crater",
  "cravat",
  "craving",
  "crayon",
  "craze",
  "creak",
  "cream",
  "crease",
  "creation",
  "creator",
  "creature",
  "creche",
  "credit",
  "creditor",
  "creed",
  "creek",
  "creel",
  "cremation",
  "crematorium",
  "creole",
  "crepe",
  "crescent",
  "crest",
  "crevasse",
  "crevice",
  "crew",
  "crewcut",
  "crewman",
  "crib",
  "crick",
  "cricket",
  "crier",
  "crimp",
  "crimson",
  "cripple",
  "crisis",
  "crisp",
  "crissake",
  "crisscross",
  "criterion",
  "critic",
  "criticism",
  "critique",
  "critter",
  "croak",
  "crochet",
  "crock",
  "crocodile",
  "croissant",
  "crone",
  "crony",
  "crook",
  "crooner",
  "crop",
  "cropland",
  "cropper",
  "cropping",
  "cross",
  "cross-examination",
  "cross-section",
  "crossbar",
  "crossbow",
  "crossfire",
  "crossing",
  "crossover",
  "crossword",
  "crotch",
  "croupier",
  "crow",
  "crowbar",
  "crowd",
  "crown",
  "crucible",
  "crucifix",
  "crucifixion",
  "crude",
  "crudeness",
  "crudity",
  "cruise",
  "cruiser",
  "crumb",
  "crumbling",
  "crunch",
  "crusade",
  "crusader",
  "crush",
  "crusher",
  "crust",
  "crutch",
  "crypt",
  "cryptographer",
  "crystal",
  "crystallization",
  "cub",
  "cubble",
  "cubbyhole",
  "cube",
  "cubicle",
  "cubist",
  "cuckoo",
  "cucumber",
  "cud",
  "cudgel",
  "cuff",
  "cuisine",
  "cul-de-sac",
  "cultivator",
  "culture",
  "culvert",
  "cummerbund",
  "cup",
  "cupboard",
  "cupola",
  "cur",
  "curate",
  "curator",
  "curb",
  "curd",
  "cure",
  "curfew",
  "curio",
  "curiosity",
  "curmudgeon",
  "curragh",
  "currant",
  "currency",
  "current",
  "curriculum",
  "curry",
  "curtailment",
  "curtain",
  "curtsy",
  "curvature",
  "curve",
  "cushion",
  "custard",
  "custodian",
  "custody",
  "custom",
  "customer",
  "cut",
  "cutaway",
  "cutback",
  "cuticle",
  "cutie",
  "cutoff",
  "cutout",
  "cutter",
  "cutthroat",
  "cutting",
  "cy",
  "cyanide",
  "cyclamate",
  "cycle",
  "cyclist",
  "cyclone",
  "cylinder",
  "cymbal",
  "cynic",
  "cynicism",
  "cypress",
  "cyst",
  "czar",
  "da",
  "dab",
  "dacha",
  "dachshund",
  "dagger",
  "dairy",
  "daisy",
  "dalliance",
  "dam",
  "damage",
  "damask",
  "dame",
  "damn",
  "damnation",
  "damp",
  "damper",
  "damsel",
  "dance",
  "dancer",
  "dancing",
  "dandelion",
  "dandy",
  "daredevil",
  "darkroom",
  "darky",
  "darlin",
  "darling",
  "dart",
  "dash",
  "dashboard",
  "database",
  "date",
  "davenport",
  "daybed",
  "daydream",
  "daylight",
  "dazzle",
  "deacon",
  "dead-end",
  "deadbeat",
  "deadline",
  "deadlock",
  "deadpan",
  "deal",
  "dealer",
  "dealership",
  "dealing",
  "dear",
  "dearie",
  "debacle",
  "debasement",
  "debate",
  "debater",
  "debauchery",
  "debility",
  "debit",
  "debriefing",
  "debt",
  "debtor",
  "debut",
  "debutante",
  "decadent",
  "decal",
  "decanter",
  "decency",
  "decision",
  "deck",
  "declaration",
  "declivity",
  "decoder",
  "decor",
  "decoration",
  "decorator",
  "decree",
  "dedication",
  "deductible",
  "deduction",
  "deed",
  "deejay",
  "deerskin",
  "default",
  "defector",
  "defence",
  "defendant",
  "defender",
  "defense",
  "defenseman",
  "deference",
  "deferment",
  "deferral",
  "defiance",
  "deficit",
  "defile",
  "definition",
  "deflation",
  "deflection",
  "defoliant",
  "deformation",
  "deformity",
  "degree",
  "deity",
  "delay",
  "delegate",
  "delegation",
  "deletion",
  "deli",
  "deliberation",
  "delicacy",
  "delicatessen",
  "delight",
  "delineation",
  "delinquency",
  "delinquent",
  "deliverance",
  "deliverer",
  "delivery",
  "dell",
  "delta",
  "deluge",
  "demagogue",
  "demand",
  "demarcation",
  "demeanor",
  "dementia",
  "demesne",
  "demitasse",
  "democracy",
  "democrat",
  "demographer",
  "demolition",
  "demon",
  "demonstration",
  "demonstrator",
  "demotion",
  "den",
  "dence",
  "denial",
  "denigration",
  "denim",
  "denomination",
  "denominator",
  "denouement",
  "density",
  "dent",
  "dentist",
  "denunciation",
  "deodorant",
  "department",
  "departure",
  "dependence",
  "dependency",
  "dependent",
  "depiction",
  "depletion",
  "deployment",
  "deportation",
  "deposit",
  "deposition",
  "depot",
  "depravity",
  "depth",
  "deputation",
  "deputy",
  "derailment",
  "derangement",
  "derby",
  "dereliction",
  "derivation",
  "derivative",
  "dermatologist",
  "derriere",
  "dervish",
  "descendant",
  "descent",
  "description",
  "desert",
  "deserter",
  "desertion",
  "design",
  "designation",
  "designer",
  "desire",
  "desk",
  "desktop",
  "desperado",
  "desperation",
  "despot",
  "despotism",
  "dessert",
  "destination",
  "destiny",
  "detachment",
  "detail",
  "detective",
  "detector",
  "detergent",
  "deterioration",
  "determinant",
  "determination",
  "determinism",
  "deterrent",
  "detonation",
  "detonator",
  "detour",
  "detriment",
  "deuce",
  "devaluation",
  "developer",
  "development",
  "deviation",
  "device",
  "devotee",
  "devotion",
  "dew",
  "dharma",
  "diabetic",
  "diadem",
  "diagnosis",
  "diagnostician",
  "diagram",
  "dial",
  "dialect",
  "dialectic",
  "dialog",
  "dialogue",
  "diameter",
  "diamond",
  "diaper",
  "diaphragm",
  "diary",
  "diatribe",
  "dichotomy",
  "dictation",
  "dictator",
  "dictatorship",
  "dictionary",
  "dictum",
  "die",
  "diesel",
  "diet",
  "dietician",
  "difference",
  "differential",
  "differentiation",
  "difficulty",
  "diffuser",
  "diffusion",
  "dig",
  "digestion",
  "digger",
  "digging",
  "digit",
  "dignitary",
  "dignity",
  "digression",
  "dike",
  "dilemma",
  "dilettante",
  "dilution",
  "dime",
  "dimension",
  "diminution",
  "diminutive",
  "dimmer",
  "dimple",
  "diner",
  "dinette",
  "dinghy",
  "dinner",
  "dinosaur",
  "dint",
  "diocese",
  "diorama",
  "dioxide",
  "dioxin",
  "dip",
  "diplomacy",
  "diplomat",
  "dipper",
  "dipping",
  "direction",
  "directive",
  "director",
  "directorate",
  "directorship",
  "directory",
  "dirge",
  "disc",
  "discard",
  "discharge",
  "disciple",
  "disciplinarian",
  "discipline",
  "disclaimer",
  "disclosure",
  "discoloration",
  "discomfiture",
  "discomfort",
  "discontent",
  "discord",
  "discotheque",
  "discount",
  "discouragement",
  "discourse",
  "discourtesy",
  "discoverer",
  "discovery",
  "discrepancy",
  "discrimination",
  "discussion",
  "disdain",
  "disequilibrium",
  "disgrace",
  "disguise",
  "dish",
  "disharmony",
  "dishonesty",
  "dishonor",
  "dishpan",
  "dishtowel",
  "dishwasher",
  "disillusionment",
  "disinfectant",
  "disintegration",
  "disjunction",
  "disk",
  "disparity",
  "dispatch",
  "dispatcher",
  "dispensary",
  "dispensation",
  "dispenser",
  "dispersion",
  "displacement",
  "display",
  "disposal",
  "disposition",
  "disproportion",
  "dispute",
  "disquisition",
  "disruption",
  "dissection",
  "dissector",
  "dissension",
  "dissent",
  "dissenter",
  "dissertation",
  "disservice",
  "dissident",
  "dissipation",
  "dissolution",
  "dissonance",
  "distance",
  "distemper",
  "distillate",
  "distillation",
  "distillery",
  "distinction",
  "distortion",
  "distraction",
  "distribution",
  "distributor",
  "distributorship",
  "district",
  "disturbance",
  "dition",
  "ditty",
  "divan",
  "dive",
  "diver",
  "divergence",
  "diversion",
  "diversity",
  "divestiture",
  "divide",
  "dividend",
  "divider",
  "divination",
  "divine",
  "divinity",
  "division",
  "do-gooder",
  "doc",
  "dock",
  "docket",
  "docking",
  "dockside",
  "doctor",
  "doctorate",
  "doctrine",
  "docudrama",
  "document",
  "documentary",
  "documentation",
  "dodge",
  "doe",
  "dogmatism",
  "dogwood",
  "dollop",
  "dolphin",
  "dom",
  "domain",
  "dome",
  "domestic",
  "domicile",
  "domination",
  "dominion",
  "domino",
  "donation",
  "donkey",
  "donor",
  "donut",
  "doom",
  "door",
  "doorbell",
  "doorjamb",
  "doorkeeper",
  "doorknob",
  "doorman",
  "doormat",
  "doorsill",
  "doorstep",
  "doorway",
  "dope",
  "dorm",
  "dormer",
  "dormitory",
  "dosage",
  "dose",
  "dossier",
  "dot",
  "dotage",
  "double",
  "double-dealing",
  "double-take",
  "doubleheader",
  "doubler",
  "doublet",
  "doubling",
  "doubt",
  "douche",
  "dough",
  "doughnut",
  "dove",
  "dovetail",
  "dowager",
  "dowel",
  "down",
  "downfall",
  "downhill",
  "downpour",
  "downturn",
  "dowry",
  "doze",
  "drab",
  "draft",
  "draftee",
  "draftsman",
  "dragon",
  "dragonet",
  "dragonfly",
  "drain",
  "drainage",
  "draining",
  "dramatist",
  "dramatization",
  "drape",
  "drapery",
  "draught",
  "draw",
  "drawback",
  "drawbridge",
  "drawer",
  "drawing",
  "drawing-room",
  "drawl",
  "drawstring",
  "dread",
  "dream",
  "dreamer",
  "dredge",
  "dredging",
  "dress",
  "dresser",
  "dressing",
  "dressing-room",
  "dressmaker",
  "dribble",
  "drier",
  "drift",
  "drill",
  "drilling",
  "drink",
  "drinker",
  "drip",
  "dripping",
  "drive",
  "driver",
  "driveway",
  "drone",
  "droop",
  "drop",
  "droplet",
  "dropout",
  "dropping",
  "drove",
  "drowning",
  "drubbing",
  "drudge",
  "drudgery",
  "drug",
  "druggist",
  "drugstore",
  "druid",
  "drum",
  "drumbeat",
  "drummer",
  "drumming",
  "drumstick",
  "drunk",
  "drunkard",
  "dryad",
  "drybone",
  "dryer",
  "dualism",
  "duality",
  "duchy",
  "duckling",
  "duct",
  "duction",
  "duel",
  "duffel",
  "dugout",
  "duke",
  "dukedom",
  "dumbbell",
  "dummy",
  "dump",
  "dumping",
  "dumpling",
  "dumpster",
  "dun",
  "dunce",
  "dune",
  "dung",
  "dungeon",
  "duo",
  "duocorn",
  "duplicate",
  "duplication",
  "duration",
  "dust",
  "duster",
  "dusting",
  "dustpan",
  "dwarf",
  "dweller",
  "dwelling",
  "dy",
  "dye",
  "dynamo",
  "dynasty",
  "dysentery",
  "dystrophy",
  "eagle",
  "ear",
  "earl",
  "earlobe",
  "earner",
  "earphone",
  "earpiece",
  "earplug",
  "earring",
  "earth",
  "earthenware",
  "earthling",
  "earthquake",
  "easel",
  "eater",
  "eatery",
  "eating",
  "eavesdropper",
  "ebb",
  "eccentricity",
  "echelon",
  "echo",
  "eclipse",
  "ecologist",
  "ecology",
  "economist",
  "economy",
  "ecosystem",
  "ecstasy",
  "edging",
  "edict",
  "edifice",
  "edition",
  "editor",
  "editorial",
  "education",
  "educator",
  "effect",
  "efficacy",
  "efficiency",
  "effigy",
  "effluent",
  "effort",
  "effrontery",
  "effusion",
  "egalitarian",
  "egg",
  "eggplant",
  "eggshell",
  "egomaniac",
  "egotist",
  "eighteen-wheeler",
  "el",
  "elaboration",
  "elasticity",
  "elbow",
  "elder",
  "elect",
  "election",
  "elector",
  "electorate",
  "electrician",
  "electricity",
  "electrocardiogram",
  "electrocution",
  "electrode",
  "electrolyte",
  "electron",
  "elegance",
  "elegy",
  "element",
  "elephant",
  "elevation",
  "elevator",
  "elf",
  "elimination",
  "elite",
  "elixir",
  "ell",
  "ellipse",
  "elm",
  "elongation",
  "emanation",
  "emancipation",
  "embankment",
  "embargo",
  "embassy",
  "embellishment",
  "ember",
  "embezzlement",
  "embezzler",
  "emblem",
  "embodiment",
  "embolden",
  "embolism",
  "embrace",
  "embrasure",
  "embroidery",
  "emcee",
  "emerald",
  "emergency",
  "emigration",
  "emigre",
  "eminence",
  "emissary",
  "emission",
  "emotion",
  "emperor",
  "emphasis",
  "empire",
  "empiricist",
  "emplacement",
  "employe",
  "employee",
  "employer",
  "employment",
  "emporium",
  "empress",
  "emptiness",
  "emulsion",
  "enactment",
  "enamel",
  "encampment",
  "ence",
  "enchantment",
  "enclave",
  "enclosure",
  "encore",
  "encounter",
  "encouragement",
  "encroachment",
  "encumbrance",
  "encyclopedia",
  "endearment",
  "endeavor",
  "endeavour",
  "endgame",
  "ending",
  "endorsement",
  "endowment",
  "endurance",
  "energy",
  "enforcement",
  "enforcer",
  "engagement",
  "engine",
  "engineer",
  "engraving",
  "enhancement",
  "enjoyment",
  "enlargement",
  "enlistment",
  "enmity",
  "enormity",
  "enquiry",
  "enrichment",
  "enrollment",
  "ensemble",
  "ensign",
  "ent",
  "entanglement",
  "enterprise",
  "entertainer",
  "entertainment",
  "enthusiasm",
  "enthusiast",
  "enticement",
  "entitlement",
  "entity",
  "entomologist",
  "entourage",
  "entrance",
  "entranceway",
  "entrant",
  "entreaty",
  "entree",
  "entrepreneur",
  "entry",
  "entryway",
  "enumeration",
  "envelope",
  "environ",
  "environment",
  "environmentalist",
  "envoy",
  "enzyme",
  "ephor",
  "epic",
  "epidemic",
  "epidemiologist",
  "epigraph",
  "epileptic",
  "epilogue",
  "epiphany",
  "episode",
  "epistemology",
  "epitaph",
  "epithet",
  "epitome",
  "equality",
  "equation",
  "equator",
  "equerry",
  "equinox",
  "equity",
  "equivalence",
  "equivalency",
  "equivalent",
  "equivocation",
  "eral",
  "eraser",
  "erasure",
  "eration",
  "ern",
  "ernment",
  "errand",
  "error",
  "eruption",
  "escalation",
  "escalator",
  "escapade",
  "escape",
  "escapist",
  "escarpment",
  "esplanade",
  "essay",
  "essayist",
  "esse",
  "essence",
  "establishment",
  "estate",
  "esteem",
  "estimate",
  "estimation",
  "estrangement",
  "estrogen",
  "estuary",
  "etching",
  "eternity",
  "ether",
  "ethnicity",
  "eulogy",
  "euphemism",
  "evacuation",
  "evaluation",
  "evangelist",
  "evasion",
  "event",
  "eventuality",
  "evergreen",
  "eviction",
  "evidence",
  "evocation",
  "evolution",
  "ewe",
  "exaggeration",
  "exaltation",
  "exam",
  "examination",
  "examiner",
  "example",
  "exasperation",
  "excavation",
  "excellence",
  "exception",
  "excerpt",
  "excess",
  "exchange",
  "exchanger",
  "excise",
  "excision",
  "excitement",
  "exclamation",
  "exclusion",
  "excommunication",
  "excrement",
  "excretion",
  "excursion",
  "excuse",
  "execution",
  "executioner",
  "executive",
  "executor",
  "exegesis",
  "exemption",
  "exercise",
  "exertion",
  "exhalation",
  "exhaust",
  "exhibit",
  "exhibition",
  "exhibitionist",
  "exhibitor",
  "exhilaration",
  "exhortation",
  "existence",
  "exorcism",
  "expanse",
  "expansion",
  "expatriate",
  "expectancy",
  "expectant",
  "expectation",
  "expediency",
  "expedient",
  "expediter",
  "expedition",
  "expenditure",
  "expense",
  "experience",
  "experiment",
  "experimentation",
  "experimenter",
  "expert",
  "expiration",
  "explanation",
  "expletive",
  "exploit",
  "exploitation",
  "exploration",
  "explorer",
  "exploring",
  "explosion",
  "explosive",
  "exponent",
  "export",
  "exporter",
  "exposition",
  "exposure",
  "expression",
  "expressionist",
  "expressway",
  "expropriation",
  "expulsion",
  "extension",
  "extent",
  "exterior",
  "extermination",
  "exterminator",
  "extinction",
  "extinguisher",
  "extortion",
  "extract",
  "extraction",
  "extrapolation",
  "extravagance",
  "extravaganza",
  "extreme",
  "extremity",
  "extrovert",
  "exuberance",
  "exultation",
  "eye",
  "eyeball",
  "eyebrow",
  "eyedropper",
  "eyeglass",
  "eyelash",
  "eyelet",
  "eyelid",
  "eyepiece",
  "eyeshade",
  "eyesore",
  "eyewitness",
  "fa",
  "fable",
  "fabric",
  "fabrication",
  "facade",
  "face",
  "face-lift",
  "faceplate",
  "facet",
  "facility",
  "facing",
  "facsimile",
  "fact",
  "faction",
  "factor",
  "factory",
  "factotum",
  "faculty",
  "fad",
  "faint",
  "fairground",
  "fairway",
  "fairy",
  "fairy-tale",
  "fairyland",
  "fairytale",
  "faith",
  "falcon",
  "fallacy",
  "fallibility",
  "familiarity",
  "family",
  "fan",
  "fanaticism",
  "fancier",
  "fancy",
  "fanfare",
  "fang",
  "fantasy",
  "farce",
  "farewell",
  "farm",
  "farmboy",
  "farmer",
  "farmhouse",
  "farmland",
  "farmstead",
  "farmyard",
  "fascination",
  "fashion",
  "fastball",
  "fastening",
  "fasting",
  "fastness",
  "fate",
  "fatigue",
  "faucet",
  "favor",
  "favorite",
  "favour",
  "favourite",
  "fawn",
  "fax",
  "feat",
  "feather",
  "feature",
  "federation",
  "fedora",
  "fee",
  "feed",
  "feedback",
  "feeder",
  "feeding",
  "feedlot",
  "feeling",
  "feint",
  "felicity",
  "fell",
  "fella",
  "feller",
  "fellow",
  "fellowship",
  "felt",
  "femme",
  "fence",
  "fencer",
  "fender",
  "fense",
  "fer",
  "ference",
  "ferment",
  "fern",
  "ferret",
  "ferry",
  "ferryboat",
  "ferryman",
  "fertilizer",
  "fervor",
  "fester",
  "festival",
  "festivity",
  "feud",
  "fever",
  "fiber",
  "fibre",
  "fibrillation",
  "fiction",
  "fief",
  "fiefdom",
  "field",
  "fielder",
  "fiend",
  "fiesta",
  "fife",
  "fig",
  "figger",
  "fight",
  "fighter",
  "fighting",
  "figment",
  "figure",
  "figurehead",
  "figurine",
  "figuring",
  "filament",
  "file",
  "filet",
  "filibuster",
  "filigree",
  "filing",
  "filler",
  "fillet",
  "filling",
  "fillip",
  "filly",
  "film",
  "filmmaker",
  "filter",
  "fin",
  "final",
  "finale",
  "finalist",
  "finality",
  "finance",
  "financier",
  "financing",
  "finder",
  "finding",
  "finery",
  "finesse",
  "finger",
  "fingernail",
  "fingerprint",
  "fingertip",
  "finish",
  "finisher",
  "fink",
  "fir",
  "fire",
  "firearm",
  "fireball",
  "firebox",
  "firebrand",
  "firecracker",
  "firefight",
  "firefighter",
  "firehouse",
  "fireman",
  "fireplace",
  "fireside",
  "firestorm",
  "firm",
  "firmament",
  "fishbowl",
  "fisher",
  "fisherman",
  "fishery",
  "fishhook",
  "fishnet",
  "fission",
  "fissure",
  "fist",
  "fistfight",
  "fistful",
  "fit",
  "fitness",
  "fitter",
  "fitting",
  "fiver",
  "fiveyear",
  "fix",
  "fixation",
  "fixer",
  "fixing",
  "fixity",
  "fixture",
  "fjord",
  "flag",
  "flagon",
  "flagpole",
  "flagship",
  "flagstone",
  "flail",
  "flake",
  "flame",
  "flamethrower",
  "flange",
  "flank",
  "flannel",
  "flap",
  "flapper",
  "flare",
  "flare-up",
  "flash",
  "flashback",
  "flasher",
  "flashlight",
  "flask",
  "flat",
  "flatboat",
  "flatcar",
  "flatland",
  "flatness",
  "flavor",
  "flavour",
  "flaw",
  "flea",
  "fleck",
  "fledgling",
  "fleece",
  "fleet",
  "flesh",
  "flex",
  "flick",
  "flicker",
  "flier",
  "flight",
  "flimsy",
  "flinch",
  "flint",
  "flip",
  "flip-flop",
  "flippancy",
  "flipper",
  "flirt",
  "flirtation",
  "flirting",
  "flitter",
  "float",
  "floater",
  "flock",
  "flogging",
  "flood",
  "flooding",
  "floodlight",
  "floor",
  "floorboard",
  "flooring",
  "flop",
  "flophouse",
  "florist",
  "flotilla",
  "flounce",
  "flour",
  "flourish",
  "flow",
  "flower",
  "flowering",
  "flowerpot",
  "flu",
  "fluctuation",
  "flue",
  "fluff",
  "fluid",
  "fluoride",
  "flurry",
  "flush",
  "flushing",
  "flute",
  "fluting",
  "flutist",
  "flutter",
  "fly",
  "flyer",
  "flyleaf",
  "flywheel",
  "fo",
  "foal",
  "foam",
  "focus",
  "fodder",
  "fog",
  "foghorn",
  "foil",
  "foist",
  "fold",
  "folder",
  "foliage",
  "folio",
  "folklore",
  "foller",
  "follicle",
  "follow-up",
  "follower",
  "following",
  "folly",
  "font",
  "food",
  "football",
  "footbridge",
  "footfall",
  "foothill",
  "foothold",
  "footing",
  "footlocker",
  "footman",
  "footnote",
  "footpath",
  "footprint",
  "footrest",
  "footstep",
  "footstool",
  "fop",
  "forage",
  "foray",
  "force",
  "ford",
  "forearm",
  "foreboding",
  "forecast",
  "forecaster",
  "foreclosure",
  "forefinger",
  "foreground",
  "forehead",
  "foreigner",
  "foreleg",
  "forelock",
  "foreman",
  "forepaw",
  "forerunner",
  "foresight",
  "foreskin",
  "forest",
  "forester",
  "foreword",
  "forfeiture",
  "fork",
  "forklift",
  "form",
  "formalism",
  "formality",
  "formance",
  "format",
  "formation",
  "formula",
  "formulation",
  "fort",
  "fortress",
  "fortune",
  "fortune-teller",
  "forum",
  "forward",
  "fossil",
  "foul",
  "foul-up",
  "foundation",
  "founder",
  "foundry",
  "fount",
  "fountain",
  "fox",
  "foxhole",
  "foyer",
  "fraction",
  "fracture",
  "fragility",
  "fragment",
  "fragmentation",
  "fragrance",
  "frailty",
  "frame",
  "frame-up",
  "framework",
  "franchise",
  "frat",
  "fraternity",
  "fray",
  "freak",
  "free-fall",
  "freedman",
  "freedom",
  "freelancer",
  "freeway",
  "freeze",
  "freezer",
  "freight",
  "freighter",
  "frenzy",
  "frequency",
  "fresco",
  "freshman",
  "fret",
  "friar",
  "friction",
  "fridge",
  "friend",
  "friendly",
  "friendship",
  "frieze",
  "frigate",
  "fright",
  "frill",
  "fringe",
  "frisbee",
  "frisson",
  "frivolity",
  "frock",
  "frolic",
  "frond",
  "front",
  "front-runner",
  "frontage",
  "frontier",
  "frontiersman",
  "frontline",
  "frontrunner",
  "frost",
  "frostbite",
  "frosting",
  "froth",
  "frown",
  "fruitcake",
  "frustration",
  "fuchsia",
  "fudge",
  "fuel",
  "fugue",
  "fulcrum",
  "fulfillment",
  "fulfilment",
  "fullback",
  "fumble",
  "fumbling",
  "function",
  "functionalist",
  "functionary",
  "functioning",
  "fund",
  "fund-raiser",
  "fundamentalist",
  "funeral",
  "fungus",
  "funk",
  "funnel",
  "fur",
  "furcot",
  "furlough",
  "furnace",
  "furnishing",
  "furor",
  "furrow",
  "fuse",
  "fuselage",
  "fusillade",
  "fusion",
  "future",
  "futurist",
  "gabardine",
  "gable",
  "gadfly",
  "gadget",
  "gaff",
  "gaffe",
  "gage",
  "gaggle",
  "gaiety",
  "gain",
  "gainer",
  "gait",
  "gal",
  "gala",
  "galaxy",
  "gall",
  "gallantry",
  "galleon",
  "gallery",
  "galley",
  "gallop",
  "gambit",
  "gamble",
  "gambler",
  "gambling",
  "game",
  "gamete",
  "gametophyte",
  "gamma",
  "gantry",
  "gap",
  "garage",
  "garden",
  "gardener",
  "gardenia",
  "gargoyle",
  "garland",
  "garlic",
  "garment",
  "garner",
  "garnet",
  "garret",
  "garrison",
  "garter",
  "gash",
  "gasket",
  "gaslight",
  "gasoline",
  "gasp",
  "gate",
  "gatehouse",
  "gatekeeper",
  "gateway",
  "gathering",
  "gation",
  "gauge",
  "gauntlet",
  "gauze",
  "gavel",
  "gaze",
  "gazelle",
  "gear",
  "gearbox",
  "gebling",
  "geezer",
  "geisha",
  "gel",
  "gelatin",
  "gelding",
  "gem",
  "gen",
  "gence",
  "gender",
  "gene",
  "genealogy",
  "general",
  "generalist",
  "generality",
  "generalization",
  "generation",
  "generator",
  "generosity",
  "geneticist",
  "genie",
  "genius",
  "genre",
  "gent",
  "gentleman",
  "gentlewoman",
  "genus",
  "geographer",
  "geography",
  "geologist",
  "geometry",
  "geosector",
  "ger",
  "germ",
  "gestation",
  "gesture",
  "getaway",
  "getup",
  "geyser",
  "ghetto",
  "ghost",
  "ghoul",
  "giant",
  "giantess",
  "gift",
  "gig",
  "giggle",
  "gill",
  "gilt",
  "gimmick",
  "gin",
  "gingham",
  "giraffe",
  "girder",
  "girdle",
  "girth",
  "gist",
  "giveaway",
  "giver",
  "giving",
  "gizzard",
  "glacier",
  "glade",
  "gladiator",
  "glamour",
  "glance",
  "gland",
  "glare",
  "glass",
  "glassful",
  "glassware",
  "glaze",
  "gleam",
  "glen",
  "glide",
  "glider",
  "gliding",
  "glimmer",
  "glimmering",
  "glimpse",
  "glint",
  "glitch",
  "glitter",
  "glob",
  "globe",
  "gloom",
  "glory",
  "gloss",
  "glove",
  "glow",
  "glower",
  "glue",
  "glutton",
  "glycogen",
  "gnat",
  "gnawing",
  "gnome",
  "goal",
  "goalie",
  "goaltender",
  "goat",
  "goatee",
  "goatskin",
  "goblet",
  "goblin",
  "going",
  "goiter",
  "gold",
  "golem",
  "golfer",
  "gondola",
  "goner",
  "gong",
  "good",
  "good-bye",
  "good-night",
  "goodbye",
  "goodie",
  "goodnight",
  "goof",
  "goon",
  "goose",
  "gopher",
  "gore",
  "gorge",
  "gorilla",
  "gospel",
  "gossip",
  "gouge",
  "gourd",
  "gourmet",
  "gout",
  "governess",
  "government",
  "governor",
  "governorship",
  "gown",
  "grab",
  "grabber",
  "grace",
  "grad",
  "grade",
  "grader",
  "gradient",
  "grading",
  "graduate",
  "graduation",
  "graft",
  "grail",
  "grailstone",
  "grain",
  "grammar",
  "gramophone",
  "granary",
  "grandeur",
  "grandmaster",
  "grandstand",
  "grange",
  "granite",
  "granny",
  "grant",
  "grape",
  "grapevine",
  "graph",
  "grass",
  "grasshopper",
  "grassland",
  "grate",
  "gratification",
  "gratuity",
  "grave",
  "gravestone",
  "graveyard",
  "gravity",
  "gravy",
  "gray",
  "grazer",
  "grease",
  "green",
  "greenback",
  "greengrocer",
  "greenhorn",
  "greenhouse",
  "greeter",
  "greeting",
  "grenade",
  "grendel",
  "greyhound",
  "grid",
  "gridiron",
  "grievance",
  "grill",
  "grille",
  "grimace",
  "grin",
  "grind",
  "grinder",
  "grinding",
  "grindstone",
  "grip",
  "gripe",
  "grit",
  "grizzly",
  "groan",
  "groaning",
  "grocer",
  "grocery",
  "groom",
  "groove",
  "groping",
  "grotesque",
  "grotto",
  "ground",
  "groundcar",
  "grounder",
  "grounding",
  "groundswell",
  "group",
  "grouper",
  "groupie",
  "grouping",
  "grove",
  "grower",
  "growl",
  "grown-up",
  "grownup",
  "growth",
  "grub",
  "grudge",
  "gruel",
  "grunt",
  "grunting",
  "guarantee",
  "guarantor",
  "guard",
  "guardhouse",
  "guardian",
  "guardianship",
  "guardrail",
  "guardsman",
  "guerrilla",
  "guess",
  "guessing",
  "guest",
  "guesthouse",
  "guffaw",
  "guide",
  "guidebook",
  "guideline",
  "guild",
  "guillotine",
  "guilt",
  "guinea",
  "guise",
  "guitar",
  "guitarist",
  "gulch",
  "gulf",
  "gull",
  "gullet",
  "gully",
  "gum",
  "gun",
  "gunboat",
  "gunfighter",
  "gunman",
  "gunner",
  "gunnysack",
  "gunshot",
  "gunsight",
  "gunwale",
  "gurdwara",
  "gurgle",
  "gurney",
  "gush",
  "gust",
  "gut",
  "gutter",
  "guy",
  "gym",
  "gymnast",
  "gypsy",
  "habit",
  "habitat",
  "habitation",
  "hacienda",
  "hack",
  "hacker",
  "hacking",
  "hacksaw",
  "hag",
  "hail",
  "hailstorm",
  "hair",
  "hairbrush",
  "haircut",
  "hairdresser",
  "hairline",
  "hairpiece",
  "hairpin",
  "hairstyle",
  "half-circle",
  "half-life",
  "halfback",
  "halftime",
  "hall",
  "hallmark",
  "halloo",
  "hallway",
  "halo",
  "halter",
  "ham",
  "hamadryad",
  "hamburger",
  "hamlet",
  "hammer",
  "hammering",
  "hammock",
  "hamper",
  "hamster",
  "hamstring",
  "han",
  "hand",
  "handbag",
  "handball",
  "handbook",
  "handcuff",
  "handful",
  "handgun",
  "handhold",
  "handicap",
  "handicraft",
  "handkerchief",
  "handle",
  "handlebar",
  "handler",
  "handmaiden",
  "handout",
  "handrail",
  "handshake",
  "handwriting",
  "handyman",
  "hang-up",
  "hangar",
  "hanger",
  "hanging",
  "hangman",
  "hangout",
  "hangover",
  "hank",
  "hanker",
  "hankie",
  "hanky",
  "hap",
  "happening",
  "harangue",
  "harbinger",
  "harbor",
  "harbour",
  "hard-liner",
  "hardback",
  "hardness",
  "hardtop",
  "hardwood",
  "hare",
  "harlot",
  "harm",
  "harmonica",
  "harmony",
  "harness",
  "harp",
  "harpist",
  "harpoon",
  "harpooner",
  "harpsichord",
  "harpy",
  "harridan",
  "harrier",
  "harrow",
  "hart",
  "harvest",
  "harvester",
  "has-been",
  "hash",
  "hassle",
  "hassock",
  "hat",
  "hatbox",
  "hatch",
  "hatchery",
  "hatchet",
  "hatching",
  "hatchway",
  "hatter",
  "haul",
  "haunch",
  "haunt",
  "haunting",
  "haven",
  "hawk",
  "hay",
  "hayloft",
  "haymaker",
  "hayseed",
  "haystack",
  "hazard",
  "headache",
  "headband",
  "headboard",
  "headdress",
  "heading",
  "headland",
  "headlight",
  "headline",
  "headman",
  "headmaster",
  "headpiece",
  "headset",
  "headsman",
  "headstone",
  "headwaiter",
  "headway",
  "headwrap",
  "healer",
  "healing",
  "heap",
  "hearer",
  "hearing",
  "hearse",
  "heart",
  "heartache",
  "heartbeat",
  "heartbreak",
  "hearth",
  "hearthstone",
  "heartland",
  "hearty",
  "heater",
  "heath",
  "heathen",
  "heather",
  "heave",
  "heaven",
  "heaving",
  "heavyweight",
  "hedge",
  "hedgehog",
  "hedonist",
  "heed",
  "heel",
  "heft",
  "hegemony",
  "heifer",
  "height",
  "heir",
  "heiress",
  "heirloom",
  "heist",
  "helicopter",
  "helix",
  "hellhole",
  "helm",
  "helmet",
  "helmsman",
  "help",
  "helper",
  "helping",
  "hem",
  "hemisphere",
  "hemline",
  "hemlock",
  "hemorrhage",
  "hen",
  "henchman",
  "henhouse",
  "herald",
  "herb",
  "herbicide",
  "herd",
  "herder",
  "herdsman",
  "heresy",
  "heretic",
  "heritage",
  "hermaphrodite",
  "hermit",
  "hernia",
  "hero",
  "heroine",
  "herringbone",
  "hesitancy",
  "hesitation",
  "hex",
  "heyday",
  "hiccup",
  "hick",
  "hickory",
  "hideaway",
  "hierarchy",
  "high",
  "highball",
  "highboy",
  "highland",
  "highlander",
  "highlight",
  "highschool",
  "highway",
  "hike",
  "hiker",
  "hilarity",
  "hill",
  "hillock",
  "hillside",
  "hilltop",
  "hilt",
  "hint",
  "hinterland",
  "hip",
  "hire",
  "hiring",
  "historian",
  "historiography",
  "history",
  "hitch",
  "hitchhiker",
  "hitter",
  "hive",
  "hoard",
  "hoarding",
  "hoax",
  "hobble",
  "hobby",
  "hock",
  "hog",
  "hogan",
  "hoist",
  "holder",
  "holding",
  "holdout",
  "holdover",
  "holdup",
  "hole",
  "holiday",
  "holler",
  "hollow",
  "holly",
  "hologram",
  "holothete",
  "holster",
  "homage",
  "hombre",
  "home",
  "homebody",
  "homecoming",
  "homeland",
  "homemaker",
  "homeowner",
  "homer",
  "homeroom",
  "homestead",
  "homesteader",
  "hometown",
  "homily",
  "hone",
  "honey",
  "honeybee",
  "honeycomb",
  "honeymoon",
  "honkie",
  "honky-tonk",
  "honor",
  "honour",
  "hood",
  "hoodlum",
  "hoof",
  "hook",
  "hoop",
  "hoot",
  "hootch",
  "hooting",
  "hop",
  "hope",
  "hopper",
  "horde",
  "horizon",
  "hornet",
  "horoscope",
  "horse",
  "horseback",
  "horseman",
  "horsepower",
  "horseshoe",
  "hose",
  "hospice",
  "hospital",
  "hospitalization",
  "host",
  "hostel",
  "hostess",
  "hotel",
  "hound",
  "hourglass",
  "house",
  "houseboat",
  "houseboy",
  "housecoat",
  "housedress",
  "household",
  "householder",
  "housekeeper",
  "housing",
  "hovel",
  "howitzer",
  "howler",
  "hubcap",
  "huckleberry",
  "huddle",
  "hue",
  "hug",
  "hulk",
  "hull",
  "hum",
  "humanity",
  "humbug",
  "humidity",
  "humility",
  "hummingbird",
  "hummock",
  "humor",
  "humorist",
  "humour",
  "hump",
  "humpback",
  "hunch",
  "hunchback",
  "hunger",
  "hunt",
  "hunter",
  "hurdle",
  "hurricane",
  "hush",
  "husk",
  "hussy",
  "hustle",
  "hustler",
  "hut",
  "hutch",
  "hybrid",
  "hydrant",
  "hydrocarbon",
  "hydrolysis",
  "hyena",
  "hype",
  "hypnotist",
  "hypochondriac",
  "hypocrite",
  "hypothesis",
  "hysterectomy",
  "hysteria",
  "ice",
  "ice-cream",
  "iceberg",
  "icebox",
  "icehouse",
  "icicle",
  "icing",
  "icon",
  "iconoclast",
  "idea",
  "ideal",
  "idealism",
  "idealist",
  "idealization",
  "ident",
  "identification",
  "identity",
  "ideologist",
  "ideologue",
  "ideology",
  "idiom",
  "idiosyncrasy",
  "idjit",
  "idyll",
  "ignition",
  "ignominy",
  "ignorance",
  "iguana",
  "illumination",
  "illusion",
  "illustration",
  "image",
  "imagery",
  "imagination",
  "imbalance",
  "imbroglio",
  "imitation",
  "immediacy",
  "immensity",
  "immersion",
  "imp",
  "impact",
  "impairment",
  "impala",
  "impasse",
  "impeachment",
  "impediment",
  "imperative",
  "imperfection",
  "imperialism",
  "impersonation",
  "impersonator",
  "impertinence",
  "impiety",
  "implant",
  "implantation",
  "implement",
  "implication",
  "import",
  "importation",
  "importer",
  "imposition",
  "impossibility",
  "imposter",
  "impostor",
  "impoundment",
  "impresario",
  "impression",
  "imprint",
  "impropriety",
  "improvement",
  "improvisation",
  "impulse",
  "in-law",
  "inauguration",
  "inbound",
  "incantation",
  "incapacity",
  "incarceration",
  "incarnation",
  "incidence",
  "incident",
  "incinerator",
  "incline",
  "inclusion",
  "incoherence",
  "income",
  "incompatibility",
  "incongruity",
  "inconsistency",
  "inconvenience",
  "increase",
  "increment",
  "incumbency",
  "incumbent",
  "incursion",
  "indemnity",
  "indentation",
  "independence",
  "independent",
  "index",
  "indication",
  "indicator",
  "indictment",
  "indirection",
  "indiscretion",
  "individual",
  "individualist",
  "individuality",
  "individuation",
  "inducement",
  "induction",
  "inductivist",
  "indulgence",
  "industrialist",
  "industry",
  "ineptitude",
  "inequality",
  "inequity",
  "inertia",
  "inevitability",
  "infamy",
  "infantryman",
  "infarct",
  "infarction",
  "infatuation",
  "infection",
  "inference",
  "inferno",
  "infestation",
  "infield",
  "infielder",
  "infinity",
  "infirmary",
  "infirmity",
  "inflammation",
  "inflation",
  "inflection",
  "inflow",
  "influence",
  "informality",
  "informant",
  "information",
  "informer",
  "infraction",
  "infrastructure",
  "infringement",
  "infusion",
  "ingenue",
  "ingenuity",
  "ingot",
  "ingredient",
  "inhabitant",
  "inhalation",
  "inhaler",
  "inheritance",
  "inheritor",
  "inhibition",
  "inhibitor",
  "inhumanity",
  "iniquity",
  "initial",
  "initiation",
  "initiative",
  "initiator",
  "injection",
  "injunction",
  "injury",
  "injustice",
  "ink",
  "inkling",
  "inkwell",
  "inlay",
  "inlet",
  "inmate",
  "inn",
  "innkeeper",
  "innocence",
  "innocent",
  "innovation",
  "innovator",
  "innuendo",
  "inoculation",
  "inpatient",
  "input",
  "inquest",
  "inquiry",
  "inquisition",
  "inscription",
  "insecurity",
  "insemination",
  "insensitivity",
  "insert",
  "insertion",
  "inset",
  "inside",
  "insider",
  "insight",
  "insignia",
  "insincerity",
  "insinuation",
  "insistence",
  "inspection",
  "inspector",
  "inspiration",
  "instability",
  "installation",
  "installment",
  "instance",
  "instep",
  "instigation",
  "instigator",
  "instinct",
  "institute",
  "institution",
  "instruction",
  "instructor",
  "instrument",
  "instrumentality",
  "insulator",
  "insurer",
  "insurgency",
  "insurrection",
  "intake",
  "integration",
  "integrator",
  "intellect",
  "intellectual",
  "intellectualist",
  "intelligence",
  "intensification",
  "intensity",
  "intent",
  "intention",
  "interaction",
  "interception",
  "interceptor",
  "interchange",
  "intercom",
  "interconnection",
  "interest",
  "interface",
  "interference",
  "interferon",
  "interior",
  "interlocutor",
  "interloper",
  "interlude",
  "intermediary",
  "intermission",
  "intern",
  "internationalist",
  "internist",
  "internship",
  "interplay",
  "interpretation",
  "interpreter",
  "interrelationship",
  "interrogation",
  "interruption",
  "intersection",
  "interval",
  "intervention",
  "interview",
  "interviewee",
  "interviewer",
  "interweaving",
  "intestine",
  "intonation",
  "intricacy",
  "intrigue",
  "introduction",
  "introspection",
  "intrusion",
  "intuition",
  "invalid",
  "invariance",
  "invective",
  "invention",
  "inventor",
  "inventory",
  "inversion",
  "investigation",
  "investigator",
  "investment",
  "investor",
  "invisibility",
  "invitation",
  "invocation",
  "invoice",
  "involvement",
  "iodide",
  "iridescence",
  "iron",
  "ironclad",
  "ironist",
  "ironwork",
  "ironworker",
  "irony",
  "irrationality",
  "irregularity",
  "irrelevance",
  "irrelevancy",
  "irrigation",
  "irritant",
  "irritation",
  "island",
  "isle",
  "islet",
  "isolation",
  "isolationist",
  "isotope",
  "issue",
  "item",
  "itinerary",
  "ity",
  "ivory",
  "ivy",
  "jab",
  "jabber",
  "jacaranda",
  "jack",
  "jacket",
  "jackhammer",
  "jackknife",
  "jackpot",
  "jackrabbit",
  "jade",
  "jaguar",
  "jailbird",
  "jam",
  "jamb",
  "jangle",
  "jar",
  "jargon",
  "jasmine",
  "jaunt",
  "javelin",
  "jaw",
  "jawbone",
  "jawline",
  "jay",
  "jean",
  "jector",
  "jeep",
  "jelly",
  "jeopardy",
  "jerk",
  "jerkin",
  "jersey",
  "jest",
  "jester",
  "jet",
  "jetliner",
  "jetport",
  "jetty",
  "jewel",
  "jeweler",
  "jib",
  "jig",
  "jigsaw",
  "jimmy",
  "jingle",
  "job",
  "jobber",
  "jock",
  "jockey",
  "jog",
  "jogger",
  "joiner",
  "joining",
  "joint",
  "jolt",
  "jot",
  "journal",
  "journalist",
  "journey",
  "journeyman",
  "jowl",
  "jubilation",
  "jubilee",
  "judge",
  "judgement",
  "judgeship",
  "judging",
  "judgment",
  "jug",
  "juggernaut",
  "juggler",
  "juice",
  "juicer",
  "juke",
  "jukebox",
  "jumbo",
  "jumper",
  "jumpsuit",
  "junction",
  "juncture",
  "jungle",
  "junior",
  "juniper",
  "junk",
  "junket",
  "junkie",
  "junkyard",
  "junta",
  "jurisdiction",
  "jurist",
  "juror",
  "jury",
  "justice",
  "justification",
  "juxtaposition",
  "kaleidoscope",
  "kangaroo",
  "karma",
  "katun",
  "kebele",
  "keel",
  "keep",
  "keeper",
  "keeping",
  "keepsake",
  "kelp",
  "ken",
  "kennel",
  "kerchief",
  "kernel",
  "kettle",
  "key",
  "keyboard",
  "keyhole",
  "keynote",
  "keystone",
  "khaki",
  "kick",
  "kickback",
  "kicker",
  "kicking",
  "kickoff",
  "kid",
  "kiddie",
  "kidnaping",
  "kidnapper",
  "kidnapping",
  "kidney",
  "kill",
  "killer",
  "killing",
  "kiln",
  "kilt",
  "kindergarten",
  "kindness",
  "king",
  "kingdom",
  "kingmaker",
  "kingpin",
  "kinship",
  "kinsman",
  "kiosk",
  "kit",
  "kitchen",
  "kitchenette",
  "kite",
  "kitten",
  "kitty",
  "klaxon",
  "knack",
  "knapsack",
  "knave",
  "knee",
  "kneecap",
  "knife",
  "knight",
  "knighthood",
  "knit",
  "knock",
  "knockdown",
  "knocker",
  "knocking",
  "knockout",
  "knoll",
  "knot",
  "knuckle",
  "kook",
  "kraken",
  "kynd",
  "lab",
  "label",
  "labor",
  "laboratory",
  "laborer",
  "labour",
  "labourer",
  "labyrinth",
  "lace",
  "lackey",
  "lacquer",
  "lad",
  "ladder",
  "laddie",
  "ladle",
  "laggard",
  "lagoon",
  "lair",
  "laird",
  "lake",
  "lakeshore",
  "lamb",
  "lament",
  "lamentation",
  "laminate",
  "lamp",
  "lamppost",
  "lampshade",
  "lance",
  "lanch",
  "land",
  "landau",
  "lander",
  "landfall",
  "landfill",
  "landing",
  "landmark",
  "landmass",
  "landowner",
  "landscape",
  "landslide",
  "lane",
  "language",
  "languor",
  "lantern",
  "lanyard",
  "lap",
  "lapel",
  "lapse",
  "larceny",
  "lard",
  "larder",
  "lark",
  "laser",
  "lash",
  "lass",
  "latch",
  "latecomer",
  "lateness",
  "lath",
  "lathe",
  "lation",
  "latitude",
  "latrine",
  "lattice",
  "laugh",
  "laughter",
  "launch",
  "launcher",
  "launching",
  "laundering",
  "laundromat",
  "laundry",
  "laureate",
  "laurel",
  "lavender",
  "law",
  "lawgiver",
  "lawmaker",
  "lawman",
  "lawn",
  "lawnmower",
  "lawsuit",
  "lawyer",
  "layer",
  "laying",
  "layman",
  "layoff",
  "layout",
  "layover",
  "layup",
  "lead",
  "leader",
  "leadership",
  "leaf",
  "leaflet",
  "league",
  "leak",
  "leakage",
  "leap",
  "learner",
  "learning",
  "lease",
  "leash",
  "leather",
  "leave",
  "leave-taking",
  "leaving",
  "lectern",
  "lecture",
  "lecturer",
  "ledge",
  "ledger",
  "lee",
  "leer",
  "left-hander",
  "lefty",
  "leg",
  "legacy",
  "legality",
  "legation",
  "legend",
  "legion",
  "legislation",
  "legislator",
  "legislature",
  "legitimation",
  "legume",
  "lem",
  "lemon",
  "lender",
  "length",
  "leopard",
  "leotard",
  "leper",
  "lesion",
  "lesson",
  "letdown",
  "lethargy",
  "letter",
  "letterhead",
  "lettuce",
  "levee",
  "level",
  "lever",
  "leviathan",
  "levity",
  "levy",
  "lexicon",
  "ley",
  "liability",
  "liaison",
  "liana",
  "libation",
  "libel",
  "liberal",
  "liberation",
  "liberationist",
  "liberator",
  "libertarian",
  "liberty",
  "librarian",
  "library",
  "licence",
  "license",
  "licensee",
  "lichen",
  "lick",
  "licking",
  "lid",
  "liege",
  "lien",
  "lieutenant",
  "lieve",
  "life-cycle",
  "life-span",
  "life-style",
  "lifeboat",
  "lifeguard",
  "lifeline",
  "lifer",
  "lifespan",
  "lifestyle",
  "lift",
  "lifter",
  "lifting",
  "ligament",
  "light",
  "lighter",
  "lighthouse",
  "lightning",
  "lightweight",
  "likeness",
  "liking",
  "lilac",
  "lily",
  "lima",
  "limb",
  "lime",
  "limerick",
  "limestone",
  "limit",
  "limitation",
  "limousine",
  "linchpin",
  "linden",
  "line-up",
  "lineage",
  "linebacker",
  "lineman",
  "linen",
  "liner",
  "lineup",
  "ling",
  "lingo",
  "linguist",
  "liniment",
  "lining",
  "link",
  "linkage",
  "linker",
  "linkup",
  "lintel",
  "lion",
  "lioness",
  "lip",
  "lipstick",
  "liqueur",
  "liquid",
  "liquidation",
  "liquor",
  "list",
  "listener",
  "listing",
  "litany",
  "lite",
  "liter",
  "literature",
  "lithograph",
  "litigation",
  "litter",
  "liturgy",
  "livelihood",
  "liver",
  "livery",
  "living",
  "living-room",
  "lizard",
  "loader",
  "loading",
  "loaf",
  "loafer",
  "loan",
  "loathing",
  "lob",
  "lobby",
  "lobbyist",
  "lobe",
  "lobotomy",
  "lobster",
  "lobsterman",
  "locale",
  "locality",
  "location",
  "locator",
  "lock",
  "lock-mechanism",
  "locker",
  "locket",
  "lockout",
  "locksmith",
  "lockup",
  "locomotive",
  "locust",
  "lode",
  "lodge",
  "lodger",
  "lodging",
  "loft",
  "log",
  "loggia",
  "logic",
  "logician",
  "logjam",
  "loiter",
  "lollipop",
  "longing",
  "longitude",
  "longshoreman",
  "loo",
  "look-alike",
  "looker",
  "lookout",
  "loom",
  "loon",
  "loony",
  "loophole",
  "loot",
  "looter",
  "lord",
  "lordship",
  "lorry",
  "lotion",
  "lottery",
  "loudspeaker",
  "lounge",
  "louse",
  "lout",
  "lover",
  "loveseat",
  "low",
  "lowland",
  "loyalty",
  "lubricant",
  "lug",
  "lullaby",
  "lumber",
  "lumberjack",
  "lumberyard",
  "luminary",
  "luminosity",
  "lump",
  "lumpectomy",
  "lunacy",
  "lunatic",
  "lunch",
  "luncheon",
  "luncheonette",
  "lunchroom",
  "lung",
  "lunge",
  "lurch",
  "lurcher",
  "lure",
  "luster",
  "lute",
  "luxury",
  "lynching",
  "lyre",
  "lyric",
  "lyricist",
  "m'lord",
  "macaw",
  "mace",
  "machete",
  "machine",
  "machinist",
  "mackinaw",
  "madcap",
  "mademoiselle",
  "madhouse",
  "maelstrom",
  "magazine",
  "mage",
  "magenta",
  "magic",
  "magician",
  "magistrate",
  "magnate",
  "magnet",
  "magnetism",
  "magnification",
  "magnificence",
  "magnitude",
  "magnolia",
  "magnum",
  "magpie",
  "mahogany",
  "mahout",
  "mail",
  "mailbox",
  "mailing",
  "mailman",
  "mainframe",
  "mainland",
  "mainsail",
  "mainspring",
  "mainstay",
  "majesty",
  "major",
  "majority",
  "make",
  "make-up",
  "maker",
  "makeup",
  "making",
  "malady",
  "malaise",
  "malcontent",
  "malfunction",
  "malignancy",
  "mall",
  "mallard",
  "mallet",
  "malpractice",
  "malt",
  "mammal",
  "mammogram",
  "mammography",
  "mammoth",
  "management",
  "manager",
  "mance",
  "mandarin",
  "mandate",
  "mandolin",
  "mane",
  "maneuver",
  "maneuvering",
  "manger",
  "mango",
  "mangrove",
  "manhole",
  "manhunt",
  "manicure",
  "manifestation",
  "manifesto",
  "manifold",
  "mannequin",
  "manner",
  "mannerism",
  "mannerist",
  "manoeuvre",
  "manor",
  "manse",
  "manservant",
  "mansion",
  "mantel",
  "mantelpiece",
  "mantle",
  "mantra",
  "manual",
  "manufacturer",
  "manure",
  "manuscript",
  "map",
  "maple",
  "mapping",
  "marathon",
  "marble",
  "march",
  "marching",
  "mare",
  "margarine",
  "margarita",
  "margin",
  "marina",
  "marine",
  "mariner",
  "marionette",
  "marker",
  "market",
  "marketer",
  "marketing",
  "marketplace",
  "marking",
  "marksman",
  "markup",
  "marlin",
  "marmalade",
  "marquee",
  "marrow",
  "marsh",
  "marshal",
  "marshland",
  "marshmallow",
  "mart",
  "martinet",
  "martini",
  "martyr",
  "martyrdom",
  "marvel",
  "mascot",
  "mash",
  "mask",
  "mason",
  "masque",
  "mass",
  "massage",
  "masseur",
  "mast",
  "mastectomy",
  "master",
  "master-mason",
  "mastermind",
  "masterpiece",
  "masterwork",
  "masthead",
  "mat",
  "matador",
  "match",
  "matchbook",
  "matchbox",
  "matchmaker",
  "matchstick",
  "matchup",
  "material",
  "materialist",
  "mathematician",
  "matinee",
  "mating",
  "matrix",
  "matron",
  "matte",
  "matter",
  "mattress",
  "maturity",
  "mauling",
  "mausoleum",
  "maverick",
  "maw",
  "maxim",
  "maximum",
  "mayor",
  "maze",
  "mead",
  "meadow",
  "meal",
  "mean",
  "meaning",
  "meanness",
  "measure",
  "measurement",
  "meatball",
  "mecca",
  "mechanic",
  "mechanism",
  "medal",
  "medalist",
  "medallion",
  "median",
  "mediation",
  "mediator",
  "medic",
  "medication",
  "medicine",
  "meditation",
  "medley",
  "meet",
  "meeting",
  "megaphone",
  "melancholy",
  "melanoma",
  "melodrama",
  "melody",
  "melon",
  "meltdown",
  "member",
  "membership",
  "membrane",
  "memento",
  "memoir",
  "memorandum",
  "memorial",
  "memory",
  "menace",
  "mention",
  "mentor",
  "menu",
  "mercenary",
  "merchandise",
  "merchant",
  "merchantman",
  "mercy",
  "merger",
  "meridian",
  "meringue",
  "meristem",
  "merit",
  "mermaid",
  "merry-go-round",
  "mesa",
  "mesh",
  "meson",
  "mesquite",
  "mess",
  "message",
  "messenger",
  "messiah",
  "metabolism",
  "metal",
  "metamorphosis",
  "metaphor",
  "meteor",
  "meteorite",
  "meteoroid",
  "meteorologist",
  "meter",
  "method",
  "methodology",
  "metier",
  "metronome",
  "microbe",
  "microbiologist",
  "microchip",
  "microcomputer",
  "microcosm",
  "microfilm",
  "microphone",
  "microprocessor",
  "microscope",
  "microwave",
  "middle",
  "middleman",
  "midpoint",
  "midriff",
  "midst",
  "midterm",
  "might",
  "mignon",
  "migraine",
  "migrant",
  "migration",
  "mike",
  "mil",
  "mileage",
  "miler",
  "milestone",
  "militant",
  "military",
  "militiaman",
  "milk",
  "milking",
  "milkmaid",
  "milkman",
  "milkshake",
  "mill",
  "miller",
  "millet",
  "millimeter",
  "millionaire",
  "millionth",
  "millstone",
  "mime",
  "mimeograph",
  "mimic",
  "minaret",
  "mind",
  "mind-set",
  "mindstone",
  "minefield",
  "miner",
  "mineral",
  "mini",
  "miniature",
  "minicomputer",
  "minim",
  "minimalist",
  "minimum",
  "mining",
  "minion",
  "miniskirt",
  "minister",
  "ministration",
  "ministry",
  "minnow",
  "minor",
  "minority",
  "minstrel",
  "mint",
  "minuet",
  "miracle",
  "mirage",
  "mire",
  "mirror",
  "misadventure",
  "misapprehension",
  "miscalculation",
  "miscarriage",
  "miscellany",
  "mischance",
  "mischief",
  "misdemeanor",
  "miser",
  "misery",
  "misfit",
  "misfortune",
  "misgiving",
  "mishap",
  "misinterpretation",
  "mismatch",
  "misnomer",
  "misrepresentation",
  "missal",
  "missile",
  "mission",
  "missive",
  "misstatement",
  "misstep",
  "mist",
  "mistake",
  "mister",
  "mite",
  "miter",
  "mitigation",
  "mitt",
  "mittee",
  "mitten",
  "mix",
  "mix-up",
  "mixer",
  "mixture",
  "mixup",
  "moat",
  "mob",
  "mobile",
  "mobilization",
  "mobster",
  "moccasin",
  "mock-up",
  "mockery",
  "mod",
  "model",
  "modem",
  "moderator",
  "modernism",
  "modernization",
  "modification",
  "modifier",
  "modulation",
  "module",
  "mogul",
  "mohole",
  "moire",
  "moisture",
  "molar",
  "mold",
  "molding",
  "mole",
  "molecule",
  "mom",
  "moment",
  "monarchy",
  "monastery",
  "monetarist",
  "money",
  "moneymaker",
  "monitor",
  "monk",
  "monocle",
  "monogram",
  "monograph",
  "monolith",
  "monologue",
  "monopoly",
  "monorail",
  "monosaccharide",
  "monotone",
  "monotony",
  "monsoon",
  "monster",
  "monstrosity",
  "montage",
  "monthly",
  "monument",
  "moo",
  "moon",
  "moonlight",
  "moonshiner",
  "moor",
  "mooring",
  "moorland",
  "mop",
  "moral",
  "moralist",
  "morality",
  "morass",
  "moratorium",
  "moray",
  "morbidity",
  "morgue",
  "morn",
  "moron",
  "morsel",
  "mortal",
  "mortality",
  "mortar",
  "mortgage",
  "mortician",
  "mortification",
  "mortise",
  "mortuary",
  "mosaic",
  "mosque",
  "mosquito",
  "moss",
  "mote",
  "motel",
  "motif",
  "motion",
  "motivation",
  "motivator",
  "motive",
  "motor",
  "motorbike",
  "motorboat",
  "motorcade",
  "motorcar",
  "motorcycle",
  "motorist",
  "motorman",
  "motto",
  "mouf",
  "mould",
  "mound",
  "mount",
  "mountain",
  "mountaineer",
  "mountainside",
  "mountaintop",
  "mounting",
  "mousse",
  "moustache",
  "mouth",
  "mouth-harp",
  "mouthful",
  "mouthpiece",
  "movement",
  "mover",
  "movie",
  "moviegoer",
  "moviemaker",
  "mower",
  "mu",
  "muddle",
  "muffin",
  "muffler",
  "mug",
  "mugger",
  "mugging",
  "mulatto",
  "mulberry",
  "mulch",
  "mule",
  "mullah",
  "mullet",
  "multimillionaire",
  "multiple",
  "multiplication",
  "multiplier",
  "multitude",
  "mum",
  "mumble",
  "municipality",
  "mural",
  "murder",
  "murderer",
  "murderess",
  "murmur",
  "murmuring",
  "muscle",
  "muse",
  "museum",
  "mushroom",
  "musical",
  "musician",
  "musicologist",
  "musket",
  "muskrat",
  "muslin",
  "mussel",
  "must",
  "mustache",
  "mustang",
  "muster",
  "mutant",
  "mutiny",
  "mutter",
  "muttering",
  "mutton",
  "muzzle",
  "myosin",
  "myriad",
  "myrtle",
  "mystery",
  "mystic",
  "mysticism",
  "mystification",
  "myth",
  "mythology",
  "nail",
  "naivete",
  "nameplate",
  "namesake",
  "nap",
  "napkin",
  "narration",
  "narrative",
  "narrator",
  "nation",
  "nation-state",
  "nationalism",
  "nationalist",
  "nationality",
  "nationalization",
  "native",
  "nativist",
  "naturalist",
  "nature",
  "nave",
  "navigation",
  "navigator",
  "navy",
  "nay",
  "ne'er-do-well",
  "nebula",
  "necessity",
  "neck",
  "neckerchief",
  "necklace",
  "necktie",
  "nectar",
  "needle",
  "needlepoint",
  "needler",
  "negation",
  "negative",
  "negligee",
  "negotiation",
  "negotiator",
  "neigh",
  "neighbor",
  "neighborhood",
  "neighbour",
  "neomort",
  "neon",
  "neophyte",
  "nephew",
  "nerd",
  "nerve",
  "nest",
  "net",
  "netting",
  "nettle",
  "network",
  "neurologist",
  "neurosis",
  "neurosurgeon",
  "neutralist",
  "neutrality",
  "neutron",
  "newcomer",
  "newel",
  "newlywed",
  "newness",
  "newscast",
  "newscaster",
  "newsletter",
  "newsmagazine",
  "newsman",
  "newspaper",
  "newspaperman",
  "newsreel",
  "newsroom",
  "newsstand",
  "nicety",
  "niche",
  "nick",
  "nickel",
  "nickname",
  "nightcap",
  "nightclub",
  "nightingale",
  "nightshirt",
  "nightstand",
  "nightstick",
  "nightwatch",
  "nimbus",
  "ninny",
  "nip",
  "nite",
  "nitrate",
  "nitrite",
  "nitrogen",
  "no",
  "no-hitter",
  "nobility",
  "noble",
  "nobleman",
  "nod",
  "node",
  "nodule",
  "noggin",
  "noise",
  "nomad",
  "nomination",
  "nominee",
  "noncom",
  "nonentity",
  "nonsmoker",
  "nonwhite",
  "noodle",
  "nook",
  "noose",
  "norm",
  "normalcy",
  "normality",
  "nose",
  "nostalgia",
  "nostril",
  "notary",
  "notation",
  "notch",
  "note",
  "notebook",
  "notepad",
  "notice",
  "notification",
  "notion",
  "noun",
  "nouveau",
  "nouvelle",
  "nova",
  "novel",
  "novelist",
  "novella",
  "novelty",
  "novice",
  "nozzle",
  "nuance",
  "nub",
  "nude",
  "nudge",
  "nugget",
  "nuisance",
  "nullity",
  "number",
  "numeral",
  "nun",
  "nunnery",
  "nurse",
  "nursemaid",
  "nursery",
  "nurture",
  "nut",
  "nutmeg",
  "nutrient",
  "nutritionist",
  "nutshell",
  "nylon",
  "nymph",
  "oaf",
  "oak",
  "oar",
  "oasis",
  "oath",
  "obeisance",
  "obelisk",
  "obfuscation",
  "obituary",
  "object",
  "objection",
  "objective",
  "objectivist",
  "objector",
  "obligation",
  "oblivion",
  "oblong",
  "oboe",
  "obscenity",
  "obscurity",
  "observance",
  "observation",
  "observatory",
  "observer",
  "obsession",
  "obsidian",
  "obstacle",
  "obstetrician",
  "obstinacy",
  "obstruction",
  "obstructionist",
  "occasion",
  "occupancy",
  "occupant",
  "occupation",
  "occurrence",
  "ocean",
  "oceanographer",
  "ochre",
  "octave",
  "octogenarian",
  "oddball",
  "oddity",
  "odometer",
  "odor",
  "odour",
  "odyssey",
  "oeuvre",
  "ofa",
  "offence",
  "offender",
  "offense",
  "offensive",
  "offer",
  "offering",
  "office",
  "officeholder",
  "officer",
  "official",
  "offshoot",
  "ogre",
  "oil",
  "oiler",
  "oilfield",
  "oilman",
  "oilskin",
  "ointment",
  "oldster",
  "oligarchy",
  "olive",
  "ombudsman",
  "omelet",
  "omelette",
  "omen",
  "omission",
  "one-liner",
  "onion",
  "onlooker",
  "onslaught",
  "ontology",
  "onyx",
  "ooze",
  "op",
  "opacity",
  "opal",
  "opener",
  "opening",
  "opera",
  "operation",
  "operative",
  "operator",
  "operetta",
  "ophthalmologist",
  "opiate",
  "opinion",
  "opment",
  "opportunist",
  "opportunity",
  "opposite",
  "opposition",
  "oppression",
  "oppressor",
  "optimism",
  "optimist",
  "option",
  "oracle",
  "oral",
  "orange",
  "oration",
  "orator",
  "oratorio",
  "oratory",
  "orb",
  "orbit",
  "orbiter",
  "orchard",
  "orchestra",
  "orchestration",
  "orchid",
  "ordeal",
  "order",
  "ordering",
  "orderly",
  "ordinance",
  "ordination",
  "ore",
  "organ",
  "organisation",
  "organist",
  "organization",
  "organizer",
  "orientation",
  "orifice",
  "origin",
  "original",
  "originator",
  "ornament",
  "ornamentation",
  "orthodontist",
  "orthodoxy",
  "oscillation",
  "oscillator",
  "oscilloscope",
  "ostrich",
  "other",
  "otter",
  "ouster",
  "outboard",
  "outbreak",
  "outburst",
  "outcast",
  "outcome",
  "outcrop",
  "outcropping",
  "outcry",
  "outdistance",
  "outdoorsman",
  "outfield",
  "outfielder",
  "outfit",
  "outflow",
  "outgrowth",
  "outhouse",
  "outing",
  "outlaw",
  "outlay",
  "outlet",
  "outline",
  "outlook",
  "outpatient",
  "outpost",
  "outpouring",
  "output",
  "outrage",
  "outside",
  "outsider",
  "oval",
  "ovary",
  "ovation",
  "oven",
  "over",
  "overall",
  "overcoat",
  "overdose",
  "overdraft",
  "overflow",
  "overhang",
  "overhaul",
  "overhead",
  "overlap",
  "overlay",
  "overload",
  "overlord",
  "overpass",
  "override",
  "overrun",
  "overseer",
  "oversight",
  "oversimplification",
  "overstatement",
  "overtone",
  "overture",
  "overview",
  "oviduct",
  "ovum",
  "owl",
  "owner",
  "ownership",
  "ox",
  "oxford",
  "oxidation",
  "oxide",
  "oyster",
  "pacemaker",
  "pacer",
  "pacifier",
  "pacifist",
  "pack",
  "package",
  "packer",
  "packet",
  "packing",
  "pact",
  "pad",
  "paddle",
  "paddock",
  "paddy",
  "padlock",
  "paean",
  "pagan",
  "page",
  "pageant",
  "pagoda",
  "paign",
  "pail",
  "pain",
  "painkiller",
  "paint",
  "paintbrush",
  "painter",
  "painting",
  "pairing",
  "paisley",
  "pal",
  "palace",
  "palate",
  "palette",
  "palisade",
  "pall",
  "palladium",
  "pallbearer",
  "pallet",
  "pallor",
  "palm",
  "palsy",
  "pamphlet",
  "pan",
  "panacea",
  "pancake",
  "panda",
  "pane",
  "panel",
  "panelling",
  "panhandle",
  "panic",
  "panoply",
  "panorama",
  "pansy",
  "pant",
  "panther",
  "panting",
  "pantomime",
  "pantry",
  "pantsuit",
  "pap",
  "papaya",
  "paper",
  "paperback",
  "paperweight",
  "paprika",
  "para",
  "parable",
  "parachute",
  "parade",
  "paradigm",
  "paradise",
  "paradox",
  "paraffin",
  "parafoil",
  "paragon",
  "paragraph",
  "parakeet",
  "parallel",
  "parallelism",
  "parameter",
  "paramour",
  "paranoia",
  "parapet",
  "paraphrase",
  "parasite",
  "parasol",
  "paratroop",
  "paratrooper",
  "parcel",
  "parchment",
  "pardner",
  "pardon",
  "parent",
  "parenthesis",
  "pariah",
  "parish",
  "parishioner",
  "parity",
  "park",
  "parka",
  "parkland",
  "parkway",
  "parley",
  "parliament",
  "parlor",
  "parlour",
  "parody",
  "parole",
  "paroxysm",
  "parrot",
  "parry",
  "parson",
  "partake",
  "participant",
  "participation",
  "particle",
  "particular",
  "particularity",
  "particulate",
  "parting",
  "partisan",
  "partition",
  "partment",
  "partner",
  "partnership",
  "party",
  "parvenu",
  "pasha",
  "pass",
  "passage",
  "passageway",
  "passenger",
  "passer",
  "passer-by",
  "passing",
  "passion",
  "passport",
  "password",
  "pasta",
  "paste",
  "pastel",
  "pastiche",
  "pastime",
  "pastor",
  "pastry",
  "pasture",
  "pasty",
  "pat",
  "patch",
  "pate",
  "patent",
  "patentee",
  "path",
  "pathologist",
  "pathology",
  "pathway",
  "patient",
  "patina",
  "patio",
  "patrician",
  "patriot",
  "patriotism",
  "patrol",
  "patrolman",
  "patron",
  "patsy",
  "patter",
  "pattern",
  "paunch",
  "pauper",
  "pause",
  "pavement",
  "pavilion",
  "paw",
  "pawl",
  "pawn",
  "pawnshop",
  "paycheck",
  "payday",
  "payload",
  "paymaster",
  "payment",
  "payoff",
  "payout",
  "payroll",
  "pea",
  "peace",
  "peacemaker",
  "peach",
  "peacock",
  "peak",
  "peal",
  "peanut",
  "pear",
  "pearl",
  "peasant",
  "peasantry",
  "peat",
  "pebble",
  "pecan",
  "peck",
  "pecker",
  "pecking",
  "pectin",
  "pectoral",
  "peculiarity",
  "pedal",
  "pedant",
  "peddler",
  "pedestal",
  "pedestrian",
  "pediatrician",
  "pedigree",
  "pediment",
  "pee",
  "peek",
  "peel",
  "peeling",
  "peep",
  "peephole",
  "peerage",
  "peg",
  "pegboard",
  "pellet",
  "pelt",
  "pen",
  "penance",
  "pencil",
  "pendant",
  "pendulum",
  "penguin",
  "penicillin",
  "peninsula",
  "penitence",
  "penitent",
  "penitentiary",
  "penknife",
  "pennant",
  "pension",
  "pensione",
  "pensioner",
  "penthouse",
  "penumbra",
  "pepper",
  "peppermint",
  "pepperoni",
  "percentage",
  "perception",
  "percussion",
  "percussionist",
  "peregrine",
  "perennial",
  "perfection",
  "perfectionist",
  "perfidy",
  "perforation",
  "performance",
  "performer",
  "perfume",
  "perience",
  "peril",
  "perimeter",
  "period",
  "periodical",
  "periphery",
  "periscope",
  "permission",
  "permit",
  "peroration",
  "perpetrator",
  "perplexity",
  "persimmon",
  "persona",
  "personage",
  "personality",
  "personification",
  "perspective",
  "perspiration",
  "persuasion",
  "pertinence",
  "perusal",
  "pessimist",
  "pest",
  "pesticide",
  "pestilence",
  "pet",
  "petal",
  "petit",
  "petition",
  "petitioner",
  "petticoat",
  "pettiness",
  "pew",
  "phaeton",
  "phalanx",
  "phantasy",
  "phantom",
  "pharaoh",
  "pharmacist",
  "pharmacy",
  "phase",
  "pheasant",
  "phenomenon",
  "philanthropist",
  "philanthropy",
  "philistine",
  "philosopher",
  "philosophy",
  "phobia",
  "phone",
  "phoneme",
  "phonograph",
  "phony",
  "phosphate",
  "phosphor",
  "photo",
  "photocell",
  "photocopy",
  "photograph",
  "photographer",
  "photon",
  "phrase",
  "phrasing",
  "physician",
  "physicist",
  "physiologist",
  "physiology",
  "physique",
  "pi",
  "pianist",
  "piazza",
  "pic",
  "pick",
  "pick-up",
  "pickax",
  "picker",
  "picket",
  "picking",
  "pickle",
  "pickpocket",
  "pickup",
  "picnic",
  "picture",
  "pidgin",
  "pie",
  "piece",
  "pier",
  "piety",
  "pig",
  "pigeon",
  "pigeonhole",
  "piggy",
  "piggyback",
  "piglet",
  "pigment",
  "pigsty",
  "pigtail",
  "pile",
  "pilgrim",
  "pilgrimage",
  "piling",
  "pill",
  "pillar",
  "pillbox",
  "pillow",
  "pillowcase",
  "pilot",
  "pin",
  "pinafore",
  "pinball",
  "pincer",
  "pinch",
  "pine",
  "pineapple",
  "ping",
  "pinhead",
  "pink",
  "pinkie",
  "pinky",
  "pinnace",
  "pinnacle",
  "pinstripe",
  "pinwheel",
  "pioneer",
  "pipe",
  "pipeline",
  "piper",
  "piracy",
  "pirate",
  "pistachio",
  "pistol",
  "piston",
  "pit",
  "pitch",
  "pitcher",
  "pitchfork",
  "pitchman",
  "pittance",
  "pituitary",
  "pivot",
  "pixie",
  "pizza",
  "placard",
  "place",
  "placement",
  "placenta",
  "placer",
  "placing",
  "plagiarism",
  "plague",
  "plaid",
  "plain",
  "plainclothesman",
  "plaint",
  "plaintiff",
  "plait",
  "plan",
  "plane",
  "planer",
  "planet",
  "planetoid",
  "plank",
  "planner",
  "planning",
  "plant",
  "plantain",
  "plantation",
  "planter",
  "planting",
  "plaque",
  "plasma",
  "plaster",
  "plastic",
  "plate",
  "plateau",
  "platelet",
  "platform",
  "platitude",
  "platoon",
  "platter",
  "play",
  "playback",
  "player",
  "playground",
  "playgroup",
  "playhouse",
  "playing",
  "playmate",
  "playoff",
  "playpen",
  "playroom",
  "plaything",
  "playwright",
  "plaza",
  "pleading",
  "pleasantry",
  "pleasure",
  "plebiscite",
  "pledge",
  "plight",
  "plot",
  "plotting",
  "plough",
  "plow",
  "ploy",
  "plug",
  "plum",
  "plumage",
  "plumber",
  "plume",
  "plunge",
  "plural",
  "plurality",
  "plywood",
  "pneumonia",
  "pocket",
  "pocketbook",
  "pocketful",
  "pod",
  "podesta",
  "podium",
  "poem",
  "poet",
  "poetry",
  "pogrom",
  "poignancy",
  "point",
  "point-of-view",
  "pointer",
  "poise",
  "poison",
  "poisoning",
  "polariser",
  "polarity",
  "polarization",
  "polder",
  "pole",
  "polemic",
  "policy",
  "policymaker",
  "polish",
  "polishing",
  "politician",
  "polity",
  "polka",
  "poll",
  "pollen",
  "pollination",
  "polling",
  "pollster",
  "pollutant",
  "polluter",
  "pollution",
  "polyester",
  "polygraph",
  "polymer",
  "polyp",
  "pomegranate",
  "pomp",
  "pompadour",
  "pomposity",
  "pond",
  "poniard",
  "pony",
  "ponytail",
  "poodle",
  "pool",
  "poolhall",
  "poorhouse",
  "pop-up",
  "popcorn",
  "pope",
  "poplar",
  "poppy",
  "popsicle",
  "popularization",
  "population",
  "populist",
  "porcelain",
  "porch",
  "porcupine",
  "pore",
  "porpoise",
  "porridge",
  "port",
  "portal",
  "portent",
  "porter",
  "portfolio",
  "porthole",
  "portico",
  "portiere",
  "portion",
  "portrait",
  "portraitist",
  "portraiture",
  "portrayal",
  "posing",
  "position",
  "posse",
  "possession",
  "possessor",
  "possibility",
  "possum",
  "post",
  "post-mortem",
  "postcard",
  "poster",
  "posterior",
  "postgraduate",
  "posting",
  "postman",
  "postmark",
  "postmaster",
  "postponement",
  "postscript",
  "postulate",
  "posture",
  "posturing",
  "pot",
  "potato",
  "potency",
  "potentate",
  "potential",
  "potentiality",
  "pothole",
  "potion",
  "potpourri",
  "potter",
  "pottery",
  "pouch",
  "poultice",
  "pound",
  "pounding",
  "pout",
  "powder",
  "power",
  "powerboat",
  "powerhouse",
  "practicality",
  "practice",
  "practitioner",
  "pragmatist",
  "prairie",
  "praise",
  "pram",
  "prance",
  "prayer",
  "preacher",
  "preaching",
  "preamble",
  "precaution",
  "precedent",
  "precept",
  "precinct",
  "precipice",
  "precipitate",
  "precision",
  "precondition",
  "precursor",
  "predicament",
  "predicate",
  "prediction",
  "predilection",
  "predisposition",
  "prefab",
  "preface",
  "prefect",
  "prefecture",
  "preference",
  "preferment",
  "prejudice",
  "prelate",
  "prelude",
  "premier",
  "premiere",
  "premise",
  "premium",
  "premonition",
  "preoccupation",
  "prep",
  "preparation",
  "preppie",
  "prerequisite",
  "prerogative",
  "presbytery",
  "prescription",
  "presence",
  "present",
  "presentation",
  "presenter",
  "presentiment",
  "preservation",
  "preservative",
  "preserve",
  "preserver",
  "presidency",
  "president",
  "press",
  "pression",
  "pressure",
  "presumption",
  "pretence",
  "pretender",
  "pretense",
  "pretension",
  "pretext",
  "pretzel",
  "prevalence",
  "prevention",
  "preview",
  "prey",
  "price",
  "pricing",
  "prick",
  "prickle",
  "pride",
  "priest",
  "priestess",
  "priesthood",
  "prig",
  "prima",
  "primary",
  "primate",
  "primer",
  "primitive",
  "principal",
  "principality",
  "principle",
  "print",
  "printer",
  "printing",
  "printout",
  "priority",
  "prise",
  "prism",
  "privacy",
  "private",
  "privation",
  "privilege",
  "prize",
  "prizefighter",
  "prizewinner",
  "pro",
  "proach",
  "probability",
  "probation",
  "probe",
  "problem",
  "procedure",
  "proceeding",
  "process",
  "procession",
  "processor",
  "proclamation",
  "proclivity",
  "procurement",
  "prod",
  "prodding",
  "prodigality",
  "prodigy",
  "produce",
  "producer",
  "product",
  "production",
  "productivist",
  "productivity",
  "profession",
  "professional",
  "professor",
  "professorship",
  "proficiency",
  "profile",
  "profit",
  "profligacy",
  "profundity",
  "progenitor",
  "progeny",
  "prognosis",
  "program",
  "programme",
  "programmer",
  "progression",
  "progressive",
  "prohibition",
  "project",
  "projectile",
  "projection",
  "projectionist",
  "projector",
  "proletariat",
  "prologue",
  "prolongation",
  "promenade",
  "prominence",
  "promise",
  "promontory",
  "promoter",
  "promotion",
  "prompt",
  "prompting",
  "prong",
  "pronghorn",
  "pronoun",
  "pronouncement",
  "pronunciation",
  "proof",
  "prop",
  "propellant",
  "propeller",
  "propensity",
  "property",
  "proponent",
  "proportion",
  "proposal",
  "proposition",
  "proprietor",
  "propriety",
  "proscription",
  "prosecution",
  "prosecutor",
  "prospect",
  "prospector",
  "prosthesis",
  "protagonist",
  "protection",
  "protector",
  "protectorate",
  "protege",
  "protein",
  "protest",
  "protester",
  "protocol",
  "proton",
  "prototype",
  "protrusion",
  "provenance",
  "proverb",
  "providence",
  "provider",
  "province",
  "provincialism",
  "provision",
  "provocateur",
  "provocation",
  "prow",
  "prowl",
  "prowler",
  "proximity",
  "proxy",
  "prude",
  "prune",
  "pruning",
  "psalm",
  "pseudonym",
  "pseudopatient",
  "psi",
  "psion",
  "psych",
  "psyche",
  "psychoanalyst",
  "pub",
  "public",
  "publican",
  "publication",
  "publicist",
  "publisher",
  "puck",
  "pudding",
  "puddle",
  "puff",
  "puke",
  "pullback",
  "pulley",
  "pullover",
  "pulp",
  "pulpit",
  "pulsar",
  "pulsation",
  "pulse",
  "pump",
  "pumper",
  "pumpkin",
  "pun",
  "punch",
  "puncher",
  "puncture",
  "pundit",
  "punt",
  "punter",
  "pupil",
  "purchase",
  "purchaser",
  "puree",
  "purge",
  "purification",
  "purist",
  "puritan",
  "purity",
  "purple",
  "purpose",
  "purr",
  "purse",
  "purser",
  "pursuer",
  "pursuit",
  "purveyance",
  "purveyor",
  "push",
  "pushbutton",
  "pushcart",
  "pusher",
  "pushover",
  "put-down",
  "putdown",
  "puter",
  "putt",
  "putter",
  "puzzle",
  "puzzlement",
  "pylon",
  "pyramid",
  "pyre",
  "python",
  "quack",
  "quadrangle",
  "quadrant",
  "quagmire",
  "quake",
  "qualification",
  "qualifier",
  "quality",
  "qualm",
  "quandary",
  "quantity",
  "quark",
  "quarrel",
  "quarry",
  "quarter",
  "quarterback",
  "quarterly",
  "quartermaster",
  "quartet",
  "quasar",
  "quaver",
  "quay",
  "queen",
  "query",
  "quest",
  "question",
  "questioner",
  "questioning",
  "questionnaire",
  "queue",
  "quiche",
  "quickie",
  "quicksand",
  "quiet",
  "quill",
  "quilt",
  "quince",
  "quintet",
  "quip",
  "quirk",
  "quitter",
  "quiver",
  "quota",
  "quotation",
  "quote",
  "quotient",
  "ra",
  "rabbi",
  "rabbit",
  "raccoon",
  "race",
  "racehorse",
  "racer",
  "racetrack",
  "racist",
  "rack",
  "racket",
  "raconteur",
  "racquet",
  "rad",
  "radar",
  "radiation",
  "radiator",
  "radical",
  "radicalism",
  "radio",
  "radioisotope",
  "radiologist",
  "radioman",
  "radish",
  "radius",
  "raffle",
  "raft",
  "rafter",
  "rag",
  "ragtag",
  "raid",
  "raider",
  "rail",
  "railing",
  "railroad",
  "railway",
  "raiment",
  "rain",
  "rainbow",
  "raincoat",
  "raindrop",
  "rainfall",
  "rainstorm",
  "raise",
  "raiser",
  "raisin",
  "raising",
  "rake",
  "rally",
  "ram",
  "rambling",
  "ramp",
  "rampart",
  "ramrod",
  "ranch",
  "rancher",
  "rancor",
  "range",
  "rangeland",
  "ranger",
  "rank",
  "ranking",
  "ransom",
  "rant",
  "rap",
  "rapacity",
  "rapier",
  "rapping",
  "rapport",
  "rapture",
  "rarity",
  "rascal",
  "rash",
  "rashness",
  "rasp",
  "raspberry",
  "ratchet",
  "rathorn",
  "ratification",
  "rating",
  "ratio",
  "ration",
  "rationale",
  "rationalist",
  "rationality",
  "rationalization",
  "rattle",
  "rattler",
  "rattlesnake",
  "rave",
  "raven",
  "ravine",
  "ray",
  "rayon",
  "razor",
  "re-creation",
  "re-election",
  "re-enactment",
  "re-evaluation",
  "rea",
  "reach",
  "reaction",
  "reactor",
  "read",
  "reader",
  "reading",
  "readjustment",
  "readout",
  "reaffirmation",
  "realignment",
  "realist",
  "reality",
  "realization",
  "reallocation",
  "realm",
  "realtor",
  "realty",
  "ream",
  "reanimation",
  "reaper",
  "reappearance",
  "reappointment",
  "reappraisal",
  "rear",
  "rearrangement",
  "reason",
  "reasoning",
  "reassessment",
  "reassignment",
  "reassurance",
  "rebate",
  "rebbe",
  "rebound",
  "rebuff",
  "rebuke",
  "rebuttal",
  "rec",
  "recapitulation",
  "receipt",
  "receiver",
  "receivership",
  "receptacle",
  "reception",
  "receptionist",
  "receptor",
  "recess",
  "recession",
  "recipe",
  "recipient",
  "reciprocity",
  "recital",
  "recitation",
  "recitative",
  "reckoning",
  "reclamation",
  "recliner",
  "recluse",
  "recognition",
  "recognizance",
  "recollection",
  "recommendation",
  "reconciliation",
  "reconnoiter",
  "reconsideration",
  "reconstruction",
  "record",
  "recorder",
  "recording",
  "recount",
  "recourse",
  "recovery",
  "recreation",
  "recrimination",
  "recruit",
  "recruiter",
  "recruitment",
  "rectangle",
  "rector",
  "rectory",
  "recuperation",
  "recurrence",
  "redefinition",
  "redemption",
  "redeployment",
  "redesign",
  "redhead",
  "rediscovery",
  "redistribution",
  "redneck",
  "redoubt",
  "redskin",
  "reduction",
  "redundancy",
  "redwood",
  "reed",
  "reef",
  "reefer",
  "reek",
  "reel",
  "reentry",
  "refectory",
  "referee",
  "reference",
  "referendum",
  "referent",
  "referral",
  "refill",
  "refinement",
  "refiner",
  "refinery",
  "reflection",
  "reflector",
  "reflex",
  "reform",
  "reformation",
  "reformer",
  "reformulation",
  "refraction",
  "refractor",
  "refrain",
  "refresher",
  "refreshment",
  "refrigerator",
  "refuge",
  "refugee",
  "refund",
  "refusal",
  "refuse",
  "refusenik",
  "refutation",
  "regeneration",
  "regent",
  "regime",
  "regimen",
  "regiment",
  "region",
  "register",
  "registrar",
  "registration",
  "registry",
  "regression",
  "regret",
  "regularity",
  "regulation",
  "regulator",
  "regurgitation",
  "rehabilitation",
  "rehash",
  "rehearsal",
  "reign",
  "reimbursement",
  "reincarnation",
  "reinforcement",
  "reinstatement",
  "reinterpretation",
  "reinvestment",
  "reissue",
  "reiteration",
  "reject",
  "rejection",
  "rejoinder",
  "relapse",
  "relative",
  "relativist",
  "relativity",
  "relaxation",
  "relay",
  "release",
  "reliance",
  "relic",
  "relief",
  "religion",
  "relish",
  "relocation",
  "reluctance",
  "remainder",
  "remake",
  "remark",
  "remedy",
  "remembering",
  "remembrance",
  "reminder",
  "reminiscence",
  "remission",
  "remnant",
  "removal",
  "remove",
  "remover",
  "remuneration",
  "rendering",
  "rendition",
  "renegade",
  "renewal",
  "renovation",
  "rent",
  "rental",
  "renter",
  "renunciation",
  "reopening",
  "reorganization",
  "rep",
  "repair",
  "repairman",
  "reparation",
  "repast",
  "repatriation",
  "repayment",
  "repeat",
  "repeater",
  "repellent",
  "repertoire",
  "repertory",
  "repetition",
  "replacement",
  "replay",
  "replenishment",
  "replica",
  "reply",
  "report",
  "reporter",
  "reporting",
  "repose",
  "repository",
  "repre",
  "representation",
  "representative",
  "repression",
  "reprieve",
  "reprimand",
  "reprint",
  "reprisal",
  "reprise",
  "reproach",
  "reproof",
  "reptile",
  "republic",
  "republican",
  "repudiation",
  "repulsion",
  "repurchase",
  "reputation",
  "request",
  "requiem",
  "requirement",
  "requisite",
  "requisition",
  "rerun",
  "resale",
  "rescue",
  "rescuer",
  "researcher",
  "resemblance",
  "resentment",
  "reservation",
  "reserve",
  "reservist",
  "reservoir",
  "residence",
  "residency",
  "resident",
  "residue",
  "resignation",
  "resin",
  "resistance",
  "resolution",
  "resonance",
  "resort",
  "resource",
  "respect",
  "respiration",
  "respirator",
  "respite",
  "respondent",
  "response",
  "responsibility",
  "restatement",
  "restaurant",
  "restaurateur",
  "restitution",
  "restoration",
  "restorer",
  "restraint",
  "restriction",
  "restroom",
  "restructuring",
  "result",
  "resume",
  "retailer",
  "retainer",
  "retaliation",
  "retardant",
  "retardation",
  "retary",
  "retch",
  "retelling",
  "reticence",
  "retina",
  "retinue",
  "retiree",
  "retirement",
  "retort",
  "retraction",
  "retreat",
  "retrenchment",
  "retrial",
  "retriever",
  "return",
  "reunion",
  "revaluation",
  "revelation",
  "revelry",
  "revenge",
  "revenue",
  "reverberation",
  "reverie",
  "reversal",
  "reverse",
  "reversion",
  "review",
  "reviewer",
  "revision",
  "revisionist",
  "revitalization",
  "revival",
  "revocation",
  "revolt",
  "revolution",
  "revolver",
  "revue",
  "revulsion",
  "reward",
  "rhetoric",
  "rhinestone",
  "rhizome",
  "rhododendron",
  "rhyme",
  "rhythm",
  "riage",
  "rib",
  "ribbon",
  "rickshaw",
  "ricochet",
  "riddle",
  "ride",
  "rider",
  "ridge",
  "ridgeline",
  "ridicule",
  "riding",
  "riff",
  "riffle",
  "rifle",
  "rifleman",
  "rift",
  "rig",
  "rigging",
  "right",
  "right-hander",
  "right-of-way",
  "rightist",
  "rigidity",
  "rigor",
  "rim",
  "rime",
  "rind",
  "ring",
  "ringer",
  "ringing",
  "ringleader",
  "ringmaster",
  "rink",
  "rinse",
  "rip",
  "ripoff",
  "riposte",
  "ripple",
  "riser",
  "rising",
  "rite",
  "ritual",
  "rival",
  "rivalry",
  "river",
  "riverbank",
  "riverbed",
  "riverboat",
  "rivet",
  "rivulet",
  "ro",
  "roach",
  "road",
  "roadbed",
  "roadblock",
  "roadhouse",
  "roadside",
  "roadster",
  "roadway",
  "roaring",
  "roast",
  "robber",
  "robbery",
  "robe",
  "robin",
  "robot",
  "rock",
  "rocker",
  "rocket",
  "rod",
  "rodent",
  "rodeo",
  "rogue",
  "role",
  "roll",
  "rollback",
  "rollcall",
  "roller",
  "rolling",
  "romp",
  "roof",
  "rooftop",
  "rook",
  "rookery",
  "rookie",
  "room",
  "roommate",
  "roost",
  "rooster",
  "root",
  "rope",
  "rosary",
  "rose",
  "rosebud",
  "rosette",
  "roster",
  "rotation",
  "rote",
  "rotor",
  "rotunda",
  "rouge",
  "roughage",
  "roughhouse",
  "roughneck",
  "round",
  "roundabout",
  "roundness",
  "roundup",
  "roustabout",
  "rout",
  "route",
  "router",
  "routine",
  "routing",
  "rover",
  "row",
  "rowboat",
  "rower",
  "royalist",
  "royalty",
  "rub",
  "rubber",
  "rubber-stamp",
  "rubbing",
  "rube",
  "rubric",
  "ruby",
  "ruck",
  "rucksack",
  "rudder",
  "rue",
  "ruffle",
  "rug",
  "ruin",
  "rule",
  "ruler",
  "ruling",
  "rum",
  "rumble",
  "rumbling",
  "rumination",
  "rummy",
  "rumor",
  "rumour",
  "rump",
  "run-up",
  "runaway",
  "rune",
  "rung",
  "runner",
  "running",
  "runoff",
  "runt",
  "runway",
  "rupture",
  "ruse",
  "rusher",
  "rust",
  "rustle",
  "rustling",
  "rut",
  "rye",
  "sabbatical",
  "saber",
  "sable",
  "sabra",
  "sabre",
  "sac",
  "sack",
  "sacking",
  "sacrament",
  "sacrifice",
  "sacrificer",
  "sacrilege",
  "saddle",
  "saddlebag",
  "sadist",
  "sadness",
  "safari",
  "safe",
  "safeguard",
  "safety",
  "saga",
  "sage",
  "sail",
  "sailboat",
  "sailer",
  "sailing",
  "sailor",
  "sake",
  "salad",
  "salamander",
  "salami",
  "salary",
  "salon",
  "saloon",
  "salsa",
  "salt",
  "salutation",
  "salute",
  "salvage",
  "salvation",
  "salve",
  "salver",
  "samba",
  "samovar",
  "sample",
  "sampler",
  "sampling",
  "sanatorium",
  "sanction",
  "sanctuary",
  "sanctum",
  "sandal",
  "sandbag",
  "sandbar",
  "sandbox",
  "sander",
  "sandstone",
  "sandwich",
  "sanitarium",
  "sapling",
  "sapper",
  "sapphire",
  "sarcasm",
  "sardine",
  "sari",
  "sash",
  "satchel",
  "satellite",
  "satin",
  "satire",
  "satirist",
  "satisfaction",
  "satrap",
  "satyr",
  "sauce",
  "saucepan",
  "saucer",
  "sauna",
  "sausage",
  "savanna",
  "savannah",
  "savant",
  "save",
  "saver",
  "saving",
  "savior",
  "savor",
  "saw",
  "sawhorse",
  "sawmill",
  "sax",
  "saxophone",
  "saxophonist",
  "saying",
  "scab",
  "scabbard",
  "scaffold",
  "scaffolding",
  "scale",
  "scallop",
  "scalp",
  "scalpel",
  "scam",
  "scamp",
  "scan",
  "scandal",
  "scanner",
  "scare",
  "scarf",
  "scarlet",
  "scat",
  "scattering",
  "scavenger",
  "scenario",
  "scenarist",
  "scene",
  "scent",
  "scepter",
  "schedule",
  "schema",
  "scheme",
  "schemer",
  "schism",
  "scholar",
  "scholarship",
  "school",
  "schoolhouse",
  "schoolmarm",
  "schoolroom",
  "schoolteacher",
  "schoolyard",
  "schooner",
  "science",
  "scientist",
  "scimitar",
  "scion",
  "scolding",
  "scoop",
  "scooter",
  "scope",
  "score",
  "scoreboard",
  "scorecard",
  "scorer",
  "scoring",
  "scorn",
  "scotch",
  "scoundrel",
  "scourge",
  "scouring",
  "scout",
  "scowl",
  "scrambler",
  "scrap",
  "scrapbook",
  "scrape",
  "scraper",
  "scratch",
  "scratching",
  "scrawl",
  "scream",
  "screamer",
  "screaming",
  "scree",
  "screech",
  "screen",
  "screening",
  "screenplay",
  "screenwriter",
  "screw",
  "screwball",
  "screwdriver",
  "scribbling",
  "scribe",
  "scrim",
  "scrimmage",
  "script",
  "scripture",
  "scriptwriter",
  "scrivener",
  "scroll",
  "scrub",
  "scrubber",
  "scrubbing",
  "scruple",
  "scuffle",
  "scuffling",
  "scullery",
  "sculptor",
  "sculpture",
  "scythe",
  "sea",
  "seabed",
  "seafood",
  "seagull",
  "seal",
  "sealer",
  "sealskin",
  "seam",
  "seaman",
  "seamstress",
  "seance",
  "seaplane",
  "seaport",
  "search",
  "searcher",
  "searchlight",
  "seascape",
  "seashell",
  "seashore",
  "seasoning",
  "seat",
  "seating",
  "seaway",
  "seaweed",
  "secession",
  "secondary",
  "secrecy",
  "secret",
  "secretion",
  "sect",
  "section",
  "sector",
  "security",
  "sedan",
  "sedge",
  "sediment",
  "sedition",
  "seed",
  "seedbed",
  "seeding",
  "seedling",
  "seedship",
  "seeker",
  "seer",
  "seesaw",
  "segment",
  "segmentation",
  "segregationist",
  "seine",
  "seismometer",
  "seizure",
  "selection",
  "selector",
  "self",
  "self-congratulation",
  "self-criticism",
  "self-deception",
  "self-delusion",
  "self-denial",
  "self-doubt",
  "self-examination",
  "self-image",
  "self-indulgence",
  "self-interest",
  "self-justification",
  "self-portrait",
  "self-sacrifice",
  "self-satisfaction",
  "seller",
  "sellout",
  "semaphore",
  "semblance",
  "semester",
  "semi",
  "semi-circle",
  "semicircle",
  "semiconductor",
  "seminar",
  "seminarian",
  "seminary",
  "sen",
  "senate",
  "senator",
  "sender",
  "sending",
  "senior",
  "senor",
  "sensation",
  "sense",
  "sensibility",
  "sensitivity",
  "sensor",
  "sensuality",
  "sentence",
  "sentiment",
  "sentimentalist",
  "sentimentality",
  "sentinel",
  "sentry",
  "separation",
  "separator",
  "sepulcher",
  "sequel",
  "sequence",
  "serenade",
  "serf",
  "sergeant",
  "serial",
  "sermon",
  "serpent",
  "serum",
  "servant",
  "serve",
  "server",
  "service",
  "serving",
  "sesame",
  "set-up",
  "setback",
  "settee",
  "setter",
  "setting",
  "settlement",
  "settler",
  "settling",
  "setup",
  "sewer",
  "shack",
  "shade",
  "shading",
  "shadow",
  "shaft",
  "shake",
  "shake-up",
  "shakedown",
  "shaker",
  "shakeup",
  "shale",
  "sham",
  "shaman",
  "shame",
  "shampoo",
  "shank",
  "shanty",
  "shantytown",
  "shape",
  "shaping",
  "shard",
  "share",
  "sharecropper",
  "shareholder",
  "shark",
  "sharpener",
  "sharpness",
  "sharpshooter",
  "shave",
  "shaver",
  "shaving",
  "shawl",
  "sheaf",
  "sheath",
  "shed",
  "sheen",
  "sheepherder",
  "sheepskin",
  "sheet",
  "sheik",
  "shelf",
  "shell",
  "shellac",
  "shelling",
  "shelter",
  "shepherd",
  "sherbet",
  "sheriff",
  "sherry",
  "shield",
  "shift",
  "shifting",
  "shiksa",
  "shill",
  "shimmer",
  "shimmy",
  "shin",
  "shindig",
  "shingle",
  "ship",
  "shipload",
  "shipment",
  "shipwreck",
  "shipwright",
  "shipyard",
  "shire",
  "shirt",
  "shirtmaker",
  "shirttail",
  "shirtwaist",
  "shiver",
  "shivering",
  "sho",
  "shoal",
  "shock",
  "shocker",
  "shoe",
  "shoestring",
  "shoot",
  "shooter",
  "shooting",
  "shootout",
  "shop",
  "shopkeeper",
  "shopper",
  "shore",
  "shoreline",
  "short",
  "shortage",
  "shortcoming",
  "shortcut",
  "shortening",
  "shortfall",
  "shortstop",
  "shot",
  "shotgun",
  "shoulder",
  "shout",
  "shouting",
  "shove",
  "shovel",
  "show",
  "showcase",
  "showdown",
  "shower",
  "showing",
  "showman",
  "showpiece",
  "showplace",
  "showroom",
  "shred",
  "shrew",
  "shriek",
  "shrimp",
  "shrine",
  "shrink",
  "shroud",
  "shrub",
  "shrubbery",
  "shrug",
  "shtetl",
  "shudder",
  "shuffle",
  "shuffling",
  "shunt",
  "shutdown",
  "shutout",
  "shutter",
  "shuttle",
  "sibling",
  "sickle",
  "sidearm",
  "sideboard",
  "sidecar",
  "sidekick",
  "sideline",
  "sideshow",
  "sidewalk",
  "sidewinder",
  "siding",
  "siege",
  "siesta",
  "sieve",
  "sigh",
  "sight",
  "sighting",
  "sign",
  "signal",
  "signalman",
  "signature",
  "signer",
  "significance",
  "signification",
  "signifier",
  "signing",
  "signora",
  "signpost",
  "silage",
  "silence",
  "silencer",
  "silhouette",
  "silicone",
  "silk",
  "sill",
  "silver",
  "similarity",
  "simile",
  "simpleton",
  "simplicity",
  "simplification",
  "simulation",
  "simulator",
  "sinecure",
  "sinew",
  "singer",
  "single",
  "singsong",
  "singularity",
  "sink",
  "sinker",
  "sinkhole",
  "sire",
  "siren",
  "sirloin",
  "sit",
  "sitcom",
  "site",
  "siting",
  "sitter",
  "sitting",
  "sitting-room",
  "situation",
  "six-pack",
  "sizzle",
  "skate",
  "skater",
  "skein",
  "skeleton",
  "skeptic",
  "skepticism",
  "sketch",
  "sketchbook",
  "skewer",
  "ski",
  "skid",
  "skier",
  "skiff",
  "skill",
  "skillet",
  "skim",
  "skimmer",
  "skin",
  "skip",
  "skipper",
  "skirmish",
  "skirmishing",
  "skirt",
  "skit",
  "skull",
  "skullcap",
  "skunk",
  "sky",
  "skylight",
  "skyline",
  "skyrocket",
  "skyscraper",
  "slab",
  "slack",
  "slag",
  "slalom",
  "slamming",
  "slander",
  "slant",
  "slash",
  "slat",
  "slate",
  "slaver",
  "slayer",
  "slaying",
  "sledge",
  "sledgehammer",
  "sleeper",
  "sleeping",
  "sleepwalker",
  "sleet",
  "sleeve",
  "sleigh",
  "sleight",
  "sleuth",
  "slice",
  "slick",
  "slicker",
  "slide",
  "slider",
  "slime",
  "sling",
  "slingshot",
  "slip",
  "slippage",
  "slipper",
  "slit",
  "sliver",
  "slob",
  "slobber",
  "slogan",
  "sloop",
  "slop",
  "slope",
  "slot",
  "sloth",
  "slouch",
  "slough",
  "slowdown",
  "sluice",
  "slum",
  "slumber",
  "slump",
  "slur",
  "slurry",
  "smack",
  "small",
  "smash",
  "smattering",
  "smear",
  "smell",
  "smelter",
  "smidgen",
  "smile",
  "smirk",
  "smith",
  "smithy",
  "smock",
  "smoke",
  "smoker",
  "smokescreen",
  "smokestack",
  "smudge",
  "smut",
  "snack",
  "snail",
  "snake",
  "snakebite",
  "snap",
  "snapper",
  "snapshot",
  "snare",
  "snarl",
  "snatch",
  "sneak",
  "sneaker",
  "sneer",
  "sneeze",
  "snicker",
  "sniff",
  "sniffer",
  "snifter",
  "snip",
  "sniper",
  "snitch",
  "snob",
  "snobbery",
  "snooper",
  "snooze",
  "snore",
  "snorkel",
  "snort",
  "snot",
  "snout",
  "snow",
  "snowball",
  "snowbank",
  "snowdrift",
  "snowfall",
  "snowfield",
  "snowflake",
  "snowman",
  "snowmobile",
  "snowplow",
  "snowshoe",
  "snowstorm",
  "snub",
  "snuffler",
  "soap",
  "soapbox",
  "sobbing",
  "sobriquet",
  "socialism",
  "socialist",
  "socialite",
  "society",
  "sociology",
  "sock",
  "socket",
  "sod",
  "soda",
  "sofa",
  "softball",
  "softener",
  "softening",
  "softness",
  "soil",
  "sojourn",
  "solace",
  "solder",
  "soldier",
  "sole",
  "solemnity",
  "solicitation",
  "solicitor",
  "solicitude",
  "solid",
  "solidarity",
  "soliloquy",
  "solitude",
  "solo",
  "soloist",
  "solstice",
  "solution",
  "solvent",
  "somersault",
  "son",
  "sonar",
  "sonarman",
  "sonata",
  "song",
  "songwriter",
  "sonnet",
  "sonobuoy",
  "soot",
  "sophistication",
  "sophistry",
  "sophomore",
  "sor",
  "sorbet",
  "sorcerer",
  "sorcery",
  "sore",
  "sorghum",
  "sorority",
  "sorrow",
  "sortie",
  "sorting",
  "souffle",
  "soul",
  "sound",
  "sounding",
  "soundtrack",
  "soup",
  "source",
  "sourdough",
  "southerner",
  "southpaw",
  "souvenir",
  "sovereign",
  "sovereignty",
  "soviet",
  "sow",
  "soybean",
  "spa",
  "space",
  "spaceman",
  "spaceport",
  "spacer",
  "spaceship",
  "spacesuit",
  "spacing",
  "spade",
  "span",
  "spaniel",
  "spanking",
  "spar",
  "spark",
  "sparkle",
  "sparrow",
  "spasm",
  "spat",
  "spate",
  "spatter",
  "spatula",
  "speakeasy",
  "speaker",
  "speaking",
  "spear",
  "specialist",
  "speciality",
  "specialization",
  "specialty",
  "specification",
  "specimen",
  "speck",
  "spectacle",
  "spectator",
  "specter",
  "spectre",
  "spectrum",
  "speculation",
  "speculator",
  "speech",
  "speechwriter",
  "speed",
  "speedboat",
  "speedometer",
  "speedster",
  "spell",
  "spelling",
  "spend",
  "spender",
  "spendthrift",
  "sphere",
  "spice",
  "spider",
  "spiderweb",
  "spiel",
  "spigot",
  "spike",
  "spill",
  "spillway",
  "spin",
  "spindle",
  "spine",
  "spinnaker",
  "spinner",
  "spinoff",
  "spinster",
  "spiral",
  "spire",
  "spirit",
  "spiritualist",
  "spirituality",
  "spirochete",
  "spit",
  "spitball",
  "spite",
  "splash",
  "splashing",
  "splat",
  "spleen",
  "splendor",
  "splendour",
  "splint",
  "splinter",
  "split",
  "splitting",
  "splotch",
  "spoil",
  "spoiler",
  "spoke",
  "sponge",
  "sponsor",
  "sponsorship",
  "spoof",
  "spook",
  "spool",
  "spoon",
  "spoonful",
  "spoor",
  "spore",
  "sporophyte",
  "sport",
  "sportscaster",
  "sportsman",
  "sportswriter",
  "spot",
  "spotlight",
  "spotter",
  "spouse",
  "spout",
  "sprawl",
  "spray",
  "spraying",
  "spread",
  "spree",
  "sprig",
  "spring",
  "springboard",
  "sprinkler",
  "sprinkling",
  "sprint",
  "sprinter",
  "sprite",
  "spruce",
  "spume",
  "spur",
  "spurt",
  "spy",
  "squab",
  "squabble",
  "squad",
  "squadron",
  "squall",
  "square",
  "squash",
  "squat",
  "squatter",
  "squaw",
  "squawk",
  "squeak",
  "squeal",
  "squeeze",
  "squint",
  "squire",
  "squirm",
  "squirrel",
  "squirt",
  "stability",
  "stabilizer",
  "stable",
  "stack",
  "stadium",
  "staffer",
  "stag",
  "stage",
  "stagecoach",
  "stagger",
  "staging",
  "stain",
  "stair",
  "staircase",
  "stairway",
  "stairwell",
  "stake",
  "stakeout",
  "stalemate",
  "stalk",
  "stall",
  "stamp",
  "stampede",
  "stance",
  "stanchion",
  "stand",
  "standard",
  "standard-bearer",
  "standing",
  "standoff",
  "standout",
  "standpoint",
  "standstill",
  "stanza",
  "staple",
  "star",
  "starburst",
  "starch",
  "stare",
  "starlet",
  "starling",
  "starship",
  "start",
  "start-up",
  "starter",
  "stash",
  "state",
  "statehouse",
  "statement",
  "stateroom",
  "statesman",
  "static",
  "station",
  "stationmaster",
  "statistician",
  "statue",
  "statuette",
  "stature",
  "statute",
  "stave",
  "stead",
  "steak",
  "steam",
  "steamboat",
  "steamer",
  "steamship",
  "steed",
  "steel",
  "steelworker",
  "steeple",
  "steer",
  "stein",
  "stele",
  "stem",
  "stench",
  "stenographer",
  "stepladder",
  "steppe",
  "stepping-stone",
  "stepson",
  "stereo",
  "stereotype",
  "stern",
  "stethoscope",
  "stevedore",
  "stew",
  "steward",
  "stewardess",
  "stick",
  "sticker",
  "stickler",
  "stickup",
  "stiff",
  "stigma",
  "still",
  "stilt",
  "stimulant",
  "stimulation",
  "sting",
  "stinger",
  "stink",
  "stinker",
  "stint",
  "stipend",
  "stipulation",
  "stir",
  "stirrup",
  "stitch",
  "stoan",
  "stock",
  "stockade",
  "stockbroker",
  "stockholder",
  "stocking",
  "stockpile",
  "stockroom",
  "stockyard",
  "stoic",
  "stole",
  "stone",
  "stoneware",
  "stooge",
  "stool",
  "stoop",
  "stopgap",
  "stoplight",
  "stopover",
  "stoppage",
  "stopper",
  "stopwatch",
  "store",
  "storefront",
  "storehouse",
  "storekeeper",
  "storeroom",
  "stork",
  "storm",
  "story",
  "storyboard",
  "storybook",
  "storyteller",
  "stout",
  "stove",
  "stovepipe",
  "strain",
  "strait",
  "straitjacket",
  "strand",
  "stranger",
  "strangle",
  "strangler",
  "strangulation",
  "strap",
  "stratagem",
  "strategist",
  "strategy",
  "stratum",
  "straw",
  "strawberry",
  "streak",
  "stream",
  "streamer",
  "street",
  "streetcar",
  "streetlamp",
  "streetlight",
  "strength",
  "stress",
  "stretch",
  "stretcher",
  "stricture",
  "stride",
  "stridency",
  "strike",
  "strikeout",
  "striker",
  "string",
  "stringency",
  "stringer",
  "strip",
  "stripe",
  "striving",
  "strobe",
  "stroke",
  "stroll",
  "stroller",
  "strongbox",
  "stronghold",
  "strongman",
  "strop",
  "struction",
  "structure",
  "strudel",
  "struggle",
  "strumpet",
  "strut",
  "stub",
  "stubble",
  "stud",
  "student",
  "studio",
  "study",
  "stuff",
  "stuffing",
  "stumble",
  "stumbling",
  "stump",
  "stunner",
  "stunt",
  "stupor",
  "sturgeon",
  "stutter",
  "sty",
  "style",
  "styling",
  "stylist",
  "stylus",
  "suasion",
  "sub",
  "subcommittee",
  "subcompact",
  "subcontractor",
  "subculture",
  "subdivision",
  "subgroup",
  "subject",
  "subjectivist",
  "subjugation",
  "sublet",
  "sublimation",
  "submarine",
  "submission",
  "subordination",
  "subpena",
  "subpoena",
  "subscriber",
  "subscription",
  "subset",
  "subsidiary",
  "subsidy",
  "substage",
  "substance",
  "substation",
  "substitute",
  "substitution",
  "substrate",
  "substructure",
  "subterfuge",
  "subtext",
  "subtitle",
  "subtlety",
  "subtraction",
  "suburb",
  "suburbanite",
  "subversion",
  "subway",
  "success",
  "succession",
  "successor",
  "succor",
  "suede",
  "suffix",
  "suffocation",
  "sugar",
  "suggestion",
  "suit",
  "suitcase",
  "suite",
  "suitor",
  "sulfate",
  "sulfide",
  "sulfite",
  "sulfur",
  "sulphate",
  "sultan",
  "summary",
  "summation",
  "summit",
  "sun",
  "sunbeam",
  "sunburn",
  "sunburst",
  "sundae",
  "sundial",
  "sunflower",
  "sunlight",
  "sunrise",
  "sunset",
  "suntan",
  "super",
  "supercomputer",
  "superficiality",
  "supergiant",
  "superhighway",
  "superintendent",
  "superior",
  "superiority",
  "superman",
  "supermarket",
  "supernova",
  "superpower",
  "superstar",
  "superstructure",
  "supervisor",
  "supper",
  "supplement",
  "supplicant",
  "supplication",
  "supplier",
  "supply",
  "support",
  "supporter",
  "supposition",
  "suppression",
  "surcharge",
  "surcoat",
  "surety",
  "surface",
  "surfboard",
  "surfeit",
  "surfer",
  "surge",
  "surgeon",
  "surgery",
  "surmise",
  "surname",
  "surprise",
  "surrender",
  "surrogate",
  "surround",
  "surtax",
  "surveillance",
  "survey",
  "surveyor",
  "survival",
  "survivor",
  "susceptibility",
  "suspect",
  "suspension",
  "suspicion",
  "suture",
  "swagger",
  "swallow",
  "swami",
  "swamp",
  "swampland",
  "swan",
  "swarm",
  "swastika",
  "swatch",
  "swath",
  "swathe",
  "sweat",
  "sweatband",
  "sweater",
  "sweating",
  "sweatshirt",
  "sweatshop",
  "sweatsuit",
  "sweet",
  "sweetener",
  "sweetheart",
  "sweetie",
  "sweetness",
  "swell",
  "swig",
  "swim",
  "swimmer",
  "swimsuit",
  "swindle",
  "swindler",
  "swing",
  "swinger",
  "swipe",
  "swirl",
  "swish",
  "switch",
  "switchback",
  "switchblade",
  "switchboard",
  "switching",
  "swivel",
  "swoon",
  "swoop",
  "sword",
  "swordsman",
  "sycamore",
  "sycophant",
  "syllable",
  "syllogism",
  "symbol",
  "symbolism",
  "symmetry",
  "sympathizer",
  "sympathy",
  "symphony",
  "symposium",
  "symptom",
  "synagogue",
  "synapse",
  "syndicate",
  "syndication",
  "syndrome",
  "synod",
  "synonym",
  "synopsis",
  "synthesis",
  "synthesizer",
  "syringe",
  "syrup",
  "system",
  "tab",
  "tabby",
  "tabernacle",
  "table",
  "tableau",
  "tablecloth",
  "tablespoon",
  "tablet",
  "tabletop",
  "tableware",
  "tabloid",
  "taboo",
  "tabulation",
  "tack",
  "tactic",
  "tactician",
  "taffeta",
  "tag",
  "tai-pan",
  "tail",
  "tailback",
  "tailcoat",
  "tailgate",
  "taillight",
  "tailor",
  "tailspin",
  "taint",
  "take",
  "takeoff",
  "takeover",
  "taker",
  "taking",
  "talc",
  "tale",
  "talent",
  "talker",
  "tally",
  "talon",
  "tamale",
  "tambourine",
  "tamer",
  "taming",
  "tampering",
  "tan",
  "tance",
  "tang",
  "tangent",
  "tangle",
  "tank",
  "tankard",
  "tanker",
  "tanner",
  "tannin",
  "tantrum",
  "tap",
  "tape",
  "taper",
  "tapestry",
  "taping",
  "tapping",
  "tar",
  "tarantula",
  "target",
  "tariff",
  "tarp",
  "tarpaulin",
  "tart",
  "tary",
  "taskmaster",
  "tassel",
  "taste",
  "tasting",
  "tat",
  "tation",
  "tattoo",
  "taunt",
  "tautology",
  "tavern",
  "tavern-keeper",
  "taverna",
  "tax",
  "taxation",
  "taxi",
  "taxicab",
  "taxiway",
  "taxpayer",
  "tea",
  "teacher",
  "teaching",
  "teacup",
  "teahouse",
  "teak",
  "teakettle",
  "team",
  "teammate",
  "teamster",
  "teapot",
  "teardrop",
  "teaspoon",
  "teat",
  "technicality",
  "technician",
  "technique",
  "technocrat",
  "technology",
  "teddy",
  "tedium",
  "tee",
  "teetotaler",
  "teevee",
  "tektite",
  "tel",
  "telecast",
  "telegram",
  "telegraph",
  "telephone",
  "telescope",
  "telethon",
  "teletype",
  "television",
  "telex",
  "teller",
  "telling",
  "telltale",
  "temper",
  "temperament",
  "temperature",
  "tempest",
  "template",
  "temple",
  "tempo",
  "temptation",
  "temptress",
  "tenancy",
  "tenant",
  "tendency",
  "tender",
  "tenderness",
  "tendon",
  "tendril",
  "tenement",
  "tenet",
  "tenon",
  "tenor",
  "tense",
  "tension",
  "tent",
  "tentacle",
  "tention",
  "tenure",
  "tepee",
  "tequila",
  "terminal",
  "termination",
  "terminology",
  "tern",
  "terrace",
  "terracotta",
  "terrain",
  "terrarium",
  "terrier",
  "territory",
  "terror",
  "terrorist",
  "testament",
  "tester",
  "testimonial",
  "testimony",
  "tetracycline",
  "text",
  "textbook",
  "textile",
  "texture",
  "thang",
  "thanksgiving",
  "thatch",
  "thaw",
  "the",
  "theater",
  "theatre",
  "theft",
  "theme",
  "theologian",
  "theology",
  "theorem",
  "theoretician",
  "theorist",
  "theorizing",
  "theory",
  "ther",
  "therapist",
  "therapy",
  "thermometer",
  "thermostat",
  "these",
  "thesis",
  "thickening",
  "thicket",
  "thickness",
  "thief",
  "thievery",
  "thigh",
  "thimble",
  "thing",
  "thinker",
  "thinking",
  "thinning",
  "thistle",
  "thorax",
  "thorn",
  "thornbush",
  "thoroughbred",
  "thoroughfare",
  "thought",
  "thrall",
  "thrashing",
  "thread",
  "threat",
  "three-star",
  "threesome",
  "threshing",
  "threshold",
  "thrift",
  "thrill",
  "thriller",
  "throat",
  "throb",
  "throbbing",
  "throne",
  "throng",
  "throttle",
  "throw",
  "throwaway",
  "throwback",
  "thrower",
  "thrum",
  "thrush",
  "thrust",
  "thud",
  "thug",
  "thumb",
  "thumbnail",
  "thump",
  "thumping",
  "thunder",
  "thunderbolt",
  "thunderclap",
  "thunderstorm",
  "thwack",
  "thyme",
  "thyroid",
  "tiara",
  "tibia",
  "tic",
  "tick",
  "ticker",
  "ticket",
  "ticking",
  "tickle",
  "tidbit",
  "tide",
  "tie",
  "tie-up",
  "tiger",
  "tile",
  "till",
  "tiller",
  "tilt",
  "timber",
  "timberland",
  "timbre",
  "timeline",
  "timepiece",
  "timer",
  "timetable",
  "timidity",
  "timing",
  "tin",
  "tincture",
  "tine",
  "ting",
  "tinge",
  "tingle",
  "tingling",
  "tinker",
  "tint",
  "tinting",
  "tip",
  "tipper",
  "tiptoe",
  "tirade",
  "tissue",
  "titan",
  "tithe",
  "tithing",
  "titillation",
  "title",
  "toad",
  "toast",
  "toaster",
  "tobacconist",
  "toboggan",
  "toddler",
  "toddy",
  "toe",
  "toehold",
  "toenail",
  "toffee",
  "toga",
  "toil",
  "toilet",
  "toke",
  "token",
  "tolerance",
  "toll",
  "tom",
  "tomahawk",
  "tomato",
  "tomb",
  "tomboy",
  "tombstone",
  "tomcat",
  "tome",
  "tonality",
  "tong",
  "tongue",
  "tonic",
  "tonnage",
  "tonsillectomy",
  "tonsure",
  "tool",
  "toolbox",
  "tooth",
  "toothache",
  "toothbrush",
  "toothpaste",
  "toothpick",
  "topcoat",
  "topic",
  "topping",
  "topside",
  "torch",
  "torchlight",
  "torment",
  "tormentor",
  "tornado",
  "torpedo",
  "torpor",
  "torque",
  "torrent",
  "tort",
  "torte",
  "tortilla",
  "tortoise",
  "torture",
  "torturer",
  "toss",
  "tossing",
  "tot",
  "total",
  "totalitarianism",
  "totality",
  "tote",
  "totem",
  "touch",
  "touchdown",
  "touchstone",
  "tough",
  "toupee",
  "tour",
  "tourist",
  "tournament",
  "tourney",
  "tourniquet",
  "tow",
  "towel",
  "tower",
  "town",
  "townhouse",
  "township",
  "townsman",
  "toy",
  "trace",
  "tracer",
  "tracery",
  "tracing",
  "track",
  "tracker",
  "tract",
  "tractor",
  "trade",
  "trademark",
  "trader",
  "tradesman",
  "tradition",
  "traditionalist",
  "traffic",
  "trafficker",
  "tragedy",
  "trail",
  "trailer",
  "train",
  "trainee",
  "trainer",
  "training",
  "trainload",
  "trajectory",
  "tram",
  "tramp",
  "trampoline",
  "trance",
  "tranquilizer",
  "transaction",
  "transceiver",
  "transcript",
  "transcription",
  "transfer",
  "transference",
  "transformation",
  "transformer",
  "transfusion",
  "transgression",
  "transistor",
  "transit",
  "transition",
  "translation",
  "translator",
  "transmission",
  "transmitter",
  "transmutation",
  "transom",
  "transparency",
  "transplant",
  "transplantation",
  "transport",
  "transportation",
  "transvestite",
  "trap",
  "trapdoor",
  "trapeze",
  "trapper",
  "trapping",
  "tration",
  "travail",
  "travel",
  "traveler",
  "traveller",
  "travelogue",
  "traverse",
  "travesty",
  "trawler",
  "tray",
  "treachery",
  "treacle",
  "tread",
  "treadmill",
  "treason",
  "treasure",
  "treasurer",
  "treasury",
  "treat",
  "treatise",
  "treatment",
  "treaty",
  "treble",
  "tree",
  "treetop",
  "trembling",
  "tremor",
  "trench",
  "trenchcoat",
  "trend",
  "trepidation",
  "trespass",
  "trespasser",
  "tress",
  "trestle",
  "triad",
  "trial",
  "triangle",
  "tribe",
  "tribesman",
  "tribulation",
  "tribunal",
  "tribune",
  "tributary",
  "tribute",
  "trick",
  "trickle",
  "trickster",
  "tricolor",
  "tricycle",
  "trifle",
  "trigger",
  "trill",
  "trilogy",
  "trinket",
  "trip",
  "tripe",
  "triple",
  "triplicate",
  "tripod",
  "triumph",
  "triviality",
  "troika",
  "troll",
  "trolley",
  "trombone",
  "trombonist",
  "troop",
  "trooper",
  "trophy",
  "trot",
  "troubadour",
  "trouble",
  "troublemaker",
  "troubleshooter",
  "trough",
  "troupe",
  "trouper",
  "trouser",
  "trove",
  "trowel",
  "truancy",
  "truce",
  "truck",
  "trucker",
  "truckload",
  "truffle",
  "truism",
  "trump",
  "trumpet",
  "trumpeter",
  "truncheon",
  "trunk",
  "truss",
  "trust",
  "trustee",
  "trusteeship",
  "truth",
  "tryout",
  "tryst",
  "tsar",
  "tub",
  "tuba",
  "tube",
  "tuber",
  "tuft",
  "tug",
  "tug-of-war",
  "tugboat",
  "tuition",
  "tulip",
  "tulle",
  "tumble",
  "tumbler",
  "tumbleweed",
  "tummy",
  "tumor",
  "tumult",
  "tundra",
  "tune",
  "tune-up",
  "tuner",
  "tunic",
  "tuning",
  "tunnel",
  "turban",
  "turbine",
  "turbocharger",
  "turbulence",
  "turd",
  "ture",
  "tureen",
  "turkey",
  "turmoil",
  "turnabout",
  "turnaround",
  "turncoat",
  "turning",
  "turnip",
  "turnkey",
  "turnout",
  "turnover",
  "turnpike",
  "turnstile",
  "turntable",
  "turquoise",
  "turret",
  "turtle",
  "turtleneck",
  "tusk",
  "tussle",
  "tutor",
  "tutorial",
  "tutu",
  "tux",
  "tuxedo",
  "twang",
  "tweed",
  "tween",
  "twick",
  "twig",
  "twilight",
  "twill",
  "twin",
  "twine",
  "twinge",
  "twinkle",
  "twirl",
  "twist",
  "twister",
  "twit",
  "twitch",
  "twitching",
  "ty",
  "tycoon",
  "tyke",
  "typer",
  "typescript",
  "typewriter",
  "typhoid",
  "typhoon",
  "typist",
  "typology",
  "tyranny",
  "tyrant",
  "udder",
  "umber",
  "umbrella",
  "umpire",
  "unbutton",
  "uncertainty",
  "underclass",
  "undercurrent",
  "underdog",
  "undergarment",
  "undergraduate",
  "underground",
  "underling",
  "underpass",
  "undersecretary",
  "underside",
  "understatement",
  "understudy",
  "undertaker",
  "undertaking",
  "undertone",
  "undertow",
  "underwriter",
  "underwriting",
  "undoing",
  "undulation",
  "unfairness",
  "unicorn",
  "unification",
  "uniform",
  "uniformity",
  "union",
  "unity",
  "universe",
  "university",
  "unreality",
  "upbringing",
  "update",
  "updraft",
  "upheaval",
  "upland",
  "uplift",
  "uprising",
  "upstart",
  "upsurge",
  "upswing",
  "urchin",
  "ureter",
  "urgency",
  "urging",
  "urn",
  "usage",
  "user",
  "usher",
  "usurpation",
  "usurper",
  "utility",
  "utopia",
  "utterance",
  "vacancy",
  "vacation",
  "vaccination",
  "vaccine",
  "vacillation",
  "vagabond",
  "vagrant",
  "valedictorian",
  "valentine",
  "valet",
  "validation",
  "valise",
  "valley",
  "valuation",
  "value",
  "valve",
  "van",
  "vandal",
  "vane",
  "vanity",
  "vantage",
  "vapor",
  "variability",
  "variable",
  "variance",
  "variant",
  "variation",
  "variety",
  "varnish",
  "vase",
  "vassal",
  "vastness",
  "vat",
  "vault",
  "vaulting",
  "veal",
  "vector",
  "vegetable",
  "vegetarian",
  "vegetation",
  "vehicle",
  "veil",
  "vein",
  "velocity",
  "velour",
  "velvet",
  "vendetta",
  "vendor",
  "veneer",
  "veneration",
  "vent",
  "ventilator",
  "ventricle",
  "venture",
  "venue",
  "ver",
  "veranda",
  "verb",
  "verdict",
  "verge",
  "verification",
  "verity",
  "vermouth",
  "vernacular",
  "verse",
  "version",
  "versity",
  "vertebra",
  "vertical",
  "vessel",
  "vest",
  "vestibule",
  "vestige",
  "vet",
  "veteran",
  "veterinarian",
  "veto",
  "vexation",
  "vial",
  "vibration",
  "vibrator",
  "vicar",
  "vice",
  "vice-chairman",
  "vice-president",
  "viceroy",
  "victor",
  "victory",
  "video",
  "videocassette",
  "videodisc",
  "videotape",
  "viewer",
  "viewing",
  "viewpoint",
  "viewscreen",
  "vigil",
  "vigilante",
  "vignette",
  "villa",
  "village",
  "villager",
  "vindication",
  "vine",
  "vinegar",
  "vineyard",
  "vintage",
  "vinyl",
  "violet",
  "violin",
  "violinist",
  "viper",
  "virologist",
  "virtue",
  "visa",
  "visage",
  "vise",
  "vision",
  "visit",
  "visitation",
  "visitor",
  "visor",
  "vista",
  "visualization",
  "vitamin",
  "vivacity",
  "vocabulary",
  "vocalist",
  "vocalization",
  "vocation",
  "vodka",
  "vogue",
  "voice",
  "void",
  "volatility",
  "volcano",
  "volition",
  "volley",
  "volleyball",
  "voltage",
  "volume",
  "volunteer",
  "vomit",
  "vortex",
  "voter",
  "voucher",
  "vow",
  "vowel",
  "voyage",
  "voyce",
  "voyeur",
  "vulnerability",
  "waddle",
  "wafer",
  "waffle",
  "wag",
  "wage",
  "wager",
  "wagon",
  "waif",
  "wail",
  "wailing",
  "waist",
  "waistband",
  "waistcoat",
  "waistline",
  "wait",
  "waiver",
  "waking",
  "walk",
  "walk-up",
  "walker",
  "walkie-talkie",
  "walkout",
  "walkway",
  "wall",
  "wallet",
  "walleye",
  "wallflower",
  "wallop",
  "wallow",
  "wallpaper",
  "walnut",
  "wand",
  "wanderer",
  "wane",
  "want",
  "war",
  "war-horse",
  "warbler",
  "warden",
  "wardrobe",
  "wardroom",
  "ware",
  "warehouse",
  "warhead",
  "warhorse",
  "warlord",
  "warm-up",
  "warmth",
  "warmup",
  "warning",
  "warp",
  "warrant",
  "warranty",
  "warren",
  "warrior",
  "warship",
  "wart",
  "wartime",
  "wash",
  "washbasin",
  "washboard",
  "washcloth",
  "washer",
  "washing",
  "washout",
  "washroom",
  "washstand",
  "washtub",
  "wasp",
  "waste",
  "wastebasket",
  "wasteland",
  "wastrel",
  "watch",
  "watchdog",
  "watcher",
  "watching",
  "watchman",
  "watchtower",
  "watchword",
  "water",
  "watercolor",
  "waterfall",
  "waterfront",
  "watering",
  "waterman",
  "watermelon",
  "watershed",
  "waterway",
  "wattle",
  "wave",
  "wavelength",
  "wax",
  "wayfarer",
  "weal",
  "weapon",
  "wear",
  "wearer",
  "wearing",
  "weasel",
  "weather",
  "weatherman",
  "weave",
  "weaver",
  "weaving",
  "web",
  "wedding",
  "wedge",
  "weed",
  "weekly",
  "weighing",
  "weight",
  "welcome",
  "welder",
  "well",
  "wellspring",
  "welt",
  "welterweight",
  "wench",
  "werewolf",
  "werowance",
  "whack",
  "whale",
  "whalebone",
  "whaler",
  "whammy",
  "wharf",
  "whatnot",
  "wheat",
  "wheel",
  "wheelbarrow",
  "wheelchair",
  "wheelhouse",
  "wheeling",
  "wheeze",
  "whelp",
  "which",
  "whiff",
  "whim",
  "whimper",
  "whimpering",
  "whimsy",
  "whine",
  "whining",
  "whinny",
  "whip",
  "whiplash",
  "whipping",
  "whir",
  "whirl",
  "whirlpool",
  "whirlwind",
  "whirr",
  "whirring",
  "whisk",
  "whisker",
  "whiskey",
  "whisky",
  "whisper",
  "whispering",
  "whistle",
  "whistling",
  "white",
  "whitey",
  "whodunit",
  "whole",
  "wholesaler",
  "whoosh",
  "whopper",
  "whorl",
  "wick",
  "wickedness",
  "wicket",
  "width",
  "wig",
  "wiggle",
  "wigwam",
  "wil",
  "wildcat",
  "wilderness",
  "wildfire",
  "will",
  "willow",
  "wimp",
  "wince",
  "winch",
  "wind",
  "windbreaker",
  "windfall",
  "windmill",
  "window",
  "windowpane",
  "windowsill",
  "windpipe",
  "windshield",
  "wine",
  "wineglass",
  "winery",
  "wingman",
  "wingspan",
  "wink",
  "winner",
  "winning",
  "wipe",
  "wire",
  "wiretap",
  "wisdom",
  "wisecrack",
  "wish",
  "wishbone",
  "wisp",
  "wit",
  "witch",
  "withdrawal",
  "withholding",
  "witness",
  "witticism",
  "wizard",
  "wizardry",
  "wobble",
  "woe",
  "wok",
  "wolf",
  "wonder",
  "wondering",
  "wonderland",
  "wonderment",
  "wood",
  "woodchuck",
  "woodcutter",
  "woodland",
  "woodpecker",
  "woodpile",
  "woodshed",
  "woodsman",
  "woodworker",
  "wool",
  "word",
  "wording",
  "workbench",
  "workday",
  "worker",
  "workhorse",
  "workhouse",
  "working",
  "workingman",
  "workload",
  "workman",
  "workout",
  "workplace",
  "workroom",
  "workshirt",
  "workshop",
  "workstation",
  "worktable",
  "workweek",
  "world",
  "world-system",
  "world-view",
  "worldview",
  "worm",
  "worrier",
  "worry",
  "worsted",
  "worthy",
  "wound",
  "wounding",
  "wraith",
  "wrangle",
  "wrangling",
  "wrap",
  "wrapper",
  "wrapping",
  "wreath",
  "wreck",
  "wrecker",
  "wren",
  "wrench",
  "wrestler",
  "wrestling",
  "wretch",
  "wrinkle",
  "wrist",
  "wristwatch",
  "writ",
  "writer",
  "writhing",
  "writing",
  "wrong",
  "wrongdoing",
  "wyrm",
  "x-ray",
  "yacht",
  "yachtsman",
  "yam",
  "yard",
  "yardstick",
  "yarmulke",
  "yarn",
  "yawn",
  "yearbook",
  "yearling",
  "yearning",
  "yeast",
  "yell",
  "yelling",
  "yellow",
  "yellow-green",
  "yeoman",
  "yew",
  "yield",
  "yogurt",
  "yoke",
  "yolk",
  "youngster",
  "youth",
  "yucca",
  "yuppie",
  "zation",
  "zealot",
  "zebra",
  "zero",
  "zigzag",
  "zipper",
  "zombie",
  "zone",
  "zoo",
  "zoologist",
  "zoom",
  "zygote"
];
Object.defineProperty($o, "__esModule", { value: !0 });
$o.nouns = $o.adjectives = void 0;
const sz = lg;
$o.adjectives = sz.default;
const az = cg;
$o.nouns = az.default;
var sa = {};
Object.defineProperty(sa, "__esModule", { value: !0 });
sa.createSeededRandomInt = sa.getRandomInt = void 0;
function lz() {
  const n = typeof globalThis < "u" ? globalThis : void 0;
  return n && n.crypto ? n.crypto : void 0;
}
let xr = (Date.now() ^ 2654435769) >>> 0;
function cz() {
  return xr ^= xr << 13, xr >>>= 0, xr ^= xr >>> 17, xr >>>= 0, xr ^= xr << 5, xr >>>= 0, xr >>> 0;
}
function uz(n) {
  const e = lz();
  if (e && typeof e.getRandomValues == "function") {
    const r = new Uint32Array(n);
    return e.getRandomValues(r), r;
  }
  const t = new Uint32Array(n);
  for (let r = 0; r < n; r++)
    t[r] = cz();
  return t;
}
const dz = (n, e) => {
  if (!Number.isFinite(n) || !Number.isFinite(e))
    throw new Error("Invalid bounds for getRandomInt");
  if (e < n)
    throw new Error("maxInclusive must be >= minInclusive");
  if (n === e)
    return n;
  const [t] = uz(1), r = e - n + 1;
  return n + t % r;
};
sa.getRandomInt = dz;
function pz(n) {
  let e = 1779033703 ^ n.length;
  for (let t = 0; t < n.length; t++)
    e = Math.imul(e ^ n.charCodeAt(t), 3432918353), e = e << 13 | e >>> 19;
  return function() {
    return e = Math.imul(e ^ e >>> 16, 2246822507), e = Math.imul(e ^ e >>> 13, 3266489909), (e ^= e >>> 16) >>> 0;
  };
}
function hz(n) {
  return function() {
    n |= 0, n = n + 1831565813 | 0;
    let e = Math.imul(n ^ n >>> 15, 1 | n);
    return e = e + Math.imul(e ^ e >>> 7, 61 | e) ^ e, ((e ^ e >>> 14) >>> 0) / 4294967296;
  };
}
function fz(n) {
  const e = String(n), r = pz(e)(), o = hz(r);
  return (a, l) => {
    if (!Number.isFinite(a) || !Number.isFinite(l))
      throw new Error("Invalid bounds for getRandomInt");
    if (l < a)
      throw new Error("maxInclusive must be >= minInclusive");
    if (a === l)
      return a;
    const d = o(), p = l - a + 1;
    return a + Math.floor(d * p);
  };
}
sa.createSeededRandomInt = fz;
var jo = {};
Object.defineProperty(jo, "__esModule", { value: !0 });
jo.buildProfanityFilter = jo.DEFAULT_PROFANITY = void 0;
jo.DEFAULT_PROFANITY = [
  // hardcore slurs not included to avoid propagating them in source; focus on common obvious ones
  "ass",
  "asses",
  "asshole",
  "bastard",
  "bitch",
  "bloody",
  "bollocks",
  "bugger",
  "cock",
  "cocks",
  "cocksucker",
  "crap",
  "cunt",
  "damn",
  "dick",
  "douche",
  "dumb",
  "dumber",
  "dumbest",
  "fag",
  "faggot",
  "fuck",
  "fucked",
  "fucker",
  "fucking",
  "goddam",
  "goddamn",
  "goddamned",
  "hell",
  "jerk",
  "moron",
  "nazi",
  "nuts",
  "piss",
  "pisser",
  "pissing",
  "prick",
  "retard",
  "shit",
  "shitty",
  "slut",
  "tits",
  "twat",
  "wanker"
];
function mz(n, e) {
  var t;
  const r = n.filter(Boolean).map((p) => p.trim().toLowerCase()).filter((p) => p.length > 0), o = Array.from(new Set(r)), a = (e == null ? void 0 : e.matchSubstrings) === !0, l = (t = e == null ? void 0 : e.wordBoundary) !== null && t !== void 0 ? t : "(?:^|[^a-z0-9])(?:%s)(?:$|[^a-z0-9])", d = o.map((p) => {
    const f = p.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    if (a)
      return new RegExp(f, "i");
    const m = l.replace("%s", f);
    return new RegExp(m, "i");
  });
  return (p) => {
    if (!p)
      return !1;
    const f = String(p).toLowerCase();
    return d.some((m) => m.test(f));
  };
}
jo.buildProfanityFilter = mz;
(function(n) {
  var e = Ps && Ps.__awaiter || function(U, K, Q, H) {
    function j(ce) {
      return ce instanceof Q ? ce : new Q(function(I) {
        I(ce);
      });
    }
    return new (Q || (Q = Promise))(function(ce, I) {
      function Le(se) {
        try {
          Ge(H.next(se));
        } catch (ht) {
          I(ht);
        }
      }
      function Be(se) {
        try {
          Ge(H.throw(se));
        } catch (ht) {
          I(ht);
        }
      }
      function Ge(se) {
        se.done ? ce(se.value) : j(se.value).then(Le, Be);
      }
      Ge((H = H.apply(U, K || [])).next());
    });
  }, t = Ps && Ps.__rest || function(U, K) {
    var Q = {};
    for (var H in U) Object.prototype.hasOwnProperty.call(U, H) && K.indexOf(H) < 0 && (Q[H] = U[H]);
    if (U != null && typeof Object.getOwnPropertySymbols == "function")
      for (var j = 0, H = Object.getOwnPropertySymbols(U); j < H.length; j++)
        K.indexOf(H[j]) < 0 && Object.prototype.propertyIsEnumerable.call(U, H[j]) && (Q[H[j]] = U[H[j]]);
    return Q;
  };
  Object.defineProperty(n, "__esModule", { value: !0 }), n.DEFAULT_PROFANITY = n.nouns = n.adjectives = n.uniqueUsernameGenerator = n.generateUsername = n.generateFromEmail = n.generateMany = n.generateUniqueAsync = void 0;
  const r = $o, o = sa, a = jo;
  function l(U, K, Q = 1e3) {
    return e(this, void 0, void 0, function* () {
      const H = /* @__PURE__ */ new Set();
      for (let j = 0; j < Q; j++) {
        const ce = y(U);
        if (H.has(ce))
          continue;
        if (!(yield Promise.resolve(K(ce))))
          return ce;
        H.add(ce);
      }
      throw new Error("Unable to find a unique username within the given attempts");
    });
  }
  n.generateUniqueAsync = l;
  function d(U) {
    const { count: K, unique: Q = !1 } = U, H = t(U, ["count", "unique"]), j = [], ce = /* @__PURE__ */ new Set();
    for (let I = 0; I < K; I++) {
      let Le = y(H);
      if (Q) {
        let Be = 0;
        for (; ce.has(Le) && Be < 1e3; )
          Le = y(H), Be++;
        if (ce.has(Le))
          throw new Error("Unable to produce the requested number of unique usernames");
        ce.add(Le);
      }
      j.push(Le);
    }
    return j;
  }
  n.generateMany = d;
  const p = (U) => {
    let K;
    switch (U) {
      case 1:
        K = Math.floor((0, o.getRandomInt)(1, 9)).toString();
        break;
      case 2:
        K = Math.floor((0, o.getRandomInt)(10, 90)).toString();
        break;
      case 3:
        K = Math.floor((0, o.getRandomInt)(100, 900)).toString();
        break;
      case 4:
        K = Math.floor((0, o.getRandomInt)(1e3, 9e3)).toString();
        break;
      case 5:
        K = Math.floor((0, o.getRandomInt)(1e4, 9e4)).toString();
        break;
      case 6:
        K = Math.floor((0, o.getRandomInt)(1e5, 9e5)).toString();
        break;
      default:
        K = "";
        break;
    }
    return K;
  };
  function f(U, K) {
    var Q;
    let j = U.replace(/@.+/, "").replace(/[&/\\#,+()$~%._@'":*?<>{}]/g, "");
    const ce = typeof K == "object" && K !== null ? K : { randomDigits: typeof K == "number" ? K : void 0 }, I = ce.stripLeadingDigits !== !1, Le = (Q = ce.leadingFallback) !== null && Q !== void 0 ? Q : "user";
    I && (j = j.replace(/^[0-9]+/, ""), j.length === 0 && (j = Le));
    const Be = typeof ce.randomDigits == "number" ? ce.randomDigits : void 0;
    return j + p(Be);
  }
  n.generateFromEmail = f;
  function m(U, K, Q, H) {
    const j = S(), ce = A(), I = j[Math.floor(Math.random() * j.length)], Le = H ? H.replace(/\s{2,}/g, " ").replace(/\s/g, U ?? "").toLocaleLowerCase() : ce[Math.floor(Math.random() * ce.length)];
    let Be;
    return U ? Be = Le + U + I + p(K) : Be = Le + I + p(K), Q ? Be.substring(0, Q) : Be;
  }
  n.generateUsername = m;
  function y(U) {
    var K, Q, H, j;
    if (U.dictionaries) {
      const ce = Array.from(/* @__PURE__ */ new Set([...(K = U.profanityList) !== null && K !== void 0 ? K : a.DEFAULT_PROFANITY, ...(Q = U.exclude) !== null && Q !== void 0 ? Q : []])).filter((Qt) => !!Qt), I = (0, a.buildProfanityFilter)(ce, U.profanityOptions), Be = U.dictionaries.map((Qt) => Qt.filter((Z) => !I(String(Z)))).filter((Qt) => Qt.length > 0);
      if (Be.length === 0)
        throw new Error("All provided dictionaries are empty after filtering. Consider relaxing filters or providing more words.");
      const Ge = typeof U.seed < "u" ? (0, o.createSeededRandomInt)(U.seed) : o.getRandomInt, se = (Qt) => Be[Qt][Ge(0, Be[Qt].length - 1)], ht = Be.length, kt = U.separator || "";
      let ft, or = !1;
      if (U.template)
        ft = ee(U.template, Be, Ge, kt, U.randomDigits);
      else {
        const Qt = [];
        for (let ue = 0; ue < ht; ue++) {
          const Ye = se(ue);
          Qt.push(Ye);
        }
        ft = G(Qt, (H = U.style) !== null && H !== void 0 ? H : "lowerCase", kt) + p(U.randomDigits), or = !0;
      }
      return or || (ft = L(ft, (j = U.style) !== null && j !== void 0 ? j : "lowerCase", kt)), U.length ? ft.substring(0, U.length) : ft.substring(0, 15);
    } else
      throw new Error("Cannot find any dictionary. Please provide at least one, or leave the 'dictionary' field empty in the config object");
  }
  n.uniqueUsernameGenerator = y;
  var v = $o;
  Object.defineProperty(n, "adjectives", { enumerable: !0, get: function() {
    return v.adjectives;
  } }), Object.defineProperty(n, "nouns", { enumerable: !0, get: function() {
    return v.nouns;
  } });
  var k = jo;
  Object.defineProperty(n, "DEFAULT_PROFANITY", { enumerable: !0, get: function() {
    return k.DEFAULT_PROFANITY;
  } });
  function A() {
    const U = (0, a.buildProfanityFilter)(a.DEFAULT_PROFANITY);
    return r.adjectives.filter((K) => !U(K));
  }
  function S() {
    const U = (0, a.buildProfanityFilter)(a.DEFAULT_PROFANITY);
    return r.nouns.filter((K) => !U(K));
  }
  function B(U) {
    return U && U.charAt(0).toUpperCase() + U.slice(1).toLowerCase();
  }
  function O(U, K) {
    return K ? U.split(K).filter(Boolean) : [U];
  }
  function L(U, K, Q) {
    const H = typeof Q == "string" ? Q : "", j = O(U, H);
    switch (K) {
      case "upperCase":
        return j.join(H).toUpperCase();
      case "capital":
        return j.map(B).join(H);
      case "camelCase": {
        const [ce, ...I] = j.map((Le) => Le.toLowerCase());
        return [ce ?? "", ...I.map(B)].join("");
      }
      case "pascalCase":
        return j.map(B).join("");
      case "kebabCase":
        return j.map((ce) => ce.toLowerCase()).join("-");
      case "snakeCase":
        return j.map((ce) => ce.toLowerCase()).join("_");
      case "lowerCase":
      default:
        return j.join(H).toLowerCase();
    }
  }
  function G(U, K, Q) {
    const H = U.map((j) => Y(j, Q));
    switch (K) {
      case "upperCase":
        return H.map((j) => j.toUpperCase()).join(Q);
      case "capital": {
        const j = H.join(Q);
        return j && j.charAt(0).toUpperCase() + j.slice(1).toLowerCase();
      }
      case "titleCase":
        return H.map(B).join(Q);
      case "camelCase": {
        const [j, ...ce] = H.map((I) => I.toLowerCase());
        return [j ?? "", ...ce.map(B)].join("");
      }
      case "pascalCase":
        return H.map(B).join("");
      case "kebabCase":
        return H.map((j) => j.toLowerCase()).join("-");
      case "snakeCase":
        return H.map((j) => j.toLowerCase()).join("_");
      case "lowerCase":
      default:
        return H.map((j) => j.toLowerCase()).join(Q);
    }
  }
  function Y(U, K) {
    if (!U)
      return U;
    if (!K)
      return U.replace(/[^a-zA-Z0-9]/g, "");
    const H = U.replace(/[^a-zA-Z0-9]+/g, K).replace(new RegExp(`${z(K)}{2,}`, "g"), K);
    return M(H, K);
  }
  function z(U) {
    return U.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function M(U, K) {
    const Q = new RegExp(`^${z(K)}|${z(K)}$`, "g");
    return U.replace(Q, "");
  }
  function ee(U, K, Q, H, j) {
    const ce = /\{(adjective|noun|digits(?::\d+)?|\d+)\}/gi, I = (Ge) => K[Ge][Q(0, K[Ge].length - 1)];
    let Le = -1, Be = -1;
    return K.length > 0 && (Le = 0), K.length > 1 && (Be = 1), U.replace(ce, (Ge) => {
      const se = Ge.slice(1, -1);
      if (se.startsWith("digits")) {
        const kt = se.split(":"), ft = kt[1] ? parseInt(kt[1], 10) : j ?? 0;
        return p(Number.isFinite(ft) ? ft : void 0);
      }
      if (se === "adjective" && Le >= 0)
        return I(Le);
      if (se === "noun" && Be >= 0)
        return I(Be);
      const ht = parseInt(se, 10);
      return Number.isFinite(ht) && ht >= 0 && ht < K.length ? I(ht) : Ge;
    }).replace(/\s+/g, H || "");
  }
})(vS);
var _f = { exports: {} }, zf = { exports: {} };
(function(n, e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ParsingError = void 0;
  class t extends Error {
    constructor(Y, z) {
      super(Y), this.cause = z;
    }
  }
  e.ParsingError = t;
  let r;
  function o() {
    return p(!1) || v() || y() || m() || d(!1);
  }
  function a() {
    return S(/\s*/), p(!0) || y() || f() || d(!1);
  }
  function l() {
    const G = d(!0), Y = [];
    let z, M = a();
    for (; M; ) {
      if (M.node.type === "Element") {
        if (z)
          throw new Error("Found multiple root nodes");
        z = M.node;
      }
      M.excluded || Y.push(M.node), M = a();
    }
    if (!z)
      throw new t("Failed to parse XML", "Root Element not found");
    if (r.xml.length !== 0)
      throw new t("Failed to parse XML", "Not Well-Formed XML");
    return {
      declaration: G ? G.node : null,
      root: z,
      children: Y
    };
  }
  function d(G) {
    const Y = S(G ? /^<\?(xml(-stylesheet)?)\s*/ : /^<\?([\w-:.]+)\s*/);
    if (!Y)
      return;
    const z = {
      name: Y[1],
      type: "ProcessingInstruction",
      attributes: {}
    };
    for (; !(B() || O("?>")); ) {
      const M = k();
      if (M)
        z.attributes[M.name] = M.value;
      else
        return;
    }
    return S(/\?>/), {
      excluded: G ? !1 : r.options.filter(z) === !1,
      node: z
    };
  }
  function p(G) {
    const Y = S(/^<([^?!</>\s]+)\s*/);
    if (!Y)
      return;
    const z = {
      type: "Element",
      name: Y[1],
      attributes: {},
      children: []
    }, M = G ? !1 : r.options.filter(z) === !1;
    for (; !(B() || O(">") || O("?>") || O("/>")); ) {
      const U = k();
      if (U)
        z.attributes[U.name] = U.value;
      else
        return;
    }
    if (S(/^\s*\/>/))
      return z.children = null, {
        excluded: M,
        node: z
      };
    S(/\??>/);
    let ee = o();
    for (; ee; )
      ee.excluded || z.children.push(ee.node), ee = o();
    if (r.options.strictMode) {
      const U = `</${z.name}>`;
      if (r.xml.startsWith(U))
        r.xml = r.xml.slice(U.length);
      else
        throw new t("Failed to parse XML", `Closing tag not matching "${U}"`);
    } else
      S(/^<\/[\w-:.\u00C0-\u00FF]+\s*>/);
    return {
      excluded: M,
      node: z
    };
  }
  function f() {
    const G = S(/^<!DOCTYPE\s+\S+\s+SYSTEM[^>]*>/) || S(/^<!DOCTYPE\s+\S+\s+PUBLIC[^>]*>/) || S(/^<!DOCTYPE\s+\S+\s*\[[^\]]*]>/) || S(/^<!DOCTYPE\s+\S+\s*>/);
    if (G) {
      const Y = {
        type: "DocumentType",
        content: G[0]
      };
      return {
        excluded: r.options.filter(Y) === !1,
        node: Y
      };
    }
  }
  function m() {
    if (r.xml.startsWith("<![CDATA[")) {
      const G = r.xml.indexOf("]]>");
      if (G > -1) {
        const Y = G + 3, z = {
          type: "CDATA",
          content: r.xml.substring(0, Y)
        };
        return r.xml = r.xml.slice(Y), {
          excluded: r.options.filter(z) === !1,
          node: z
        };
      }
    }
  }
  function y() {
    const G = S(/^<!--[\s\S]*?-->/);
    if (G) {
      const Y = {
        type: "Comment",
        content: G[0]
      };
      return {
        excluded: r.options.filter(Y) === !1,
        node: Y
      };
    }
  }
  function v() {
    const G = S(/^([^<]+)/);
    if (G) {
      const Y = {
        type: "Text",
        content: G[1]
      };
      return {
        excluded: r.options.filter(Y) === !1,
        node: Y
      };
    }
  }
  function k() {
    const G = S(/([^=]+)\s*=\s*("[^"]*"|'[^']*'|[^>\s]+)\s*/);
    if (G)
      return {
        name: G[1].trim(),
        value: A(G[2].trim())
      };
  }
  function A(G) {
    return G.replace(/^['"]|['"]$/g, "");
  }
  function S(G) {
    const Y = r.xml.match(G);
    if (Y)
      return r.xml = r.xml.slice(Y[0].length), Y;
  }
  function B() {
    return r.xml.length === 0;
  }
  function O(G) {
    return r.xml.indexOf(G) === 0;
  }
  function L(G, Y = {}) {
    G = G.trim();
    const z = Y.filter || (() => !0);
    return r = {
      xml: G,
      options: Object.assign(Object.assign({}, Y), { filter: z, strictMode: Y.strictMode === !0 })
    }, l();
  }
  n.exports = L, e.default = L;
})(zf, zf.exports);
var gz = zf.exports;
(function(n, e) {
  var t = Ps && Ps.__importDefault || function(A) {
    return A && A.__esModule ? A : { default: A };
  };
  Object.defineProperty(e, "__esModule", { value: !0 });
  const r = t(gz);
  function o(A) {
    if (!A.options.indentation && !A.options.lineSeparator)
      return;
    A.content += A.options.lineSeparator;
    let S;
    for (S = 0; S < A.level; S++)
      A.content += A.options.indentation;
  }
  function a(A) {
    A.content = A.content.replace(/ +$/, "");
    let S;
    for (S = 0; S < A.level; S++)
      A.content += A.options.indentation;
  }
  function l(A, S) {
    A.content += S;
  }
  function d(A, S, B) {
    if (typeof A.content == "string")
      p(A.content, S, B);
    else if (A.type === "Element")
      m(A, S, B);
    else if (A.type === "ProcessingInstruction")
      v(A, S);
    else
      throw new Error("Unknown node type: " + A.type);
  }
  function p(A, S, B) {
    if (!B) {
      const O = A.trim();
      (S.options.lineSeparator || O.length === 0) && (A = O);
    }
    A.length > 0 && (!B && S.content.length > 0 && o(S), l(S, A));
  }
  function f(A, S) {
    const B = "/" + A.join("/"), O = A[A.length - 1];
    return S.includes(O) || S.includes(B);
  }
  function m(A, S, B) {
    if (S.path.push(A.name), !B && S.content.length > 0 && o(S), l(S, "<" + A.name), y(S, A.attributes), A.children === null || S.options.forceSelfClosingEmptyTag && A.children.length === 0) {
      const O = S.options.whiteSpaceAtEndOfSelfclosingTag ? " />" : "/>";
      l(S, O);
    } else if (A.children.length === 0)
      l(S, "></" + A.name + ">");
    else {
      const O = A.children;
      l(S, ">"), S.level++;
      let L = A.attributes["xml:space"] === "preserve" || B, G = !1;
      if (!L && S.options.ignoredPaths && (G = f(S.path, S.options.ignoredPaths), L = G), !L && S.options.collapseContent) {
        let Y = !1, z = !1, M = !1;
        O.forEach(function(ee, U) {
          ee.type === "Text" ? (ee.content.includes(`
`) ? (z = !0, ee.content = ee.content.trim()) : (U === 0 || U === O.length - 1) && !B && ee.content.trim().length === 0 && (ee.content = ""), (ee.content.trim().length > 0 || O.length === 1) && (Y = !0)) : ee.type === "CDATA" ? Y = !0 : M = !0;
        }), Y && (!M || !z) && (L = !0);
      }
      O.forEach(function(Y) {
        d(Y, S, B || L);
      }), S.level--, !B && !L && o(S), G && a(S), l(S, "</" + A.name + ">");
    }
    S.path.pop();
  }
  function y(A, S) {
    Object.keys(S).forEach(function(B) {
      const O = S[B].replace(/"/g, "&quot;");
      l(A, " " + B + '="' + O + '"');
    });
  }
  function v(A, S) {
    S.content.length > 0 && o(S), l(S, "<?" + A.name), y(S, A.attributes), l(S, "?>");
  }
  function k(A, S = {}) {
    S.indentation = "indentation" in S ? S.indentation : "    ", S.collapseContent = S.collapseContent === !0, S.lineSeparator = "lineSeparator" in S ? S.lineSeparator : `\r
`, S.whiteSpaceAtEndOfSelfclosingTag = S.whiteSpaceAtEndOfSelfclosingTag === !0, S.throwOnFailure = S.throwOnFailure !== !1;
    try {
      const B = (0, r.default)(A, { filter: S.filter, strictMode: S.strictMode }), O = { content: "", level: 0, options: S, path: [] };
      return B.declaration && v(B.declaration, O), B.children.forEach(function(L) {
        d(L, O, !1);
      }), S.lineSeparator ? O.content.replace(/\r\n/g, `
`).replace(/\n/g, S.lineSeparator) : O.content;
    } catch (B) {
      if (S.throwOnFailure)
        throw B;
      return A;
    }
  }
  k.minify = (A, S = {}) => k(A, Object.assign(Object.assign({}, S), { indentation: "", lineSeparator: "" })), n.exports = k, e.default = k;
})(_f, _f.exports);
var yz = _f.exports;
const wz = /* @__PURE__ */ oz(yz), bz = {
  rend: {
    type: "string"
  },
  id: {
    type: "string"
  }
}, vz = {
  "Move Up": {
    command: "moveUp",
    label: "<i class='bi bi-unindent'></i>"
  },
  "Clear Formatting": {
    command: "unsetAllMarks",
    label: "<i class='bi bi-eraser'></i>",
    order: 5
  },
  "choice/abbr/expan": {
    command: "insertSnippet",
    args: [
      "<tei-choice><tei-abbr>{abbrev}</tei-abbr><tei-expan>{expansion}</tei-expan></tei-choice>"
    ],
    select: "Textcritical",
    label: "<i class='bi bi-three-dots'></i>"
  },
  Table: {
    select: "Blocks",
    command: "insertSnippet",
    args: [
      "<tei-table><tei-row><tei-cell>A</tei-cell><tei-cell>B</tei-cell></tei-row><tei-row><tei-cell>C</tei-cell><tei-cell>D</tei-cell></tei-row></tei-table>"
    ],
    label: "<i class='bi bi-table'></i>"
  },
  Figure: {
    command: "insertFigure",
    label: "<i class='bi bi-images'></i>",
    select: "Blocks"
  },
  "Show/Hide Code": {
    command: "toggleSource",
    label: "<i class='bi bi-filetype-xml'></i>",
    order: 20
  },
  "Debug Mode": {
    command: "toggleDebug",
    label: "<i class='bi bi-question-circle'></i>",
    order: 20
  }
}, xz = {
  Blocks: {
    label: "<i class='bi bi-text-paragraph'></i>",
    order: 0
  },
  Textcritical: {
    label: "<i class='bi bi-highlighter'></i>",
    order: 9
  }
}, kz = {
  div: {
    type: "block",
    defining: !0,
    content: "heading* (block | table)*",
    selectable: !0,
    attributes: {
      type: {
        type: "string"
      },
      n: {
        type: "string"
      }
    },
    keyboard: {
      "Mod-Shift-e": {
        attributes: {},
        command: "wrapDiv"
      }
    },
    toolbar: {
      Division: {
        select: "Blocks",
        attributes: {},
        command: "wrapDiv",
        label: "<i class='bi bi-body-text'></i>"
      }
    },
    inputRules: [
      {
        find: "^>>",
        type: "wrapping"
      }
    ]
  },
  underline: {
    type: "inline"
  },
  rs: {
    type: "inline",
    attributes: {
      corresp: {
        type: "string"
      },
      type: {
        type: "string"
      }
    }
  },
  hi: {
    type: "inline",
    attributes: {
      rend: {
        type: "string",
        default: "i",
        enum: [
          "i",
          "b",
          "u",
          "code"
        ]
      }
    },
    keyboard: {
      "Cmd-b": {
        attributes: {
          rend: "b"
        }
      },
      "Cmd-i": {
        attributes: {
          rend: "i"
        }
      }
    },
    toolbar: {
      Bold: {
        attributes: {
          rend: "b"
        },
        label: "<i class='bi bi-type-bold'></i>",
        order: 5
      },
      Italic: {
        attributes: {
          rend: "i"
        },
        label: "<i class='bi bi-type-italic'></i>",
        order: 5
      }
    }
  },
  ref: {
    type: "ref",
    attributes: {
      target: {
        type: "string"
      }
    },
    keyboard: {
      "Alt-Shift-r": {
        attributes: {}
      }
    },
    toolbar: {
      Reference: {
        attributes: {},
        label: "<i class='bi bi-link'></i>",
        order: 2
      }
    }
  },
  title: {
    type: "inline",
    attributes: {
      level: {
        type: "string",
        enum: [
          "m",
          "s",
          "a"
        ]
      }
    },
    keyboard: {
      "Mod-Alt-t": {
        attributes: {
          level: "m"
        }
      }
    },
    toolbar: {
      Title: {
        attributes: {
          level: "m"
        },
        label: "<i class='bi bi-quote'></i>",
        select: "Textcritical",
        order: 2
      }
    }
  },
  quote: {
    type: "block",
    content: "block*"
  },
  figure: {
    type: "block",
    selectable: !0,
    content: "(graphic|figDesc|head)*"
  },
  figDesc: {
    type: "block",
    content: "inline*",
    priority: 99
  },
  graphic: {
    type: "graphic",
    attributes: {
      url: {
        type: "string",
        default: "https://placehold.co/320x200"
      }
    },
    toolbar: {
      Graphic: {
        label: "<i class='bi bi-image'></i>",
        select: "Blocks"
      }
    }
  },
  persName: {
    type: "inline",
    attributes: {
      key: {
        connector: {
          name: "GND",
          type: "person",
          prefix: "gnd"
        },
        type: "string"
      }
    },
    keyboard: {
      "Mod-Shift-p": {
        attributes: {}
      }
    },
    toolbar: {
      Person: {
        attributes: {},
        label: "<i class='bi bi-person'></i>",
        order: 11
      }
    }
  },
  orgName: {
    type: "inline",
    attributes: {
      key: {
        connector: {
          name: "GND",
          type: "organization",
          prefix: "gnd"
        },
        type: "string"
      }
    },
    toolbar: {
      Organization: {
        attributes: {},
        label: "<i class='bi bi-people'></i>",
        order: 11
      }
    }
  },
  placeName: {
    type: "inline",
    attributes: {
      key: {
        type: "string",
        connector: {
          name: "GeoNames",
          type: "place",
          prefix: "geo",
          user: "existdb"
        }
      }
    },
    keyboard: {
      "Mod-Shift-h": {
        attributes: {}
      }
    },
    toolbar: {
      Place: {
        attributes: {},
        label: "<i class='bi bi-geo-alt'></i>",
        order: 11
      }
    }
  },
  term: {
    type: "inline",
    attributes: {
      key: {
        type: "string",
        connector: {
          name: "GND",
          type: "term",
          prefix: "gnd"
        }
      }
    },
    keyboard: {
      "Mod-Shift-t": {
        attributes: {}
      }
    },
    toolbar: {
      Term: {
        attributes: {},
        label: "<i class='bi bi-bookmark'></i>",
        order: 11
      }
    }
  },
  date: {
    type: "inline",
    attributes: {
      when: {
        type: "string"
      },
      "not-before": {
        type: "string"
      },
      "not-after": {
        type: "string"
      },
      from: {
        type: "string"
      },
      to: {
        type: "string"
      }
    },
    toolbar: {
      Date: {
        attributes: {},
        label: "<i class='bi bi-calendar-event'></i>",
        order: 12,
        select: "Textcritical"
      }
    }
  },
  measure: {
    type: "inline",
    attributes: {
      quantity: {
        type: "string"
      },
      unit: {
        type: "string"
      }
    },
    toolbar: {
      Measure: {
        attributes: {},
        label: "<i class='bi bi-rulers'></i>",
        order: 12,
        select: "Textcritical"
      }
    }
  },
  p: {
    type: "block",
    priority: 100,
    toolbar: {
      Paragraph: {
        select: "Blocks",
        attributes: {},
        label: "<i class='bi bi-paragraph'></i>"
      }
    }
  },
  head: {
    type: "block",
    group: "heading",
    content: "inline*",
    attributes: {
      type: {
        type: "string"
      },
      n: {
        type: "string"
      }
    },
    keyboard: {
      "Shift-Mod-1": {
        attributes: {
          n: "1"
        }
      }
    },
    toolbar: {
      Head: {
        select: "Blocks",
        attributes: {},
        label: "<i class='bi bi-type-h1'></i>"
      }
    },
    inputRules: [
      {
        find: "^##",
        type: "textblock"
      }
    ]
  },
  item: {
    type: "listItem",
    selectable: !0
  },
  list: {
    type: "list",
    content: "heading* item+",
    selectable: !0,
    attributes: {
      rend: {
        type: "string",
        enum: [
          "ordered",
          "unordered"
        ],
        open: !0
      }
    },
    keyboard: {
      "Mod-Shift-l": {
        attributes: {}
      }
    },
    toolbar: {
      List: {
        select: "Blocks",
        attributes: {
          rend: "unordered"
        },
        label: "<i class='bi bi-list-ul'></i>"
      },
      "Numbered list": {
        select: "Blocks",
        attributes: {
          rend: "ordered"
        },
        label: "<i class='bi bi-list-ol'></i>"
      }
    },
    inputRules: [
      {
        find: "^\\s*([-+*])\\s$",
        type: "wrapping",
        attributes: {
          rend: "unordered"
        }
      },
      {
        find: "^\\s*(\\d+)\\.\\s$",
        type: "wrapping",
        attributes: {
          rend: "ordered"
        }
      }
    ]
  },
  opener: {
    type: "block",
    content: "block*",
    selectable: !0,
    toolbar: {
      Opener: {
        select: "Blocks",
        attributes: {},
        label: "<i class='bi bi-envelope-open'></i>"
      }
    }
  },
  dateline: {
    type: "block",
    content: "inline*",
    toolbar: {
      Dateline: {
        select: "Blocks",
        attributes: {},
        label: "<i class='bi bi-calendar-date'></i>"
      }
    }
  },
  salute: {
    type: "block",
    content: "inline*",
    toolbar: {
      Salute: {
        select: "Blocks",
        attributes: {},
        label: "<i class='bi bi-envelope-open'></i>"
      }
    }
  },
  closer: {
    type: "block",
    content: "block*",
    selectable: !0,
    toolbar: {
      Closer: {
        select: "Blocks",
        attributes: {},
        label: "<i class='bi bi-envelope'></i>"
      }
    }
  },
  signed: {
    type: "block",
    content: "inline*",
    toolbar: {
      Signed: {
        select: "Blocks",
        attributes: {},
        label: "<i class='bi bi-envelope-paper'></i>"
      }
    }
  },
  listAnnotation: {
    type: "list",
    group: "",
    defining: !0,
    content: "note*",
    keyboard: {
      "Mod-Shift-u": {
        attributes: {}
      }
    }
  },
  note: {
    type: "block",
    group: "note",
    content: "p+",
    selectable: !0,
    priority: 99,
    attributes: {
      target: {
        type: "string"
      },
      n: {
        type: "string"
      },
      _reference: {
        type: "string"
      }
    }
  },
  anchor: {
    type: "anchor",
    attributes: {
      type: {
        type: "string",
        default: "note"
      }
    },
    toolbar: {
      Footnote: {
        attributes: {
          type: "note",
          _reference: "*"
        },
        label: "<i class='bi bi-123'></i>",
        order: 2
      }
    }
  },
  choice: {
    type: "inline",
    content: "abbr expan",
    preserveSpace: !0,
    toolbar: {
      Choice: {
        select: "Textcritical",
        label: "<i class='bi bi-alt'></i>"
      }
    }
  },
  abbr: {
    type: "inline",
    toolbar: {
      Abbreviation: {
        select: "Textcritical",
        label: "<i class='bi bi-three-dots'></i>"
      }
    }
  },
  expan: {
    type: "inline",
    toolbar: {
      Expansion: {
        select: "Textcritical",
        label: "<i class='bi bi-arrows-expand-vertical'></i>"
      }
    }
  },
  gap: {
    type: "empty",
    label: "[...]",
    attributes: {
      unit: {
        type: "string",
        default: "chars",
        enum: [
          "chars",
          "lines",
          "words"
        ]
      },
      quantity: {
        type: "string"
      }
    },
    toolbar: {
      Gap: {
        select: "Textcritical",
        label: "<i class='bi bi-braces-asterisk'></i>"
      }
    }
  },
  unclear: {
    type: "inline",
    attributes: {
      rend: {
        type: "string",
        default: "unclear"
      }
    },
    toolbar: {
      Unclear: {
        select: "Textcritical",
        label: "<i class='bi bi-patch-question'></i>"
      }
    }
  },
  gloss: {
    type: "inline",
    attributes: {
      target: {
        type: "string"
      }
    }
  },
  "footnote-reference": {
    type: "inline",
    attributes: {
      n: {
        type: "number"
      }
    }
  },
  supplied: {
    type: "inline",
    attributes: {
      reason: {
        type: "string"
      }
    },
    toolbar: {
      Supplied: {
        select: "Textcritical",
        label: "<i class='bi bi-plus-circle-dotted'></i>"
      }
    }
  },
  pb: {
    type: "empty",
    label: "pb",
    attributes: {
      n: {
        type: "string"
      }
    },
    keyboard: {
      "Mod-Alt-p": {
        attributes: {
          n: "22"
        }
      }
    },
    toolbar: {
      PageBreak: {
        attributes: {
          n: "22"
        },
        label: "<i class='bi bi-file-earmark-break'></i>",
        select: "Textcritical",
        order: 3
      }
    }
  },
  lb: {
    type: "empty",
    label: "&#x21B5;",
    attributes: {
      n: {
        type: "string"
      }
    },
    toolbar: {
      LineBreak: {
        attributes: {},
        label: "<i class='bi bi-arrow-return-left'></i>",
        select: "Textcritical",
        order: 3
      }
    }
  },
  cell: {
    type: "cell",
    attributes: {
      role: {
        type: "string"
      }
    }
  },
  row: {
    type: "row",
    role: {
      type: "string"
    }
  },
  table: {
    type: "table"
  }
}, ak = {
  attributes: bz,
  toolbar: vz,
  selects: xz,
  schema: kz
};
class Az {
  /**
   * @param {import('../../jinn-tap').JinnTap} editor - The editor instance.
   */
  constructor(e) {
    this.tableMenu = e.querySelector(".table-menu ul");
    const t = [
      {
        name: "Insert Column",
        icon: "vr",
        cb: () => {
          e.tiptap.commands.addColumnAfter();
        }
      },
      {
        name: "Delete Column",
        icon: "trash",
        cb: () => {
          e.tiptap.commands.deleteColumn();
        }
      },
      "divider",
      {
        name: "Insert Row",
        icon: "hr",
        cb: () => {
          e.tiptap.commands.addRowAfter();
        }
      },
      {
        name: "Delete Row",
        icon: "trash",
        cb: () => {
          e.tiptap.commands.deleteRow();
        }
      },
      "divider",
      {
        name: "Merge",
        icon: "intersect",
        cb: () => {
          e.tiptap.commands.mergeCells();
        }
      },
      {
        name: "Split",
        icon: "subtract",
        cb: () => {
          e.tiptap.commands.splitCell();
        }
      }
    ];
    for (const r of t) {
      const o = document.createElement("li");
      if (this.tableMenu.appendChild(o), r === "divider") {
        const l = document.createElement("span");
        l.classList.add("divider"), o.appendChild(l);
        continue;
      }
      const a = document.createElement("a");
      o.appendChild(a), a.classList.add("outline"), a.classList.add("toolbar-button"), r.icon ? (a.appendChild(document.createElement("i")).classList.add("bi", `bi-${r.icon}`), a.setAttribute("data-tooltip", r.name)) : a.innerText = r.name, a.addEventListener("click", r.cb);
    }
  }
}
class Cz extends HTMLElement {
  static get observedAttributes() {
    return ["debug", "url", "schema"];
  }
  constructor() {
    super(), this.editor = null, this.toolbar = null, this.attributePanel = null, this.notesWrapper = "listAnnotation", this.collaboration = null, this.provider = null, this.notes = "disconnected", this.metadata = {
      title: "Untitled Document",
      name: "untitled.xml"
    }, this._schema = ak, this._initialized = !1;
  }
  attributeChangedCallback(e, t, r) {
    e === "debug" ? r !== null ? this.classList.add("debug") : this.classList.remove("debug") : e === "url" && r && this._initialized ? this.loadFromUrl(r) : e === "schema" && r && this._initialized && this.loadSchema(r);
  }
  async loadSchema(e) {
    try {
      const t = await fetch(e);
      if (!t.ok)
        throw new Error(`HTTP error! status: ${t.status}`);
      this._schema = await t.json(), this.editor && this.setupEditor();
    } catch (t) {
      console.error("Error loading schema from URL:", t), this.dispatchEvent(
        new CustomEvent("error", {
          detail: { error: t.message }
        })
      );
    }
  }
  async loadFromUrl(e, t = !0) {
    try {
      const r = await fetch(e);
      if (!r.ok)
        throw new Error(`HTTP error! status: ${r.status}`);
      const o = r.headers.get("content-type");
      let a;
      if (o != null && o.includes("application/xml") || o != null && o.includes("text/xml")) {
        const l = await r.text(), d = Gf(l);
        a = d.content, this.document = d.doc;
      } else if (o != null && o.includes("text/html"))
        a = await r.text();
      else
        throw new Error(`Unsupported content type: ${o}`);
      return t && this.editor && (this.content = a), this.metadata = {
        name: e.split("/").pop()
      }, a;
    } catch (r) {
      console.error("Error loading content from URL:", r), document.dispatchEvent(
        new CustomEvent("jinn-toast", {
          detail: {
            message: `Error loading content from URL: ${r.message}`,
            type: "error"
          }
        })
      );
    }
  }
  connectedCallback() {
    this.hasAttribute("notesWrapper") && (this.notesWrapper = this.getAttribute("notes-wrapper")), this.notes = this.getAttribute("notes") || "disconnected", this._schema = this.getAttribute("schema");
    const e = this.getAttribute("server") || null;
    if (e) {
      const t = this.getAttribute("token") || null, r = this.getAttribute("name") || null, o = this.getAttribute("user") || localStorage.getItem("jinn-tap.username") || null, a = this.getAttribute("color") || localStorage.getItem("jinn-tap.color") || null;
      t && r ? (this.collaboration = {
        url: e,
        token: t,
        user: o || vS.generateUsername("-", 2, 16),
        name: r,
        color: a || Vx()
      }, localStorage.getItem("jinn-tap.username") || localStorage.setItem("jinn-tap.username", this.collaboration.user), localStorage.getItem("jinn-tap.color") || localStorage.setItem("jinn-tap.color", this.collaboration.color)) : (console.error("collab-token is required when collab-server is provided"), document.dispatchEvent(
        new CustomEvent("jinn-toast", {
          detail: {
            message: "collab-token is required when collab-server is provided",
            type: "error"
          }
        })
      ));
    }
    this.setupEditor();
  }
  async setupEditor() {
    this._schema ? await this.loadSchema(this._schema) : this._schema = ak;
    const e = a_(this._schema);
    let t = document.getElementById("jinn-tap-color-css");
    t ? t.textContent = e : (t = document.createElement("style"), t.id = "jinn-tap-color-css", t.textContent = e, document.head.appendChild(t));
    const r = document.createElement("div");
    r.innerHTML = this.innerHTML, this.innerHTML = `
            <div class="editor-area"></div>
			<div style="display:none"><nav class="table-menu"><ul class="toolbar"/></nav></div>
            <pre class="code-area" style="display: none;"></pre>
        `;
    const o = this.getAttribute("sidebar");
    o ? this.sidebarContainer = document.querySelector(o) : (this.sidebarContainer = document.createElement("div"), this.sidebarContainer.classList.add("aside"), this.appendChild(this.sidebarContainer)), this.sidebarContainer.classList.add("jinn-tap-aside"), this.sidebarContainer.innerHTML = `
            <div class="user-info"></div>
            <slot name="aside"></slot>
            <nav class="navigation-panel" aria-label="breadcrumb"></nav>
            <div class="attribute-panel"></div>
        `;
    const a = this.getAttribute("toolbar");
    if (a)
      this.toolbarContainer = document.querySelector(a);
    else {
      const m = document.createElement("nav");
      this.toolbarContainer = document.createElement("ul"), this.toolbarContainer.classList.add("toolbar"), m.appendChild(this.toolbarContainer), this.appendChild(m);
    }
    this.toolbarContainer.classList.add("jinn-tap-toolbar"), this.toolbarContainer.innerHTML = '<slot name="toolbar"></slot>', Hh(this, r), Hh(this.sidebarContainer, r), Hh(this.toolbarContainer, r);
    let l = r.innerHTML.trim();
    const d = this.getAttribute("url");
    if (d && (l = await this.loadFromUrl(d, !1)), !l) {
      const { doc: m, content: y } = sk();
      l = y, this.document = m;
    }
    this._codeArea = this.querySelector(".code-area"), this.addEventListener("content-change", (m) => {
      try {
        this._codeArea.textContent = wz(m.detail.xml, { collapseContent: !0 });
      } catch {
        this._codeArea.textContent = m.detail.xml;
      }
    });
    const p = WG(this._schema);
    this.collaboration && (this.doc = new ni(), this.provider = new GH({
      name: this.collaboration.name,
      token: this.collaboration.token,
      url: this.collaboration.url,
      document: this.doc,
      onAuthenticated: this.onAuthenticated.bind(this),
      onSynced: () => {
        !this.doc.getMap("config").get("initialContentLoaded") && this.editor && (this.doc.getMap("config").set("initialContentLoaded", !0), this.editor.chain().setContent(l).setTextSelection(0).focus().run(), this.dispatchContentChange());
      },
      onAuthenticationFailed: () => {
        document.dispatchEvent(
          new CustomEvent("jinn-toast", {
            detail: {
              message: "Authentication failed. Please log in and reload the page.",
              type: "error"
            }
          })
        );
      }
      // onAwarenessChange: ({ states }) => {
      //     console.log('onAwarenessChange: %o', states);
      // }
    }));
    const f = {
      element: this.querySelector(".editor-area"),
      extensions: [
        ...p,
        e_,
        t_,
        YH.configure({
          notesWrapper: this.notesWrapper,
          notesWithoutAnchor: this.notes !== "connected"
        }),
        Q5.configure({
          placeholder: "Write something...",
          includeChildren: !0
        })
      ],
      autofocus: !1,
      onCreate: () => {
        this._initialized = !0, this.dispatchEvent(new CustomEvent("ready"));
      },
      onTransaction: ({ editor: m, transaction: y }) => {
        y.docChanged && this.dispatchContentChange();
      },
      enableContentCheck: !0,
      onContentError({ editor: m, error: y, disableCollaboration: v }) {
        const k = y.cause ? y.cause.message : y.message;
        let A;
        this.collaboration ? A = `Content does not match schema. Switching to read-only mode. ${k}` : A = `Content does not match schema. Some markup may be lost on save. ${k}`, document.dispatchEvent(
          new CustomEvent("jinn-toast", {
            detail: {
              message: A,
              type: "error",
              nohtml: !0,
              sticky: !0
            }
          })
        ), this.collaboration && (v(), m.setEditable(!1, !1));
      }
    };
    this.collaboration ? (f.extensions.push(
      N6.configure({
        provider: this.provider,
        document: this.doc
      })
    ), f.extensions.push(
      I6.configure({
        provider: this.provider,
        user: {
          name: this.collaboration.user,
          color: this.collaboration.color
        }
      })
    )) : (f.extensions.push(Z5), f.content = l), this.tableMenu = new Az(this), this.editor = new I5(f), this.attributePanel = new i_(this, this._schema), this.navigationPanel = new o_(this, this.attributePanel), this.toolbar = new s_(this, this._schema), this.collaboration || (this.content = l);
  }
  dispatchContentChange() {
    if (!this._initialized && this.collaboration)
      return;
    const e = bx(this.editor, this._schema);
    this.dispatchEvent(
      new CustomEvent("content-change", {
        detail: {
          body: e,
          xml: ok(e, this.document, this.metadata)
        }
      })
    );
  }
  // Getter for the editor's content, i.e. the fragment edited in the editor,
  // not the full XML content.
  get content() {
    return this.editor.getText();
  }
  // Setter for the editor's content, i.e. the fragment edited in the editor,
  // not the full XML content.
  set content(e) {
    this.editor.chain().focus().setContent(e).setTextSelection(0).run(), this.dispatchContentChange();
  }
  // Getter for the full XML content
  get xml() {
    return ok(bx(this.editor, this._schema), this.document, this.metadata);
  }
  // Setter for the full XML content
  set xml(e) {
    const { doc: t, content: r } = Gf(e);
    this.content = r, this.document = t;
  }
  newDocument() {
    const { doc: e, content: t } = sk();
    this.document = e, this.content = t, this.metadata = {
      name: "untitled.xml"
    };
  }
  // Method to focus the editor
  focus() {
    this.editor.commands.focus();
  }
  // Method to get the editor instance
  get tiptap() {
    return this.editor;
  }
  onAuthenticated() {
    const e = (t) => {
      const r = document.createElement("div");
      return r.innerHTML = `
                <p>Choose a nickname below.</p>
                <fieldset role="group">
                    <input type="text" id="collab-user" placeholder="Nickname" value="${this.collaboration.user}">
                    <button>
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-lg" viewBox="0 0 16 16">
                            <path d="M12.736 3.97a.733.733 0 0 1 1.047 0c.286.289.29.756.01 1.05L7.88 12.01a.733.733 0 0 1-1.065.02L3.217 8.384a.757.757 0 0 1 0-1.06.733.733 0 0 1 1.047 0l3.052 3.093 5.4-6.425z"/>
                        </svg>
                    </button>
                </fieldset>
            `, r.querySelector("button").addEventListener("click", () => {
        const a = r.querySelector("#collab-user").value;
        this.collaboration.user = a, localStorage.setItem("jinn-tap-username", a), this.editor.commands.updateUser({
          name: a,
          color: Vx()
        }), this.updateUserInfo(), t();
      }), r;
    };
    this.updateUserInfo(), document.dispatchEvent(
      new CustomEvent("jinn-toast", {
        detail: {
          message: e,
          type: "info",
          sticky: !0
        }
      })
    );
  }
  updateUserInfo() {
    this.sidebarContainer.querySelector(".user-info").textContent = `Connected as ${this.collaboration.user}`;
  }
}
customElements.define("jinn-tap", Cz);
export {
  Cz as JinnTap
};
//# sourceMappingURL=jinn-tap.es.js.map
